{"resultsPerPage":312,"startIndex":0,"totalResults":312,"format":"NVD_CVE","version":"2.0","timestamp":"2024-05-02T16:11:28.670","vulnerabilities":[{"cve":{"id":"CVE-2024-4369","sourceIdentifier":"secalert@redhat.com","published":"2024-05-01T00:15:06.890","lastModified":"2024-05-02T03:15:15.027","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An information disclosure flaw was found in OpenShift's internal image registry operator. The AZURE_CLIENT_SECRET can be exposed through an environment variable defined in the pod definition, but is limited to Azure environments. An attacker controlling an account that has high enough permissions to obtain pod information from the openshift-image-registry namespace could use this obtained client secret to perform actions as the registry operator's Azure service account."},{"lang":"es","value":"Se encontró una falla de divulgación de información en el operador de registro de imágenes interno de OpenShift. AZURE_CLIENT_SECRET se puede exponer a través de una variable de entorno definida en la definición del pod, pero está limitado a entornos de Azure. Un atacante que controle una cuenta que tenga permisos suficientemente altos para obtener información de pod del espacio de nombres openshift-image-registry podría usar este secreto de cliente obtenido para realizar acciones como la cuenta de servicio de Azure del operador de registro."}],"metrics":{"cvssMetricV31":[{"source":"secalert@redhat.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:H\/UI:N\/S:C\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":6.8,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.3,"impactScore":4.0}]},"weaknesses":[{"source":"secalert@redhat.com","type":"Primary","description":[{"lang":"en","value":"CWE-526"}]}],"references":[{"url":"https:\/\/access.redhat.com\/security\/cve\/CVE-2024-4369","source":"secalert@redhat.com"},{"url":"https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=2278035","source":"secalert@redhat.com"}]}},{"cve":{"id":"CVE-2024-33763","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T03:15:07.257","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"lunasvg v2.3.9 was discovered to contain a stack-buffer-underflow at lunasvg\/source\/layoutcontext.cpp."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/keepinggg\/poc\/tree\/main\/poc_of_lunasvg","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33764","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T03:15:07.320","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"lunasvg v2.3.9 was discovered to contain a stack-overflow at lunasvg\/source\/element.h."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/keepinggg\/poc\/tree\/main\/poc_of_lunasvg","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33766","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T03:15:07.370","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"lunasvg v2.3.9 was discovered to contain an FPE (Floating Point Exception) at blend_transformed_tiled_argb.isra.0."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/keepinggg\/poc\/tree\/main\/poc_of_lunasvg","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33767","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T03:15:07.413","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"lunasvg v2.3.9 was discovered to contain a segmentation violation via the component composition_solid_source."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/keepinggg\/poc\/tree\/main\/poc_of_lunasvg","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33768","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T03:15:07.463","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"lunasvg v2.3.9 was discovered to contain a segmentation violation via the component composition_solid_source_over."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/keepinggg\/poc\/tree\/main\/poc_of_lunasvg","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-28978","sourceIdentifier":"security_alert@emc.com","published":"2024-05-01T04:15:10.153","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Dell OpenManage Enterprise, versions 3.10 and 4.0, contains an Improper Access Control vulnerability. A high privileged remote attacker could potentially exploit this vulnerability, leading to unauthorized access to resources."}],"metrics":{"cvssMetricV31":[{"source":"security_alert@emc.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:A\/AC:L\/PR:H\/UI:N\/S:U\/C:H\/I:L\/A:N","attackVector":"ADJACENT_NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":5.2,"baseSeverity":"MEDIUM"},"exploitabilityScore":0.9,"impactScore":4.2}]},"weaknesses":[{"source":"security_alert@emc.com","type":"Primary","description":[{"lang":"en","value":"CWE-284"}]}],"references":[{"url":"https:\/\/www.dell.com\/support\/kbdoc\/en-us\/000224641\/dsa-2024-201-security-update-for-dell-openmanage-enterprise-vulnerability","source":"security_alert@emc.com"}]}},{"cve":{"id":"CVE-2024-28979","sourceIdentifier":"security_alert@emc.com","published":"2024-05-01T04:15:10.387","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Dell OpenManage Enterprise, versions prior to 4.1.0, contains an XSS injection vulnerability in UI. A high privileged local attacker could potentially exploit this vulnerability, leading to JavaScript injection."}],"metrics":{"cvssMetricV31":[{"source":"security_alert@emc.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:H\/UI:R\/S:C\/C:L\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"HIGH","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":5.1,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.0,"impactScore":3.7}]},"weaknesses":[{"source":"security_alert@emc.com","type":"Secondary","description":[{"lang":"en","value":"CWE-20"}]}],"references":[{"url":"https:\/\/www.dell.com\/support\/kbdoc\/en-us\/000224642\/dsa-2024-202-security-update-for-dell-openmanage-enterprise-vulnerability","source":"security_alert@emc.com"}]}},{"cve":{"id":"CVE-2023-52647","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:06.627","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: nxp: imx8-isi: Check whether crossbar pad is non-NULL before access\n\nWhen translating source to sink streams in the crossbar subdev, the\ndriver tries to locate the remote subdev connected to the sink pad. The\nremote pad may be NULL, if userspace tries to enable a stream that ends\nat an unconnected crossbar sink. When that occurs, the driver\ndereferences the NULL pad, leading to a crash.\n\nPrevent the crash by checking if the pad is NULL before using it, and\nreturn an error if it is."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: media: nxp: imx8-isi: compruebe si el crossbar pad no es NULL antes del acceso. Al traducir el código fuente a las secuencias receptoras en el subdev de la barra transversal, el controlador intenta localizar el subdev remoto conectado a la plataforma del fregadero. El pad remoto puede ser NULL, si el espacio de usuario intenta habilitar una secuencia que termina en un receptor de barra transversal no conectado. Cuando eso ocurre, el controlador elimina la referencia al pad NULL, lo que provoca un bloqueo. Evite el bloqueo verificando si el pad es NULL antes de usarlo y devuelva un error si lo es."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/91c8ce42fcde09f1da24acab9013b3e19cb88a4e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c4bd29bf5b7f67925bc1abd16069f22dadf5f061","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c95318607fbe8fdd44991a8dad2e44118e6b8812","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb2f932100288dbb881eadfed02e1459c6b9504c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52648","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:07.217","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/vmwgfx: Unmap the surface before resetting it on a plane state\n\nSwitch to a new plane state requires unreferencing of all held surfaces.\nIn the work required for mob cursors the mapped surfaces started being\ncached but the variable indicating whether the surface is currently\nmapped was not being reset. This leads to crashes as the duplicated\nstate, incorrectly, indicates the that surface is mapped even when\nno surface is present. That's because after unreferencing the surface\nit's perfectly possible for the plane to be backed by a bo instead of a\nsurface.\n\nReset the surface mapped flag when unreferencing the plane state surface\nto fix null derefs in cleanup. Fixes crashes in KDE KWin 6.0 on Wayland:\n\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 4 PID: 2533 Comm: kwin_wayland Not tainted 6.7.0-rc3-vmwgfx #2\nHardware name: VMware, Inc. VMware Virtual Platform\/440BX Desktop Reference Platform, BIOS 6.00 11\/12\/2020\nRIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124\/0x140 [vmwgfx]\nCode: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc cc 48 8b b3 a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 <48> 8b 78 28 e8 e3 f>\nRSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff969d84cdcb00 RCX: 0000000000000027\nRDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600\nRBP: ffff969d4143dc50 R08: 0000000000000000 R09: ffffb6b98216f920\nR10: 0000000000000003 R11: ffff969e7feb3b10 R12: 0000000000000000\nR13: 0000000000000000 R14: 000000000000027b R15: ffff969d49c9fc00\nFS:  00007f1e8f1b4180(0000) GS:ffff969e75f00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000028 CR3: 0000000104006004 CR4: 00000000003706f0\nCall Trace:\n <TASK>\n ? __die+0x23\/0x70\n ? page_fault_oops+0x171\/0x4e0\n ? exc_page_fault+0x7f\/0x180\n ? asm_exc_page_fault+0x26\/0x30\n ? vmw_du_cursor_plane_cleanup_fb+0x124\/0x140 [vmwgfx]\n drm_atomic_helper_cleanup_planes+0x9b\/0xc0\n commit_tail+0xd1\/0x130\n drm_atomic_helper_commit+0x11a\/0x140\n drm_atomic_commit+0x97\/0xd0\n ? __pfx___drm_printfn_info+0x10\/0x10\n drm_atomic_helper_update_plane+0xf5\/0x160\n drm_mode_cursor_universal+0x10e\/0x270\n drm_mode_cursor_common+0x102\/0x230\n ? __pfx_drm_mode_cursor2_ioctl+0x10\/0x10\n drm_ioctl_kernel+0xb2\/0x110\n drm_ioctl+0x26d\/0x4b0\n ? __pfx_drm_mode_cursor2_ioctl+0x10\/0x10\n ? __pfx_drm_ioctl+0x10\/0x10\n vmw_generic_ioctl+0xa4\/0x110 [vmwgfx]\n __x64_sys_ioctl+0x94\/0xd0\n do_syscall_64+0x61\/0xe0\n ? __x64_sys_ioctl+0xaf\/0xd0\n ? syscall_exit_to_user_mode+0x2b\/0x40\n ? do_syscall_64+0x70\/0xe0\n ? __x64_sys_ioctl+0xaf\/0xd0\n ? syscall_exit_to_user_mode+0x2b\/0x40\n ? do_syscall_64+0x70\/0xe0\n ? exc_page_fault+0x7f\/0x180\n entry_SYSCALL_64_after_hwframe+0x6e\/0x76\nRIP: 0033:0x7f1e93f279ed\nCode: 04 25 28 00 00 00 48 89 45 c8 31 c0 48 8d 45 10 c7 45 b0 10 00 00 00 48 89 45 b8 48 8d 45 d0 48 89 45 c0 b8 10 00 00 00 0f 05 <89> c2 3d 00 f0 ff f>\nRSP: 002b:00007ffca0faf600 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 000055db876ed2c0 RCX: 00007f1e93f279ed\nRDX: 00007ffca0faf6c0 RSI: 00000000c02464bb RDI: 0000000000000015\nRBP: 00007ffca0faf650 R08: 000055db87184010 R09: 0000000000000007\nR10: 000055db886471a0 R11: 0000000000000246 R12: 00007ffca0faf6c0\nR13: 00000000c02464bb R14: 0000000000000015 R15: 00007ffca0faf790\n <\/TASK>\nModules linked in: snd_seq_dummy snd_hrtimer nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_ine>\nCR2: 0000000000000028\n---[ end trace 0000000000000000 ]---\nRIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124\/0x140 [vmwgfx]\nCode: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc cc 48 8b b3 a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 <48> 8b 78 28 e8 e3 f>\nRSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff969d84cdcb00 RCX: 0000000000000027\nRDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600\nRBP: ffff969d4143\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/vmwgfx: desasignar la superficie antes de restablecerla en un estado plano. Cambiar a un nuevo estado plano requiere eliminar la referencia de todas las superficies retenidas. En el trabajo requerido para los cursores de mob, las superficies mapeadas comenzaron a almacenarse en caché, pero la variable que indica si la superficie está actualmente mapeada no se restableció. Esto provoca fallos ya que el estado duplicado, incorrectamente, indica que esa superficie está mapeada incluso cuando no hay ninguna superficie presente. Esto se debe a que después de eliminar la referencia a la superficie, es perfectamente posible que el avión esté respaldado por un bo en lugar de una superficie. Restablezca el indicador de superficie asignada al eliminar la referencia a la superficie del estado del plano para corregir las desreferencias nulas en la limpieza. Soluciona fallas en KDE KWin 6.0 en Wayland: Ups: 0000 [#1] PREEMPT SMP PTI CPU: 4 PID: 2533 Comm: kwin_wayland Not tainted 6.7.0-rc3-vmwgfx #2 Nombre del hardware: VMware, Inc. VMware Virtual Platform\/ Plataforma de referencia de escritorio 440BX, BIOS 6.00 12\/11\/2020 RIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124\/0x140 [vmwgfx] Código: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc 48 8b b 3a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 &lt;48&gt; 8b 78 28 e8 e3 f&gt; RSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246 RAX: 0000000000000000 : ffff969d84cdcb00 RCX: 00000000000000027 RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600 RBP: ffff969d4143dc50 R08: 0000000000000000 R09: ffffb6b98216f920 R10: 0000000000000003 R11: 9e7feb3b10 R12: 0000000000000000 R13: 0000000000000000 R14: 000000000000027b R15: ffff969d49c9fc00 FS: 00007f1e8f1b4180(0000) e75f00000(0000) knlGS:0000000000000000 CS: 0010 DS : 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000028 CR3: 0000000104006004 CR4: 00000000003706f0 Seguimiento de llamadas:  ? __morir+0x23\/0x70 ? page_fault_oops+0x171\/0x4e0? exc_page_fault+0x7f\/0x180? asm_exc_page_fault+0x26\/0x30? vmw_du_cursor_plane_cleanup_fb+0x124\/0x140 [vmwgfx] drm_atomic_helper_cleanup_planes+0x9b\/0xc0 commit_tail+0xd1\/0x130 drm_atomic_helper_commit+0x11a\/0x140 drm_atomic_commit+0x97\/0xd0 ? __pfx___drm_printfn_info+0x10\/0x10 drm_atomic_helper_update_plane+0xf5\/0x160 drm_mode_cursor_universal+0x10e\/0x270 drm_mode_cursor_common+0x102\/0x230 ? __pfx_drm_mode_cursor2_ioctl+0x10\/0x10 drm_ioctl_kernel+0xb2\/0x110 drm_ioctl+0x26d\/0x4b0 ? __pfx_drm_mode_cursor2_ioctl+0x10\/0x10 ? __pfx_drm_ioctl+0x10\/0x10 vmw_generic_ioctl+0xa4\/0x110 [vmwgfx] __x64_sys_ioctl+0x94\/0xd0 do_syscall_64+0x61\/0xe0 ? __x64_sys_ioctl+0xaf\/0xd0 ? syscall_exit_to_user_mode+0x2b\/0x40? do_syscall_64+0x70\/0xe0? __x64_sys_ioctl+0xaf\/0xd0 ? syscall_exit_to_user_mode+0x2b\/0x40? do_syscall_64+0x70\/0xe0? exc_page_fault+0x7f\/0x180 Entry_SYSCALL_64_after_hwframe+0x6e\/0x76 RIP: 0033:0x7f1e93f279ed Código: 04 25 28 00 00 00 48 89 45 c8 31 c0 48 8d 45 10 c7 45 b0 10 00 00 00 48 89 45 b8 48 8d 45 d0 48 89 45 c0 b8 10 00 00 00 0f 05 &lt;89&gt; c2 3d 00 f0 ff f&gt; RSP: 002b:00007ffca0faf600 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 55db876ed2c0 RCX: 00007f1e93f279ed RDX: 00007ffca0faf6c0 RSI: 00000000c02464bb RDI: 0000000000000015 RBP: 00007ffca0faf650 R08: 000055db87184010 R09: 0000000000000007 R10: 000055db886471a0 R11: 0000000000000246 R12: 00007ffca0faf6c0 R13: 0000c02464bb R14: 0000000000000015 R15: 00007ffca0faf790  Módulos vinculados en: snd_seq_dummy snd_hrtimer nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 fib_ipv6 nft_fib nft_reject_ine&gt; CR2: 0000000000000028 ---[ seguimiento final 0000000000000000 ]--- RIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124\/0x140 [vmwgfx] Código: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc 48 8b b3 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 &lt;48&gt; 8b 78 28 e8 e3 f&gt; RSP: 0018:ffffb6b98216fa80 ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0a23f95af7f28dae7c0f7c82578ca5e1a239d461","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/105f72cc48c4c93f4578fcc61e06276471858e92","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/27571c64f1855881753e6f33c3186573afbab7ba","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/75baad63c033b3b900d822bffbc96c9d3649bc75","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26929","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:07.380","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix double free of fcport\n\nThe server was crashing after LOGO because fcport was getting freed twice.\n\n -----------[ cut here ]-----------\n kernel BUG at mm\/slub.c:371!\n invalid opcode: 0000 1 SMP PTI\n CPU: 35 PID: 4610 Comm: bash Kdump: loaded Tainted: G OE --------- - - 4.18.0-425.3.1.el8.x86_64 #1\n Hardware name: HPE ProLiant DL360 Gen10\/ProLiant DL360 Gen10, BIOS U32 09\/03\/2021\n RIP: 0010:set_freepointer.part.57+0x0\/0x10\n RSP: 0018:ffffb07107027d90 EFLAGS: 00010246\n RAX: ffff9cb7e3150000 RBX: ffff9cb7e332b9c0 RCX: ffff9cb7e3150400\n RDX: 0000000000001f37 RSI: 0000000000000000 RDI: ffff9cb7c0005500\n RBP: fffff693448c5400 R08: 0000000080000000 R09: 0000000000000009\n R10: 0000000000000000 R11: 0000000000132af0 R12: ffff9cb7c0005500\n R13: ffff9cb7e3150000 R14: ffffffffc06990e0 R15: ffff9cb7ea85ea58\n FS: 00007ff6b79c2740(0000) GS:ffff9cb8f7ec0000(0000) knlGS:0000000000000000\n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000055b426b7d700 CR3: 0000000169c18002 CR4: 00000000007706e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n PKRU: 55555554\n Call Trace:\n kfree+0x238\/0x250\n qla2x00_els_dcmd_sp_free+0x20\/0x230 [qla2xxx]\n ? qla24xx_els_dcmd_iocb+0x607\/0x690 [qla2xxx]\n qla2x00_issue_logo+0x28c\/0x2a0 [qla2xxx]\n ? qla2x00_issue_logo+0x28c\/0x2a0 [qla2xxx]\n ? kernfs_fop_write+0x11e\/0x1a0\n\nRemove one of the free calls and add check for valid fcport. Also use\nfunction qla2x00_free_fcport() instead of kfree()."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: scsi: qla2xxx: Corrección doble liberación de fcport El servidor fallaba después de LOGO porque fcport se liberaba dos veces. -----------[ cortar aquí ]----------- ¡ERROR del kernel en mm\/slub.c:371! código de operación no válido: 0000 1 SMP PTI CPU: 35 PID: 4610 Comm: bash Kdump: cargado Contaminado: G OE --------- - - 4.18.0-425.3.1.el8.x86_64 #1 Nombre de hardware: HPE ProLiant DL360 Gen10\/ProLiant DL360 Gen10, BIOS U32 03\/09\/2021 RIP: 0010:set_freepointer.part.57+0x0\/0x10 RSP: 0018:ffffb07107027d90 EFLAGS: 00010246 RAX: RBX: ffff9cb7e332b9c0 RCX: ffff9cb7e3150400 RDX: 0000000000001f37 RSI : 0000000000000000 RDI: ffff9cb7c0005500 RBP: fffff693448c5400 R08: 0000000080000000 R09: 00000000000000009 R10: 0000000000000000 R11: 0000000132af0 R12: ffff9cb7c0005500 R13: ffff9cb7e3150000 R14: ffffffffc06990e0 R15: ffff9cb7ea85ea58 FS: 00007ff6b79c2740(0000) GS:ffff9cb8f7ec0000(000) 0) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000055b426b7d700 CR3: 0000000169c18002 CR4: 00000000007706e0 DR0: 0000000000000000 DR1: 00000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Seguimiento de llamadas: kfree+0x238\/0x250 _els_dcmd_sp_free+0x20 \/0x230 [qla2xxx] ? qla24xx_els_dcmd_iocb+0x607\/0x690 [qla2xxx] qla2x00_issue_logo+0x28c\/0x2a0 [qla2xxx] ? qla2x00_issue_logo+0x28c\/0x2a0 [qla2xxx] ? kernfs_fop_write+0x11e\/0x1a0 Elimine una de las llamadas gratuitas y agregue una verificación de fcport válido. Utilice también la función qla2x00_free_fcport() en lugar de kfree()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/282877633b25d67021a34169c5b5519b1d4ef65e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/82f522ae0d97119a43da53e0f729275691b9c525","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/846fb9f112f618ec6ae181d8dae7961652574774","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9b43d2884b54d415caab48878b526dfe2ae9921b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b03e626bd6d3f0684f56ee1890d70fc9ca991c04","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f85af9f1aa5e2f53694a6cbe72010f754b5ff862","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26930","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:07.540","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix double free of the ha->vp_map pointer\n\nCoverity scan reported potential risk of double free of the pointer\nha->vp_map.  ha->vp_map was freed in qla2x00_mem_alloc(), and again freed\nin function qla2x00_mem_free(ha).\n\nAssign NULL to vp_map and kfree take care of NULL."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: scsi: qla2xxx: Corrección de doble liberación del puntero ha-&gt;vp_map Coverity scan informó un riesgo potencial de doble liberación del puntero ha-&gt;vp_map. ha-&gt;vp_map se liberó en qla2x00_mem_alloc() y nuevamente se liberó en la función qla2x00_mem_free(ha). Asigne NULL a vp_map y kfree se encargará de NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/825d63164a2e6bacb059a9afb5605425b485413f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7deb675d674f44e0ddbab87fee8f9f098925e73","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e288285d47784fdcf7c81be56df7d65c6f10c58b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f14cee7a882cb79528f17a2335f53e9fd1848467","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26931","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:07.673","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix command flush on cable pull\n\nSystem crash due to command failed to flush back to SCSI layer.\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n PGD 0 P4D 0\n Oops: 0000 [#1] SMP NOPTI\n CPU: 27 PID: 793455 Comm: kworker\/u130:6 Kdump: loaded Tainted: G           OE    --------- -  - 4.18.0-372.9.1.el8.x86_64 #1\n Hardware name: HPE ProLiant DL360 Gen10\/ProLiant DL360 Gen10, BIOS U32 09\/03\/2021\n Workqueue: nvme-wq nvme_fc_connect_ctrl_work [nvme_fc]\n RIP: 0010:__wake_up_common+0x4c\/0x190\n Code: 24 10 4d 85 c9 74 0a 41 f6 01 04 0f 85 9d 00 00 00 48 8b 43 08 48 83 c3 08 4c 8d 48 e8 49 8d 41 18 48 39 c3 0f 84 f0 00 00 00 <49> 8b 41 18 89 54 24 08 31 ed 4c 8d 70 e8 45 8b 29 41 f6 c5 04 75\n RSP: 0018:ffff95f3e0cb7cd0 EFLAGS: 00010086\n RAX: 0000000000000000 RBX: ffff8b08d3b26328 RCX: 0000000000000000\n RDX: 0000000000000001 RSI: 0000000000000003 RDI: ffff8b08d3b26320\n RBP: 0000000000000001 R08: 0000000000000000 R09: ffffffffffffffe8\n R10: 0000000000000000 R11: ffff95f3e0cb7a60 R12: ffff95f3e0cb7d20\n R13: 0000000000000003 R14: 0000000000000000 R15: 0000000000000000\n FS:  0000000000000000(0000) GS:ffff8b2fdf6c0000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 0000002f1e410002 CR4: 00000000007706e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n PKRU: 55555554\n Call Trace:\n  __wake_up_common_lock+0x7c\/0xc0\n  qla_nvme_ls_req+0x355\/0x4c0 [qla2xxx]\n qla2xxx [0000:12:00.1]-f084:3: qlt_free_session_done: se_sess 0000000000000000 \/ sess ffff8ae1407ca000 from port 21:32:00:02:ac:07:ee:b8 loop_id 0x02 s_id 01:02:00 logout 1 keep 0 els_logo 0\n ? __nvme_fc_send_ls_req+0x260\/0x380 [nvme_fc]\n qla2xxx [0000:12:00.1]-207d:3: FCPort 21:32:00:02:ac:07:ee:b8 state transitioned from ONLINE to LOST - portid=010200.\n  ? nvme_fc_send_ls_req.constprop.42+0x1a\/0x45 [nvme_fc]\n qla2xxx [0000:12:00.1]-2109:3: qla2x00_schedule_rport_del 21320002ac07eeb8. rport ffff8ae598122000 roles 1\n ? nvme_fc_connect_ctrl_work.cold.63+0x1e3\/0xa7d [nvme_fc]\n qla2xxx [0000:12:00.1]-f084:3: qlt_free_session_done: se_sess 0000000000000000 \/ sess ffff8ae14801e000 from port 21:32:01:02:ad:f7:ee:b8 loop_id 0x04 s_id 01:02:01 logout 1 keep 0 els_logo 0\n  ? __switch_to+0x10c\/0x450\n ? process_one_work+0x1a7\/0x360\n qla2xxx [0000:12:00.1]-207d:3: FCPort 21:32:01:02:ad:f7:ee:b8 state transitioned from ONLINE to LOST - portid=010201.\n  ? worker_thread+0x1ce\/0x390\n  ? create_worker+0x1a0\/0x1a0\n qla2xxx [0000:12:00.1]-2109:3: qla2x00_schedule_rport_del 21320102adf7eeb8. rport ffff8ae3b2312800 roles 70\n  ? kthread+0x10a\/0x120\n qla2xxx [0000:12:00.1]-2112:3: qla_nvme_unregister_remote_port: unregister remoteport on ffff8ae14801e000 21320102adf7eeb8\n  ? set_kthread_struct+0x40\/0x40\n qla2xxx [0000:12:00.1]-2110:3: remoteport_delete of ffff8ae14801e000 21320102adf7eeb8 completed.\n  ? ret_from_fork+0x1f\/0x40\n qla2xxx [0000:12:00.1]-f086:3: qlt_free_session_done: waiting for sess ffff8ae14801e000 logout\n\nThe system was under memory stress where driver was not able to allocate an\nSRB to carry out error recovery of cable pull.  The failure to flush causes\nupper layer to start modifying scsi_cmnd.  When the system frees up some\nmemory, the subsequent cable pull trigger another command flush. At this\npoint the driver access a null pointer when attempting to DMA unmap the\nSGL.\n\nAdd a check to make sure commands are flush back on session tear down to\nprevent the null pointer access."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: scsi: qla2xxx: corrige el vaciado del comando al tirar del cable. Fallo del sistema debido a que el comando no pudo volver a vaciarse a la capa SCSI. ERROR: no se puede manejar la desreferencia del puntero NULL del kernel en 0000000000000000 PGD 0 P4D 0 Ups: 0000 [#1] SMP NOPTI CPU: 27 PID: 793455 Comm: kworker\/u130:6 Kdump: cargado Contaminado: G OE ------ --- - - 4.18.0-372.9.1.el8.x86_64 #1 Nombre de hardware: HPE ProLiant DL360 Gen10\/ProLiant DL360 Gen10, BIOS U32 03\/09\/2021 Cola de trabajo: nvme-wq nvme_fc_connect_ctrl_work [nvme_fc] RIP: 0010: __wake_up_common+0x4c\/0x190 Código: 24 10 4d 85 c9 74 0a 41 f6 01 04 0f 85 9d 00 00 00 48 8b 43 08 48 83 c3 08 4c 8d 48 e8 49 8d 41 18 48 c3 0f 84 f0 00 00 00 &lt; 49&gt; 8b 41 18 89 54 24 08 31 ed 4c 8d 70 e8 45 8b 29 41 f6 c5 04 75 RSP: 0018:ffff95f3e0cb7cd0 EFLAGS: 00010086 RAX: 0000000000000000 RBX: ffff8b08d3b26328 RCX: 00000000000000000 RDX: 0000000000000001 RSI: 00000000000000003 RDI: ffff8b08d3b26320 RBP : 0000000000000001 R08: 0000000000000000 R09: ffffffffffffffe8 R10: 0000000000000000 R11: ffff95f3e0cb7a60 R12: ffff95f3e0cb7d20 R13: 0000003 R14: 0000000000000000 R15: 0000000000000000 FS: 0000000000000000(0000) GS:ffff8b2fdf6c0000(0000) knlGS:0000000000000000 CS: 0 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 0000002f1e410002 CR4: 00000000007706e0 DR0: 00000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Seguimiento de llamadas: __wake_up_common_lock+0x7c\/0xc0 qla_nvme_ls_req+ 0x355\/0x4c0 [qla2xxx] qla2xxx [0000:12:00.1]-f084:3: qlt_free_session_done: se_sess 0000000000000000 \/ sess ffff8ae1407ca000 desde el puerto 21:32:00:02:ac:07:ee:b8 loop_id 0x02 s_id 01:02:00 cerrar sesión 1 mantener 0 els_logo 0 ? __nvme_fc_send_ls_req+0x260\/0x380 [nvme_fc] qla2xxx [0000:12:00.1]-207d:3: FCPort 21:32:00:02:ac:07:ee:b8 el estado pasó de EN LÍNEA a PERDIDO - portid=010200. ? nvme_fc_send_ls_req.constprop.42+0x1a\/0x45 [nvme_fc] qla2xxx [0000:12:00.1]-2109:3: qla2x00_schedule_rport_del 21320002ac07eeb8. informe ffff8ae598122000 roles 1 ? nvme_fc_connect_ctrl_work.cold.63+0x1e3\/0xa7d [nvme_fc] qla2xxx [0000:12:00.1]-f084:3: qlt_free_session_done: se_sess 0000000000000000 \/ sess ffff8ae14801e000 desde el puerto 21: 32:01:02:ad:f7:ee:b8 loop_id 0x04 s_id 01:02:01 cerrar sesión 1 mantener 0 els_logo 0? __cambiar_a+0x10c\/0x450 ? Process_one_work+0x1a7\/0x360 qla2xxx [0000:12:00.1]-207d:3: FCPort 21:32:01:02:ad:f7:ee:b8 el estado pasó de EN LÍNEA a PERDIDO - portid=010201. ? hilo_trabajador+0x1ce\/0x390? create_worker+0x1a0\/0x1a0 qla2xxx [0000:12:00.1]-2109:3: qla2x00_schedule_rport_del 21320102adf7eeb8. informe ffff8ae3b2312800 roles 70 ? kthread+0x10a\/0x120 qla2xxx [0000:12:00.1]-2112:3: qla_nvme_unregister_remote_port: cancelar el registro del puerto remoto en ffff8ae14801e000 21320102adf7eeb8? set_kthread_struct+0x40\/0x40 qla2xxx [0000:12:00.1]-2110:3: Remoteport_delete de ffff8ae14801e000 21320102adf7eeb8 completado. ? ret_from_fork+0x1f\/0x40 qla2xxx [0000:12:00.1]-f086:3: qlt_free_session_done: esperando sess ffff8ae14801e000 cerrar sesión El sistema estaba bajo estrés de memoria y el controlador no pudo asignar un SRB para llevar a cabo la recuperación de errores de extracción del cable. La falla al vaciar hace que la capa superior comience a modificar scsi_cmnd. Cuando el sistema libera algo de memoria, el siguiente tirón del cable activa otro comando de descarga. En este punto, el controlador accede a un puntero nulo cuando intenta desasignar DMA el SGL. Agregue una verificación para asegurarse de que los comandos se vuelvan a borrar al cerrar la sesión para evitar el acceso al puntero nulo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/09c0ac18cac206ed1218b1fe6c1a0918e5ea9211","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/67b2d35853c2da25a8ca1c4190a5e96d3083c2ac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8de1584ec4fe0ebea33c273036e7e0a05e65c81d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f0d32004e3a572bb77e6c11c2797c87f8c9703d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a27d4d0e7de305def8a5098a614053be208d1aa1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a859f6a8f4234b8ef62862bf7a92f1af5f8cd47a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b73377124f56d2fec154737c2f8d2e839c237d5a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d7a68eee87b05d4e29419e6f151aef99314970a9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ec7587eef003cab15a13446d67c3adb88146a150","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26932","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:07.810","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: tcpm: fix double-free issue in tcpm_port_unregister_pd()\n\nWhen unregister pd capabilitie in tcpm, KASAN will capture below double\n-free issue. The root cause is the same capabilitiy will be kfreed twice,\nthe first time is kfreed by pd_capabilities_release() and the second time\nis explicitly kfreed by tcpm_port_unregister_pd().\n\n[    3.988059] BUG: KASAN: double-free in tcpm_port_unregister_pd+0x1a4\/0x3dc\n[    3.995001] Free of addr ffff0008164d3000 by task kworker\/u16:0\/10\n[    4.001206]\n[    4.002712] CPU: 2 PID: 10 Comm: kworker\/u16:0 Not tainted 6.8.0-rc5-next-20240220-05616-g52728c567a55 #53\n[    4.012402] Hardware name: Freescale i.MX8QXP MEK (DT)\n[    4.017569] Workqueue: events_unbound deferred_probe_work_func\n[    4.023456] Call trace:\n[    4.025920]  dump_backtrace+0x94\/0xec\n[    4.029629]  show_stack+0x18\/0x24\n[    4.032974]  dump_stack_lvl+0x78\/0x90\n[    4.036675]  print_report+0xfc\/0x5c0\n[    4.040289]  kasan_report_invalid_free+0xa0\/0xc0\n[    4.044937]  __kasan_slab_free+0x124\/0x154\n[    4.049072]  kfree+0xb4\/0x1e8\n[    4.052069]  tcpm_port_unregister_pd+0x1a4\/0x3dc\n[    4.056725]  tcpm_register_port+0x1dd0\/0x2558\n[    4.061121]  tcpci_register_port+0x420\/0x71c\n[    4.065430]  tcpci_probe+0x118\/0x2e0\n\nTo fix the issue, this will remove kree() from tcpm_port_unregister_pd()."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: usb: typec: tcpm: soluciona el problema de doble liberación en tcpm_port_unregister_pd() Cuando se cancela el registro de la capacidad de pd en tcpm, KASAN capturará el siguiente problema de doble liberación. La causa principal es que la misma capacidad se liberará dos veces, la primera vez se liberará mediante pd_capabilities_release() y la segunda vez se liberará explícitamente mediante tcpm_port_unregister_pd(). [3.988059] ERROR: KASAN: doble liberación en tcpm_port_unregister_pd+0x1a4\/0x3dc [3.995001] Libre de dirección ffff0008164d3000 por tarea kworker\/u16:0\/10 [4.001206] [4.002712] CPU: 2 PID: 10 Co mm: ktrabajador\/u16: 0 No contaminado 6.8.0-rc5-next-20240220-05616-g52728c567a55 #53 [4.012402] Nombre del hardware: Freescale i.MX8QXP MEK (DT) [4.017569] Cola de trabajo: events_unbound deferred_probe_work_func [4.023456] Seguimiento de llamadas: [ 4.025920] dump_backtrace+ 0x94\/0xec [ 4.029629] show_stack+0x18\/0x24 [ 4.032974] dump_stack_lvl+0x78\/0x90 [ 4.036675] print_report+0xfc\/0x5c0 [ 4.040289] kasan_report_invalid_free+0xa0\/0xc0 [ 4 .044937] __kasan_slab_free+0x124\/0x154 [ 4.049072] kfree+0xb4\/ 0x1e8 [ 4.052069] tcpm_port_unregister_pd+0x1a4\/0x3dc [ 4.056725] tcpm_register_port+0x1dd0\/0x2558 [ 4.061121] tcpci_register_port+0x420\/0x71c [ 4.065430] +0x118\/0x2e0 Para solucionar el problema, esto eliminará kree() de tcpm_port_unregister_pd()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/242e425ed580b2f4dbcb86c8fc03a410a4084a69","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b63f90487bdf93a4223ce7853d14717e9d452856","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26933","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:07.930","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: core: Fix deadlock in port \"disable\" sysfs attribute\n\nThe show and store callback routines for the \"disable\" sysfs attribute\nfile in port.c acquire the device lock for the port's parent hub\ndevice.  This can cause problems if another process has locked the hub\nto remove it or change its configuration:\n\n\tRemoving the hub or changing its configuration requires the\n\thub interface to be removed, which requires the port device\n\tto be removed, and device_del() waits until all outstanding\n\tsysfs attribute callbacks for the ports have returned.  The\n\tlock can't be released until then.\n\n\tBut the disable_show() or disable_store() routine can't return\n\tuntil after it has acquired the lock.\n\nThe resulting deadlock can be avoided by calling\nsysfs_break_active_protection().  This will cause the sysfs core not\nto wait for the attribute's callback routine to return, allowing the\nremoval to proceed.  The disadvantage is that after making this call,\nthere is no guarantee that the hub structure won't be deallocated at\nany moment.  To prevent this, we have to acquire a reference to it\nfirst by calling hub_get()."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: USB: core: corrige el punto muerto en el atributo sysfs \"disable\" del puerto. Las rutinas de devolución de llamada para mostrar y almacenar para el archivo del atributo sysfs \"disable\" en port.c adquieren el bloqueo del dispositivo para el puerto. dispositivo central principal. Esto puede causar problemas si otro proceso ha bloqueado el concentrador para eliminarlo o cambiar su configuración: Quitar el concentrador o cambiar su configuración requiere que se elimine la interfaz del concentrador, lo que requiere que se elimine el dispositivo del puerto, y device_del() espera hasta que todo Se han devuelto devoluciones de llamadas de atributos sysfs pendientes para los puertos. El bloqueo no podrá desbloquearse hasta entonces. Pero la rutina enable_show() o enable_store() no puede regresar hasta que haya adquirido el bloqueo. El punto muerto resultante se puede evitar llamando a sysfs_break_active_protection(). Esto hará que el núcleo de sysfs no espere a que regrese la rutina de devolución de llamada del atributo, lo que permitirá que continúe la eliminación. La desventaja es que después de realizar esta llamada, no hay garantía de que la estructura del centro no se desasignará en ningún momento. Para evitar esto, primero debemos adquirir una referencia llamando a hub_get()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4facc9421117ba9d8148c73771b213887fec77f7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/73d1589b91f2099e5f6534a8497b7c6b527e064e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9dac54f08198147f5ec0ec52fcf1bc8ac899ac05","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f4d1960764d8a70318b02f15203a1be2b2554ca1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f51849833705dea5b4f9b0c8de714dd87bd6c95c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26934","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:08.090","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: core: Fix deadlock in usb_deauthorize_interface()\n\nAmong the attribute file callback routines in\ndrivers\/usb\/core\/sysfs.c, the interface_authorized_store() function is\nthe only one which acquires a device lock on an ancestor device: It\ncalls usb_deauthorize_interface(), which locks the interface's parent\nUSB device.\n\nThe will lead to deadlock if another process already owns that lock\nand tries to remove the interface, whether through a configuration\nchange or because the device has been disconnected.  As part of the\nremoval procedure, device_del() waits for all ongoing sysfs attribute\ncallbacks to complete.  But usb_deauthorize_interface() can't complete\nuntil the device lock has been released, and the lock won't be\nreleased until the removal has finished.\n\nThe mechanism provided by sysfs to prevent this kind of deadlock is\nto use the sysfs_break_active_protection() function, which tells sysfs\nnot to wait for the attribute callback.\n\nReported-and-tested by: Yue Sun <samsun1006219@gmail.com>\nReported by: xingwei lee <xrivendell7@gmail.com>"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: USB: core: corrige el punto muerto en usb_deauthorize_interface() Entre las rutinas de devolución de llamada de archivos de atributos en drivers\/usb\/core\/sysfs.c, la función interface_authorized_store() es la única que adquiere un bloqueo de dispositivo en un dispositivo antecesor: llama a usb_deauthorize_interface(), que bloquea el dispositivo USB principal de la interfaz. Esto conducirá a un punto muerto si otro proceso ya posee ese bloqueo e intenta eliminar la interfaz, ya sea mediante un cambio de configuración o porque el dispositivo se ha desconectado. Como parte del procedimiento de eliminación, device_del() espera a que se completen todas las devoluciones de llamadas de atributos sysfs en curso. Pero usb_deauthorize_interface() no se puede completar hasta que se haya liberado el bloqueo del dispositivo, y el bloqueo no se liberará hasta que haya finalizado la eliminación. El mecanismo proporcionado por sysfs para evitar este tipo de punto muerto es utilizar la función sysfs_break_active_protection(), que le dice a sysfs que no espere la devolución de llamada del atributo. Reportado y probado por: Yue Sun  Reportado por: xingwei lee "}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/07acf979da33c721357ff27129edf74c23c036c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/122a06f1068bf5e39089863f4f60b1f5d4273384","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/12d6a5681a0a5cecc2af7860f0a1613fa7c6e947","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1b175bc579f46520b11ecda443bcd2ee4904f66a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/80ba43e9f799cbdd83842fc27db667289b3150f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8cbdd324b41528994027128207fae8100dff094f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ab062fa3dc69aea88fe62162c5881ba14b50ecc5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dbdf66250d2d33e8b27352fcb901de79f3521057","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e451709573f8be904a8a72d0775bf114d7c291d9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26935","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:08.240","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: core: Fix unremoved procfs host directory regression\n\nCommit fc663711b944 (\"scsi: core: Remove the \/proc\/scsi\/${proc_name}\ndirectory earlier\") fixed a bug related to modules loading\/unloading, by\nadding a call to scsi_proc_hostdir_rm() on scsi_remove_host(). But that led\nto a potential duplicate call to the hostdir_rm() routine, since it's also\ncalled from scsi_host_dev_release(). That triggered a regression report,\nwhich was then fixed by commit be03df3d4bfe (\"scsi: core: Fix a procfs host\ndirectory removal regression\"). The fix just dropped the hostdir_rm() call\nfrom dev_release().\n\nBut it happens that this proc directory is created on scsi_host_alloc(),\nand that function \"pairs\" with scsi_host_dev_release(), while\nscsi_remove_host() pairs with scsi_add_host(). In other words, it seems the\nreason for removing the proc directory on dev_release() was meant to cover\ncases in which a SCSI host structure was allocated, but the call to\nscsi_add_host() didn't happen. And that pattern happens to exist in some\nerror paths, for example.\n\nSyzkaller causes that by using USB raw gadget device, error'ing on\nusb-storage driver, at usb_stor_probe2(). By checking that path, we can see\nthat the BadDevice label leads to a scsi_host_put() after a SCSI host\nallocation, but there's no call to scsi_add_host() in such path. That leads\nto messages like this in dmesg (and a leak of the SCSI host proc\nstructure):\n\nusb-storage 4-1:87.51: USB Mass Storage device detected\nproc_dir_entry 'scsi\/usb-storage' already registered\nWARNING: CPU: 1 PID: 3519 at fs\/proc\/generic.c:377 proc_register+0x347\/0x4e0 fs\/proc\/generic.c:376\n\nThe proper fix seems to still call scsi_proc_hostdir_rm() on dev_release(),\nbut guard that with the state check for SHOST_CREATED; there is even a\ncomment in scsi_host_dev_release() detailing that: such conditional is\nmeant for cases where the SCSI host was allocated but there was no calls to\n{add,remove}_host(), like the usb-storage case.\n\nThis is what we propose here and with that, the error path of usb-storage\ndoes not trigger the warning anymore."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: scsi: core: corrige la regresión del directorio del host procfs no eliminado. el commit fc663711b944 (\"scsi: core: elimina el directorio \/proc\/scsi\/${proc_name} anteriormente\") corrigió un error relacionado con carga\/descarga de módulos, agregando una llamada a scsi_proc_hostdir_rm() en scsi_remove_host(). Pero eso llevó a una posible llamada duplicada a la rutina hostdir_rm(), ya que también se llama desde scsi_host_dev_release(). Eso desencadenó un informe de regresión, que luego se solucionó mediante el commit be03df3d4bfe (\"scsi: core: Fix a procfs host directorio de eliminación de regresión\"). La solución simplemente eliminó la llamada hostdir_rm() desde dev_release(). Pero sucede que este directorio proc se crea en scsi_host_alloc(), y esa función se \"empareja\" con scsi_host_dev_release(), mientras que scsi_remove_host() se empareja con scsi_add_host(). En otras palabras, parece que la razón para eliminar el directorio proc en dev_release() fue para cubrir casos en los que se asignó una estructura de host SCSI, pero la llamada a scsi_add_host() no ocurrió. Y ese patrón existe en algunas rutas de error, por ejemplo. Syzkaller provoca que, al utilizar un dispositivo USB sin formato, se produzca un error en el controlador de almacenamiento USB, en usb_stor_probe2(). Al verificar esa ruta, podemos ver que la etiqueta BadDevice conduce a scsi_host_put() después de una asignación de host SCSI, pero no hay ninguna llamada a scsi_add_host() en dicha ruta. Eso lleva a mensajes como este en dmesg (y una fuga de la estructura del proceso del host SCSI): usb-storage 4-1:87.51: Dispositivo de almacenamiento masivo USB detectado proc_dir_entry 'scsi\/usb-storage' ya registrado ADVERTENCIA: CPU: 1 PID : 3519 en fs\/proc\/generic.c:377 proc_register+0x347\/0x4e0 fs\/proc\/generic.c:376 La solución adecuada parece seguir llamando a scsi_proc_hostdir_rm() en dev_release(), pero guárdela con la verificación de estado para SHOST_CREATED ; incluso hay un comentario en scsi_host_dev_release() que detalla que: dicho condicional está destinado a casos en los que se asignó el host SCSI pero no hubo llamadas a {add,remove}_host(), como el caso del almacenamiento USB. Esto es lo que proponemos aquí y con eso, la ruta de error del almacenamiento USB ya no activa la advertencia."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0053f15d50d50c9312d8ab9c11e2e405812dfcac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3678cf67ff7136db1dd3bf63c361650db5d92889","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5c2386ba80e779a92ec3bb64ccadbedd88f779b1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cea234bb214b17d004dfdccce4491e6ff57c96ee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d4c34782b6d7b1e68d18d9549451b19433bd4c6c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e293c773c13b830cdc251f155df2254981abc320","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f23a4d6e07570826fe95023ca1aa96a011fa9f84","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f4ff08fab66eb5c0b97e1a24edac052fb40bf5d7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26936","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:08.833","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: validate request buffer size in smb2_allocate_rsp_buf()\n\nThe response buffer should be allocated in smb2_allocate_rsp_buf\nbefore validating request. But the fields in payload as well as smb2 header\nis used in smb2_allocate_rsp_buf(). This patch add simple buffer size\nvalidation to avoid potencial out-of-bounds in request buffer."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ksmbd: validar el tamaño del búfer de solicitud en smb2_allocate_rsp_buf() El búfer de respuesta debe asignarse en smb2_allocate_rsp_buf antes de validar la solicitud. Pero los campos en el payload y el encabezado smb2 se usan en smb2_allocate_rsp_buf(). Este parche agrega una validación simple del tamaño del búfer para evitar posibles límites en el búfer de solicitud."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/17cf0c2794bdb6f39671265aa18aea5c22ee8c4a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/21ff9d7d223c5c19cb4334009e4c0c83a2f4d674","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2c27a64a2bc47d9bfc7c3cf8be14be53b1ee7cb6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5c20b242d4fed73a93591e48bfd9772e2322fb11","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26937","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:08.960","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/i915\/gt: Reset queue_priority_hint on parking\n\nOriginally, with strict in order execution, we could complete execution\nonly when the queue was empty. Preempt-to-busy allows replacement of an\nactive request that may complete before the preemption is processed by\nHW. If that happens, the request is retired from the queue, but the\nqueue_priority_hint remains set, preventing direct submission until\nafter the next CS interrupt is processed.\n\nThis preempt-to-busy race can be triggered by the heartbeat, which will\nalso act as the power-management barrier and upon completion allow us to\nidle the HW. We may process the completion of the heartbeat, and begin\nparking the engine before the CS event that restores the\nqueue_priority_hint, causing us to fail the assertion that it is MIN.\n\n<3>[  166.210729] __engine_park:283 GEM_BUG_ON(engine->sched_engine->queue_priority_hint != (-((int)(~0U >> 1)) - 1))\n<0>[  166.210781] Dumping ftrace buffer:\n<0>[  166.210795] ---------------------------------\n...\n<0>[  167.302811] drm_fdin-1097      2..s1. 165741070us : trace_ports: 0000:00:02.0 rcs0: promote { ccid:20 1217:2 prio 0 }\n<0>[  167.302861] drm_fdin-1097      2d.s2. 165741072us : execlists_submission_tasklet: 0000:00:02.0 rcs0: preempting last=1217:2, prio=0, hint=2147483646\n<0>[  167.302928] drm_fdin-1097      2d.s2. 165741072us : __i915_request_unsubmit: 0000:00:02.0 rcs0: fence 1217:2, current 0\n<0>[  167.302992] drm_fdin-1097      2d.s2. 165741073us : __i915_request_submit: 0000:00:02.0 rcs0: fence 3:4660, current 4659\n<0>[  167.303044] drm_fdin-1097      2d.s1. 165741076us : execlists_submission_tasklet: 0000:00:02.0 rcs0: context:3 schedule-in, ccid:40\n<0>[  167.303095] drm_fdin-1097      2d.s1. 165741077us : trace_ports: 0000:00:02.0 rcs0: submit { ccid:40 3:4660* prio 2147483646 }\n<0>[  167.303159] kworker\/-89       11..... 165741139us : i915_request_retire.part.0: 0000:00:02.0 rcs0: fence c90:2, current 2\n<0>[  167.303208] kworker\/-89       11..... 165741148us : __intel_context_do_unpin: 0000:00:02.0 rcs0: context:c90 unpin\n<0>[  167.303272] kworker\/-89       11..... 165741159us : i915_request_retire.part.0: 0000:00:02.0 rcs0: fence 1217:2, current 2\n<0>[  167.303321] kworker\/-89       11..... 165741166us : __intel_context_do_unpin: 0000:00:02.0 rcs0: context:1217 unpin\n<0>[  167.303384] kworker\/-89       11..... 165741170us : i915_request_retire.part.0: 0000:00:02.0 rcs0: fence 3:4660, current 4660\n<0>[  167.303434] kworker\/-89       11d..1. 165741172us : __intel_context_retire: 0000:00:02.0 rcs0: context:1216 retire runtime: { total:56028ns, avg:56028ns }\n<0>[  167.303484] kworker\/-89       11..... 165741198us : __engine_park: 0000:00:02.0 rcs0: parked\n<0>[  167.303534]   <idle>-0         5d.H3. 165741207us : execlists_irq_handler: 0000:00:02.0 rcs0: semaphore yield: 00000040\n<0>[  167.303583] kworker\/-89       11..... 165741397us : __intel_context_retire: 0000:00:02.0 rcs0: context:1217 retire runtime: { total:325575ns, avg:0ns }\n<0>[  167.303756] kworker\/-89       11..... 165741777us : __intel_context_retire: 0000:00:02.0 rcs0: context:c90 retire runtime: { total:0ns, avg:0ns }\n<0>[  167.303806] kworker\/-89       11..... 165742017us : __engine_park: __engine_park:283 GEM_BUG_ON(engine->sched_engine->queue_priority_hint != (-((int)(~0U >> 1)) - 1))\n<0>[  167.303811] ---------------------------------\n<4>[  167.304722] ------------[ cut here ]------------\n<2>[  167.304725] kernel BUG at drivers\/gpu\/drm\/i915\/gt\/intel_engine_pm.c:283!\n<4>[  167.304731] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n<4>[  167.304734] CPU: 11 PID: 89 Comm: kworker\/11:1 Tainted: G        W          6.8.0-rc2-CI_DRM_14193-gc655e0fd2804+ #1\n<4>[  167.304736] Hardware name: Intel Corporation Rocket Lake Client Platform\/RocketLake S UDIMM 6L RVP, BIOS RKLSFWI1.R00.3173.A03.2204210138 04\/21\/2022\n<4>[  167.304738] Workqueue: i915-unordered retire_work_handler [i915]\n<4>[  16\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/i915\/gt: Restablecer queue_priority_hint al estacionar Originalmente, con ejecución en orden estricto, podíamos completar la ejecución solo cuando la cola estaba vacía. La preferencia por ocupación permite el reemplazo de una solicitud activa que puede completarse antes de que HW procese la preferencia. Si eso sucede, la solicitud se retira de la cola, pero queue_priority_hint permanece configurada, lo que impide el envío directo hasta después de que se procese la siguiente interrupción de CS. Esta ejecución de prioridad a ocupación puede ser desencadenada por el latido del corazón, que también actuará como barrera de administración de energía y, al finalizar, nos permitirá dejar el HW inactivo. Podemos procesar la finalización del latido y comenzar a estacionar el motor antes del evento CS que restaura queue_priority_hint, lo que hace que falle la afirmación de que es MIN. &lt;3&gt;[ 166.210729] __engine_park:283 GEM_BUG_ON(motor-&gt;sched_engine-&gt;queue_priority_hint != (-((int)(~0U &gt;&gt; 1)) - 1)) &lt;0&gt;[ 166.210781] Volviendo buffer ftrace: &lt;0 &gt;[ 166.210795] --------------------------------- ... &lt;0&gt;[ 167.302811] drm_fdin-1097 2 ..s1. 165741070us: trace_ports: 0000:00:02.0 rcs0: promover { ccid:20 1217:2 prio 0 } &lt;0&gt;[ 167.302861] drm_fdin-1097 2d.s2. 165741072us: execlists_submission_tasklet: 0000:00:02.0 rcs0: apropiación del último = 1217:2, prio = 0, sugerencia = 2147483646 &lt;0&gt; [167.302928] drm_fdin-1097 2d.s2. 165741072us: __i915_request_unsubmit: 0000:00:02.0 rcs0: valla 1217:2, actual 0 &lt;0&gt;[ 167.302992] drm_fdin-1097 2d.s2. 165741073us: __i915_request_submit: 0000:00:02.0 rcs0: valla 3:4660, actual 4659 &lt;0&gt;[ 167.303044] drm_fdin-1097 2d.s1. 165741076us: execlists_submission_tasklet: 0000:00:02.0 rcs0: contexto:3 programación de entrada, ccid:40 &lt;0&gt;[ 167.303095] drm_fdin-1097 2d.s1. 165741077us: trace_ports: 0000:00:02.0 rcs0: enviar { ccid:40 3:4660* prio 2147483646 } &lt;0&gt;[ 167.303159] kworker\/-89 11..... 165741139us: i915_request_retire.part.0: 0000:00 :02.0 rcs0: valla c90:2, actual 2 &lt;0&gt;[ 167.303208] kworker\/-89 11..... 165741148us : __intel_context_do_unpin: 0000:00:02.0 rcs0: contexto:c90 desanclar &lt;0&gt;[ 167.303272] kworker\/ -89 11..... 165741159us: i915_request_retire.part.0: 0000:00:02.0 rcs0: valla 1217:2, actual 2 &lt;0&gt;[ 167.303321] kworker\/-89 11..... 165741166us: __intel_context_do_unpin: 0000:00:02.0 rcs0: contexto:1217 desanclar &lt;0&gt;[ 167.303384] kworker\/-89 11..... 165741170us: i915_request_retire.part.0: 0000:00:02.0 rcs0: valla 3:4660, actual 4660 &lt; 0&gt;[ 167.303434] ktrabajador\/-89 11d..1. 165741172us: __intel_context_retire: 0000:00:02.0 rcs0: contexto:1216 retirar tiempo de ejecución: { total:56028ns, avg:56028ns } &lt;0&gt;[ 167.303484] kworker\/-89 11..... 165741198us: __engine_park: 0000:00: 02.0 rcs0: estacionado &lt;0&gt;[ 167.303534] -0 5d.H3. 165741207us: execlists_irq_handler: 0000:00:02.0 rcs0: rendimiento del semáforo: 00000040 &lt;0&gt;[ 167.303583] kworker\/-89 11..... 165741397us: __intel_context_retire: 0000:00:02.0 s0: contexto: 1217 retirar el tiempo de ejecución: {total :325575ns, promedio:0ns } &lt;0&gt;[ 167.303756] kworker\/-89 11..... 165741777us : __intel_context_retire: 0000:00:02.0 rcs0: contexto:c90 retirar tiempo de ejecución: { total:0ns, promedio:0ns } &lt; 0&gt;[ 167.303806] kworker\/-89 11..... 165742017us : __engine_park: __engine_park:283 GEM_BUG_ON(motor-&gt;sched_engine-&gt;queue_priority_hint != (-((int)(~0U &gt;&gt; 1)) - 1) ) &lt;0&gt;[ 167.303811] --------------------------------- &lt;4&gt;[ 167.304722] ---- --------[ cortar aquí ]------------ &lt;2&gt;[ 167.304725] ERROR del kernel en drivers\/gpu\/drm\/i915\/gt\/intel_engine_pm.c:283! &lt;4&gt;[ 167.304731] código de operación no válido: 0000 [#1] PREEMPT SMP NOPTI &lt;4&gt;[ 167.304734] CPU: 11 PID: 89 Comm: kworker\/11:1 Contaminado: GW 6.8.0-rc2-CI_DRM_14193-gc655e0fd2804+ #1 &lt;4&gt;[ 167.304736] ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3b031e4fcb2740988143c303f81f69f18ce86325","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4a3859ea5240365d21f6053ee219bb240d520895","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/67944e6db656bf1e986aa2a359f866f851091f8a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7eab7b021835ae422c38b968d5cc60e99408fb62","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8fd9b0ce8c26533fe4d5d15ea15bbf7b904b611c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ac9b6b3e8d1237136c8ebf0fa1ce037dd7e2948f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aed034866a08bb7e6e34d50a5629a4d23fe83703","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fe34587acc995e7b1d7a5d3444a0736721ec32b3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26938","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:09.077","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/i915\/bios: Tolerate devdata==NULL in intel_bios_encoder_supports_dp_dual_mode()\n\nIf we have no VBT, or the VBT didn't declare the encoder\nin question, we won't have the 'devdata' for the encoder.\nInstead of oopsing just bail early.\n\nWe won't be able to tell whether the port is DP++ or not,\nbut so be it.\n\n(cherry picked from commit 26410896206342c8a80d2b027923e9ee7d33b733)"},{"lang":"es","value":"En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: drm\/i915\/bios: Tolerate devdata==NULL in intel_bios_encoder_supports_dp_dual_mode() Si no tenemos VBT, o el VBT no declaró el codificador en cuestión, no tendremos los 'devdata' para el codificador. En lugar de huir, simplemente sal de la cárcel antes de tiempo. No podremos saber si el puerto es DP++ o no, pero que así sea. (cereza escogida del compromiso 26410896206342c8a80d2b027923e9ee7d33b733)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/32e39bab59934bfd3f37097d4dd85ac5eb0fd549","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/72e4d3fb72e9f0f016946158a7d95304832768e6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/94cf2fb6feccd625e5b4e23e1b70f39a206f82ac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a891add409e3bc381f4f68c2ce9d953f1865cb1f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f4bbac954d8f9ab214ea1d4f385de4fa6bd92dd0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26939","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:09.193","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/i915\/vma: Fix UAF on destroy against retire race\n\nObject debugging tools were sporadically reporting illegal attempts to\nfree a still active i915 VMA object when parking a GT believed to be idle.\n\n[161.359441] ODEBUG: free active (active state 0) object: ffff88811643b958 object type: i915_active hint: __i915_vma_active+0x0\/0x50 [i915]\n[161.360082] WARNING: CPU: 5 PID: 276 at lib\/debugobjects.c:514 debug_print_object+0x80\/0xb0\n...\n[161.360304] CPU: 5 PID: 276 Comm: kworker\/5:2 Not tainted 6.5.0-rc1-CI_DRM_13375-g003f860e5577+ #1\n[161.360314] Hardware name: Intel Corporation Rocket Lake Client Platform\/RocketLake S UDIMM 6L RVP, BIOS RKLSFWI1.R00.3173.A03.2204210138 04\/21\/2022\n[161.360322] Workqueue: i915-unordered __intel_wakeref_put_work [i915]\n[161.360592] RIP: 0010:debug_print_object+0x80\/0xb0\n...\n[161.361347] debug_object_free+0xeb\/0x110\n[161.361362] i915_active_fini+0x14\/0x130 [i915]\n[161.361866] release_references+0xfe\/0x1f0 [i915]\n[161.362543] i915_vma_parked+0x1db\/0x380 [i915]\n[161.363129] __gt_park+0x121\/0x230 [i915]\n[161.363515] ____intel_wakeref_put_last+0x1f\/0x70 [i915]\n\nThat has been tracked down to be happening when another thread is\ndeactivating the VMA inside __active_retire() helper, after the VMA's\nactive counter has been already decremented to 0, but before deactivation\nof the VMA's object is reported to the object debugging tool.\n\nWe could prevent from that race by serializing i915_active_fini() with\n__active_retire() via ref->tree_lock, but that wouldn't stop the VMA from\nbeing used, e.g. from __i915_vma_retire() called at the end of\n__active_retire(), after that VMA has been already freed by a concurrent\ni915_vma_destroy() on return from the i915_active_fini().  Then, we should\nrather fix the issue at the VMA level, not in i915_active.\n\nSince __i915_vma_parked() is called from __gt_park() on last put of the\nGT's wakeref, the issue could be addressed by holding the GT wakeref long\nenough for __active_retire() to complete before that wakeref is released\nand the GT parked.\n\nI believe the issue was introduced by commit d93939730347 (\"drm\/i915:\nRemove the vma refcount\") which moved a call to i915_active_fini() from\na dropped i915_vma_release(), called on last put of the removed VMA kref,\nto i915_vma_parked() processing path called on last put of a GT wakeref.\nHowever, its visibility to the object debugging tool was suppressed by a\nbug in i915_active that was fixed two weeks later with commit e92eb246feb9\n(\"drm\/i915\/active: Fix missing debug object activation\").\n\nA VMA associated with a request doesn't acquire a GT wakeref by itself.\nInstead, it depends on a wakeref held directly by the request's active\nintel_context for a GT associated with its VM, and indirectly on that\nintel_context's engine wakeref if the engine belongs to the same GT as the\nVMA's VM.  Those wakerefs are released asynchronously to VMA deactivation.\n\nFix the issue by getting a wakeref for the VMA's GT when activating it,\nand putting that wakeref only after the VMA is deactivated.  However,\nexclude global GTT from that processing path, otherwise the GPU never goes\nidle.  Since __i915_vma_retire() may be called from atomic contexts, use\nasync variant of wakeref put.  Also, to avoid circular locking dependency,\ntake care of acquiring the wakeref before VM mutex when both are needed.\n\nv7: Add inline comments with justifications for:\n    - using untracked variants of intel_gt_pm_get\/put() (Nirmoy),\n    - using async variant of _put(),\n    - not getting the wakeref in case of a global GTT,\n    - always getting the first wakeref outside vm->mutex.\nv6: Since __i915_vma_active\/retire() callbacks are not serialized, storing\n    a wakeref tracking handle inside struct i915_vma is not safe, and\n    there is no other good place for that.  Use untracked variants of\n    intel_gt_pm_get\/put_async().\nv5: Replace \"tile\" with \"GT\" across commit description (Rodrigo),\n  - \n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/i915\/vma: Corrección de UAF al destruir contra ejecución de retirada. Las herramientas de depuración de objetos informaban esporádicamente intentos ilegales de liberar un objeto i915 VMA aún activo al estacionar un GT que se creía que estaba inactivo. [161.359441] ODEBUG: objeto activo libre (estado activo 0): ffff88811643b958 tipo de objeto: i915_active sugerencia: __i915_vma_active+0x0\/0x50 [i915] [161.360082] ADVERTENCIA: CPU: 5 PID: 276 en lib\/debugobjects.c:514 _imprimir_objeto+ 0x80\/0xb0 ... [161.360304] CPU: 5 PID: 276 Comm: kworker\/5:2 No contaminado 6.5.0-rc1-CI_DRM_13375-g003f860e5577+ #1 [161.360314] Nombre de hardware: Intel Corporation Rocket Lake Client Platform\/RocketLake S UDIMM 6L RVP, BIOS RKLSFWI1.R00.3173.A03.2204210138 21\/04\/2022 [161.360322] Cola de trabajo: i915 desordenado __intel_wakeref_put_work [i915] [161.360592] RIP 0010:debug_print_object+0x 80\/0xb0... [161.361347] debug_object_free +0xeb\/0x110 [161.361362] i915_active_fini+0x14\/0x130 [i915] [161.361866] referencias de versión+0xfe\/0x1f0 [i915] [161.362543] i915_vma_parked+0x1db\/0x380 [i915] .363129] __gt_park+0x121\/0x230 [i915] [161.363515 ] ____intel_wakeref_put_last+0x1f\/0x70 [i915] Se ha rastreado que eso sucede cuando otro subproceso desactiva el VMA dentro del asistente __active_retire(), después de que el contador activo del VMA ya se haya reducido a 0, pero antes de que se desactive la desactivación del objeto del VMA. reportado a la herramienta de depuración de objetos. Podríamos evitar esa ejecución serializando i915_active_fini() con __active_retire() a través de ref-&gt;tree_lock, pero eso no impediría que se use VMA, por ejemplo, desde __i915_vma_retire() llamado al final de __active_retire(), después de ese VMA ya ha sido liberado por un i915_vma_destroy() concurrente al regresar de i915_active_fini(). Entonces, deberíamos solucionar el problema a nivel de VMA, no en i915_active. Dado que __i915_vma_parked() se llama desde __gt_park() en la última colocación del wakeref del GT, el problema podría solucionarse manteniendo el wakeref del GT el tiempo suficiente para que __active_retire() se complete antes de que se libere el wakeref y se estacione el GT. Creo que el problema fue introducido por el commit d93939730347 (\"drm\/i915: Eliminar el recuento de vma\") que movió una llamada a i915_active_fini() desde un i915_vma_release() eliminado, llamado en la última colocación del kref de VMA eliminado, a i915_vma_parked() ruta de procesamiento llamada en la última colocación de un wakeref GT. Sin embargo, su visibilidad para la herramienta de depuración de objetos fue suprimida por un error en i915_active que se solucionó dos semanas después con el commit e92eb246feb9 (\"drm\/i915\/active: Reparar la activación del objeto de depuración que falta\"). Un VMA asociado con una solicitud no adquiere un wakeref GT por sí solo. En cambio, depende de un wakeref mantenido directamente por el intel_context activo de la solicitud para un GT asociado con su VM, e indirectamente del wakeref del motor de ese intel_context si el motor pertenece al mismo GT que la VM del VMA. Esos wakerefs se liberan de forma asincrónica con la desactivación de VMA. Solucione el problema obteniendo un wakeref para el GT del VMA al activarlo y colocando ese wakeref solo después de que se desactive el VMA. Sin embargo, excluya el GTT global de esa ruta de procesamiento; de lo contrario, la GPU nunca quedará inactiva. Dado que se puede llamar a __i915_vma_retire() desde contextos atómicos, utilice la variante asíncrona de wakeref put. Además, para evitar la dependencia del bloqueo circular, tenga cuidado de adquirir el wakeref antes del mutex de VM cuando ambos sean necesarios. v7: agregue comentarios en línea con justificaciones para: - usar variantes sin seguimiento de intel_gt_pm_get\/put() (Nirmoy), - usar la variante asíncrona de _put(), - no obtener el wakeref en caso de un GTT global, - obtener siempre el primer wakeref fuera de vm-&gt;mutex. ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0e45882ca829b26b915162e8e86dbb1095768e9e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/59b2626dd8c8a2e13f18054b3530e0c00073d79f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5e3eb862df9f972ab677fb19e0d4b9b1be8db7b5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/704edc9252f4988ae1ad7dafa23d0db8d90d7190","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26940","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:09.343","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/vmwgfx: Create debugfs ttm_resource_manager entry only if needed\n\nThe driver creates \/sys\/kernel\/debug\/dri\/0\/mob_ttm even when the\ncorresponding ttm_resource_manager is not allocated.\nThis leads to a crash when trying to read from this file.\n\nAdd a check to create mob_ttm, system_mob_ttm, and gmr_ttm debug file\nonly when the corresponding ttm_resource_manager is allocated.\n\ncrash> bt\nPID: 3133409  TASK: ffff8fe4834a5000  CPU: 3    COMMAND: \"grep\"\n #0 [ffffb954506b3b20] machine_kexec at ffffffffb2a6bec3\n #1 [ffffb954506b3b78] __crash_kexec at ffffffffb2bb598a\n #2 [ffffb954506b3c38] crash_kexec at ffffffffb2bb68c1\n #3 [ffffb954506b3c50] oops_end at ffffffffb2a2a9b1\n #4 [ffffb954506b3c70] no_context at ffffffffb2a7e913\n #5 [ffffb954506b3cc8] __bad_area_nosemaphore at ffffffffb2a7ec8c\n #6 [ffffb954506b3d10] do_page_fault at ffffffffb2a7f887\n #7 [ffffb954506b3d40] page_fault at ffffffffb360116e\n    [exception RIP: ttm_resource_manager_debug+0x11]\n    RIP: ffffffffc04afd11  RSP: ffffb954506b3df0  RFLAGS: 00010246\n    RAX: ffff8fe41a6d1200  RBX: 0000000000000000  RCX: 0000000000000940\n    RDX: 0000000000000000  RSI: ffffffffc04b4338  RDI: 0000000000000000\n    RBP: ffffb954506b3e08   R8: ffff8fee3ffad000   R9: 0000000000000000\n    R10: ffff8fe41a76a000  R11: 0000000000000001  R12: 00000000ffffffff\n    R13: 0000000000000001  R14: ffff8fe5bb6f3900  R15: ffff8fe41a6d1200\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n #8 [ffffb954506b3e00] ttm_resource_manager_show at ffffffffc04afde7 [ttm]\n #9 [ffffb954506b3e30] seq_read at ffffffffb2d8f9f3\n    RIP: 00007f4c4eda8985  RSP: 00007ffdbba9e9f8  RFLAGS: 00000246\n    RAX: ffffffffffffffda  RBX: 000000000037e000  RCX: 00007f4c4eda8985\n    RDX: 000000000037e000  RSI: 00007f4c41573000  RDI: 0000000000000003\n    RBP: 000000000037e000   R8: 0000000000000000   R9: 000000000037fe30\n    R10: 0000000000000000  R11: 0000000000000246  R12: 00007f4c41573000\n    R13: 0000000000000003  R14: 00007f4c41572010  R15: 0000000000000003\n    ORIG_RAX: 0000000000000000  CS: 0033  SS: 002b"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/vmwgfx: cree la entrada debugfs ttm_resource_manager solo si es necesario. El controlador crea \/sys\/kernel\/debug\/dri\/0\/mob_ttm incluso cuando el ttm_resource_manager correspondiente no está asignado. Esto provoca un bloqueo al intentar leer este archivo. Agregue una marca para crear archivos de depuración mob_ttm, system_mob_ttm y gmr_ttm solo cuando se asigne el ttm_resource_manager correspondiente. crash&gt; bt PID: 3133409 TAREA: ffff8fe4834a5000 CPU: 3 COMANDO: \"grep\" #0 [ffffb954506b3b20] machine_kexec en ffffffffb2a6bec3 #1 [ffffb954506b3b78] __crash_kexec en ffffffffb2bb598a #2 ffb954506b3c38] crash_kexec en ffffffffb2bb68c1 #3 [ffffb954506b3c50] oops_end en ffffffffb2a2a9b1 # 4 [ffffb954506b3c70] no_context en ffffffffb2a7e913 #5 [ffffb954506b3cc8] __bad_area_nosemaphore en ffffffffb2a7ec8c #6 [ffffb954506b3d10] do_page_fault en ffffffffb2a7f887 #7 54506b3d40] page_fault en ffffffffb360116e [excepción RIP: ttm_resource_manager_debug+0x11] RIP: ffffffffc04afd11 RSP: ffffb954506b3df0 RFLAGS: 00010246 RAX: ffff8fe41a6d1200 RBX: 0000000000000000 RCX: 0000000000000940 RDX: 0000000000000000 RSI: ffffffffc04b4338 RDI: 0000000000000000 RBP: ffffb9545 06b3e08 R8: ffff8fee3ffad000 R9: 0000000000000000 R10: ffff8fe41a76a000 R11: 0000000000000001 R12: 00000000ffffffff R13: 0000000000000001 R14: ffff8fe5bb6f3900 R15: ffff8fe41a6d1200 ORIG_RAX: ffffffffffffff CS: 0010 SS : 0018 #8 [ffffb954506b3e00] ttm_resource_manager_show en ffffffffc04afde7 [ttm] #9 [ffffb954506b3e30] seq_read en ffffffffb2d8f9f3 RIP: 00007f4c4eda8985 RSP: RFLAGS: 00000246 RAX: ffffffffffffffda RBX: 000000000037e000 RCX: 00007f4c4eda8985 RDX: 000000000037e000 RSI: 00007f4c41573000 RDI: 00000000000000 03 PBR: 000000000037e000 R8: 0000000000000000 R9: 000000000037fe30 R10: 0000000000000000 R11: 0000000000000246 R12: 00007f4c41573000 R13: 0000000000000003 R14: 00007f4c41572010 R15: 0000000000000003 ORIG_RAX: 0000000000000000 CS: 0033 SS: 002b"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/016119154981d81c9e8f2ea3f56b9e2b4ea14500","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/042ef0afc40fa1a22b3608f22915b91ce39d128f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/25e3ce59c1200f1f0563e39de151f34962ab0fe1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4be9075fec0a639384ed19975634b662bfab938f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb08db0fc5354fa17b7ed66dab3c503332423451","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26941","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:09.487","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/dp: Fix divide-by-zero regression on DP MST unplug with nouveau\n\nFix a regression when using nouveau and unplugging a StarTech MSTDP122DP\nDisplayPort 1.2 MST hub (the same regression does not appear when using\na Cable Matters DisplayPort 1.4 MST hub). Trace:\n\n divide error: 0000 [#1] PREEMPT SMP PTI\n CPU: 7 PID: 2962 Comm: Xorg Not tainted 6.8.0-rc3+ #744\n Hardware name: Razer Blade\/DANA_MB, BIOS 01.01 08\/31\/2018\n RIP: 0010:drm_dp_bw_overhead+0xb4\/0x110 [drm_display_helper]\n Code: c6 b8 01 00 00 00 75 61 01 c6 41 0f af f3 41 0f af f1 c1 e1 04 48 63 c7 31 d2 89 ff 48 8b 5d f8 c9 48 0f af f1 48 8d 44 06 ff <48> f7 f7 31 d2 31 c9 31 f6 31 ff 45 31 c0 45 31 c9 45 31 d2 45 31\n RSP: 0018:ffffb2c5c211fa30 EFLAGS: 00010206\n RAX: ffffffffffffffff RBX: 0000000000000000 RCX: 0000000000f59b00\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n RBP: ffffb2c5c211fa48 R08: 0000000000000001 R09: 0000000000000020\n R10: 0000000000000004 R11: 0000000000000000 R12: 0000000000023b4a\n R13: ffff91d37d165800 R14: ffff91d36fac6d80 R15: ffff91d34a764010\n FS:  00007f4a1ca3fa80(0000) GS:ffff91d6edbc0000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000559491d49000 CR3: 000000011d180002 CR4: 00000000003706f0\n Call Trace:\n  <TASK>\n  ? show_regs+0x6d\/0x80\n  ? die+0x37\/0xa0\n  ? do_trap+0xd4\/0xf0\n  ? do_error_trap+0x71\/0xb0\n  ? drm_dp_bw_overhead+0xb4\/0x110 [drm_display_helper]\n  ? exc_divide_error+0x3a\/0x70\n  ? drm_dp_bw_overhead+0xb4\/0x110 [drm_display_helper]\n  ? asm_exc_divide_error+0x1b\/0x20\n  ? drm_dp_bw_overhead+0xb4\/0x110 [drm_display_helper]\n  ? drm_dp_calc_pbn_mode+0x2e\/0x70 [drm_display_helper]\n  nv50_msto_atomic_check+0xda\/0x120 [nouveau]\n  drm_atomic_helper_check_modeset+0xa87\/0xdf0 [drm_kms_helper]\n  drm_atomic_helper_check+0x19\/0xa0 [drm_kms_helper]\n  nv50_disp_atomic_check+0x13f\/0x2f0 [nouveau]\n  drm_atomic_check_only+0x668\/0xb20 [drm]\n  ? drm_connector_list_iter_next+0x86\/0xc0 [drm]\n  drm_atomic_commit+0x58\/0xd0 [drm]\n  ? __pfx___drm_printfn_info+0x10\/0x10 [drm]\n  drm_atomic_connector_commit_dpms+0xd7\/0x100 [drm]\n  drm_mode_obj_set_property_ioctl+0x1c5\/0x450 [drm]\n  ? __pfx_drm_connector_property_set_ioctl+0x10\/0x10 [drm]\n  drm_connector_property_set_ioctl+0x3b\/0x60 [drm]\n  drm_ioctl_kernel+0xb9\/0x120 [drm]\n  drm_ioctl+0x2d0\/0x550 [drm]\n  ? __pfx_drm_connector_property_set_ioctl+0x10\/0x10 [drm]\n  nouveau_drm_ioctl+0x61\/0xc0 [nouveau]\n  __x64_sys_ioctl+0xa0\/0xf0\n  do_syscall_64+0x76\/0x140\n  ? do_syscall_64+0x85\/0x140\n  ? do_syscall_64+0x85\/0x140\n  entry_SYSCALL_64_after_hwframe+0x6e\/0x76\n RIP: 0033:0x7f4a1cd1a94f\n Code: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10 00 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 44 24 10 b8 10 00 00 00 0f 05 <41> 89 c0 3d 00 f0 ff ff 77 1f 48 8b 44 24 18 64 48 2b 04 25 28 00\n RSP: 002b:00007ffd2f1df520 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n RAX: ffffffffffffffda RBX: 00007ffd2f1df5b0 RCX: 00007f4a1cd1a94f\n RDX: 00007ffd2f1df5b0 RSI: 00000000c01064ab RDI: 000000000000000f\n RBP: 00000000c01064ab R08: 000056347932deb8 R09: 000056347a7d99c0\n R10: 0000000000000000 R11: 0000000000000246 R12: 000056347938a220\n R13: 000000000000000f R14: 0000563479d9f3f0 R15: 0000000000000000\n  <\/TASK>\n Modules linked in: rfcomm xt_conntrack nft_chain_nat xt_MASQUERADE nf_nat nf_conntrack_netlink nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 xfrm_user xfrm_algo xt_addrtype nft_compat nf_tables nfnetlink br_netfilter bridge stp llc ccm cmac algif_hash overlay algif_skcipher af_alg bnep binfmt_misc snd_sof_pci_intel_cnl snd_sof_intel_hda_common snd_soc_hdac_hda snd_sof_pci snd_sof_xtensa_dsp snd_sof_intel_hda snd_sof snd_sof_utils snd_soc_acpi_intel_match snd_soc_acpi snd_soc_core snd_compress snd_sof_intel_hda_mlink snd_hda_ext_core iwlmvm intel_rapl_msr intel_rapl_common intel_tcc_cooling x86_pkg_temp_thermal intel_powerclamp mac80211 coretemp kvm_intel snd_hda_codec_hdmi kvm snd_hda_\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/dp: Se corrigió la regresión de división por cero en DP MST desconectar con nouveau Se corrigió una regresión al usar nouveau y desconectar un concentrador MST StarTech MSTDP122DP DisplayPort 1.2 (la misma regresión no aparecen cuando se utiliza un concentrador Cable Matters DisplayPort 1.4 MST). Seguimiento: error de división: 0000 [#1] PREEMPT SMP PTI CPU: 7 PID: 2962 Comm: Xorg Not tainted 6.8.0-rc3+ #744 Nombre de hardware: Razer Blade\/DANA_MB, BIOS 01.01 31\/08\/2018 RIP: 0010: drm_dp_bw_overhead+0xb4\/0x110 [drm_display_helper] Código: c6 b8 01 00 00 00 75 61 01 c6 41 0f af f3 41 0f af f1 c1 e1 04 48 63 c7 31 d2 89 ff 48 8b 5d f8 c9 48 0f af f1 48 8d 44 06 y siguientes &lt;48&gt; f7 f7 31 d2 31 c9 31 f6 31 ff 45 31 c0 45 31 c9 45 31 d2 45 31 RSP: 0018:ffffb2c5c211fa30 EFLAGS: 00010206 RAX: ffffffffffffffff RBX: 000000000 RCX: 0000000000f59b00 RDX: 0000000000000000 RSI: 0000000000000000 RDI : 0000000000000000 RBP: ffffb2c5c211fa48 R08: 0000000000000001 R09: 0000000000000020 R10: 00000000000000004 R11: 0000000000000000 R12: 0000000000023b4a R13: ffff91d37d165800 R14: ffff91d36fac6d80 R15: ffff91d34a764010 FS: 00007f4a1ca3fa80(0000) GS:ffff91d6edbc0000(0000) 00000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000559491d49000 CR3: 000000011d180002 CR4: 00000000003706f0 Seguimiento de llamadas:  ? show_regs+0x6d\/0x80? morir+0x37\/0xa0? do_trap+0xd4\/0xf0? do_error_trap+0x71\/0xb0? drm_dp_bw_overhead+0xb4\/0x110 [drm_display_helper] ? exc_divide_error+0x3a\/0x70? drm_dp_bw_overhead+0xb4\/0x110 [drm_display_helper] ? asm_exc_divide_error+0x1b\/0x20? drm_dp_bw_overhead+0xb4\/0x110 [drm_display_helper] ? drm_dp_calc_pbn_mode+0x2e\/0x70 [drm_display_helper] nv50_msto_atomic_check+0xda\/0x120 [nuevo] drm_atomic_helper_check_modeset+0xa87\/0xdf0 [drm_kms_helper] drm_atomic_helper_check+0x19\/0xa0 [drm_km s_helper] nv50_disp_atomic_check+0x13f\/0x2f0 [nuevo] drm_atomic_check_only+0x668\/0xb20 [drm]? drm_connector_list_iter_next+0x86\/0xc0 [drm] drm_atomic_commit+0x58\/0xd0 [drm] ? __pfx___drm_printfn_info+0x10\/0x10 [drm] drm_atomic_connector_commit_dpms+0xd7\/0x100 [drm] drm_mode_obj_set_property_ioctl+0x1c5\/0x450 [drm] ? __pfx_drm_connector_property_set_ioctl+0x10\/0x10 [drm] drm_connector_property_set_ioctl+0x3b\/0x60 [drm] drm_ioctl_kernel+0xb9\/0x120 [drm] drm_ioctl+0x2d0\/0x550 [drm] ? __pfx_drm_connector_property_set_ioctl+0x10\/0x10 [drm] nouveau_drm_ioctl+0x61\/0xc0 [nuevo] __x64_sys_ioctl+0xa0\/0xf0 do_syscall_64+0x76\/0x140 ? do_syscall_64+0x85\/0x140? do_syscall_64+0x85\/0x140 Entry_SYSCALL_64_after_hwframe+0x6e\/0x76 RIP: 0033:0x7f4a1cd1a94f Código: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 44 24 10 b8 10 00 00 00 0f 05 &lt;41&gt; 89 c0 3d 00 f0 ff ff 77 1f 48 8b 44 24 18 64 48 2b 04 25 28 00 RSP: 002b:00007ffd2f1df520 EFLAGS: 0246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00007ffd2f1df5b0 RCX: 00007f4a1cd1a94f RDX: 00007ffd2f1df5b0 RSI: 00000000c01064ab RDI: 000000000000000f RBP: 00000000c01064ab R08: 000056347932deb8 R09: 00056347a7d99c0 R10: 0000000000000000 R11: 0000000000000246 R12: 000056347938a220 R13: 0000000000000000f R14: 0000563479d9f3f0 0000000000000000  Módulos vinculados en: rfcomm xt_conntrack nft_chain_nat xt_masquerade nf_nat nf_conntrack_netlink nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 xfrm_user xfrm_algo Xad_addrtype nft_compat nf_tables nfnetlink br_netfilter puente stp llc ccm cmac alkh_ overkh_ overkh_ overkh_ overkh_ overgh_ upny _alg bnep binfmt_misc snd_sof_pci_intel_cnl snd_sof_intel_hda_common snd_soc_hdac_hda snd_sof_pci snd_sof_xtensa_dsp snd_sof_intel_hda SOC_ACPP SOCPI SND_SOC_CORE SND_COMPRESS SND_SOF_INTEL_INTEL_HDA_MLINK SND_HDA_EXT_CORE IWLMVM Intel_raPl_MMSR Intel_raPl_Common Intel_tccc_Cooling x86_pkg_temp_Thermal Intel_PowerClAMCCLAMCCLAMCCLAMCO11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111. a_codec_hdmi kvm snd_hda_ ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/828862071a6ca0c52655e6e62ac7abfef3e5c578","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9cbd1dae842737bfafa4b10a87909fa209dde250","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26942","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:09.633","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: phy: qcom: at803x: fix kernel panic with at8031_probe\n\nOn reworking and splitting the at803x driver, in splitting function of\nat803x PHYs it was added a NULL dereference bug where priv is referenced\nbefore it's actually allocated and then is tried to write to for the\nis_1000basex and is_fiber variables in the case of at8031, writing on\nthe wrong address.\n\nFix this by correctly setting priv local variable only after\nat803x_probe is called and actually allocates priv in the phydev struct."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: phy: qcom: at803x: corrige el pánico del kernel con at8031_probe Al reelaborar y dividir el controlador at803x, en la función de división de los PHY de at803x se agregó un error de desreferencia NULL donde se hace referencia a priv antes de que realmente se asigne y luego se intenta escribir para las variables is_1000basex e is_fiber en el caso de at8031, escribiendo en la dirección incorrecta. Solucione este problema configurando correctamente la variable local priv solo después de llamar a at803x_probe y realmente asignar priv en la estructura phydev."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6a4aee277740d04ac0fd54cfa17cc28261932ddc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a8a296ad9957b845b89bcf48be1cf8c74875ecc3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26943","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:09.877","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnouveau\/dmem: handle kcalloc() allocation failure\n\nThe kcalloc() in nouveau_dmem_evict_chunk() will return null if\nthe physical memory has run out. As a result, if we dereference\nsrc_pfns, dst_pfns or dma_addrs, the null pointer dereference bugs\nwill happen.\n\nMoreover, the GPU is going away. If the kcalloc() fails, we could not\nevict all pages mapping a chunk. So this patch adds a __GFP_NOFAIL\nflag in kcalloc().\n\nFinally, as there is no need to have physically contiguous memory,\nthis patch switches kcalloc() to kvcalloc() in order to avoid\nfailing allocations."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nouveau\/dmem: maneja el error de asignación de kcalloc() El kcalloc() en nouveau_dmem_evict_chunk() devolverá nulo si la memoria física se ha agotado. Como resultado, si eliminamos la referencia a src_pfns, dst_pfns o dma_addrs, se producirán errores de desreferenciación del puntero nulo. Además, la GPU está desapareciendo. Si kcalloc() falla, no podremos desalojar todas las páginas que asignan un fragmento. Entonces este parche agrega un indicador __GFP_NOFAIL en kcalloc(). Finalmente, como no es necesario tener memoria físicamente contigua, este parche cambia kcalloc() a kvcalloc() para evitar asignaciones fallidas."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/16e87fe23d4af6df920406494ced5c0f4354567b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2a84744a037b8a511d6a9055f3defddc28ff4a4d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3e82f7383e0b82a835e6b6b06a348b2bc4e2c2ee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5e81773757a95fc298e96cfd6d4700f07b6192a2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9acfd8b083a0ffbd387566800d89f55058a68af2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26944","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:10.010","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: zoned: fix use-after-free in do_zone_finish()\n\nShinichiro reported the following use-after-free triggered by the device\nreplace operation in fstests btrfs\/070.\n\n BTRFS info (device nullb1): scrub: finished on devid 1 with status: 0\n ==================================================================\n BUG: KASAN: slab-use-after-free in do_zone_finish+0x91a\/0xb90 [btrfs]\n Read of size 8 at addr ffff8881543c8060 by task btrfs-cleaner\/3494007\n\n CPU: 0 PID: 3494007 Comm: btrfs-cleaner Tainted: G        W          6.8.0-rc5-kts #1\n Hardware name: Supermicro Super Server\/X11SPi-TF, BIOS 3.3 02\/21\/2020\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x5b\/0x90\n  print_report+0xcf\/0x670\n  ? __virt_addr_valid+0x200\/0x3e0\n  kasan_report+0xd8\/0x110\n  ? do_zone_finish+0x91a\/0xb90 [btrfs]\n  ? do_zone_finish+0x91a\/0xb90 [btrfs]\n  do_zone_finish+0x91a\/0xb90 [btrfs]\n  btrfs_delete_unused_bgs+0x5e1\/0x1750 [btrfs]\n  ? __pfx_btrfs_delete_unused_bgs+0x10\/0x10 [btrfs]\n  ? btrfs_put_root+0x2d\/0x220 [btrfs]\n  ? btrfs_clean_one_deleted_snapshot+0x299\/0x430 [btrfs]\n  cleaner_kthread+0x21e\/0x380 [btrfs]\n  ? __pfx_cleaner_kthread+0x10\/0x10 [btrfs]\n  kthread+0x2e3\/0x3c0\n  ? __pfx_kthread+0x10\/0x10\n  ret_from_fork+0x31\/0x70\n  ? __pfx_kthread+0x10\/0x10\n  ret_from_fork_asm+0x1b\/0x30\n  <\/TASK>\n\n Allocated by task 3493983:\n  kasan_save_stack+0x33\/0x60\n  kasan_save_track+0x14\/0x30\n  __kasan_kmalloc+0xaa\/0xb0\n  btrfs_alloc_device+0xb3\/0x4e0 [btrfs]\n  device_list_add.constprop.0+0x993\/0x1630 [btrfs]\n  btrfs_scan_one_device+0x219\/0x3d0 [btrfs]\n  btrfs_control_ioctl+0x26e\/0x310 [btrfs]\n  __x64_sys_ioctl+0x134\/0x1b0\n  do_syscall_64+0x99\/0x190\n  entry_SYSCALL_64_after_hwframe+0x6e\/0x76\n\n Freed by task 3494056:\n  kasan_save_stack+0x33\/0x60\n  kasan_save_track+0x14\/0x30\n  kasan_save_free_info+0x3f\/0x60\n  poison_slab_object+0x102\/0x170\n  __kasan_slab_free+0x32\/0x70\n  kfree+0x11b\/0x320\n  btrfs_rm_dev_replace_free_srcdev+0xca\/0x280 [btrfs]\n  btrfs_dev_replace_finishing+0xd7e\/0x14f0 [btrfs]\n  btrfs_dev_replace_by_ioctl+0x1286\/0x25a0 [btrfs]\n  btrfs_ioctl+0xb27\/0x57d0 [btrfs]\n  __x64_sys_ioctl+0x134\/0x1b0\n  do_syscall_64+0x99\/0x190\n  entry_SYSCALL_64_after_hwframe+0x6e\/0x76\n\n The buggy address belongs to the object at ffff8881543c8000\n  which belongs to the cache kmalloc-1k of size 1024\n The buggy address is located 96 bytes inside of\n  freed 1024-byte region [ffff8881543c8000, ffff8881543c8400)\n\n The buggy address belongs to the physical page:\n page:00000000fe2c1285 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1543c8\n head:00000000fe2c1285 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0\n flags: 0x17ffffc0000840(slab|head|node=0|zone=2|lastcpupid=0x1fffff)\n page_type: 0xffffffff()\n raw: 0017ffffc0000840 ffff888100042dc0 ffffea0019e8f200 dead000000000002\n raw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\n page dumped because: kasan: bad access detected\n\n Memory state around the buggy address:\n  ffff8881543c7f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  ffff8881543c7f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n >ffff8881543c8000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                                        ^\n  ffff8881543c8080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  ffff8881543c8100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\nThis UAF happens because we're accessing stale zone information of a\nalready removed btrfs_device in do_zone_finish().\n\nThe sequence of events is as follows:\n\nbtrfs_dev_replace_start\n  btrfs_scrub_dev\n   btrfs_dev_replace_finishing\n    btrfs_dev_replace_update_device_in_mapping_tree <-- devices replaced\n    btrfs_rm_dev_replace_free_srcdev\n     btrfs_free_device                              <-- device freed\n\ncleaner_kthread\n btrfs_delete_unused_bgs\n  btrfs_zone_finish\n   do_zone_finish              <-- refers the freed device\n\nThe reason for this is that we're using a\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: btrfs:zoned: corrige use-after-free en do_zone_finish() Shinichiro informó el siguiente use-after-free desencadenado por la operación de reemplazo de dispositivo en fstests btrfs\/070. Información BTRFS (dispositivo nullb1): limpieza: finalizado en el dispositivo 1 con estado: 0 ================================== ================================= ERROR: KASAN: uso de losa después de liberarlo en do_zone_finish+0x91a\/0xb90 [btrfs] Lectura del tamaño 8 en la dirección ffff8881543c8060 mediante la tarea btrfs-cleaner\/3494007 CPU: 0 PID: 3494007 Comm: btrfs-cleaner Contaminado: GW 6.8.0-rc5-kts #1 Nombre del hardware: Supermicro Super Server\/X11SPi-TF , BIOS 3.3 21\/02\/2020 Seguimiento de llamadas:  dump_stack_lvl+0x5b\/0x90 print_report+0xcf\/0x670 ? __virt_addr_valid+0x200\/0x3e0 kasan_report+0xd8\/0x110 ? do_zone_finish+0x91a\/0xb90 [btrfs]? do_zone_finish+0x91a\/0xb90 [btrfs] do_zone_finish+0x91a\/0xb90 [btrfs] btrfs_delete_unused_bgs+0x5e1\/0x1750 [btrfs] ? __pfx_btrfs_delete_unused_bgs+0x10\/0x10 [btrfs] ? btrfs_put_root+0x2d\/0x220 [btrfs] ? btrfs_clean_one_deleted_snapshot+0x299\/0x430 [btrfs] clean_kthread+0x21e\/0x380 [btrfs] ? __pfx_cleaner_kthread+0x10\/0x10 [btrfs] kthread+0x2e3\/0x3c0 ? __pfx_kthread+0x10\/0x10 ret_from_fork+0x31\/0x70 ? __pfx_kthread+0x10\/0x10 ret_from_fork_asm+0x1b\/0x30  Asignado por tarea 3493983: kasan_save_stack+0x33\/0x60 kasan_save_track+0x14\/0x30 __kasan_kmalloc+0xaa\/0xb0 btrfs_alloc_device+0x b3\/0x4e0 [btrfs] lista_dispositivo_add.constprop.0+0x993\/ 0x1630 [btrfs] btrfs_scan_one_device+0x219\/0x3d0 [btrfs] btrfs_control_ioctl+0x26e\/0x310 [btrfs] __x64_sys_ioctl+0x134\/0x1b0 do_syscall_64+0x99\/0x190 entrada_SYSCALL_6 4_after_hwframe+0x6e\/0x76 Liberado por la tarea 3494056: kasan_save_stack+0x33\/0x60 kasan_save_track+0x14\/0x30 kasan_save_free_info+0x3f\/0x60 veneno_slab_object+0x102\/0x170 __kasan_slab_free+0x32\/0x70 kfree+0x11b\/0x320 btrfs_rm_dev_replace_free_srcdev+0xca\/0x280 [btrfs_dev_replace_finishing+0xd 7e\/0x14f0 [btrfs] btrfs_dev_replace_by_ioctl+0x1286\/0x25a0 [btrfs] btrfs_ioctl+0xb27\/0x57d0 [ btrfs] __x64_sys_ioctl+0x134\/0x1b0 do_syscall_64+0x99\/0x190 Entry_SYSCALL_64_after_hwframe+0x6e\/0x76 La dirección con errores pertenece al objeto en ffff8881543c8000 que pertenece al caché kmalloc-1k de tamaño 1024 Se encuentra la dirección con errores 96 bytes dentro de los 1024 bytes liberados región [ffff8881543c8000, ffff8881543c8400) La dirección del error pertenece a la página física: página:00000000fe2c1285 refcount:1 mapcount:0 mapeo:00000000000000000 index:0x0 pfn:0x1543c8 head:00000000fe2c1285 entero_mapcount:0 nr_pages_mapped:0 pincount:0 banderas: 0x17ffffc0000840(slab|head|node=0|zone=2|lastcpupid=0x1fffff) tipo de página: 0xffffffff() raw: 0017ffffc0000840 ffff888100042dc0 ffffea0019e8f200 dead000000000002 raw: 0000000000 0000000000100010 00000001ffffffff 0000000000000000 página volcada porque: kasan: mal acceso detectado Estado de la memoria alrededor de la dirección con errores : ffff8881543c7f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff8881543c7f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &gt;ffff8881543c8000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff8881543c8080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff8881543c8100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb Esta UAF sucede porque estamos acceder a información de zona obsoleta de un btrfs_device ya eliminado en do_zone_finish(). La secuencia de eventos es la siguiente: btrfs_dev_replace_start btrfs_scrub_dev btrfs_dev_replace_finishing btrfs_dev_replace_update_device_in_mapping_tree &lt;-- dispositivos reemplazados btrfs_rm_dev_replace_free_srcdev btrfs_free_device &lt;-- dispositivo liberado clean_kthread btrfs_delete_unused_ bgs btrfs_zone_finish do_zone_finish &lt;-- hace referencia al dispositivo liberado. La razón de esto es que estamos usando un ---truncado ---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1ec17ef59168a1a6f1105f5dc517f783839a5302","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/34ca809e055eca5cfe63d9c7efbf80b7c21b4e57","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26945","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:10.177","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: iaa - Fix nr_cpus < nr_iaa case\n\nIf nr_cpus < nr_iaa, the calculated cpus_per_iaa will be 0, which\ncauses a divide-by-0 in rebalance_wq_table().\n\nMake sure cpus_per_iaa is 1 in that case, and also in the nr_iaa == 0\ncase, even though cpus_per_iaa is never used if nr_iaa == 0, for\nparanoia."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: crypto: iaa - Corrige el caso nr_cpus &lt; nr_iaa Si nr_cpus &lt; nr_iaa, el cpus_per_iaa calculado será 0, lo que provoca una división por 0 en rebalance_wq_table(). Asegúrese de que cpus_per_iaa sea 1 en ese caso, y también en el caso de nr_iaa == 0, aunque cpus_per_iaa nunca se use si nr_iaa == 0, para paranoia."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5a7e89d3315d1be86aff8a8bf849023cda6547f7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a5ca1be7f9817de4e93085778b3ee2219bdc2664","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26946","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:10.480","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nkprobes\/x86: Use copy_from_kernel_nofault() to read from unsafe address\n\nRead from an unsafe address with copy_from_kernel_nofault() in\narch_adjust_kprobe_addr() because this function is used before checking\nthe address is in text or not. Syzcaller bot found a bug and reported\nthe case if user specifies inaccessible data area,\narch_adjust_kprobe_addr() will cause a kernel panic.\n\n[ mingo: Clarified the comment. ]"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: kprobes\/x86: use copy_from_kernel_nofault() para leer desde una dirección no segura Lea desde una dirección no segura con copy_from_kernel_nofault() en arch_adjust_kprobe_addr() porque esta función se usa antes de verificar que la dirección esté en texto O no. El bot Syzcaller encontró un error e informó el caso si el usuario especifica un área de datos inaccesible, arch_adjust_kprobe_addr() provocará un pánico en el kernel. [ mingo: Aclaró el comentario. ]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/20fdb21eabaeb8f78f8f701f56d14ea0836ec861","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4e51653d5d871f40f1bd5cf95cc7f2d8b33d063b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6417684315087904fffe8966d27ca74398c57dd6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b69f577308f1070004cafac106dd1a44099e5483","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f13edd1871d4fb4ab829aff629d47914e251bae3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26947","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:10.607","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nARM: 9359\/1: flush: check if the folio is reserved for no-mapping addresses\n\nSince commit a4d5613c4dc6 (\"arm: extend pfn_valid to take into account\nfreed memory map alignment\") changes the semantics of pfn_valid() to check\npresence of the memory map for a PFN. A valid page for an address which\nis reserved but not mapped by the kernel[1], the system crashed during\nsome uio test with the following memory layout:\n\n node   0: [mem 0x00000000c0a00000-0x00000000cc8fffff]\n node   0: [mem 0x00000000d0000000-0x00000000da1fffff]\n the uio layout is?0xc0900000, 0x100000\n\nthe crash backtrace like:\n\n  Unable to handle kernel paging request at virtual address bff00000\n  [...]\n  CPU: 1 PID: 465 Comm: startapp.bin Tainted: G           O      5.10.0 #1\n  Hardware name: Generic DT based system\n  PC is at b15_flush_kern_dcache_area+0x24\/0x3c\n  LR is at __sync_icache_dcache+0x6c\/0x98\n  [...]\n   (b15_flush_kern_dcache_area) from (__sync_icache_dcache+0x6c\/0x98)\n   (__sync_icache_dcache) from (set_pte_at+0x28\/0x54)\n   (set_pte_at) from (remap_pfn_range+0x1a0\/0x274)\n   (remap_pfn_range) from (uio_mmap+0x184\/0x1b8 [uio])\n   (uio_mmap [uio]) from (__mmap_region+0x264\/0x5f4)\n   (__mmap_region) from (__do_mmap_mm+0x3ec\/0x440)\n   (__do_mmap_mm) from (do_mmap+0x50\/0x58)\n   (do_mmap) from (vm_mmap_pgoff+0xfc\/0x188)\n   (vm_mmap_pgoff) from (ksys_mmap_pgoff+0xac\/0xc4)\n   (ksys_mmap_pgoff) from (ret_fast_syscall+0x0\/0x5c)\n  Code: e0801001 e2423001 e1c00003 f57ff04f (ee070f3e)\n  ---[ end trace 09cf0734c3805d52 ]---\n  Kernel panic - not syncing: Fatal exception\n\nSo check if PG_reserved was set to solve this issue.\n\n[1]: https:\/\/lore.kernel.org\/lkml\/Zbtdue57RO0QScJM@linux.ibm.com\/"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ARM: 9359\/1: descarga: verifique si la publicación está reservada para direcciones sin asignación. Desde el commit a4d5613c4dc6 (\"arm: extienda pfn_valid para tener en cuenta la alineación del mapa de memoria liberada\") cambia la semántica de pfn_valid() para verificar la presencia del mapa de memoria para un PFN. A valid page for an address which is reserved but not mapped by the kernel[1], the system crashed during some uio test with the following memory layout: node 0: [mem 0x00000000c0a00000-0x00000000cc8fffff] node 0: [mem 0x00000000d0000000-0x00000000da1fffff] el diseño de uio es? 0xc0900000, 0x100000 el seguimiento del fallo es como: No se puede manejar la solicitud de paginación del kernel en la dirección virtual bff00000 [...] CPU: 1 PID: 465 Comm: startapp.bin Contaminado: GO 5.10.0 #1 Nombre del hardware: La PC del sistema basado en DT genérico está en b15_flush_kern_dcache_area+0x24\/0x3c LR está en __sync_icache_dcache+0x6c\/0x98 [...] (b15_flush_kern_dcache_area) de (__sync_icache_dcache+0x6c\/0x98) (__sync_icache_dcache) de (set_pte_at+0x2 8\/0x54) (set_pte_at) desde (remap_pfn_range+0x1a0\/0x274) (remap_pfn_range) desde (uio_mmap+0x184\/0x1b8 [uio]) (uio_mmap [uio]) desde (__mmap_region+0x264\/0x5f4) (__mmap_region) desde (__do_mmap_mm+0x3ec\/0x440) milímetros) de (do_mmap+0x50\/0x58) (do_mmap) de (vm_mmap_pgoff+0xfc\/0x188) (vm_mmap_pgoff) de (ksys_mmap_pgoff+0xac\/0xc4) (ksys_mmap_pgoff) de (ret_fast_syscall+0x0\/0x5c) Código: e0801001 423001 e1c00003 f57ff04f (ee070f3e) ---[ end trace 09cf0734c3805d52 ]--- Pánico del kernel - no se sincroniza: excepción fatal. Así que verifique si PG_reserved estaba configurado para resolver este problema. [1]: https:\/\/lore.kernel.org\/lkml\/Zbtdue57RO0QScJM@linux.ibm.com\/"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0c027c2bad7f5111c51a358b5d392e1a695dabff","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0c66c6f4e21cb22220cbd8821c5c73fc157d20dc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9f7ddc222cae8254e93d5c169a8ae11a49d912a7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fb3a122a978626b33de3367ee1762da934c0f512","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26948","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:10.757","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/display: Add a dc_state NULL check in dc_state_release\n\n[How]\nCheck wheather state is NULL before releasing it."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amd\/display: agregue una verificación dc_state NULL en dc_state_release [Cómo] Verifique si el estado es NULL antes de liberarlo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/334b56cea5d9df5989be6cf1a5898114fa70ad98","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d37a08f840485995e3fb91dad95e441b9d28a269","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26949","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:10.930","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu\/pm: Fix NULL pointer dereference when get power limit\n\nBecause powerplay_table initialization is skipped under\nsriov case, We check and set default lower and upper OD\nvalue if powerplay_table is NULL."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amdgpu\/pm: corrige la desreferencia del puntero NULL cuando se obtiene el límite de energía. Debido a que la inicialización de powerplay_table se omite en el caso sriov, verificamos y configuramos el valor OD inferior y superior predeterminado si powerplay_table es NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/08ae9ef829b8055c2fdc8cfee37510c1f4721a07","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/99c2f1563b1400cc8331fc79d19ada1bb95bb388","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b8eaa8ef1f1157a9f330e36e66bdd7a693309948","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26950","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:11.080","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwireguard: netlink: access device through ctx instead of peer\n\nThe previous commit fixed a bug that led to a NULL peer->device being\ndereferenced. It's actually easier and faster performance-wise to\ninstead get the device from ctx->wg. This semantically makes more sense\ntoo, since ctx->wg->peer_allowedips.seq is compared with\nctx->allowedips_seq, basing them both in ctx. This also acts as a\ndefence in depth provision against freed peers."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: wireguard: netlink: acceda al dispositivo a través de ctx en lugar de peer. el commit anterior solucionó un error que provocaba que se desreferenciara un dispositivo NULL peer-&gt;. En realidad, es más fácil y rápido en cuanto a rendimiento obtener el dispositivo desde ctx-&gt;wg. Esto también tiene más sentido semánticamente, ya que ctx-&gt;wg-&gt;peer_allowedips.seq se compara con ctx-&gt;allowedips_seq, basándose ambos en ctx. Esto también actúa como una defensa en profundidad contra los pares liberados."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/09c3fa70f65175861ca948cb2f0f791e666c90e5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/493aa6bdcffd90a4f82aa614fe4f4db0641b4068","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4be453271a882c8ebc28df3dbf9e4d95e6ac42f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/71cbd32e3db82ea4a74e3ef9aeeaa6971969c86f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/93bcc1752c69bb309f4d8cfaf960ef1faeb34996","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c991567e6c638079304cc15dff28748e4a3c4a37","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d44bd323d8bb8031eef4bdc44547925998a11e47","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26951","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:11.223","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwireguard: netlink: check for dangling peer via is_dead instead of empty list\n\nIf all peers are removed via wg_peer_remove_all(), rather than setting\npeer_list to empty, the peer is added to a temporary list with a head on\nthe stack of wg_peer_remove_all(). If a netlink dump is resumed and the\ncursored peer is one that has been removed via wg_peer_remove_all(), it\nwill iterate from that peer and then attempt to dump freed peers.\n\nFix this by instead checking peer->is_dead, which was explictly created\nfor this purpose. Also move up the device_update_lock lockdep assertion,\nsince reading is_dead relies on that.\n\nIt can be reproduced by a small script like:\n\n    echo \"Setting config...\"\n    ip link add dev wg0 type wireguard\n    wg setconf wg0 \/big-config\n    (\n            while true; do\n                    echo \"Showing config...\"\n                    wg showconf wg0 > \/dev\/null\n            done\n    ) &\n    sleep 4\n    wg setconf wg0 <(printf \"[Peer]\\nPublicKey=$(wg genkey)\\n\")\n\nResulting in:\n\n    BUG: KASAN: slab-use-after-free in __lock_acquire+0x182a\/0x1b20\n    Read of size 8 at addr ffff88811956ec70 by task wg\/59\n    CPU: 2 PID: 59 Comm: wg Not tainted 6.8.0-rc2-debug+ #5\n    Call Trace:\n     <TASK>\n     dump_stack_lvl+0x47\/0x70\n     print_address_description.constprop.0+0x2c\/0x380\n     print_report+0xab\/0x250\n     kasan_report+0xba\/0xf0\n     __lock_acquire+0x182a\/0x1b20\n     lock_acquire+0x191\/0x4b0\n     down_read+0x80\/0x440\n     get_peer+0x140\/0xcb0\n     wg_get_device_dump+0x471\/0x1130"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: wireguard: netlink: verifique si hay pares pendientes a través de is_dead en lugar de una lista vacía. Si todos los pares se eliminan a través de wg_peer_remove_all(), en lugar de configurar peer_list como vacío, el par se agrega a una lista temporal. lista con un encabezado en la pila de wg_peer_remove_all(). Si se reanuda un volcado de netlink y el par seleccionado es uno que se eliminó mediante wg_peer_remove_all(), iterará desde ese par y luego intentará volcar los pares liberados. Para solucionar este problema, marque peer-&gt;is_dead, que se creó explícitamente para este propósito. También suba la aserción de bloqueo de dispositivo_update_lock, ya que la lectura is_dead depende de eso. Se puede reproducir mediante un pequeño script como: echo \"Configuración de configuración...\" ip link add dev wg0 tipo wireguard wg setconf wg0 \/big-config (mientras sea verdadero; haga echo \"Mostrando configuración...\" wg showconf wg0 &gt; \/ dev\/null done) &amp; sleep 4 wg setconf wg0 &lt;(printf \"[Peer]\\nPublicKey=$(wg genkey)\\n\") Resultando en: ERROR: KASAN: slab-use-after-free en __lock_acquire+0x182a\/0x1b20 Lectura de tamaño 8 en la dirección ffff88811956ec70 mediante la tarea wg\/59 CPU: 2 PID: 59 Comm: wg Not tainted 6.8.0-rc2-debug+ #5 Seguimiento de llamadas:  dump_stack_lvl+0x47\/0x70 print_address_description.constprop.0+0x2c \/0x380 print_report+0xab\/0x250 kasan_report+0xba\/0xf0 __lock_acquire+0x182a\/0x1b20 lock_acquire+0x191\/0x4b0 down_read+0x80\/0x440 get_peer+0x140\/0xcb0 wg_get_device_dump+0x471\/0x1130"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/13d107794304306164481d31ce33f8fdb25a9c04","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/302b2dfc013baca3dea7ceda383930d9297d231d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/55b6c738673871c9b0edae05d0c97995c1ff08c4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/710a177f347282eea162aec8712beb1f42d5ad87","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7bedfe4cfa38771840a355970e4437cd52d4046b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7cea3a9af0853fdbb1b16633a458f991dde6aac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f52be46e3e6ecefc2539119784324f0cbc09620a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26952","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:11.350","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: fix potencial out-of-bounds when buffer offset is invalid\n\nI found potencial out-of-bounds when buffer offset fields of a few requests\nis invalid. This patch set the minimum value of buffer offset field to\n->Buffer offset to validate buffer length."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ksmbd: corrige posibles límites cuando el desplazamiento del búfer no es válido. Encontré posibles límites cuando los campos de desplazamiento del búfer de algunas solicitudes no son válidos. Este parche establece el valor mínimo del campo de compensación del búfer en -&gt;Desplazamiento del búfer para validar la longitud del búfer."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0c5541b4c980626fa3cab16ba1a451757778bbb5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2dcda336b6e80b72d58d30d40f2fad9724e5fe63","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c6cd2e8d2d9aa7ee35b1fa6a668e32a22a9753da","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26953","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:11.457","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: esp: fix bad handling of pages from page_pool\n\nWhen the skb is reorganized during esp_output (!esp->inline), the pages\ncoming from the original skb fragments are supposed to be released back\nto the system through put_page. But if the skb fragment pages are\noriginating from a page_pool, calling put_page on them will trigger a\npage_pool leak which will eventually result in a crash.\n\nThis leak can be easily observed when using CONFIG_DEBUG_VM and doing\nipsec + gre (non offloaded) forwarding:\n\n  BUG: Bad page state in process ksoftirqd\/16  pfn:1451b6\n  page:00000000de2b8d32 refcount:0 mapcount:0 mapping:0000000000000000 index:0x1451b6000 pfn:0x1451b6\n  flags: 0x200000000000000(node=0|zone=2)\n  page_type: 0xffffffff()\n  raw: 0200000000000000 dead000000000040 ffff88810d23c000 0000000000000000\n  raw: 00000001451b6000 0000000000000001 00000000ffffffff 0000000000000000\n  page dumped because: page_pool leak\n  Modules linked in: ip_gre gre mlx5_ib mlx5_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink iptable_nat nf_nat xt_addrtype br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm ib_ipoib iw_cm ib_cm ib_uverbs ib_core overlay zram zsmalloc fuse [last unloaded: mlx5_core]\n  CPU: 16 PID: 96 Comm: ksoftirqd\/16 Not tainted 6.8.0-rc4+ #22\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04\/01\/2014\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x36\/0x50\n   bad_page+0x70\/0xf0\n   free_unref_page_prepare+0x27a\/0x460\n   free_unref_page+0x38\/0x120\n   esp_ssg_unref.isra.0+0x15f\/0x200\n   esp_output_tail+0x66d\/0x780\n   esp_xmit+0x2c5\/0x360\n   validate_xmit_xfrm+0x313\/0x370\n   ? validate_xmit_skb+0x1d\/0x330\n   validate_xmit_skb_list+0x4c\/0x70\n   sch_direct_xmit+0x23e\/0x350\n   __dev_queue_xmit+0x337\/0xba0\n   ? nf_hook_slow+0x3f\/0xd0\n   ip_finish_output2+0x25e\/0x580\n   iptunnel_xmit+0x19b\/0x240\n   ip_tunnel_xmit+0x5fb\/0xb60\n   ipgre_xmit+0x14d\/0x280 [ip_gre]\n   dev_hard_start_xmit+0xc3\/0x1c0\n   __dev_queue_xmit+0x208\/0xba0\n   ? nf_hook_slow+0x3f\/0xd0\n   ip_finish_output2+0x1ca\/0x580\n   ip_sublist_rcv_finish+0x32\/0x40\n   ip_sublist_rcv+0x1b2\/0x1f0\n   ? ip_rcv_finish_core.constprop.0+0x460\/0x460\n   ip_list_rcv+0x103\/0x130\n   __netif_receive_skb_list_core+0x181\/0x1e0\n   netif_receive_skb_list_internal+0x1b3\/0x2c0\n   napi_gro_receive+0xc8\/0x200\n   gro_cell_poll+0x52\/0x90\n   __napi_poll+0x25\/0x1a0\n   net_rx_action+0x28e\/0x300\n   __do_softirq+0xc3\/0x276\n   ? sort_range+0x20\/0x20\n   run_ksoftirqd+0x1e\/0x30\n   smpboot_thread_fn+0xa6\/0x130\n   kthread+0xcd\/0x100\n   ? kthread_complete_and_exit+0x20\/0x20\n   ret_from_fork+0x31\/0x50\n   ? kthread_complete_and_exit+0x20\/0x20\n   ret_from_fork_asm+0x11\/0x20\n   <\/TASK>\n\nThe suggested fix is to introduce a new wrapper (skb_page_unref) that\ncovers page refcounting for page_pool pages as well."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: esp: corrige el mal manejo de las páginas desde page_pool Cuando el skb se reorganiza durante esp_output (!esp-&gt;inline), se supone que las páginas provenientes de los fragmentos del skb original son devuelto al sistema a través de put_page. Pero si las páginas del fragmento skb se originan en un page_pool, llamar a put_page en ellas desencadenará una fuga de page_pool que eventualmente resultará en un bloqueo. Esta fuga se puede observar fácilmente cuando se usa CONFIG_DEBUG_VM y se realiza el reenvío ipsec + gre (no descargado): ERROR: Estado de página incorrecto en el proceso ksoftirqd\/16 pfn:1451b6 página:00000000de2b8d32 refcount:0 mapcount:0 mapeo:0000000000000000 índice:0x1451b6000 pfn: 0x1451b6 banderas: 0x200000000000000(nodo=0|zona=2) tipo de página: 0xffffffff() sin formato: 0200000000000000 muerto000000000040 ffff88810d23c000 0000000000000000 sin formato: 0001451b6000 0000000000000001 00000000ffffffff 0000000000000000 página volcada porque: fuga de page_pool Módulos vinculados en: ip_gre gre mlx5_ib mlx5_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink iptable_nat nf_nat xt_addrtype br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm ib_ipoib iw_cm ib_cm ib_uverbs ib_core overlay zram zsmalloc fuse [última descarga: mlx5_core] CPU: 16 PID: 96 Comm: ksoftirqd\/16 No contaminado 6 .8.0-rc4+ #22 Nombre del hardware: PC estándar QEMU (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 01\/04\/2014 Seguimiento de llamadas:  dump_stack_lvl+0x36\/0x50 bad_page+0x70\/0xf0 free_unref_page_prepare+0x27a\/0x460 free_unref_page+0x38\/0x120 esp_ssg_unref.isra.0+0x15f\/0x200 esp_output_tail+0x66d\/0x780 esp_xmit+0x2c5\/0x360 validar_xmit_xfrm+0x313\/0x370 ? validar_xmit_skb+0x1d\/0x330 validar_xmit_skb_list+0x4c\/0x70 sch_direct_xmit+0x23e\/0x350 __dev_queue_xmit+0x337\/0xba0 ? nf_hook_slow+0x3f\/0xd0 ip_finish_output2+0x25e\/0x580 iptunnel_xmit+0x19b\/0x240 ip_tunnel_xmit+0x5fb\/0xb60 ipgre_xmit+0x14d\/0x280 [ip_gre] dev_hard_start_xmit+0xc3\/0x1c0 __dev_queue_xmit+0x208\/0xba0? nf_hook_slow+0x3f\/0xd0 ip_finish_output2+0x1ca\/0x580 ip_sublist_rcv_finish+0x32\/0x40 ip_sublist_rcv+0x1b2\/0x1f0 ? ip_rcv_finish_core.constprop.0+0x460\/0x460 ip_list_rcv+0x103\/0x130 __netif_receive_skb_list_core+0x181\/0x1e0 netif_receive_skb_list_internal+0x1b3\/0x2c0 napi_gro_receive+0xc8\/0x200 encuesta+0x52\/0x90 __napi_poll+0x25\/0x1a0 net_rx_action+0x28e\/0x300 __do_softirq+0xc3\/0x276 ? sort_range+0x20\/0x20 run_ksoftirqd+0x1e\/0x30 smpboot_thread_fn+0xa6\/0x130 kthread+0xcd\/0x100 ? kthread_complete_and_exit+0x20\/0x20 ret_from_fork+0x31\/0x50 ? kthread_complete_and_exit+0x20\/0x20 ret_from_fork_asm+0x11\/0x20  La solución sugerida es introducir un nuevo contenedor (skb_page_unref) que cubra también el recuento de páginas para las páginas page_pool."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1abb20a5f4b02fb3020f88456fc1e6069b3cdc45","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8291b4eac429c480386669444c6377573f5d8664","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c3198822c6cb9fb588e446540485669cc81c5d34","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f278ff9db67264715d0d50e3e75044f8b78990f4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26954","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:11.583","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: fix slab-out-of-bounds in smb_strndup_from_utf16()\n\nIf ->NameOffset of smb2_create_req is smaller than Buffer offset of\nsmb2_create_req, slab-out-of-bounds read can happen from smb2_open.\nThis patch set the minimum value of the name offset to the buffer offset\nto validate name length of smb2_create_req()."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ksmbd: corrige slab-out-of-bounds en smb_strndup_from_utf16() Si -&gt;NameOffset de smb2_create_req es menor que el desplazamiento del búfer de smb2_create_req, puede ocurrir una lectura de slab-out-of-bounds de smb2_open. Este parche establece el valor mínimo del desplazamiento del nombre en el desplazamiento del búfer para validar la longitud del nombre de smb2_create_req()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3b8da67191e938a63d2736dabb4ac5d337e5de57","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4f97e6a9d62cb1fce82fbf4baff44b83221bc178","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a80a486d72e20bd12c335bcd38b6e6f19356b0aa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26955","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:11.730","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: prevent kernel bug at submit_bh_wbc()\n\nFix a bug where nilfs_get_block() returns a successful status when\nsearching and inserting the specified block both fail inconsistently.  If\nthis inconsistent behavior is not due to a previously fixed bug, then an\nunexpected race is occurring, so return a temporary error -EAGAIN instead.\n\nThis prevents callers such as __block_write_begin_int() from requesting a\nread into a buffer that is not mapped, which would cause the BUG_ON check\nfor the BH_Mapped flag in submit_bh_wbc() to fail."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: nilfs2: previene el error del kernel en submit_bh_wbc(). Se corrige un error por el cual nilfs_get_block() devuelve un estado exitoso cuando la búsqueda y la inserción del bloque especificado fallan de manera inconsistente. Si este comportamiento inconsistente no se debe a un error solucionado previamente, entonces se está produciendo una ejecución inesperada, por lo que se devuelve un error temporal -EAGAIN. Esto evita que llamadores como __block_write_begin_int() soliciten una lectura en un búfer que no está asignado, lo que provocaría que falle la verificación BUG_ON del indicador BH_Mapped en submit_bh_wbc()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0c8aa4cfda4e4adb15d5b6536d155eca9c9cd44c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/192e9f9078c96be30b31c4b44d6294b24520fce5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/269cdf353b5bdd15f1a079671b0f889113865f20","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/32eaee72e96590a75445c8a6c7c1057673b47e07","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/48d443d200237782dc82e6b60663ec414ef02e39","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/76ffbe911e2798c7296968f5fd72f7bf67207a8d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/91e4c4595fae5e87069e44687ae879091783c183","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca581d237f3b8539c044205bb003de71d75d227c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f0fe7ad5aff4f0fcf988913313c497de85f1e186","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26956","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:11.837","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix failure to detect DAT corruption in btree and direct mappings\n\nPatch series \"nilfs2: fix kernel bug at submit_bh_wbc()\".\n\nThis resolves a kernel BUG reported by syzbot.  Since there are two\nflaws involved, I've made each one a separate patch.\n\nThe first patch alone resolves the syzbot-reported bug, but I think\nboth fixes should be sent to stable, so I've tagged them as such.\n\n\nThis patch (of 2):\n\nSyzbot has reported a kernel bug in submit_bh_wbc() when writing file data\nto a nilfs2 file system whose metadata is corrupted.\n\nThere are two flaws involved in this issue.\n\nThe first flaw is that when nilfs_get_block() locates a data block using\nbtree or direct mapping, if the disk address translation routine\nnilfs_dat_translate() fails with internal code -ENOENT due to DAT metadata\ncorruption, it can be passed back to nilfs_get_block().  This causes\nnilfs_get_block() to misidentify an existing block as non-existent,\ncausing both data block lookup and insertion to fail inconsistently.\n\nThe second flaw is that nilfs_get_block() returns a successful status in\nthis inconsistent state.  This causes the caller __block_write_begin_int()\nor others to request a read even though the buffer is not mapped,\nresulting in a BUG_ON check for the BH_Mapped flag in submit_bh_wbc()\nfailing.\n\nThis fixes the first issue by changing the return value to code -EINVAL\nwhen a conversion using DAT fails with code -ENOENT, avoiding the\nconflicting condition that leads to the kernel bug described above.  Here,\ncode -EINVAL indicates that metadata corruption was detected during the\nblock lookup, which will be properly handled as a file system error and\nconverted to -EIO when passing through the nilfs2 bmap layer."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nilfs2: corrige el error al detectar daños en DAT en btree y asignaciones directas Serie de parches \"nilfs2: corrige el error del kernel en submit_bh_wbc()\". Esto resuelve un ERROR del kernel informado por syzbot. Dado que hay dos fallas involucradas, hice un parche para cada uno por separado. El primer parche por sí solo resuelve el error reportado por syzbot, pero creo que ambas correcciones deberían enviarse a estable, así que las etiqueté como tales. Este parche (de 2): Syzbot ha informado de un error en el kernel en submit_bh_wbc() al escribir datos de archivos en un sistema de archivos nilfs2 cuyos metadatos están dañados. Hay dos errores involucrados en este tema. El primer defecto es que cuando nilfs_get_block() localiza un bloque de datos usando btree o mapeo directo, si la rutina de traducción de direcciones de disco nilfs_dat_translate() falla con el código interno -ENOENT debido a la corrupción de los metadatos DAT, se puede devolver a nilfs_get_block(). Esto hace que nilfs_get_block() identifique erróneamente un bloque existente como inexistente, lo que provoca que tanto la búsqueda como la inserción del bloque de datos fallen de manera inconsistente. El segundo defecto es que nilfs_get_block() devuelve un estado exitoso en este estado inconsistente. Esto hace que la persona que llama __block_write_begin_int() u otros soliciten una lectura aunque el búfer no esté asignado, lo que resulta en una verificación BUG_ON para el indicador BH_Mapped en submit_bh_wbc() que falla. Esto soluciona el primer problema cambiando el valor de retorno al código -EINVAL cuando falla una conversión usando DAT con el código -ENOENT, evitando la condición conflictiva que conduce al error del kernel descrito anteriormente. Aquí, el código -EINVAL indica que se detectó corrupción de metadatos durante la búsqueda del bloque, lo que se manejará adecuadamente como un error del sistema de archivos y se convertirá a -EIO al pasar a través de la capa bmap nilfs2."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2e2619ff5d0def4bb6c2037a32a6eaa28dd95c84","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/46b832e09d43b394ac0f6d9485d2b1a06593f0b7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/82827ca21e7c8a91384c5baa656f78a5adfa4ab4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9cbe1ad5f4354f4df1445e5f4883983328cd6d8e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a8e4d098de1c0f4c5c1f2ed4633a860f0da6d713","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b67189690eb4b7ecc84ae16fa1e880e0123eaa35","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c3b5c5c31e723b568f83d8cafab8629d9d830ffb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f2f26b4a84a0ef41791bd2d70861c8eac748f4ba","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f69e81396aea66304d214f175aa371f1b5578862","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26957","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:11.953","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ns390\/zcrypt: fix reference counting on zcrypt card objects\n\nTests with hot-plugging crytpo cards on KVM guests with debug\nkernel build revealed an use after free for the load field of\nthe struct zcrypt_card. The reason was an incorrect reference\nhandling of the zcrypt card object which could lead to a free\nof the zcrypt card object while it was still in use.\n\nThis is an example of the slab message:\n\n    kernel: 0x00000000885a7512-0x00000000885a7513 @offset=1298. First byte 0x68 instead of 0x6b\n    kernel: Allocated in zcrypt_card_alloc+0x36\/0x70 [zcrypt] age=18046 cpu=3 pid=43\n    kernel:  kmalloc_trace+0x3f2\/0x470\n    kernel:  zcrypt_card_alloc+0x36\/0x70 [zcrypt]\n    kernel:  zcrypt_cex4_card_probe+0x26\/0x380 [zcrypt_cex4]\n    kernel:  ap_device_probe+0x15c\/0x290\n    kernel:  really_probe+0xd2\/0x468\n    kernel:  driver_probe_device+0x40\/0xf0\n    kernel:  __device_attach_driver+0xc0\/0x140\n    kernel:  bus_for_each_drv+0x8c\/0xd0\n    kernel:  __device_attach+0x114\/0x198\n    kernel:  bus_probe_device+0xb4\/0xc8\n    kernel:  device_add+0x4d2\/0x6e0\n    kernel:  ap_scan_adapter+0x3d0\/0x7c0\n    kernel:  ap_scan_bus+0x5a\/0x3b0\n    kernel:  ap_scan_bus_wq_callback+0x40\/0x60\n    kernel:  process_one_work+0x26e\/0x620\n    kernel:  worker_thread+0x21c\/0x440\n    kernel: Freed in zcrypt_card_put+0x54\/0x80 [zcrypt] age=9024 cpu=3 pid=43\n    kernel:  kfree+0x37e\/0x418\n    kernel:  zcrypt_card_put+0x54\/0x80 [zcrypt]\n    kernel:  ap_device_remove+0x4c\/0xe0\n    kernel:  device_release_driver_internal+0x1c4\/0x270\n    kernel:  bus_remove_device+0x100\/0x188\n    kernel:  device_del+0x164\/0x3c0\n    kernel:  device_unregister+0x30\/0x90\n    kernel:  ap_scan_adapter+0xc8\/0x7c0\n    kernel:  ap_scan_bus+0x5a\/0x3b0\n    kernel:  ap_scan_bus_wq_callback+0x40\/0x60\n    kernel:  process_one_work+0x26e\/0x620\n    kernel:  worker_thread+0x21c\/0x440\n    kernel:  kthread+0x150\/0x168\n    kernel:  __ret_from_fork+0x3c\/0x58\n    kernel:  ret_from_fork+0xa\/0x30\n    kernel: Slab 0x00000372022169c0 objects=20 used=18 fp=0x00000000885a7c88 flags=0x3ffff00000000a00(workingset|slab|node=0|zone=1|lastcpupid=0x1ffff)\n    kernel: Object 0x00000000885a74b8 @offset=1208 fp=0x00000000885a7c88\n    kernel: Redzone  00000000885a74b0: bb bb bb bb bb bb bb bb                          ........\n    kernel: Object   00000000885a74b8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74d8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74e8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74f8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a7508: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 68 4b 6b 6b 6b a5  kkkkkkkkkkhKkkk.\n    kernel: Redzone  00000000885a7518: bb bb bb bb bb bb bb bb                          ........\n    kernel: Padding  00000000885a756c: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a              ZZZZZZZZZZZZ\n    kernel: CPU: 0 PID: 387 Comm: systemd-udevd Not tainted 6.8.0-HF #2\n    kernel: Hardware name: IBM 3931 A01 704 (KVM\/Linux)\n    kernel: Call Trace:\n    kernel:  [<00000000ca5ab5b8>] dump_stack_lvl+0x90\/0x120\n    kernel:  [<00000000c99d78bc>] check_bytes_and_report+0x114\/0x140\n    kernel:  [<00000000c99d53cc>] check_object+0x334\/0x3f8\n    kernel:  [<00000000c99d820c>] alloc_debug_processing+0xc4\/0x1f8\n    kernel:  [<00000000c99d852e>] get_partial_node.part.0+0x1ee\/0x3e0\n    kernel:  [<00000000c99d94ec>] ___slab_alloc+0xaf4\/0x13c8\n    kernel:  [<00000000c99d9e38>] __slab_alloc.constprop.0+0x78\/0xb8\n    kernel:  [<00000000c99dc8dc>] __kmalloc+0x434\/0x590\n    kernel:  [<00000000c9b4c0ce>] ext4_htree_store_dirent+0x4e\/0x1c0\n    kernel:  [<00000000c9b908a2>] htree_dirblock_to_tree+0x17a\/0x3f0\n    kernel: \n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: s390\/zcrypt: corrige el recuento de referencias en los objetos de la tarjeta zcrypt. Las pruebas con tarjetas crypto de conexión en caliente en invitados KVM con compilación del kernel de depuración revelaron un use after free el campo de carga de la estructura zcrypt_card . El motivo fue un manejo de referencia incorrecto del objeto de la tarjeta zcrypt que podría provocar la liberación del objeto de la tarjeta zcrypt mientras aún estaba en uso. Este es un ejemplo del mensaje de losa: kernel: 0x00000000885a7512-0x00000000885a7513 @offset=1298. Primer byte 0x68 en lugar de 0x6b kernel: Asignado en zcrypt_card_alloc+0x36\/0x70 [zcrypt] age=18046 cpu=3 pid=43 kernel: kmalloc_trace+0x3f2\/0x470 kernel: zcrypt_card_alloc+0x36\/0x70 [zcrypt] kernel: zcrypt_cex4_card_probe+0x26\/ 0x380 [zcrypt_cex4] kernel: ap_device_probe+0x15c\/0x290 kernel: Actually_probe+0xd2\/0x468 kernel: driver_probe_device+0x40\/0xf0 kernel: __device_attach_driver+0xc0\/0x140 kernel: bus_for_each_drv+0x8c\/0xd0 kernel: __device_ adjuntar+0x114\/0x198 kernel: bus_probe_device+ Kernel 0xb4\/0xc8: device_add+0x4d2\/0x6e0 kernel: ap_scan_adapter+0x3d0\/0x7c0 kernel: ap_scan_bus+0x5a\/0x3b0 kernel: ap_scan_bus_wq_callback+0x40\/0x60 kernel: Process_one_work+0x26e\/0x620 kernel: Kernel x21c\/0x440: liberado en zcrypt_card_put +0x54\/0x80 [zcrypt] edad=9024 cpu=3 pid=43 kernel: kfree+0x37e\/0x418 kernel: zcrypt_card_put+0x54\/0x80 [zcrypt] kernel: ap_device_remove+0x4c\/0xe0 kernel: device_release_driver_internal+0x1c4\/0x270 kernel: bus_remove_device +0x100\/0x188 kernel: device_del+0x164\/0x3c0 kernel: device_unregister+0x30\/0x90 kernel: ap_scan_adapter+0xc8\/0x7c0 kernel: ap_scan_bus+0x5a\/0x3b0 kernel: ap_scan_bus_wq_callback+0x40\/0x60 kernel: Núcleo 26e\/0x620: trabajador_thread+ Kernel 0x21c\/0x440: kthread+0x150\/0x168 kernel: __ret_from_fork+0x3c\/0x58 kernel: ret_from_fork+0xa\/0x30 kernel: Slab 0x00000372022169c0 objetos=20 usados=18 fp=0x00000000885a7c88 3ffff00000000a00(conjunto de trabajo|losa|nodo=0|zona =1|lastcpupid=0x1ffff) kernel: Objeto 0x00000000885a74b8 @offset=1208 fp=0x00000000885a7c88 kernel: Redzone 00000000885a74b0: bb bb bb bb bb bb bb bb ........ kernel: Objeto 00000000885a74 b8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkkk kernel: Objeto 00000000885a74c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkk kkkkkkkk kernel: Objeto 00000000885a74d8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkk kernel: Objeto 00000000885a74e8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkk kernel: Objeto 000000 00885a74f8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkkk kernel : Objeto 00000000885a7508: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 68 4b 6b 6b 6b a5 kkkkkkkkkhKkkk. kernel: Redzone 00000000885a7518: bb bb bb bb bb bb bb bb bb ........ kernel: Padding 00000000885a756c: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZ kernel: CPU: 0 PID: 387 Comm: systemd -udevd Not tainted 6.8.0-HF #2 kernel: Nombre del hardware: IBM 3931 A01 704 (KVM\/Linux) kernel: Call Trace: kernel: [&lt;00000000ca5ab5b8&gt;] dump_stack_lvl+0x90\/0x120 kernel: [&lt;00000000c99d78bc&gt;] check_bytes_and_report +0x114\/0x140 kernel: [&lt;00000000c99d53cc&gt;] check_object+0x334\/0x3f8 kernel: [&lt;00000000c99d820c&gt;] alloc_debug_processing+0xc4\/0x1f8 kernel: [&lt;00000000c99d852e&gt;] +0x1ee\/0x3e0 núcleo: [&lt;00000000c99d94ec&gt; ] ___slab_alloc+0xaf4\/0x13c8 kernel: [&lt;00000000c99d9e38&gt;] __slab_alloc.constprop.0+0x78\/0xb8 kernel: [&lt;00000000c99dc8dc&gt;] __kmalloc+0x434\/0x590 kernel: [&lt;00000000c9b4c0 ce&gt;] ext4_htree_store_dirent+0x4e\/0x1c0 kernel: [&lt; 00000000c9b908a2&gt;] htree_dirblock_to_tree+0x17a\/0x3f0 kernel: ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/394b6d8bbdf9ddee6d5bcf3e1f3e9f23eecd6484","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/50ed48c80fecbe17218afed4f8bed005c802976c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6470078ab3d8f222115e11c4ec67351f3031b3dd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7e500849fa558879a1cde43f80c7c048c2437058","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9daddee03de3f231012014dab8ab2b277a116a55","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a55677878b93e9ebc31f66d0e2fb93be5e7836a6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a64ab862e84e3e698cd351a87cdb504c7fc575ca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7f6c3630eb3f103115ab0d7613588064f665d0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/befb7f889594d23e1b475720cf93efd2f77df000","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26958","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:12.090","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnfs: fix UAF in direct writes\n\nIn production we have been hitting the following warning consistently\n\n------------[ cut here ]------------\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 17 PID: 1800359 at lib\/refcount.c:28 refcount_warn_saturate+0x9c\/0xe0\nWorkqueue: nfsiod nfs_direct_write_schedule_work [nfs]\nRIP: 0010:refcount_warn_saturate+0x9c\/0xe0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? __warn+0x9f\/0x130\n ? refcount_warn_saturate+0x9c\/0xe0\n ? report_bug+0xcc\/0x150\n ? handle_bug+0x3d\/0x70\n ? exc_invalid_op+0x16\/0x40\n ? asm_exc_invalid_op+0x16\/0x20\n ? refcount_warn_saturate+0x9c\/0xe0\n nfs_direct_write_schedule_work+0x237\/0x250 [nfs]\n process_one_work+0x12f\/0x4a0\n worker_thread+0x14e\/0x3b0\n ? ZSTD_getCParams_internal+0x220\/0x220\n kthread+0xdc\/0x120\n ? __btf_name_valid+0xa0\/0xa0\n ret_from_fork+0x1f\/0x30\n\nThis is because we're completing the nfs_direct_request twice in a row.\n\nThe source of this is when we have our commit requests to submit, we\nprocess them and send them off, and then in the completion path for the\ncommit requests we have\n\nif (nfs_commit_end(cinfo.mds))\n\tnfs_direct_write_complete(dreq);\n\nHowever since we're submitting asynchronous requests we sometimes have\none that completes before we submit the next one, so we end up calling\ncomplete on the nfs_direct_request twice.\n\nThe only other place we use nfs_generic_commit_list() is in\n__nfs_commit_inode, which wraps this call in a\n\nnfs_commit_begin();\nnfs_commit_end();\n\nWhich is a common pattern for this style of completion handling, one\nthat is also repeated in the direct code with get_dreq()\/put_dreq()\ncalls around where we process events as well as in the completion paths.\n\nFix this by using the same pattern for the commit requests.\n\nBefore with my 200 node rocksdb stress running this warning would pop\nevery 10ish minutes.  With my patch the stress test has been running for\nseveral hours without popping."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nfs: corrige UAF en escrituras directas En producción hemos estado recibiendo la siguiente advertencia constantemente ------------[ cortar aquí ]----- ------- refcount_t: desbordamiento insuficiente; use-after-free. ADVERTENCIA: CPU: 17 PID: 1800359 en lib\/refcount.c:28 refcount_warn_saturate+0x9c\/0xe0 Cola de trabajo: nfsiod nfs_direct_write_schedule_work [nfs] RIP: 0010:refcount_warn_saturate+0x9c\/0xe0 PKRU: 55555554 Llamada Seguimiento:  ? __advertir+0x9f\/0x130 ? refcount_warn_saturate+0x9c\/0xe0? report_bug+0xcc\/0x150? handle_bug+0x3d\/0x70? exc_invalid_op+0x16\/0x40? asm_exc_invalid_op+0x16\/0x20? refcount_warn_saturate+0x9c\/0xe0 nfs_direct_write_schedule_work+0x237\/0x250 [nfs] Process_one_work+0x12f\/0x4a0 trabajador_thread+0x14e\/0x3b0? ZSTD_getCParams_internal+0x220\/0x220 kthread+0xdc\/0x120? __btf_name_valid+0xa0\/0xa0 ret_from_fork+0x1f\/0x30 Esto se debe a que estamos completando nfs_direct_request dos veces seguidas. La fuente de esto es cuando tenemos que enviar nuestras solicitudes de confirmación, las procesamos y las enviamos, y luego en la ruta de finalización para las solicitudes de confirmación tenemos if (nfs_commit_end(cinfo.mds)) nfs_direct_write_complete(dreq); Sin embargo, dado que enviamos solicitudes asincrónicas, a veces tenemos una que se completa antes de enviar la siguiente, por lo que terminamos llamando a complete en nfs_direct_request dos veces. El único otro lugar donde usamos nfs_generic_commit_list() es en __nfs_commit_inode, que envuelve esta llamada en nfs_commit_begin(); nfs_commit_end(); Este es un patrón común para este estilo de manejo de finalización, uno que también se repite en el código directo con llamadas get_dreq()\/put_dreq() en el lugar donde procesamos eventos, así como en las rutas de finalización. Solucione este problema utilizando el mismo patrón para las solicitudes de confirmación. Antes, con mi estrés de rocksdb de 200 nodos ejecutándose, esta advertencia aparecía cada 10 minutos. Con mi parche, la prueba de esfuerzo ha estado funcionando durante varias horas sin aparecer."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/17f46b803d4f23c66cacce81db35fef3adb8f2af","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1daf52b5ffb24870fbeda20b4967526d8f9e12ab","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3abc2d160ed8213948b147295d77d44a22c88fa3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4595d90b5d2ea5fa4d318d13f59055aa4bf3e7f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/80d24b308b7ee7037fc90d8ac99f6f78df0a256f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cf54f66e1dd78990ec6b32177bca7e6ea2144a95","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e25447c35f8745337ea8bc0c9697fcac14df8605","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26959","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:12.207","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: btnxpuart: Fix btnxpuart_close\n\nFix scheduling while atomic BUG in btnxpuart_close(), properly\npurge the transmit queue and free the receive skb.\n\n[   10.973809] BUG: scheduling while atomic: kworker\/u9:0\/80\/0x00000002\n...\n[   10.980740] CPU: 3 PID: 80 Comm: kworker\/u9:0 Not tainted 6.8.0-rc7-0.0.0-devel-00005-g61fdfceacf09 #1\n[   10.980751] Hardware name: Toradex Verdin AM62 WB on Dahlia Board (DT)\n[   10.980760] Workqueue: hci0 hci_power_off [bluetooth]\n[   10.981169] Call trace:\n...\n[   10.981363]  uart_update_mctrl+0x58\/0x78\n[   10.981373]  uart_dtr_rts+0x104\/0x114\n[   10.981381]  tty_port_shutdown+0xd4\/0xdc\n[   10.981396]  tty_port_close+0x40\/0xbc\n[   10.981407]  uart_close+0x34\/0x9c\n[   10.981414]  ttyport_close+0x50\/0x94\n[   10.981430]  serdev_device_close+0x40\/0x50\n[   10.981442]  btnxpuart_close+0x24\/0x98 [btnxpuart]\n[   10.981469]  hci_dev_close_sync+0x2d8\/0x718 [bluetooth]\n[   10.981728]  hci_dev_do_close+0x2c\/0x70 [bluetooth]\n[   10.981862]  hci_power_off+0x20\/0x64 [bluetooth]"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: Bluetooth: btnxpuart: Reparar btnxpuart_close Reparar la programación mientras el ERROR atómico en btnxpuart_close(), purgar adecuadamente la cola de transmisión y liberar el skb de recepción. [10.973809] ERROR: programación mientras es atómico: kworker\/u9:0\/80\/0x00000002... [10.980740] CPU: 3 PID: 80 Comm: kworker\/u9:0 No contaminado 6.8.0-rc7-0.0.0-devel -00005-g61fdfceacf09 #1 [10.980751] Nombre de hardware: Toradex Verdin AM62 WB en Dahlia Board (DT) [10.980760] Cola de trabajo: hci0 hci_power_off [bluetooth] [10.981169] Seguimiento de llamadas: ... [10.981363] 8\/0x78 [ 10.981373] uart_dtr_rts+0x104\/0x114 [ 10.981381] tty_port_shutdown+0xd4\/0xdc [ 10.981396] tty_port_close+0x40\/0xbc [ 10.981407] uart_close+0x34\/0x9c [ 10.9814 14] ttyport_close+0x50\/0x94 [ 10.981430] serdev_device_close+0x40\/0x50 [ 10.981442] btnxpuart_close+0x24\/0x98 [btnxpuart] [ 10.981469] hci_dev_close_sync+0x2d8\/0x718 [bluetooth] [ 10.981728] hci_dev_do_close+0x2c\/0x70 [bluetooth] [ 10.981862] x64 [bluetooth]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/586e099c93fe26b7bd40593979532f507ed9f6a4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/664130c0b0309b360bc5bdd40a30604a9387bde8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/74bcf708775c405f7fb6ed776ccd3e1957f38a52","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d4e2365b07f1ae1f811a915b514caef5b2d6581e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26960","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:12.323","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmm: swap: fix race between free_swap_and_cache() and swapoff()\n\nThere was previously a theoretical window where swapoff() could run and\nteardown a swap_info_struct while a call to free_swap_and_cache() was\nrunning in another thread.  This could cause, amongst other bad\npossibilities, swap_page_trans_huge_swapped() (called by\nfree_swap_and_cache()) to access the freed memory for swap_map.\n\nThis is a theoretical problem and I haven't been able to provoke it from a\ntest case.  But there has been agreement based on code review that this is\npossible (see link below).\n\nFix it by using get_swap_device()\/put_swap_device(), which will stall\nswapoff().  There was an extra check in _swap_info_get() to confirm that\nthe swap entry was not free.  This isn't present in get_swap_device()\nbecause it doesn't make sense in general due to the race between getting\nthe reference and swapoff.  So I've added an equivalent check directly in\nfree_swap_and_cache().\n\nDetails of how to provoke one possible issue (thanks to David Hildenbrand\nfor deriving this):\n\n--8<-----\n\n__swap_entry_free() might be the last user and result in\n\"count == SWAP_HAS_CACHE\".\n\nswapoff->try_to_unuse() will stop as soon as soon as si->inuse_pages==0.\n\nSo the question is: could someone reclaim the folio and turn\nsi->inuse_pages==0, before we completed swap_page_trans_huge_swapped().\n\nImagine the following: 2 MiB folio in the swapcache. Only 2 subpages are\nstill references by swap entries.\n\nProcess 1 still references subpage 0 via swap entry.\nProcess 2 still references subpage 1 via swap entry.\n\nProcess 1 quits. Calls free_swap_and_cache().\n-> count == SWAP_HAS_CACHE\n[then, preempted in the hypervisor etc.]\n\nProcess 2 quits. Calls free_swap_and_cache().\n-> count == SWAP_HAS_CACHE\n\nProcess 2 goes ahead, passes swap_page_trans_huge_swapped(), and calls\n__try_to_reclaim_swap().\n\n__try_to_reclaim_swap()->folio_free_swap()->delete_from_swap_cache()->\nput_swap_folio()->free_swap_slot()->swapcache_free_entries()->\nswap_entry_free()->swap_range_free()->\n...\nWRITE_ONCE(si->inuse_pages, si->inuse_pages - nr_entries);\n\nWhat stops swapoff to succeed after process 2 reclaimed the swap cache\nbut before process1 finished its call to swap_page_trans_huge_swapped()?\n\n--8<-----"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm: swap: corrige la ejecución entre free_swap_and_cache() y swapoff() Anteriormente existía una ventana teórica donde swapoff() podía ejecutar y desmantelar un swap_info_struct mientras se realizaba una llamada a free_swap_and_cache(). corriendo en otro hilo. Esto podría causar, entre otras malas posibilidades, que swap_page_trans_huge_swapped() (llamado por free_swap_and_cache()) acceda a la memoria liberada para swap_map. Este es un problema teórico y no he podido provocarlo a partir de un caso de prueba. Pero ha habido un acuerdo basado en la revisión del código de que esto es posible (ver enlace a continuación). Solucionarlo usando get_swap_device()\/put_swap_device(), lo que detendrá swapoff(). Hubo una verificación adicional en _swap_info_get() para confirmar que la entrada de intercambio no era gratuita. Esto no está presente en get_swap_device() porque en general no tiene sentido debido a la ejecución entre obtener la referencia y el intercambio. Así que agregué una verificación equivalente directamente en free_swap_and_cache(). Detalles de cómo provocar un posible problema (gracias a David Hildenbrand por derivar esto): --8&lt;----- __swap_entry_free() podría ser el último usuario y dar como resultado \"count == SWAP_HAS_CACHE\". swapoff-&gt;try_to_unuse() se detendrá tan pronto como si-&gt;inuse_pages==0. Entonces la pregunta es: ¿alguien podría reclamar la publicación y activar si-&gt;inuse_pages==0, antes de que completemos swap_page_trans_huge_swapped()? Imagine lo siguiente: folio de 2 MiB en el swapcache. Sólo 2 subpáginas siguen siendo referencias mediante entradas de intercambio. El proceso 1 todavía hace referencia a la subpágina 0 mediante la entrada de intercambio. El proceso 2 todavía hace referencia a la subpágina 1 mediante la entrada de intercambio. El proceso 1 se cierra. Llama a free_swap_and_cache(). -&gt; count == SWAP_HAS_CACHE [luego, adelantado en el hipervisor, etc.] El proceso 2 se cierra. Llama a free_swap_and_cache(). -&gt; count == SWAP_HAS_CACHE El proceso 2 continúa, pasa swap_page_trans_huge_swapped() y llama a __try_to_reclaim_swap(). __try_to_reclaim_swap()-&gt;folio_free_swap()-&gt;delete_from_swap_cache()-&gt; put_swap_folio()-&gt;free_swap_slot()-&gt;swapcache_free_entries()-&gt; swap_entry_free()-&gt;swap_range_free()-&gt; ... WRITE_ONCE(si-&gt;inuse_pages, si-&gt;inuse_pages - nr_entries); ¿Qué impide que el intercambio tenga éxito después de que el proceso 2 recuperó el caché de intercambio pero antes de que el proceso 1 terminara su llamada a swap_page_trans_huge_swapped()? --8&lt;-----"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0f98f6d2fb5fad00f8299b84b85b6bc1b6d7d19a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1ede7f1d7eed1738d1b9333fd1e152ccb450b86a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2da5568ee222ce0541bfe446a07998f92ed1643e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/363d17e7f7907c8e27a9e86968af0eaa2301787b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3ce4c4c653e4e478ecb15d3c88e690f12cbf6b39","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/82b1c07a0af603e3c47b906c8e991dc96f01688e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d85c11c97ecf92d47a4b29e3faca714dc1f18d0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26961","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:12.437","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmac802154: fix llsec key resources release in mac802154_llsec_key_del\n\nmac802154_llsec_key_del() can free resources of a key directly without\nfollowing the RCU rules for waiting before the end of a grace period. This\nmay lead to use-after-free in case llsec_lookup_key() is traversing the\nlist of keys in parallel with a key deletion:\n\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 4 PID: 16000 at lib\/refcount.c:25 refcount_warn_saturate+0x162\/0x2a0\nModules linked in:\nCPU: 4 PID: 16000 Comm: wpan-ping Not tainted 6.7.0 #19\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04\/01\/2014\nRIP: 0010:refcount_warn_saturate+0x162\/0x2a0\nCall Trace:\n <TASK>\n llsec_lookup_key.isra.0+0x890\/0x9e0\n mac802154_llsec_encrypt+0x30c\/0x9c0\n ieee802154_subif_start_xmit+0x24\/0x1e0\n dev_hard_start_xmit+0x13e\/0x690\n sch_direct_xmit+0x2ae\/0xbc0\n __dev_queue_xmit+0x11dd\/0x3c20\n dgram_sendmsg+0x90b\/0xd60\n __sys_sendto+0x466\/0x4c0\n __x64_sys_sendto+0xe0\/0x1c0\n do_syscall_64+0x45\/0xf0\n entry_SYSCALL_64_after_hwframe+0x6e\/0x76\n\nAlso, ieee802154_llsec_key_entry structures are not freed by\nmac802154_llsec_key_del():\n\nunreferenced object 0xffff8880613b6980 (size 64):\n  comm \"iwpan\", pid 2176, jiffies 4294761134 (age 60.475s)\n  hex dump (first 32 bytes):\n    78 0d 8f 18 80 88 ff ff 22 01 00 00 00 00 ad de  x.......\".......\n    00 00 00 00 00 00 00 00 03 00 cd ab 00 00 00 00  ................\n  backtrace:\n    [<ffffffff81dcfa62>] __kmem_cache_alloc_node+0x1e2\/0x2d0\n    [<ffffffff81c43865>] kmalloc_trace+0x25\/0xc0\n    [<ffffffff88968b09>] mac802154_llsec_key_add+0xac9\/0xcf0\n    [<ffffffff8896e41a>] ieee802154_add_llsec_key+0x5a\/0x80\n    [<ffffffff8892adc6>] nl802154_add_llsec_key+0x426\/0x5b0\n    [<ffffffff86ff293e>] genl_family_rcv_msg_doit+0x1fe\/0x2f0\n    [<ffffffff86ff46d1>] genl_rcv_msg+0x531\/0x7d0\n    [<ffffffff86fee7a9>] netlink_rcv_skb+0x169\/0x440\n    [<ffffffff86ff1d88>] genl_rcv+0x28\/0x40\n    [<ffffffff86fec15c>] netlink_unicast+0x53c\/0x820\n    [<ffffffff86fecd8b>] netlink_sendmsg+0x93b\/0xe60\n    [<ffffffff86b91b35>] ____sys_sendmsg+0xac5\/0xca0\n    [<ffffffff86b9c3dd>] ___sys_sendmsg+0x11d\/0x1c0\n    [<ffffffff86b9c65a>] __sys_sendmsg+0xfa\/0x1d0\n    [<ffffffff88eadbf5>] do_syscall_64+0x45\/0xf0\n    [<ffffffff890000ea>] entry_SYSCALL_64_after_hwframe+0x6e\/0x76\n\nHandle the proper resource release in the RCU callback function\nmac802154_llsec_key_del_rcu().\n\nNote that if llsec_lookup_key() finds a key, it gets a refcount via\nllsec_key_get() and locally copies key id from key_entry (which is a\nlist element). So it's safe to call llsec_key_put() and free the list\nentry after the RCU grace period elapses.\n\nFound by Linux Verification Center (linuxtesting.org)."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: mac802154: corrige la liberación de recursos de clave llsec en mac802154_llsec_key_del mac802154_llsec_key_del() puede liberar recursos de una clave directamente sin seguir las reglas de RCU para esperar antes del final de un período de gracia. Esto puede llevar a un use-after-free en caso de que llsec_lookup_key() esté recorriendo la lista de claves en paralelo con una eliminación de clave: refcount_t: suma en 0; use-after-free. ADVERTENCIA: CPU: 4 PID: 16000 en lib\/refcount.c:25 refcount_warn_saturate+0x162\/0x2a0 Módulos vinculados en: CPU: 4 PID: 16000 Comm: wpan-ping Not tainted 6.7.0 #19 Nombre de hardware: PC estándar QEMU ( i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 01\/04\/2014 RIP: 0010:refcount_warn_saturate+0x162\/0x2a0 Seguimiento de llamadas:  llsec_lookup_key.isra.0+0x890\/0x9e0 mac802154_llsec_ cifrar+ 0x30c\/0x9c0 ieee802154_subif_start_xmit+0x24\/0x1e0 dev_hard_start_xmit+0x13e\/0x690 sch_direct_xmit+0x2ae\/0xbc0 __dev_queue_xmit+0x11dd\/0x3c20 dgram_sendmsg+0x90b\/0xd60 __ sys_sendto+0x466\/0x4c0 __x64_sys_sendto+0xe0\/0x1c0 do_syscall_64+0x45\/0xf0 Entry_SYSCALL_64_after_hwframe+0x6e\/0x76 Además, Las estructuras ieee802154_llsec_key_entry no son liberadas por mac802154_llsec_key_del(): objeto sin referencia 0xffff8880613b6980 (tamaño 64): comm \"iwpan\", pid 2176, jiffies 4294761134 (edad 60,475 s) volcado hexadecimal (primeros 32 bytes): 8 0d 8f 18 80 88 y siguientes y siguientes 22 01 00 00 00 00 ad de x.......\"....... 00 00 00 00 00 00 00 00 03 00 cd ab 00 00 00 00 ........... ..... retroceso: [] __kmem_cache_alloc_node+0x1e2\/0x2d0 [] kmalloc_trace+0x25\/0xc0 [] mac802154_llsec_key_add+0xac9\/0xcf0 ffffffff8896e41a&gt;] ieee802154_add_llsec_key+0x5a\/0x80 [] nl802154_add_llsec_key+0x426\/0x5b0 [] genl_family_rcv_msg_doit+0x1fe\/0x2f0 [] genl_rcv_msg+0x531\/0x7d0 [] netlink_rcv_skb+0x169\/0x440 [] genl_rcv+0x28\/0x40 [] netlink_unicast+0x53c\/0x820 [] netlink_sendmsg+0x93b\/0xe60 [] ____sys_sendmsg+0xac5\/0xca0 [] ___sys_sendmsg+0x11d\/0 x1c0 [] __sys_sendmsg+0xfa\/0x1d0 [] do_syscall_64+0x45\/0xf0 [] Entry_SYSCALL_64_after_hwframe+0x6e\/0x76 Maneja la liberación adecuada de recursos en la función de devolución de llamada de RCU mac802154_llsec_key_del_rcu(). Tenga en cuenta que si llsec_lookup_key() encuentra una clave, obtiene un recuento a través de llsec_key_get() y copia localmente la identificación de la clave de key_entry (que es un elemento de la lista). Por lo tanto, es seguro llamar a llsec_key_put() y liberar la entrada de la lista después de que transcurra el período de gracia de RCU. Encontrado por el Centro de verificación de Linux (linuxtesting.org)."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/068ab2759bc0b4daf0b964de61b2731449c86531","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/20d3e1c8a1847497269f04d874b2a5818ec29e2d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/49c8951680d7b76fceaee89dcfbab1363fb24fd1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/640297c3e897bd7e1481466a6a5cb9560f1edb88","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d3d858650933d44ac12c1f31337e7110c2071821","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dcd51ab42b7a0431575689c5f74b8b6efd45fc2f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e8a1e58345cf40b7b272e08ac7b32328b2543e40","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26962","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:12.527","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndm-raid456, md\/raid456: fix a deadlock for dm-raid456 while io concurrent with reshape\n\nFor raid456, if reshape is still in progress, then IO across reshape\nposition will wait for reshape to make progress. However, for dm-raid,\nin following cases reshape will never make progress hence IO will hang:\n\n1) the array is read-only;\n2) MD_RECOVERY_WAIT is set;\n3) MD_RECOVERY_FROZEN is set;\n\nAfter commit c467e97f079f (\"md\/raid6: use valid sector values to determine\nif an I\/O should wait on the reshape\") fix the problem that IO across\nreshape position doesn't wait for reshape, the dm-raid test\nshell\/lvconvert-raid-reshape.sh start to hang:\n\n[root@fedora ~]# cat \/proc\/979\/stack\n[<0>] wait_woken+0x7d\/0x90\n[<0>] raid5_make_request+0x929\/0x1d70 [raid456]\n[<0>] md_handle_request+0xc2\/0x3b0 [md_mod]\n[<0>] raid_map+0x2c\/0x50 [dm_raid]\n[<0>] __map_bio+0x251\/0x380 [dm_mod]\n[<0>] dm_submit_bio+0x1f0\/0x760 [dm_mod]\n[<0>] __submit_bio+0xc2\/0x1c0\n[<0>] submit_bio_noacct_nocheck+0x17f\/0x450\n[<0>] submit_bio_noacct+0x2bc\/0x780\n[<0>] submit_bio+0x70\/0xc0\n[<0>] mpage_readahead+0x169\/0x1f0\n[<0>] blkdev_readahead+0x18\/0x30\n[<0>] read_pages+0x7c\/0x3b0\n[<0>] page_cache_ra_unbounded+0x1ab\/0x280\n[<0>] force_page_cache_ra+0x9e\/0x130\n[<0>] page_cache_sync_ra+0x3b\/0x110\n[<0>] filemap_get_pages+0x143\/0xa30\n[<0>] filemap_read+0xdc\/0x4b0\n[<0>] blkdev_read_iter+0x75\/0x200\n[<0>] vfs_read+0x272\/0x460\n[<0>] ksys_read+0x7a\/0x170\n[<0>] __x64_sys_read+0x1c\/0x30\n[<0>] do_syscall_64+0xc6\/0x230\n[<0>] entry_SYSCALL_64_after_hwframe+0x6c\/0x74\n\nThis is because reshape can't make progress.\n\nFor md\/raid, the problem doesn't exist because register new sync_thread\ndoesn't rely on the IO to be done any more:\n\n1) If array is read-only, it can switch to read-write by ioctl\/sysfs;\n2) md\/raid never set MD_RECOVERY_WAIT;\n3) If MD_RECOVERY_FROZEN is set, mddev_suspend() doesn't hold\n   'reconfig_mutex', hence it can be cleared and reshape can continue by\n   sysfs api 'sync_action'.\n\nHowever, I'm not sure yet how to avoid the problem in dm-raid yet. This\npatch on the one hand make sure raid_message() can't change\nsync_thread() through raid_message() after presuspend(), on the other\nhand detect the above 3 cases before wait for IO do be done in\ndm_suspend(), and let dm-raid requeue those IO."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: dm-raid456, md\/raid456: soluciona un punto muerto para dm-raid456 mientras io concurre con reshape. Para raid456, si el reshape todavía está en progreso, entonces IO en la posición de reshape esperará remodelar para progresar. Sin embargo, para dm-raid, en los siguientes casos la remodelación nunca progresará, por lo que IO se bloqueará: 1) la matriz es de solo lectura; 2) MD_RECOVERY_WAIT está configurado; 3) MD_RECOVERY_FROZEN está configurado; Después de confirmar c467e97f079f (\"md\/raid6: use valores de sector válidos para determinar si una E\/S debe esperar a la remodelación\") solucione el problema de que IO en la posición de remodelación no espera a la remodelación, la prueba dm-raid shell\/lvconvert -raid-reshape.sh comienza a colgarse: [root@fedora ~]# cat \/proc\/979\/stack [&lt;0&gt;] wait_woken+0x7d\/0x90 [&lt;0&gt;] raid5_make_request+0x929\/0x1d70 [raid456] [&lt;0 &gt;] md_handle_request+0xc2\/0x3b0 [md_mod] [&lt;0&gt;] raid_map+0x2c\/0x50 [dm_raid] [&lt;0&gt;] __map_bio+0x251\/0x380 [dm_mod] [&lt;0&gt;] dm_submit_bio+0x1f0\/0x760 [dm_mod] [ &lt;0&gt;] __submit_bio+0xc2\/0x1c0 [&lt;0&gt;] submit_bio_noacct_nocheck+0x17f\/0x450 [&lt;0&gt;] submit_bio_noacct+0x2bc\/0x780 [&lt;0&gt;] submit_bio+0x70\/0xc0 [&lt;0&gt;] mpage_readahead+0x169\/0x1f0 [ &lt;0&gt;] blkdev_readahead+0x18\/0x30 [&lt;0&gt;] read_pages+0x7c\/0x3b0 [&lt;0&gt;] page_cache_ra_unbounded+0x1ab\/0x280 [&lt;0&gt;] force_page_cache_ra+0x9e\/0x130 [&lt;0&gt;] page_cache_sync_ra+0x3b\/0x110 [ &lt;0&gt;] filemap_get_pages+0x143\/0xa30 [&lt;0&gt;] filemap_read+0xdc\/0x4b0 [&lt;0&gt;] blkdev_read_iter+0x75\/0x200 [&lt;0&gt;] vfs_read+0x272\/0x460 [&lt;0&gt;] ksys_read+0x7a\/0x170 [ &lt;0&gt;] __x64_sys_read+0x1c\/0x30 [&lt;0&gt;] do_syscall_64+0xc6\/0x230 [&lt;0&gt;] Entry_SYSCALL_64_after_hwframe+0x6c\/0x74 Esto se debe a que la remodelación no puede progresar. Para md\/raid, el problema no existe porque registrar un nuevo sync_thread ya no depende de que se realice la IO: 1) Si la matriz es de solo lectura, puede cambiar a lectura-escritura mediante ioctl\/sysfs; 2) md\/raid nunca configuró MD_RECOVERY_WAIT; 3) Si se configura MD_RECOVERY_FROZEN, mddev_suspend() no contiene 'reconfig_mutex', por lo tanto, se puede borrar y la remodelación puede continuar mediante sysfs api 'sync_action'. Sin embargo, todavía no estoy seguro de cómo evitar el problema en dm-raid. Este parche, por un lado, garantiza que raid_message() no pueda cambiar sync_thread() a través de raid_message() después de presuspend(), por otro lado detecta los 3 casos anteriores antes de esperar a que IO se realice en dm_suspend(), y deja dm-raid pone en cola esas IO."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/41425f96d7aa59bc865f60f5dda3d7697b555677","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5943a34bf6bab5801e08a55f63e1b8d5bc90dae1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a8d249d770cb357d16a2097b548d2e4c1c137304","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26963","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:12.610","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3-am62: fix module unload\/reload behavior\n\nAs runtime PM is enabled, the module can be runtime\nsuspended when .remove() is called.\n\nDo a pm_runtime_get_sync() to make sure module is active\nbefore doing any register operations.\n\nDoing a pm_runtime_put_sync() should disable the refclk\nso no need to disable it again.\n\nFixes the below warning at module removel.\n\n[   39.705310] ------------[ cut here ]------------\n[   39.710004] clk:162:3 already disabled\n[   39.713941] WARNING: CPU: 0 PID: 921 at drivers\/clk\/clk.c:1090 clk_core_disable+0xb0\/0xb8\n\nWe called of_platform_populate() in .probe() so call the\ncleanup function of_platform_depopulate() in .remove().\nGet rid of the now unnnecessary dwc3_ti_remove_core().\nWithout this, module re-load doesn't work properly."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: dwc3-am62: corrige el comportamiento de descarga\/recarga del módulo. Como el PM en tiempo de ejecución está habilitado, el tiempo de ejecución del módulo se puede suspender cuando se llama a .remove(). Realice pm_runtime_get_sync() para asegurarse de que el módulo esté activo antes de realizar cualquier operación de registro. Hacer pm_runtime_put_sync() debería deshabilitar refclk, por lo que no es necesario deshabilitarlo nuevamente. Corrige la siguiente advertencia al eliminar el módulo. [39.705310] ------------[ cortar aquí ]------------ [ 39.710004] clk:162:3 ya deshabilitado [ 39.713941] ADVERTENCIA: CPU: 0 PID : 921 en drivers\/clk\/clk.c:1090 clk_core_disable+0xb0\/0xb8 Llamamos a of_platform_populate() en .probe(), así que llame a la función de limpieza of_platform_depopulate() en .remove(). Deshágase del ahora innecesario dwc3_ti_remove_core(). Sin esto, la recarga del módulo no funciona correctamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3895780fabd120d0fbd54354014e85207b25687c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/629b534c42d04f0797980f2d1ed105fdb8906975","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6661befe41009c210efa2c1bcd16a5cc4cff8a06","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6c6a45645a2e6a272dfde14eddbb6706de63c25d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7dfed9855397d0df4c6f748d1f66547ab3bad766","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26964","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:12.707","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: xhci: Add error handling in xhci_map_urb_for_dma\n\nCurrently xhci_map_urb_for_dma() creates a temporary buffer and copies\nthe SG list to the new linear buffer. But if the kzalloc_node() fails,\nthen the following sg_pcopy_to_buffer() can lead to crash since it\ntries to memcpy to NULL pointer.\n\nSo return -ENOMEM if kzalloc returns null pointer."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: xhci: agregar manejo de errores en xhci_map_urb_for_dma Actualmente, xhci_map_urb_for_dma() crea un búfer temporal y copia la lista SG en el nuevo búfer lineal. Pero si kzalloc_node() falla, entonces el siguiente sg_pcopy_to_buffer() puede provocar un fallo ya que intenta memcpy al puntero NULL. Entonces devuelve -ENOMEM si kzalloc devuelve un puntero nulo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4a49d24fdec0a802aa686a567a3989a9fdf4e5dd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/620b6cf2f1a270f48d38e6b8ce199c1acb3e90f4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7b6cc33593d7ccfc3011b290849cfa899db46757","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/962300a360d24c5be5a188cda48da58a37e4304d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b2c898469dfc388f619c6c972a28466cbb1442ea","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/be95cc6d71dfd0cba66e3621c65413321b398052","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26965","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:12.783","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: mmcc-msm8974: fix terminating of frequency table arrays\n\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\n\nOnly compile tested."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: qcom: mmcc-msm8974: corrección de terminación de matrices de tablas de frecuencia Se supone que las matrices de tablas de frecuencia terminan con un elemento vacío. Agregue dicha entrada al final de las matrices donde falta para evitar un posible acceso fuera de los límites cuando la tabla es atravesada por funciones como qcom_find_freq() o qcom_find_freq_floor(). Solo compilar probado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3ff4a0f6a8f0ad4b4ee9e908bdfc3cacb7be4060","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/537040c257ab4cd0673fbae048f3940c8ea2e589","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7e9926fef71e514b4a8ea9d11d5a84d52b181362","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/86bf75d9158f511db7530bc82a84b19a5134d089","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f562f3b25177c2055b20fd8cf000496f6fa9194","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/99740c4791dc8019b0d758c5389ca6d1c0604d95","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ae99e199037c580b7350bfa3596f447a53bcf01f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca2cf98d46748373e830a13d85d215d64a2d9bf2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e2c02a85bf53ae86d79b5fccf0a75ac0b78e0c96","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26966","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:12.913","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: mmcc-apq8084: fix terminating of frequency table arrays\n\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\n\nOnly compile tested."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: qcom: mmcc-apq8084: corrección de terminación de matrices de tablas de frecuencia Se supone que las matrices de tablas de frecuencia terminan con un elemento vacío. Agregue dicha entrada al final de las matrices donde falta para evitar un posible acceso fuera de los límites cuando la tabla es atravesada por funciones como qcom_find_freq() o qcom_find_freq_floor(). Solo compilar probado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/185de0b7cdeaad8b89ebd4c8a258ff2f21adba99","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3aedcf3755c74dafc187eb76acb04e3e6348b1a9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5533686e99b04994d7c4877dc0e4282adc9444a2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5638330150db2cc30b53eed04e481062faa3ece8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7e5432401536117c316d7f3b21d46b64c1514f38","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9b4c4546dd61950e80ffdca1bf6925f42b665b03","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a09aecb6cb482de88301c43bf00a6c8726c4d34f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a903cfd38d8dee7e754fb89fd1bebed99e28003d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b2dfb216f32627c2f6a8041f2d9d56d102ab87c0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26967","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:13.010","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: camcc-sc8280xp: fix terminating of frequency table arrays\n\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\n\nOnly compile tested."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: qcom: camcc-sc8280xp: corrección de terminación de matrices de tablas de frecuencia Se supone que las matrices de tablas de frecuencia terminan con un elemento vacío. Agregue dicha entrada al final de las matrices donde falta para evitar un posible acceso fuera de los límites cuando la tabla es atravesada por funciones como qcom_find_freq() o qcom_find_freq_floor(). Solo compilar probado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6a3d70f7802a98e6c28a74f997a264118b9f50cd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/93ff48729211dae55df5d216023be4528d29babb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26968","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:13.133","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: gcc-ipq9574: fix terminating of frequency table arrays\n\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\n\nOnly compile tested."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: qcom: gcc-ipq9574: corrección de terminación de matrices de tablas de frecuencia Se supone que las matrices de tablas de frecuencia terminan con un elemento vacío. Agregue dicha entrada al final de las matrices donde falta para evitar un posible acceso fuera de los límites cuando la tabla es atravesada por funciones como qcom_find_freq() o qcom_find_freq_floor(). Solo compilar probado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0204247cf3669b6021fb745c3b7f37ae392ab19c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1723629fea8a4e75333196866e10d395463dca72","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/604f2d7c46727c5e24fc7faddc980bc1cc0b1011","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bd2b6395671d823caa38d8e4d752de2448ae61e1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26969","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:13.220","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: gcc-ipq8074: fix terminating of frequency table arrays\n\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\n\nOnly compile tested."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: qcom: gcc-ipq8074: corrección de terminación de matrices de tablas de frecuencia Se supone que las matrices de tablas de frecuencia terminan con un elemento vacío. Agregue dicha entrada al final de las matrices donde falta para evitar un posible acceso fuera de los límites cuando la tabla es atravesada por funciones como qcom_find_freq() o qcom_find_freq_floor(). Solo compilar probado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1040ef5ed95d6fd2628bad387d78a61633e09429","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/83fe1bbd9e259ad109827ccfbfc2488e0dea8e94","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/851cc19bdb02556fb13629b3e4fef6f2bdb038fe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9de184d4e557d550fb0b7b833b676bda4f269e4f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b6b31b4c67ea6bd9222e5b73b330554c57f2f90d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/be9e2752d823eca1d5af67014a1844a9176ff566","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dd92b159c506804ac57adf3742d9728298bb1255","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e117c6e2d1617520f5f7d7f6f6b395f01d8b5a27","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fc3ac2fcd0a7fad63eba1b359490a4b81720d0f9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26970","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:13.320","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: gcc-ipq6018: fix terminating of frequency table arrays\n\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\n\nOnly compile tested."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: qcom: gcc-ipq6018: corrección de terminación de matrices de tablas de frecuencia Se supone que las matrices de tablas de frecuencia terminan con un elemento vacío. Agregue dicha entrada al final de las matrices donde falta para evitar un posible acceso fuera de los límites cuando la tabla es atravesada por funciones como qcom_find_freq() o qcom_find_freq_floor(). Solo compilar probado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/421b135aceace99789c982f6a77ce9476564fb52","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/852db52b45ea96dac2720f108e7c7331cd3738bb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ae60e3342296f766f88911d39199f77b05f657a6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4527ee3de365a742215773d20f07db3e2c06f3b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cdbc6e2d8108bc47895e5a901cfcaf799b00ca8d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/db4066e3ab6b3d918ae2b92734a89c04fe82cc1d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dcb13b5c9ae8743f99a96f392186527c3df89198","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26971","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:13.450","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: gcc-ipq5018: fix terminating of frequency table arrays\n\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor()."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: qcom: gcc-ipq5018: corrección de terminación de matrices de tablas de frecuencia Se supone que las matrices de tablas de frecuencia terminan con un elemento vacío. Agregue dicha entrada al final de las matrices donde falta para evitar un posible acceso fuera de los límites cuando la tabla es atravesada por funciones como qcom_find_freq() o qcom_find_freq_floor()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/50c3acd460551cdf9d8ac6fe0c04f2de0e8e0872","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90ad946fff70f312b8d23226afc38c13ddd88c4b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0cf3d200e8a72b6d28e6e088c062b4a98cb5eaf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c8f4bef0667947b826848db1c45a645f751357c1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26972","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:13.597","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nubifs: ubifs_symlink: Fix memleak of inode->i_link in error path\n\nFor error handling path in ubifs_symlink(), inode will be marked as\nbad first, then iput() is invoked. If inode->i_link is initialized by\nfscrypt_encrypt_symlink() in encryption scenario, inode->i_link won't\nbe freed by callchain ubifs_free_inode -> fscrypt_free_inode in error\nhandling path, because make_bad_inode() has changed 'inode->i_mode' as\n'S_IFREG'.\nFollowing kmemleak is easy to be reproduced by injecting error in\nubifs_jnl_update() when doing symlink in encryption scenario:\n unreferenced object 0xffff888103da3d98 (size 8):\n  comm \"ln\", pid 1692, jiffies 4294914701 (age 12.045s)\n  backtrace:\n   kmemdup+0x32\/0x70\n   __fscrypt_encrypt_symlink+0xed\/0x1c0\n   ubifs_symlink+0x210\/0x300 [ubifs]\n   vfs_symlink+0x216\/0x360\n   do_symlinkat+0x11a\/0x190\n   do_syscall_64+0x3b\/0xe0\nThere are two ways fixing it:\n 1. Remove make_bad_inode() in error handling path. We can do that\n    because ubifs_evict_inode() will do same processes for good\n    symlink inode and bad symlink inode, for inode->i_nlink checking\n    is before is_bad_inode().\n 2. Free inode->i_link before marking inode bad.\nMethod 2 is picked, it has less influence, personally, I think."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ubifs: ubifs_symlink: corrige la fuga de memleak de inodo-&gt;i_link en la ruta de error Para el manejo de errores en la ruta en ubifs_symlink(), el inodo se marcará como incorrecto primero y luego se invocará iput(). Si inode-&gt;i_link se inicializa mediante fscrypt_encrypt_symlink() en el escenario de cifrado, inode-&gt;i_link no será liberado por la cadena de llamadas ubifs_free_inode -&gt; fscrypt_free_inode en la ruta de manejo de errores, porque make_bad_inode() ha cambiado 'inode-&gt;i_mode' como 'S_IFREG '. El siguiente kmemleak es fácil de reproducir inyectando un error en ubifs_jnl_update() al realizar un enlace simbólico en un escenario de cifrado: objeto sin referencia 0xffff888103da3d98 (tamaño 8): comm \"ln\", pid 1692, jiffies 4294914701 (edad 12.045 s) backtrace: kmemdup+0x32\/ 0x70 __fscrypt_encrypt_symlink+0xed\/0x1c0 ubifs_symlink+0x210\/0x300 [ubifs] vfs_symlink+0x216\/0x360 do_symlinkat+0x11a\/0x190 do_syscall_64+0x3b\/0xe0 Hay dos formas de solucionarlo: 1. Eliminar make_bad _inode() en la ruta de manejo de errores. Podemos hacer eso porque ubifs_evict_inode() realizará los mismos procesos para el inodo de enlace simbólico bueno y el inodo de enlace simbólico incorrecto, para inodo-&gt;i_nlink la verificación es antes de is_bad_inode(). 2. Libere inodo-&gt;i_link antes de marcar el inodo como incorrecto. Se elige el método 2, creo que tiene menos influencia, personalmente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/62b5ae00c2b835639002ce898ccb5d82c51073ae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6379b44cdcd67f5f5d986b73953e99700591edfa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26973","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:13.920","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nfat: fix uninitialized field in nostale filehandles\n\nWhen fat_encode_fh_nostale() encodes file handle without a parent it\nstores only first 10 bytes of the file handle. However the length of the\nfile handle must be a multiple of 4 so the file handle is actually 12\nbytes long and the last two bytes remain uninitialized. This is not\ngreat at we potentially leak uninitialized information with the handle\nto userspace. Properly initialize the full handle length."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: fat: corrige el campo no inicializado en los identificadores de archivos notale Cuando fat_encode_fh_nostale() codifica el identificador de archivo sin un padre, almacena solo los primeros 10 bytes del identificador de archivo. Sin embargo, la longitud del identificador del archivo debe ser múltiplo de 4, por lo que el identificador del archivo tiene en realidad 12 bytes de longitud y los dos últimos bytes permanecen sin inicializar. Esto no es bueno porque potencialmente filtramos información no inicializada con el identificador al espacio de usuario. Inicialice correctamente toda la longitud del mango."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/03a7e3f2ba3ca25f1da1d3898709a08db14c1abb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/74f852654b8b7866f15323685f1e178d3386c688","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9840d1897e28f8733cc1e38f97e044f987dc0a63","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a276c595c3a629170b0f052a3724f755d7c6adc6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7fb63e807c6dadf7ecc1d43448c4f1711d7eeee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c8cc05de8e6b5612b6e9f92c385c1a064b0db375","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cdd33d54e789d229d6d5007cbf3f53965ca1a5c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f52d7663a10a1266a2d3871a6dd8fd111edc549f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fde2497d2bc3a063d8af88b258dbadc86bd7b57c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26974","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:14.313","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: qat - resolve race condition during AER recovery\n\nDuring the PCI AER system's error recovery process, the kernel driver\nmay encounter a race condition with freeing the reset_data structure's\nmemory. If the device restart will take more than 10 seconds the function\nscheduling that restart will exit due to a timeout, and the reset_data\nstructure will be freed. However, this data structure is used for\ncompletion notification after the restart is completed, which leads\nto a UAF bug.\n\nThis results in a KFENCE bug notice.\n\n  BUG: KFENCE: use-after-free read in adf_device_reset_worker+0x38\/0xa0 [intel_qat]\n  Use-after-free read at 0x00000000bc56fddf (in kfence-#142):\n  adf_device_reset_worker+0x38\/0xa0 [intel_qat]\n  process_one_work+0x173\/0x340\n\nTo resolve this race condition, the memory associated to the container\nof the work_struct is freed on the worker if the timeout expired,\notherwise on the function that schedules the worker.\nThe timeout detection can be done by checking if the caller is\nstill waiting for completion or not by using completion_done() function."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: crypto: qat: resuelve la condición de ejecución durante la recuperación de AER Durante el proceso de recuperación de errores del sistema PCI AER, el controlador del kernel puede encontrar una condición de ejecución al liberar la memoria de la estructura reset_data. Si el reinicio del dispositivo demora más de 10 segundos, la función que programa el reinicio se cerrará debido a un tiempo de espera y se liberará la estructura reset_data. Sin embargo, esta estructura de datos se utiliza para la notificación de finalización después de que se completa el reinicio, lo que genera un error de UAF. Esto da como resultado un aviso de error de KFENCE. ERROR: KFENCE: lectura de uso después de liberación en adf_device_reset_worker+0x38\/0xa0 [intel_qat] Lectura de uso después de liberación en 0x00000000bc56fddf (en kfence-#142): adf_device_reset_worker+0x38\/0xa0 [intel_qat] Process_one_work+0x173\/0x340 Para resolver En esta condición de ejecución, la memoria asociada al contenedor de work_struct se libera en el trabajador si el tiempo de espera expiró; en caso contrario, en la función que programa al trabajador. La detección del tiempo de espera se puede realizar comprobando si la persona que llama todavía está esperando que finalice o no mediante la función complete_done()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0c2cf5142bfb634c0ef0a1a69cdf37950747d0be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/226fc408c5fcd23cc4186f05ea3a09a7a9aef2f7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4ae5a97781ce7d6ecc9c7055396535815b64ca4f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7d42e097607c4d246d99225bf2b195b6167a210c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a5a7611ccc7b1fba8d933a9f22a2e76859d94dc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8e81cd58aee14a470891733181a47d123193ba81","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bb279ead42263e9fb09480f02a4247b2c287d828","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d03092550f526a79cf1ade7f0dfa74906f39eb71","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/daba62d9eeddcc5b1081be7d348ca836c83c59d7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26975","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:14.533","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npowercap: intel_rapl: Fix a NULL pointer dereference\n\nA NULL pointer dereference is triggered when probing the MMIO RAPL\ndriver on platforms with CPU ID not listed in intel_rapl_common CPU\nmodel list.\n\nThis is because the intel_rapl_common module still probes on such\nplatforms even if 'defaults_msr' is not set after commit 1488ac990ac8\n(\"powercap: intel_rapl: Allow probing without CPUID match\"). Thus the\nMMIO RAPL rp->priv->defaults is NULL when registering to RAPL framework.\n\nFix the problem by adding sanity check to ensure rp->priv->rapl_defaults\nis always valid."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: powercap: intel_rapl: corrige una desreferencia de puntero NULL Se activa una desreferencia de puntero NULL al probar el controlador MMIO RAPL en plataformas con ID de CPU que no figuran en la lista de modelos de CPU intel_rapl_common. Esto se debe a que el módulo intel_rapl_common aún sondea en dichas plataformas incluso si 'defaults_msr' no está configurado después de confirmar 1488ac990ac8 (\"powercap: intel_rapl: Permitir sondeo sin coincidencia de CPUID\"). Por lo tanto, MMIO RAPL rp-&gt;priv-&gt;defaults es NULL cuando se registra en el marco RAPL. Solucione el problema agregando una verificación de cordura para garantizar que rp-&gt;priv-&gt;rapl_defaults siempre sea válido."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0641908b906a133f1494c312a71f9fecbe2b6c78","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2d1f5006ff95770da502f8cee2a224a1ff83866e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2f73cf2ae5e0f4e629db5be3a4380ff7807148e6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9b254feb249981b66ccdb1dae54e757789a15ba1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26976","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:14.667","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: Always flush async #PF workqueue when vCPU is being destroyed\n\nAlways flush the per-vCPU async #PF workqueue when a vCPU is clearing its\ncompletion queue, e.g. when a VM and all its vCPUs is being destroyed.\nKVM must ensure that none of its workqueue callbacks is running when the\nlast reference to the KVM _module_ is put.  Gifting a reference to the\nassociated VM prevents the workqueue callback from dereferencing freed\nvCPU\/VM memory, but does not prevent the KVM module from being unloaded\nbefore the callback completes.\n\nDrop the misguided VM refcount gifting, as calling kvm_put_kvm() from\nasync_pf_execute() if kvm_put_kvm() flushes the async #PF workqueue will\nresult in deadlock.  async_pf_execute() can't return until kvm_put_kvm()\nfinishes, and kvm_put_kvm() can't return until async_pf_execute() finishes:\n\n WARNING: CPU: 8 PID: 251 at virt\/kvm\/kvm_main.c:1435 kvm_put_kvm+0x2d\/0x320 [kvm]\n Modules linked in: vhost_net vhost vhost_iotlb tap kvm_intel kvm irqbypass\n CPU: 8 PID: 251 Comm: kworker\/8:1 Tainted: G        W          6.6.0-rc1-e7af8d17224a-x86\/gmem-vm #119\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02\/06\/2015\n Workqueue: events async_pf_execute [kvm]\n RIP: 0010:kvm_put_kvm+0x2d\/0x320 [kvm]\n Call Trace:\n  <TASK>\n  async_pf_execute+0x198\/0x260 [kvm]\n  process_one_work+0x145\/0x2d0\n  worker_thread+0x27e\/0x3a0\n  kthread+0xba\/0xe0\n  ret_from_fork+0x2d\/0x50\n  ret_from_fork_asm+0x11\/0x20\n  <\/TASK>\n ---[ end trace 0000000000000000 ]---\n INFO: task kworker\/8:1:251 blocked for more than 120 seconds.\n       Tainted: G        W          6.6.0-rc1-e7af8d17224a-x86\/gmem-vm #119\n \"echo 0 > \/proc\/sys\/kernel\/hung_task_timeout_secs\" disables this message.\n task:kworker\/8:1     state:D stack:0     pid:251   ppid:2      flags:0x00004000\n Workqueue: events async_pf_execute [kvm]\n Call Trace:\n  <TASK>\n  __schedule+0x33f\/0xa40\n  schedule+0x53\/0xc0\n  schedule_timeout+0x12a\/0x140\n  __wait_for_common+0x8d\/0x1d0\n  __flush_work.isra.0+0x19f\/0x2c0\n  kvm_clear_async_pf_completion_queue+0x129\/0x190 [kvm]\n  kvm_arch_destroy_vm+0x78\/0x1b0 [kvm]\n  kvm_put_kvm+0x1c1\/0x320 [kvm]\n  async_pf_execute+0x198\/0x260 [kvm]\n  process_one_work+0x145\/0x2d0\n  worker_thread+0x27e\/0x3a0\n  kthread+0xba\/0xe0\n  ret_from_fork+0x2d\/0x50\n  ret_from_fork_asm+0x11\/0x20\n  <\/TASK>\n\nIf kvm_clear_async_pf_completion_queue() actually flushes the workqueue,\nthen there's no need to gift async_pf_execute() a reference because all\ninvocations of async_pf_execute() will be forced to complete before the\nvCPU and its VM are destroyed\/freed.  And that in turn fixes the module\nunloading bug as __fput() won't do module_put() on the last vCPU reference\nuntil the vCPU has been freed, e.g. if closing the vCPU file also puts the\nlast reference to the KVM module.\n\nNote that kvm_check_async_pf_completion() may also take the work item off\nthe completion queue and so also needs to flush the work queue, as the\nwork will not be seen by kvm_clear_async_pf_completion_queue().  Waiting\non the workqueue could theoretically delay a vCPU due to waiting for the\nwork to complete, but that's a very, very small chance, and likely a very\nsmall delay.  kvm_arch_async_page_present_queued() unconditionally makes a\nnew request, i.e. will effectively delay entering the guest, so the\nremaining work is really just:\n\n        trace_kvm_async_pf_completed(addr, cr2_or_gpa);\n\n        __kvm_vcpu_wake_up(vcpu);\n\n        mmput(mm);\n\nand mmput() can't drop the last reference to the page tables if the vCPU is\nstill alive, i.e. the vCPU won't get stuck tearing down page tables.\n\nAdd a helper to do the flushing, specifically to deal with \"wakeup all\"\nwork items, as they aren't actually work items, i.e. are never placed in a\nworkqueue.  Trying to flush a bogus workqueue entry rightly makes\n__flush_work() complain (kudos to whoever added that sanity check).\n\nNote, commit 5f6de5cbebee (\"KVM: Prevent module exit until al\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: siempre vacíe la cola de trabajo asíncrona #PF cuando se destruya la vCPU. Siempre vacíe la cola de trabajo asíncrona #PF por vCPU cuando una vCPU esté limpiando su cola de finalización, por ejemplo, cuando una VM y todo sus vCPU están siendo destruidas. KVM debe asegurarse de que ninguna de sus devoluciones de llamada de la cola de trabajo se esté ejecutando cuando se coloca la última referencia al _módulo_ KVM. Regalar una referencia a la VM asociada evita que la devolución de llamada de la cola de trabajo elimine la referencia a la memoria de vCPU\/VM liberada, pero no evita que el módulo KVM se descargue antes de que se complete la devolución de llamada. Elimine el regalo de recuento de VM equivocado, ya que llamar a kvm_put_kvm() desde async_pf_execute() si kvm_put_kvm() vacía la cola de trabajo asíncrona #PF resultará en un punto muerto. async_pf_execute() no puede regresar hasta que finalice kvm_put_kvm(), y kvm_put_kvm() no puede regresar hasta que finalice async_pf_execute(): ADVERTENCIA: CPU: 8 PID: 251 en virt\/kvm\/kvm_main.c:1435 kvm_put_kvm+0x2d\/0x320 [kvm] Módulos vinculados en: vhost_net vhost vhost_iotlb tap kvm_intel kvm irqbypass CPU: 8 PID: 251 Comm: kworker\/8:1 Tainted: GW 6.6.0-rc1-e7af8d17224a-x86\/gmem-vm #119 Nombre de hardware: Estándar QEMU PC (Q35 + ICH9, 2009), BIOS 0.0.0 06\/02\/2015 Cola de trabajo: eventos async_pf_execute [kvm] RIP: 0010:kvm_put_kvm+0x2d\/0x320 [kvm] Seguimiento de llamadas:  async_pf_execute+0x198\/0x260 [kvm ] Process_one_work+0x145\/0x2d0 work_thread+0x27e\/0x3a0 kthread+0xba\/0xe0 ret_from_fork+0x2d\/0x50 ret_from_fork_asm+0x11\/0x20  ---[ end trace 0000000000000000 ]--- INFORMACIÓN: tarea kworker \/8:1: 251 bloqueado durante más de 120 segundos. Contaminado: GW 6.6.0-rc1-e7af8d17224a-x86\/gmem-vm #119 \"echo 0 &gt; \/proc\/sys\/kernel\/hung_task_timeout_secs\" desactiva este mensaje. tarea:kworker\/8:1 estado:D pila:0 pid:251 ppid:2 banderas:0x00004000 Cola de trabajo: eventos async_pf_execute [kvm] Seguimiento de llamadas:  __schedule+0x33f\/0xa40 Schedule+0x53\/0xc0 Schedule_timeout+0x12a\/0x140 __wait_for_common+0x8d\/0x1d0 __flush_work.isra.0+0x19f\/0x2c0 kvm_clear_async_pf_completion_queue+0x129\/0x190 [kvm] kvm_arch_destroy_vm+0x78\/0x1b0 [kvm] x320 [kvm] async_pf_execute+0x198\/0x260 [kvm] proceso_one_work+0x145\/ 0x2d0 trabajador_thread+0x27e\/0x3a0 kthread+0xba\/0xe0 ret_from_fork+0x2d\/0x50 ret_from_fork_asm+0x11\/0x20  Si kvm_clear_async_pf_completion_queue() realmente vacía la cola de trabajo, entonces no hay necesidad de regalar un referencia porque todas las invocaciones de async_pf_execute () se verá obligado a completarse antes de que la vCPU y su VM sean destruidas o liberadas. Y eso, a su vez, corrige el error de descarga del módulo, ya que __fput() no ejecutará module_put() en la última referencia de vCPU hasta que se haya liberado la vCPU, por ejemplo, si al cerrar el archivo de vCPU también se coloca la última referencia al módulo KVM. Tenga en cuenta que kvm_check_async_pf_completion() también puede sacar el elemento de trabajo de la cola de finalización y, por lo tanto, también necesita vaciar la cola de trabajos, ya que kvm_clear_async_pf_completion_queue() no verá el trabajo. En teoría, esperar en la cola de trabajo podría retrasar una vCPU debido a la espera de que se complete el trabajo, pero esa es una posibilidad muy, muy pequeña y probablemente un retraso muy pequeño. kvm_arch_async_page_present_queued() realiza incondicionalmente una nueva solicitud, es decir, efectivamente retrasará la entrada del invitado, por lo que el trabajo restante es realmente solo: trace_kvm_async_pf_completed(addr, cr2_or_gpa); __kvm_vcpu_wake_up(vcpu); mmput(mm); y mmput() no puede eliminar la última referencia a las tablas de páginas si la vCPU aún está activa, es decir, la vCPU no se atascará al derribar las tablas de páginas. ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3d75b8aa5c29058a512db29da7cbee8052724157","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4f3a3bce428fb439c66a578adc447afce7b4a750","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/82e25cc1c2e93c3023da98be282322fc08b61ffb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/83d3c5e309611ef593e2fcb78444fc8ceedf9bac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a75afe480d4349c524d9c659b1a5a544dbc39a98","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ab2c2f5d9576112ad22cfd3798071cb74693b1f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b54478d20375874aeee257744dedfd3e413432ff","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/caa9af2e27c275e089d702cfbaaece3b42bca31b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f8730d6335e5f43d09151fca1f0f41922209a264","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26977","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:14.860","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npci_iounmap(): Fix MMIO mapping leak\n\nThe #ifdef ARCH_HAS_GENERIC_IOPORT_MAP accidentally also guards iounmap(),\nwhich means MMIO mappings are leaked.\n\nMove the guard so we call iounmap() for MMIO mappings."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: pci_iounmap(): corrige la fuga de mapeo MMIO El #ifdef ARCH_HAS_GENERIC_IOPORT_MAP accidentalmente también protege iounmap(), lo que significa que se filtraron los mapeos MMIO. Mueva la guardia para que llamemos a iounmap() para asignaciones MMIO."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5e4b23e7a7b33a1e56bfa3e5598138a2234d55b6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6d21d0356aa44157a62e39c0d1a13d4c69a8d0c8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7626913652cc786c238e2dd7d8740b17d41b2637","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/af280e137e273935f2e09f4d73169998298792ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b5d40f02e7222da032c2042aebcf2a07de9b342f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f3749345a9b7295dd071d0ed589634cb46364f77","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26978","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:15.040","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nserial: max310x: fix NULL pointer dereference in I2C instantiation\n\nWhen trying to instantiate a max14830 device from userspace:\n\n    echo max14830 0x60 > \/sys\/bus\/i2c\/devices\/i2c-2\/new_device\n\nwe get the following error:\n\n    Unable to handle kernel NULL pointer dereference at virtual address...\n    ...\n    Call trace:\n        max310x_i2c_probe+0x48\/0x170 [max310x]\n        i2c_device_probe+0x150\/0x2a0\n    ...\n\nAdd check for validity of devtype to prevent the error, and abort probe\nwith a meaningful error message."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: serial: max310x: corrige la desreferencia del puntero NULL en la creación de instancias I2C Al intentar crear una instancia de un dispositivo max14830 desde el espacio de usuario: echo max14830 0x60 &gt; \/sys\/bus\/i2c\/devices\/i2c-2\/ new_device obtenemos el siguiente error: No se puede manejar la desreferencia del puntero NULL del kernel en la dirección virtual... ... Rastreo de llamadas: max310x_i2c_probe+0x48\/0x170 [max310x] i2c_device_probe+0x150\/0x2a0... Agregar verificación de validez del tipo de desarrollo para evitar el error y cancelar la sonda con un mensaje de error significativo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0d27056c24efd3d63a03f3edfbcfc4827086b110","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/12609c76b755dbeb1645c0aacc0f0f4743b2eff3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2160ad6861c4a21d3fa553d7b2aaec6634a37f8a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5cd8af02b466e1beeae13e2de3dc58fcc7925e5a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7d271b798add90c6196539167c019d0817285cf0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aeca49661fd02fd56fb026768b580ce301b45733","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c45e53c27b78afd6c81fc25608003576f27b5735","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26979","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:15.227","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/vmwgfx: Fix possible null pointer derefence with invalid contexts\n\nvmw_context_cotable can return either an error or a null pointer and its\nusage sometimes went unchecked. Subsequent code would then try to access\neither a null pointer or an error value.\n\nThe invalid dereferences were only possible with malformed userspace\napps which never properly initialized the rendering contexts.\n\nCheck the results of vmw_context_cotable to fix the invalid derefs.\n\nThanks:\nziming zhang(@ezrak1e) from Ant Group Light-Year Security Lab\nwho was the first person to discover it.\nNiels De Graef who reported it and helped to track down the poc."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/vmwgfx: corrige una posible desreferencia del puntero nulo con contextos no válidos. vmw_context_cotable puede devolver un error o un puntero nulo y, en ocasiones, su uso no se controlaba. El código posterior intentaría acceder a un puntero nulo o a un valor de error. Las desreferencias no válidas solo fueron posibles con aplicaciones de espacio de usuario con formato incorrecto que nunca inicializaron correctamente los contextos de representación. Verifique los resultados de vmw_context_cotable para corregir los derefs no válidos. Gracias: ziming zhang (@ezrak1e) de Ant Group Light-Year Security Lab, quien fue la primera persona en descubrirlo. Niels De Graef, quien lo informó y ayudó a localizar al poc."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/07c3fe923ff7eccf684fb4f8c953d0a7cc8ded73","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/517621b7060096e48e42f545fa6646fc00252eac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/585fec7361e7850bead21fada49a7fcde2f2e791","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/899e154f9546fcae18065d74064889d08fff62c2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9cb3755b1e3680b720b74dbedfac889e904605c7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c560327d900bab968c2e1b4cd7fa2d46cd429e3d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ff41e0d4f3fa10d7cdd7d40f8026bea9fcc8b000","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26980","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:15.423","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: fix slab-out-of-bounds in smb2_allocate_rsp_buf\n\nIf ->ProtocolId is SMB2_TRANSFORM_PROTO_NUM, smb2 request size\nvalidation could be skipped. if request size is smaller than\nsizeof(struct smb2_query_info_req), slab-out-of-bounds read can happen in\nsmb2_allocate_rsp_buf(). This patch allocate response buffer after\ndecrypting transform request. smb3_decrypt_req() will validate transform\nrequest size and avoid slab-out-of-bound in smb2_allocate_rsp_buf()."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ksmbd: corrige slab-out-of-bounds en smb2_allocate_rsp_buf Si -&gt;ProtocolId es SMB2_TRANSFORM_PROTO_NUM, se podría omitir la validación del tamaño de la solicitud smb2. Si el tamaño de la solicitud es menor que sizeof (struct smb2_query_info_req), la lectura de losa fuera de los límites puede ocurrir en smb2_allocate_rsp_buf(). Este parche asigna un búfer de respuesta después de descifrar la solicitud de transformación. smb3_decrypt_req() validará el tamaño de la solicitud de transformación y evitará la losa fuera de los límites en smb2_allocate_rsp_buf()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0977f89722eceba165700ea384f075143f012085","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3160d9734453a40db248487f8204830879c207f1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b80ba648714e6d790d69610cf14656be222d0248","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c119f4ede3fa90a9463f50831761c28f989bfb20","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26981","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:15.517","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix OOB in nilfs_set_de_type\n\nThe size of the nilfs_type_by_mode array in the fs\/nilfs2\/dir.c file is\ndefined as \"S_IFMT >> S_SHIFT\", but the nilfs_set_de_type() function,\nwhich uses this array, specifies the index to read from the array in the\nsame way as \"(mode & S_IFMT) >> S_SHIFT\".\n\nstatic void nilfs_set_de_type(struct nilfs_dir_entry *de, struct inode\n *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\tde->file_type = nilfs_type_by_mode[(mode & S_IFMT)>>S_SHIFT]; \/\/ oob\n}\n\nHowever, when the index is determined this way, an out-of-bounds (OOB)\nerror occurs by referring to an index that is 1 larger than the array size\nwhen the condition \"mode & S_IFMT == S_IFMT\" is satisfied.  Therefore, a\npatch to resize the nilfs_type_by_mode array should be applied to prevent\nOOB errors."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nilfs2: corrige OOB en nilfs_set_de_type El tamaño de la matriz nilfs_type_by_mode en el archivo fs\/nilfs2\/dir.c se define como \"S_IFMT &gt;&gt; S_SHIFT\", pero la función nilfs_set_de_type() , que utiliza esta matriz, especifica el índice a leer de la matriz de la misma manera que \"(mode &amp; S_IFMT) &gt;&gt; S_SHIFT\". static void nilfs_set_de_type(struct nilfs_dir_entry *de, struct inode *inode) { umode_t modo = inodo-&gt;i_mode; de-&gt;tipo_archivo = nilfs_type_by_mode[(modo &amp; S_IFMT)&gt;&gt;S_SHIFT]; \/\/ oob } Sin embargo, cuando el índice se determina de esta manera, se produce un error fuera de los límites (OOB) al hacer referencia a un índice que es 1 mayor que el tamaño de la matriz cuando la condición \"modo &amp; S_IFMT == S_IFMT\" es satisfecho. Por lo tanto, se debe aplicar un parche para cambiar el tamaño de la matriz nilfs_type_by_mode para evitar errores OOB."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2382eae66b196c31893984a538908c3eb7506ff9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/897ac5306bbeb83e90c437326f7044c79a17c611","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90823f8d9ecca3d5fa6b102c8e464c62f416975f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bdbe483da21f852c93b22557b146bc4d989260f0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c4a7dc9523b59b3e73fd522c73e95e072f876b16","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26982","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:15.610","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nSquashfs: check the inode number is not the invalid value of zero\n\nSyskiller has produced an out of bounds access in fill_meta_index().\n\nThat out of bounds access is ultimately caused because the inode\nhas an inode number with the invalid value of zero, which was not checked.\n\nThe reason this causes the out of bounds access is due to following\nsequence of events:\n\n1. Fill_meta_index() is called to allocate (via empty_meta_index())\n   and fill a metadata index.  It however suffers a data read error\n   and aborts, invalidating the newly returned empty metadata index.\n   It does this by setting the inode number of the index to zero,\n   which means unused (zero is not a valid inode number).\n\n2. When fill_meta_index() is subsequently called again on another\n   read operation, locate_meta_index() returns the previous index\n   because it matches the inode number of 0.  Because this index\n   has been returned it is expected to have been filled, and because\n   it hasn't been, an out of bounds access is performed.\n\nThis patch adds a sanity check which checks that the inode number\nis not zero when the inode is created and returns -EINVAL if it is.\n\n[phillip@squashfs.org.uk: whitespace fix]\n  Link: https:\/\/lkml.kernel.org\/r\/20240409204723.446925-1-phillip@squashfs.org.uk"},{"lang":"es","value":"En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: Squashfs: comprobar que el número de inodo no sea el valor no válido de cero. Syskiller ha producido un acceso fuera de los límites en fill_meta_index(). Ese acceso fuera de los límites se debe en última instancia a que el inodo tiene un número de inodo con un valor no válido de cero, que no se verificó. La razón por la que esto causa el acceso fuera de los límites se debe a la siguiente secuencia de eventos: 1. Se llama a Fill_meta_index() para asignar (a través de vacío_meta_index()) y completar un índice de metadatos. Sin embargo, sufre un error de lectura de datos y se cancela, invalidando el índice de metadatos vacío recién devuelto. Para ello, establece el número de inodo del índice en cero, lo que significa que no se utiliza (cero no es un número de inodo válido). 2. Cuando posteriormente se vuelve a llamar a fill_meta_index() en otra operación de lectura, localizar_meta_index() devuelve el índice anterior porque coincide con el número de inodo de 0. Debido a que este índice ha sido devuelto, se espera que se haya completado, y porque no lo ha hecho. Si no lo ha sido, se realiza un acceso fuera de los límites. Este parche agrega una verificación de cordura que verifica que el número de inodo no sea cero cuando se crea el inodo y devuelve -EINVAL si lo es. [phillip@squashfs.org.uk: corrección de espacios en blanco] Enlace: https:\/\/lkml.kernel.org\/r\/20240409204723.446925-1-phillip@squashfs.org.uk"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7def00ebc9f2d6a581ddf46ce4541f84a10680e5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9253c54e01b6505d348afbc02abaa4d9f8a01395","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26983","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:15.747","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbootconfig: use memblock_free_late to free xbc memory to buddy\n\nOn the time to free xbc memory in xbc_exit(), memblock may has handed\nover memory to buddy allocator. So it doesn't make sense to free memory\nback to memblock. memblock_free() called by xbc_exit() even causes UAF bugs\non architectures with CONFIG_ARCH_KEEP_MEMBLOCK disabled like x86.\nFollowing KASAN logs shows this case.\n\nThis patch fixes the xbc memory free problem by calling memblock_free()\nin early xbc init error rewind path and calling memblock_free_late() in\nxbc exit path to free memory to buddy allocator.\n\n[    9.410890] ==================================================================\n[    9.418962] BUG: KASAN: use-after-free in memblock_isolate_range+0x12d\/0x260\n[    9.426850] Read of size 8 at addr ffff88845dd30000 by task swapper\/0\/1\n\n[    9.435901] CPU: 9 PID: 1 Comm: swapper\/0 Tainted: G     U             6.9.0-rc3-00208-g586b5dfb51b9 #5\n[    9.446403] Hardware name: Intel Corporation RPLP LP5 (CPU:RaptorLake)\/RPLP LP5 (ID:13), BIOS IRPPN02.01.01.00.00.19.015.D-00000000 Dec 28 2023\n[    9.460789] Call Trace:\n[    9.463518]  <TASK>\n[    9.465859]  dump_stack_lvl+0x53\/0x70\n[    9.469949]  print_report+0xce\/0x610\n[    9.473944]  ? __virt_addr_valid+0xf5\/0x1b0\n[    9.478619]  ? memblock_isolate_range+0x12d\/0x260\n[    9.483877]  kasan_report+0xc6\/0x100\n[    9.487870]  ? memblock_isolate_range+0x12d\/0x260\n[    9.493125]  memblock_isolate_range+0x12d\/0x260\n[    9.498187]  memblock_phys_free+0xb4\/0x160\n[    9.502762]  ? __pfx_memblock_phys_free+0x10\/0x10\n[    9.508021]  ? mutex_unlock+0x7e\/0xd0\n[    9.512111]  ? __pfx_mutex_unlock+0x10\/0x10\n[    9.516786]  ? kernel_init_freeable+0x2d4\/0x430\n[    9.521850]  ? __pfx_kernel_init+0x10\/0x10\n[    9.526426]  xbc_exit+0x17\/0x70\n[    9.529935]  kernel_init+0x38\/0x1e0\n[    9.533829]  ? _raw_spin_unlock_irq+0xd\/0x30\n[    9.538601]  ret_from_fork+0x2c\/0x50\n[    9.542596]  ? __pfx_kernel_init+0x10\/0x10\n[    9.547170]  ret_from_fork_asm+0x1a\/0x30\n[    9.551552]  <\/TASK>\n\n[    9.555649] The buggy address belongs to the physical page:\n[    9.561875] page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x1 pfn:0x45dd30\n[    9.570821] flags: 0x200000000000000(node=0|zone=2)\n[    9.576271] page_type: 0xffffffff()\n[    9.580167] raw: 0200000000000000 ffffea0011774c48 ffffea0012ba1848 0000000000000000\n[    9.588823] raw: 0000000000000001 0000000000000000 00000000ffffffff 0000000000000000\n[    9.597476] page dumped because: kasan: bad access detected\n\n[    9.605362] Memory state around the buggy address:\n[    9.610714]  ffff88845dd2ff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[    9.618786]  ffff88845dd2ff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[    9.626857] >ffff88845dd30000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[    9.634930]                    ^\n[    9.638534]  ffff88845dd30080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[    9.646605]  ffff88845dd30100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[    9.654675] =================================================================="},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: bootconfig: use memblock_free_late para liberar memoria xbc para el amigo En el momento de liberar memoria xbc en xbc_exit(), es posible que memblock haya entregado la memoria al asignador de amigos. Por lo tanto, no tiene sentido liberar memoria en Memblock. memblock_free() llamado por xbc_exit() incluso causa errores UAF en arquitecturas con CONFIG_ARCH_KEEP_MEMBLOCK deshabilitado como x86. Los siguientes registros de KASAN muestran este caso. Este parche soluciona el problema de falta de memoria de xbc llamando a memblock_free() en la ruta de rebobinado del error de inicio temprano de xbc y llamando a memblock_free_late() en la ruta de salida de xbc para liberar memoria al asignador de amigos. [9.410890] ================================================= =================== [9.418962] ERROR: KASAN: use-after-free en memblock_isolate_range+0x12d\/0x260 [9.426850] Lectura de tamaño 8 en la dirección ffff88845dd30000 por el intercambiador de tareas \/0\/1 [ 9.435901] CPU: 9 PID: 1 Comm: swapper\/0 Contaminado: GU 6.9.0-rc3-00208-g586b5dfb51b9 #5 [ 9.446403] Nombre de hardware: Intel Corporation RPLP LP5 (CPU:RaptorLake)\/RPLP LP5 (ID:13), BIOS IRPPN02.01.01.00.00.19.015.D-00000000 28 de diciembre de 2023 [9.460789] Seguimiento de llamadas: [9.463518]  [9.465859] dump_stack_lvl+0x53\/0x70 [9.469949] puerto+0xce\/0x610 [ 9.473944] ? __virt_addr_valid+0xf5\/0x1b0 [9.478619]? memblock_isolate_range+0x12d\/0x260 [ 9.483877] kasan_report+0xc6\/0x100 [ 9.487870] ? memblock_isolate_range+0x12d\/0x260 [9.493125] memblock_isolate_range+0x12d\/0x260 [9.498187] memblock_phys_free+0xb4\/0x160 [9.502762]? __pfx_memblock_phys_free+0x10\/0x10 [9.508021]? mutex_unlock+0x7e\/0xd0 [9.512111]? __pfx_mutex_unlock+0x10\/0x10 [9.516786]? kernel_init_freeable+0x2d4\/0x430 [9.521850]? __pfx_kernel_init+0x10\/0x10 [ 9.526426] xbc_exit+0x17\/0x70 [ 9.529935] kernel_init+0x38\/0x1e0 [ 9.533829] ? _raw_spin_unlock_irq+0xd\/0x30 [9.538601] ret_from_fork+0x2c\/0x50 [9.542596]? __pfx_kernel_init+0x10\/0x10 [ 9.547170] ret_from_fork_asm+0x1a\/0x30 [ 9.551552]  [ 9.555649] La dirección con errores pertenece a la página física: [ 9.561875] página: refcount:0 mapcount:0 mapeo:00000000000 Índice 00000: 0x1 pfn :0x45dd30 [ 9.570821] banderas: 0x200000000000000(nodo=0|zona=2) [ 9.576271] tipo de página: 0xffffffff() [ 9.580167] raw: 0200000000000000 ffffea0011774c48 12ba1848 0000000000000000 [9.588823] raw: 0000000000000001 0000000000000000 00000000ffffffff 000000000000000000000000 [9.597476] página volcada porque: kasan: mal acceso detectado [9.605362] Estado de la memoria alrededor de la dirección con errores: [9.610714] ffff88845dd2ff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 9.618786] ffff88845dd2ff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 9.626857] &gt;ffff88845dd30000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 9.634930] ^ [ 9.638534] ffff88845dd30080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 9.646605] ffff88845dd30100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 9.654675] ======================= ==============================================="}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1e7feb31a18c197d63a5e606025ed63c762f8918","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5a7dfb8fcd3f29fc93161100179b27f24f3d5f35","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/89f9a1e876b5a7ad884918c03a46831af202c8a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e46d3be714ad9652480c6db129ab8125e2d20ab7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26984","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:15.880","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnouveau: fix instmem race condition around ptr stores\n\nRunning a lot of VK CTS in parallel against nouveau, once every\nfew hours you might see something like this crash.\n\nBUG: kernel NULL pointer dereference, address: 0000000000000008\nPGD 8000000114e6e067 P4D 8000000114e6e067 PUD 109046067 PMD 0\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 7 PID: 53891 Comm: deqp-vk Not tainted 6.8.0-rc6+ #27\nHardware name: Gigabyte Technology Co., Ltd. Z390 I AORUS PRO WIFI\/Z390 I AORUS PRO WIFI-CF, BIOS F8 11\/05\/2021\nRIP: 0010:gp100_vmm_pgt_mem+0xe3\/0x180 [nouveau]\nCode: c7 48 01 c8 49 89 45 58 85 d2 0f 84 95 00 00 00 41 0f b7 46 12 49 8b 7e 08 89 da 42 8d 2c f8 48 8b 47 08 41 83 c7 01 48 89 ee <48> 8b 40 08 ff d0 0f 1f 00 49 8b 7e 08 48 89 d9 48 8d 75 04 48 c1\nRSP: 0000:ffffac20c5857838 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: 00000000004d8001 RCX: 0000000000000001\nRDX: 00000000004d8001 RSI: 00000000000006d8 RDI: ffffa07afe332180\nRBP: 00000000000006d8 R08: ffffac20c5857ad0 R09: 0000000000ffff10\nR10: 0000000000000001 R11: ffffa07af27e2de0 R12: 000000000000001c\nR13: ffffac20c5857ad0 R14: ffffa07a96fe9040 R15: 000000000000001c\nFS:  00007fe395eed7c0(0000) GS:ffffa07e2c980000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000008 CR3: 000000011febe001 CR4: 00000000003706f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\n...\n\n ? gp100_vmm_pgt_mem+0xe3\/0x180 [nouveau]\n ? gp100_vmm_pgt_mem+0x37\/0x180 [nouveau]\n nvkm_vmm_iter+0x351\/0xa20 [nouveau]\n ? __pfx_nvkm_vmm_ref_ptes+0x10\/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10\/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10\/0x10 [nouveau]\n ? __lock_acquire+0x3ed\/0x2170\n ? __pfx_gp100_vmm_pgt_mem+0x10\/0x10 [nouveau]\n nvkm_vmm_ptes_get_map+0xc2\/0x100 [nouveau]\n ? __pfx_nvkm_vmm_ref_ptes+0x10\/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10\/0x10 [nouveau]\n nvkm_vmm_map_locked+0x224\/0x3a0 [nouveau]\n\nAdding any sort of useful debug usually makes it go away, so I hand\nwrote the function in a line, and debugged the asm.\n\nEvery so often pt->memory->ptrs is NULL. This ptrs ptr is set in\nthe nv50_instobj_acquire called from nvkm_kmap.\n\nIf Thread A and Thread B both get to nv50_instobj_acquire around\nthe same time, and Thread A hits the refcount_set line, and in\nlockstep thread B succeeds at refcount_inc_not_zero, there is a\nchance the ptrs value won't have been stored since refcount_set\nis unordered. Force a memory barrier here, I picked smp_mb, since\nwe want it on all CPUs and it's write followed by a read.\n\nv2: use paired smp_rmb\/smp_wmb."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: nouveau: corrige la condición de ejecución de instmem alrededor de las tiendas ptr Al ejecutar una gran cantidad de VK CTS en paralelo contra nouveau, una vez cada pocas horas es posible que vea algo como este bloqueo. ERROR: desreferencia del puntero NULL del kernel, dirección: 0000000000000008 PGD 8000000114e6e067 P4D 8000000114e6e067 PUD 109046067 PMD 0 Ups: 0000 [#1] PREEMPT SMP PTI CPU: 7 PID: 53891 Comm: deqp-vk No contaminado 6.8.0-rc6+ #27 Nombre del hardware : Gigabyte Technology Co., Ltd. Z390 I AORUS PRO WIFI\/Z390 I AORUS PRO WIFI-CF, BIOS F8 05\/11\/2021 RIP: 0010:gp100_vmm_pgt_mem+0xe3\/0x180 [nuevo] Código: c7 48 01 c8 49 89 45 58 85 d2 0f 84 95 00 00 00 41 0f b7 46 12 49 8b 7e 08 89 da 42 8d 2c f8 48 8b 47 08 41 83 c7 01 48 89 ee &lt;48&gt; 8b 40 08 ff d0 0f 1f 0 0 49 8b 7e 08 48 89 d9 48 8d 75 04 48 c1 RSP: 0000:ffffac20c5857838 EFLAGS: 00010202 RAX: 0000000000000000 RBX: 00000000004d8001 RCX: 0000000000000001 RDX: 00000000004d8001 RSI: 00000000000006d8 RDI: ffffa07afe332180 RBP: 00000000000006d8 R08: ffffac20c5857ad0 R09: 0000000000ffff10 R10: 000000001 R11: ffffa07af27e2de0 R12: 000000000000001c R13: ffffac20c5857ad0 R14: ffffa07a96fe9040 R15: 000000000000001c FS: 00007fe395eed7c0(0000) GS:ffffa07e2c980000(0000) nlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000008 CR3: 000000011febe001 CR4: 00000000003706f0 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Rastreo de llamadas: ... ? gp100_vmm_pgt_mem+0xe3\/0x180 [nuevo]? gp100_vmm_pgt_mem+0x37\/0x180 [nuevo] nvkm_vmm_iter+0x351\/0xa20 [nuevo] ? __pfx_nvkm_vmm_ref_ptes+0x10\/0x10 [nuevo] ? __pfx_gp100_vmm_pgt_mem+0x10\/0x10 [nuevo] ? __pfx_gp100_vmm_pgt_mem+0x10\/0x10 [nuevo] ? __lock_acquire+0x3ed\/0x2170? __pfx_gp100_vmm_pgt_mem+0x10\/0x10 [nuevo] nvkm_vmm_ptes_get_map+0xc2\/0x100 [nuevo] ? __pfx_nvkm_vmm_ref_ptes+0x10\/0x10 [nuevo] ? __pfx_gp100_vmm_pgt_mem+0x10\/0x10 [nuevo] nvkm_vmm_map_locked+0x224\/0x3a0 [nuevo] Agregar cualquier tipo de depuración útil generalmente hace que desaparezca, así que escribí la función a mano en una línea y depuré el asm. De vez en cuando pt-&gt;memoria-&gt;ptrs es NULL. Este ptrs ptr se establece en nv50_instobj_acquire llamado desde nvkm_kmap. Si el subproceso A y el subproceso B llegan a nv50_instobj_acquire aproximadamente al mismo tiempo, y el subproceso A llega a la línea refcount_set, y en paralelo el subproceso B tiene éxito en refcount_inc_not_zero, existe la posibilidad de que el valor de ptrs no se haya almacenado ya que refcount_set no está ordenado. Forzar una barrera de memoria aquí, elegí smp_mb, ya que lo queremos en todas las CPU y es escritura seguida de lectura. v2: use smp_rmb\/smp_wmb emparejado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/21ca9539f09360fd83654f78f2c361f2f5ddcb52","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3ab056814cd8ab84744c9a19ef51360b2271c572","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a019b44b1bc6ed224c46fb5f88a8a10dd116e525","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad74d208f213c06d860916ad40f609ade8c13039","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fff1386cc889d8fb4089d285f883f8cba62d82ce","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26985","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:16.063","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/xe: Fix bo leak in intel_fb_bo_framebuffer_init\n\nAdd a unreference bo in the error path, to prevent leaking a bo ref.\n\nReturn 0 on success to clarify the success path.\n\n(cherry picked from commit a2f3d731be3893e730417ae3190760fcaffdf549)"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/xe: corrija la fuga de bo en intel_fb_bo_framebuffer_init. Agregue un bo sin referencia en la ruta del error, para evitar que se filtre una referencia de bo. Devuelve 0 en caso de éxito para aclarar la ruta del éxito. (cereza escogida del compromiso a2f3d731be3893e730417ae3190760fcaffdf549)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/652ead9b746a63e4e79d7ad66d3edf0a8a5b0c2f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7d8ac0942c312abda43b407eff72d31747a7b472","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26986","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:16.180","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdkfd: Fix memory leak in create_process failure\n\nFix memory leak due to a leaked mmget reference on an error handling\ncode path that is triggered when attempting to create KFD processes\nwhile a GPU reset is in progress."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amdkfd: corrige la pérdida de memoria en el error create_process. Corrige la pérdida de memoria debido a una referencia mmget filtrada en una ruta de código de manejo de errores que se activa al intentar crear procesos KFD mientras se reinicia la GPU. Está en proceso."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0dcd876411644da98a6b4d5a18d32ca94c15bdb5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/18921b205012568b45760753ad3146ddb9e2d4e2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aa02d43367a9adf8c85fb382fea4171fb266c8d0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26987","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:16.260","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmm\/memory-failure: fix deadlock when hugetlb_optimize_vmemmap is enabled\n\nWhen I did hard offline test with hugetlb pages, below deadlock occurs:\n\n======================================================\nWARNING: possible circular locking dependency detected\n6.8.0-11409-gf6cef5f8c37f #1 Not tainted\n------------------------------------------------------\nbash\/46904 is trying to acquire lock:\nffffffffabe68910 (cpu_hotplug_lock){++++}-{0:0}, at: static_key_slow_dec+0x16\/0x60\n\nbut task is already holding lock:\nffffffffabf92ea8 (pcp_batch_high_lock){+.+.}-{3:3}, at: zone_pcp_disable+0x16\/0x40\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 (pcp_batch_high_lock){+.+.}-{3:3}:\n       __mutex_lock+0x6c\/0x770\n       page_alloc_cpu_online+0x3c\/0x70\n       cpuhp_invoke_callback+0x397\/0x5f0\n       __cpuhp_invoke_callback_range+0x71\/0xe0\n       _cpu_up+0xeb\/0x210\n       cpu_up+0x91\/0xe0\n       cpuhp_bringup_mask+0x49\/0xb0\n       bringup_nonboot_cpus+0xb7\/0xe0\n       smp_init+0x25\/0xa0\n       kernel_init_freeable+0x15f\/0x3e0\n       kernel_init+0x15\/0x1b0\n       ret_from_fork+0x2f\/0x50\n       ret_from_fork_asm+0x1a\/0x30\n\n-> #0 (cpu_hotplug_lock){++++}-{0:0}:\n       __lock_acquire+0x1298\/0x1cd0\n       lock_acquire+0xc0\/0x2b0\n       cpus_read_lock+0x2a\/0xc0\n       static_key_slow_dec+0x16\/0x60\n       __hugetlb_vmemmap_restore_folio+0x1b9\/0x200\n       dissolve_free_huge_page+0x211\/0x260\n       __page_handle_poison+0x45\/0xc0\n       memory_failure+0x65e\/0xc70\n       hard_offline_page_store+0x55\/0xa0\n       kernfs_fop_write_iter+0x12c\/0x1d0\n       vfs_write+0x387\/0x550\n       ksys_write+0x64\/0xe0\n       do_syscall_64+0xca\/0x1e0\n       entry_SYSCALL_64_after_hwframe+0x6d\/0x75\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(pcp_batch_high_lock);\n                               lock(cpu_hotplug_lock);\n                               lock(pcp_batch_high_lock);\n  rlock(cpu_hotplug_lock);\n\n *** DEADLOCK ***\n\n5 locks held by bash\/46904:\n #0: ffff98f6c3bb23f0 (sb_writers#5){.+.+}-{0:0}, at: ksys_write+0x64\/0xe0\n #1: ffff98f6c328e488 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0xf8\/0x1d0\n #2: ffff98ef83b31890 (kn->active#113){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x100\/0x1d0\n #3: ffffffffabf9db48 (mf_mutex){+.+.}-{3:3}, at: memory_failure+0x44\/0xc70\n #4: ffffffffabf92ea8 (pcp_batch_high_lock){+.+.}-{3:3}, at: zone_pcp_disable+0x16\/0x40\n\nstack backtrace:\nCPU: 10 PID: 46904 Comm: bash Kdump: loaded Not tainted 6.8.0-11409-gf6cef5f8c37f #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04\/01\/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x68\/0xa0\n check_noncircular+0x129\/0x140\n __lock_acquire+0x1298\/0x1cd0\n lock_acquire+0xc0\/0x2b0\n cpus_read_lock+0x2a\/0xc0\n static_key_slow_dec+0x16\/0x60\n __hugetlb_vmemmap_restore_folio+0x1b9\/0x200\n dissolve_free_huge_page+0x211\/0x260\n __page_handle_poison+0x45\/0xc0\n memory_failure+0x65e\/0xc70\n hard_offline_page_store+0x55\/0xa0\n kernfs_fop_write_iter+0x12c\/0x1d0\n vfs_write+0x387\/0x550\n ksys_write+0x64\/0xe0\n do_syscall_64+0xca\/0x1e0\n entry_SYSCALL_64_after_hwframe+0x6d\/0x75\nRIP: 0033:0x7fc862314887\nCode: 10 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b7 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24\nRSP: 002b:00007fff19311268 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\nRAX: ffffffffffffffda RBX: 000000000000000c RCX: 00007fc862314887\nRDX: 000000000000000c RSI: 000056405645fe10 RDI: 0000000000000001\nRBP: 000056405645fe10 R08: 00007fc8623d1460 R09: 000000007fffffff\nR10: 0000000000000000 R11: 0000000000000246 R12: 000000000000000c\nR13: 00007fc86241b780 R14: 00007fc862417600 R15: 00007fc862416a00\n\nIn short, below scene breaks the \n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: mm\/memory-failure: corrige el interbloqueo cuando Hugetlb_optimize_vmemmap está habilitado Cuando hice una prueba dura sin conexión con páginas de Hugetlb, se produce el siguiente interbloqueo: ============ ========================================== ADVERTENCIA: posible dependencia de bloqueo circular detectada 6.8 .0-11409-gf6cef5f8c37f #1 No contaminado ---------------------------------------- -------------- bash\/46904 está intentando adquirir el bloqueo: ffffffffabe68910 (cpu_hotplug_lock){++++}-{0:0}, en: static_key_slow_dec+0x16\/0x60 pero la tarea está ya mantiene el bloqueo: ffffffffabf92ea8 (pcp_batch_high_lock){+.+.}-{3:3}, en: zone_pcp_disable+0x16\/0x40 cuyo bloqueo ya depende del nuevo bloqueo. la cadena de dependencia existente (en orden inverso) es: -&gt; #1 (pcp_batch_high_lock){+.+.}-{3:3}: __mutex_lock+0x6c\/0x770 page_alloc_cpu_online+0x3c\/0x70 cpuhp_invoke_callback+0x397\/0x5f0 __cpuhp_invoke_callback_range+0x71\/ 0xe0 _cpu_up+0xeb\/0x210 cpu_up+0x91\/0xe0 cpuhp_bringup_mask+0x49\/0xb0 Bringup_nonboot_cpus+0xb7\/0xe0 smp_init+0x25\/0xa0 kernel_init_freeable+0x15f\/0x3e0 kernel_init+0x15\/0x1b0 t_from_fork+0x2f\/0x50 ret_from_fork_asm+0x1a\/0x30 -&gt; #0 (cpu_hotplug_lock){++++}-{0:0}: __lock_acquire+0x1298\/0x1cd0 lock_acquire+0xc0\/0x2b0 cpus_read_lock+0x2a\/0xc0 static_key_slow_dec+0x16\/0x60 __hugetlb_vmemmap_restore_folio+0x1b9\/0x200 dissolve_free_huge _página+0x211\/0x260 __página_handle_poison+0x45\/ 0xc0 error_de_memoria+0x65e\/0xc70 hard_offline_page_store+0x55\/0xa0 kernfs_fop_write_iter+0x12c\/0x1d0 vfs_write+0x387\/0x550 ksys_write+0x64\/0xe0 do_syscall_64+0xca\/0x1e0 entrada_SYSCALL_6 4_after_hwframe+0x6d\/0x75 otra información que podría ayudarnos a depurar esto: Posible escenario de bloqueo inseguro: CPU0 CPU1 ---- ---- bloqueo(pcp_batch_high_lock); bloquear(cpu_hotplug_lock); bloquear(pcp_batch_high_lock); rlock(cpu_hotplug_lock); *** DEADLOCK *** 5 bloqueos retenidos por bash\/46904: #0: ffff98f6c3bb23f0 (sb_writers#5){.+.+}-{0:0}, en: ksys_write+0x64\/0xe0 #1: ffff98f6c328e488 (&amp;of -&gt;mutex){+.+.}-{3:3}, en: kernfs_fop_write_iter+0xf8\/0x1d0 #2: ffff98ef83b31890 (kn-&gt;active#113){.+.+}-{0:0}, en : kernfs_fop_write_iter+0x100\/0x1d0 #3: ffffffffabf9db48 (mf_mutex){+.+.}-{3:3}, en: Memory_failure+0x44\/0xc70 #4: ffffffffabf92ea8 (pcp_batch_high_lock){+.+.}-{3: 3}, en: zone_pcp_disable+0x16\/0x40 seguimiento de pila: CPU: 10 PID: 46904 Comm: bash Kdump: cargado No contaminado 6.8.0-11409-gf6cef5f8c37f #1 Nombre de hardware: PC estándar QEMU (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 01\/04\/2014 Seguimiento de llamadas:  dump_stack_lvl+0x68\/0xa0 check_noncircular+0x129\/0x140 __lock_acquire+0x1298\/0x1cd0 lock_acquire+0xc0\/0x2b0 cpus _read_lock+0x2a \/0xc0 static_key_slow_dec+0x16\/0x60 __hugetlb_vmemmap_restore_folio+0x1b9\/0x200 dissolve_free_huge_page+0x211\/0x260 __page_handle_poison+0x45\/0xc0 Memory_failure+0x65e\/0xc70 hard_offline_page_store+0x55\/0 xa0 kernfs_fop_write_iter+0x12c\/0x1d0 vfs_write+0x387\/0x550 ksys_write+0x64\/0xe0 do_syscall_64+0xca \/0x1e0 Entry_SYSCALL_64_after_hwframe+0x6d\/0x75 RIP: 0033:0x7fc862314887 Código: 10 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b7 0f 1f 00 f3 0f 1e fa 64 8b 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 &lt;48&gt; 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24 RSP: 002b:00007fff19311268 EFLAGS: 00000246 : 0000000000000001 RAX: ffffffffffffffda RBX: 000000000000000c RCX: 00007fc862314887 RDX: 000000000000000c RSI: 000056405645fe10 RDI: 0000000000000001 RBP: 000056405645fe10 R08: 00007fc8623d1460 R09: 000000007ffffff R10: 0000000000000000 R11: 0000000000000246 R12: 000000000000000c R13: 00007fc86241b780 R14: 00007fc862417600 R15: 00007fc862416a00 En resumen, La siguiente escena rompe el ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1983184c22dd84a4d95a71e5c6775c2638557dc7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/49955b24002dc16a0ae2e83a57a2a6c863a1845c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5ef7ba2799a3b5ed292b8f6407376e2c25ef002e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/882e1180c83f5b75bae03d0ccc31ccedfe5159de","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26988","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:16.420","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ninit\/main.c: Fix potential static_command_line memory overflow\n\nWe allocate memory of size 'xlen + strlen(boot_command_line) + 1' for\nstatic_command_line, but the strings copied into static_command_line are\nextra_command_line and command_line, rather than extra_command_line and\nboot_command_line.\n\nWhen strlen(command_line) > strlen(boot_command_line), static_command_line\nwill overflow.\n\nThis patch just recovers strlen(command_line) which was miss-consolidated\nwith strlen(boot_command_line) in the commit f5c7310ac73e (\"init\/main: add\nchecks for the return value of memblock_alloc*()\")"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: init\/main.c: soluciona un posible desbordamiento de memoria de static_command_line Asignamos memoria de tamaño 'xlen + strlen(boot_command_line) + 1' para static_command_line, pero las cadenas copiadas en static_command_line son extra_command_line y command_line, en lugar de extra_command_line y boot_command_line. Cuando strlen(command_line) &gt; strlen(boot_command_line), static_command_line se desbordará. Este parche simplemente recupera strlen(command_line) que no se consolidó con strlen(boot_command_line) en el commit f5c7310ac73e (\"init\/main: agregue comprobaciones para el valor de retorno de memblock_alloc*()\")"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0dc727a4e05400205358a22c3d01ccad2c8e1fe4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/46dad3c1e57897ab9228332f03e1c14798d2d3b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/76c2f4d426a5358fced5d5990744d46f10a4ccea","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/81cf85ae4f2dd5fa3e43021782aa72c4c85558e8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/936a02b5a9630c5beb0353c3085cc49d86c57034","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26989","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:16.577","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\narm64: hibernate: Fix level3 translation fault in swsusp_save()\n\nOn arm64 machines, swsusp_save() faults if it attempts to access\nMEMBLOCK_NOMAP memory ranges. This can be reproduced in QEMU using UEFI\nwhen booting with rodata=off debug_pagealloc=off and CONFIG_KFENCE=n:\n\n  Unable to handle kernel paging request at virtual address ffffff8000000000\n  Mem abort info:\n    ESR = 0x0000000096000007\n    EC = 0x25: DABT (current EL), IL = 32 bits\n    SET = 0, FnV = 0\n    EA = 0, S1PTW = 0\n    FSC = 0x07: level 3 translation fault\n  Data abort info:\n    ISV = 0, ISS = 0x00000007, ISS2 = 0x00000000\n    CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n    GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\n  swapper pgtable: 4k pages, 39-bit VAs, pgdp=00000000eeb0b000\n  [ffffff8000000000] pgd=180000217fff9803, p4d=180000217fff9803, pud=180000217fff9803, pmd=180000217fff8803, pte=0000000000000000\n  Internal error: Oops: 0000000096000007 [#1] SMP\n  Internal error: Oops: 0000000096000007 [#1] SMP\n  Modules linked in: xt_multiport ipt_REJECT nf_reject_ipv4 xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 libcrc32c iptable_filter bpfilter rfkill at803x snd_hda_codec_hdmi snd_hda_intel snd_intel_dspcfg dwmac_generic stmmac_platform snd_hda_codec stmmac joydev pcs_xpcs snd_hda_core phylink ppdev lp parport ramoops reed_solomon ip_tables x_tables nls_iso8859_1 vfat multipath linear amdgpu amdxcp drm_exec gpu_sched drm_buddy hid_generic usbhid hid radeon video drm_suballoc_helper drm_ttm_helper ttm i2c_algo_bit drm_display_helper cec drm_kms_helper drm\n  CPU: 0 PID: 3663 Comm: systemd-sleep Not tainted 6.6.2+ #76\n  Source Version: 4e22ed63a0a48e7a7cff9b98b7806d8d4add7dc0\n  Hardware name: Greatwall GW-XXXXXX-XXX\/GW-XXXXXX-XXX, BIOS KunLun BIOS V4.0 01\/19\/2021\n  pstate: 600003c5 (nZCv DAIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n  pc : swsusp_save+0x280\/0x538\n  lr : swsusp_save+0x280\/0x538\n  sp : ffffffa034a3fa40\n  x29: ffffffa034a3fa40 x28: ffffff8000001000 x27: 0000000000000000\n  x26: ffffff8001400000 x25: ffffffc08113e248 x24: 0000000000000000\n  x23: 0000000000080000 x22: ffffffc08113e280 x21: 00000000000c69f2\n  x20: ffffff8000000000 x19: ffffffc081ae2500 x18: 0000000000000000\n  x17: 6666662074736420 x16: 3030303030303030 x15: 3038666666666666\n  x14: 0000000000000b69 x13: ffffff9f89088530 x12: 00000000ffffffea\n  x11: 00000000ffff7fff x10: 00000000ffff7fff x9 : ffffffc08193f0d0\n  x8 : 00000000000bffe8 x7 : c0000000ffff7fff x6 : 0000000000000001\n  x5 : ffffffa0fff09dc8 x4 : 0000000000000000 x3 : 0000000000000027\n  x2 : 0000000000000000 x1 : 0000000000000000 x0 : 000000000000004e\n  Call trace:\n   swsusp_save+0x280\/0x538\n   swsusp_arch_suspend+0x148\/0x190\n   hibernation_snapshot+0x240\/0x39c\n   hibernate+0xc4\/0x378\n   state_store+0xf0\/0x10c\n   kobj_attr_store+0x14\/0x24\n\nThe reason is swsusp_save() -> copy_data_pages() -> page_is_saveable()\n-> kernel_page_present() assuming that a page is always present when\ncan_set_direct_map() is false (all of rodata_full,\ndebug_pagealloc_enabled() and arm64_kfence_can_set_direct_map() false),\nirrespective of the MEMBLOCK_NOMAP ranges. Such MEMBLOCK_NOMAP regions\nshould not be saved during hibernation.\n\nThis problem was introduced by changes to the pfn_valid() logic in\ncommit a7d9f306ba70 (\"arm64: drop pfn_valid_within() and simplify\npfn_valid()\").\n\nSimilar to other architectures, drop the !can_set_direct_map() check in\nkernel_page_present() so that page_is_savable() skips such pages.\n\n[catalin.marinas@arm.com: rework commit message]"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: arm64: hibernación: corrige el error de traducción de nivel 3 en swsusp_save() En máquinas arm64, swsusp_save() falla si intenta acceder a los rangos de memoria MEMBLOCK_NOMAP. Esto se puede reproducir en QEMU usando UEFI al arrancar con rodata=off debug_pagealloc=off y CONFIG_KFENCE=n: No se puede manejar la solicitud de paginación del kernel en la dirección virtual ffffff8000000000 Información de cancelación de memoria: ESR = 0x0000000096000007 EC = 0x25: DABT (EL actual), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x07: fallo de traducción de nivel 3 Información de cancelación de datos: ISV = 0, ISS = 0x00000007, ISS2 = 0x00000000 CM = 0, WnR = 0, TnD = 0, TagAccess = 0 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 pgtable de intercambio: páginas de 4k, VA de 39 bits, pgdp=00000000eeb0b000 [ffffff8000000000] pgd=180000217fff9803, p4d=180000217fff 9803, pud=180000217fff9803, pmd =180000217fff8803, pte=0000000000000000 Error interno: Ups: 0000000096000007 [#1] Error interno de SMP: Ups: 0000000096000007 [#1] Módulos SMP vinculados en: xt_multiport ipt_REJECT nf_reject_ipv4 x t_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 libcrc32c iptable_filter bpfilter rfkill at803x snd_hda_codec_hdmi snd_hda_intel snd_intel_dspcfg dwmac_generic stmmac_platform snd_hda_codec stmmac joydev pcs_xpcs snd_hda_core phylink ppdev lp parport ramoops reed_solomon ip_tables x_tables nls_iso8859_1 vfat multipath lineal amdgpu amdxcp drm_exec gpu_sched drm_buddy hid_generic usbhid hid radeon video drm_suballoc_helper drm_ttm_helper ttm algo_bit drm_display_helper cec drm_kms_helper drm CPU: 0 PID: 3663 Comm: systemd-sleep No contaminado 6.6.2 + #76 Versión de origen: 4e22ed63a0a48e7a7cff9b98b7806d8d4add7dc0 Nombre del hardware: Greatwall GW-XXXXXX-XXX\/GW-XXXXXX-XXX, BIOS KunLun BIOS V4.0 19\/01\/2021 pstate: 600003c5 (nZCv DAIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc: swsusp_save+0x280\/0x538 lr: swsusp_save+0x280\/0x538 sp: ffffffa034a3fa40 x29: ffffffa034a3fa40 x28: ffffff8000001000 x27: 0000000000000000 x26: ffff8001400000 x25: ffffffc08113e248 x24: 0000000000000000 x23: 0000000000080000 x22: ffffffc08113e280 x21: 00000000000c69f2 x20 : ffffff8000000000 x19: ffffffc081ae2500 x18: 0000000000000000 x17: 6666662074736420 x16: 3030303030303030 x15: 3038666666666666 x14: 00000000000b69 x13: ffffff9f89088530 x12: 00000000ffffffea x11: 00000000ffff7fff x10: 00000000ffff7fff x9: fffffc08193f0d0 x8: 00000000000bffe8 x7: c 0000000ffff7fff x6: 0000000000000001 x5: fffffa0fff09dc8 x4: 0000000000000000 x3: 0000000000000027 x2: 0000000000000000 x1: 0000000000000000 x0: 000000000000004e Rastreo de llamadas: swsusp_save+0x280\/0x538 swsusp_arch_suspend+0x148\/0x190 bernation_snapshot+0x240\/0x39c hibernate+0xc4\/0x378 state_store+0xf0\/0x10c kobj_attr_store+0x14\/0x24 El motivo es swsusp_save( ) -&gt; copy_data_pages() -&gt; page_is_saveable() -&gt; kernel_page_present() suponiendo que una página siempre está presente cuando can_set_direct_map() es falsa (todos rodata_full, debug_pagealloc_enabled() y arm64_kfence_can_set_direct_map() son falsos), independientemente de los rangos de MEMBLOCK_NOMAP. Estas regiones MEMBLOCK_NOMAP no deben guardarse durante la hibernación. Este problema se introdujo por cambios en la lógica pfn_valid() en el commit a7d9f306ba70 (\"arm64: drop pfn_valid_within() and simplifica pfn_valid()\"). Al igual que en otras arquitecturas, elimine la verificación !can_set_direct_map() en kernel_page_present() para que page_is_savable() omita dichas páginas. [catalin.marinas@arm.com: mensaje de confirmación de reelaboración]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/022b19ebc31cce369c407617041a3db810db23b3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/31f815cb436082e72d34ed2e8a182140a73ebdf4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/50449ca66cc5a8cbc64749cf4b9f3d3fc5f4b457","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/813f5213f2c612dc800054859aaa396ec8ad7069","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f7e71a7cf399f53ff9fc314ca3836dc913b05bd6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26990","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:16.673","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86\/mmu: Write-protect L2 SPTEs in TDP MMU when clearing dirty status\n\nCheck kvm_mmu_page_ad_need_write_protect() when deciding whether to\nwrite-protect or clear D-bits on TDP MMU SPTEs, so that the TDP MMU\naccounts for any role-specific reasons for disabling D-bit dirty logging.\n\nSpecifically, TDP MMU SPTEs must be write-protected when the TDP MMU is\nbeing used to run an L2 (i.e. L1 has disabled EPT) and PML is enabled.\nKVM always disables PML when running L2, even when L1 and L2 GPAs are in\nthe some domain, so failing to write-protect TDP MMU SPTEs will cause\nwrites made by L2 to not be reflected in the dirty log.\n\n[sean: massage shortlog and changelog, tweak ternary op formatting]"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: x86\/mmu: Proteger contra escritura los SPTE L2 en la MMU TDP al borrar el estado sucio. Verifique kvm_mmu_page_ad_need_write_protect() cuando decida si desea proteger contra escritura o borrar los bits D en los SPTE de la MMU TDP. , de modo que la MMU TDP tenga en cuenta cualquier motivo específico de la función para deshabilitar el registro sucio de bits D. Específicamente, los SPTE de TDP MMU deben estar protegidos contra escritura cuando la TDP MMU se utiliza para ejecutar un L2 (es decir, L1 tiene EPT deshabilitado) y PML está habilitado. KVM siempre desactiva PML cuando se ejecuta L2, incluso cuando los GPA L1 y L2 están en algún dominio, por lo que si no se protegen contra escritura los SPTE TDP MMU, las escrituras realizadas por L2 no se reflejarán en el registro sucio. [sean: masajear el registro corto y el registro de cambios, modificar el formato de operación ternario]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2673dfb591a359c75080dd5af3da484b89320d22","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cdf811a937471af2d1facdf8ae80e5e68096f1ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e20bff0f1b2de9cfe303dd35ff46470104a87404","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26991","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:16.820","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86\/mmu: x86: Don't overflow lpage_info when checking attributes\n\nFix KVM_SET_MEMORY_ATTRIBUTES to not overflow lpage_info array and trigger\nKASAN splat, as seen in the private_mem_conversions_test selftest.\n\nWhen memory attributes are set on a GFN range, that range will have\nspecific properties applied to the TDP. A huge page cannot be used when\nthe attributes are inconsistent, so they are disabled for those the\nspecific huge pages. For internal KVM reasons, huge pages are also not\nallowed to span adjacent memslots regardless of whether the backing memory\ncould be mapped as huge.\n\nWhat GFNs support which huge page sizes is tracked by an array of arrays\n'lpage_info' on the memslot, of ‘kvm_lpage_info’ structs. Each index of\nlpage_info contains a vmalloc allocated array of these for a specific\nsupported page size. The kvm_lpage_info denotes whether a specific huge\npage (GFN and page size) on the memslot is supported. These arrays include\nindices for unaligned head and tail huge pages.\n\nPreventing huge pages from spanning adjacent memslot is covered by\nincrementing the count in head and tail kvm_lpage_info when the memslot is\nallocated, but disallowing huge pages for memory that has mixed attributes\nhas to be done in a more complicated way. During the\nKVM_SET_MEMORY_ATTRIBUTES ioctl KVM updates lpage_info for each memslot in\nthe range that has mismatched attributes. KVM does this a memslot at a\ntime, and marks a special bit, KVM_LPAGE_MIXED_FLAG, in the kvm_lpage_info\nfor any huge page. This bit is essentially a permanently elevated count.\nSo huge pages will not be mapped for the GFN at that page size if the\ncount is elevated in either case: a huge head or tail page unaligned to\nthe memslot or if KVM_LPAGE_MIXED_FLAG is set because it has mixed\nattributes.\n\nTo determine whether a huge page has consistent attributes, the\nKVM_SET_MEMORY_ATTRIBUTES operation checks an xarray to make sure it\nconsistently has the incoming attribute. Since level - 1 huge pages are\naligned to level huge pages, it employs an optimization. As long as the\nlevel - 1 huge pages are checked first, it can just check these and assume\nthat if each level - 1 huge page contained within the level sized huge\npage is not mixed, then the level size huge page is not mixed. This\noptimization happens in the helper hugepage_has_attrs().\n\nUnfortunately, although the kvm_lpage_info array representing page size\n'level' will contain an entry for an unaligned tail page of size level,\nthe array for level - 1  will not contain an entry for each GFN at page\nsize level. The level - 1 array will only contain an index for any\nunaligned region covered by level - 1 huge page size, which can be a\nsmaller region. So this causes the optimization to overflow the level - 1\nkvm_lpage_info and perform a vmalloc out of bounds read.\n\nIn some cases of head and tail pages where an overflow could happen,\ncallers skip the operation completely as KVM_LPAGE_MIXED_FLAG is not\nrequired to prevent huge pages as discussed earlier. But for memslots that\nare smaller than the 1GB page size, it does call hugepage_has_attrs(). In\nthis case the huge page is both the head and tail page. The issue can be\nobserved simply by compiling the kernel with CONFIG_KASAN_VMALLOC and\nrunning the selftest “private_mem_conversions_test”, which produces the\noutput like the following:\n\nBUG: KASAN: vmalloc-out-of-bounds in hugepage_has_attrs+0x7e\/0x110\nRead of size 4 at addr ffffc900000a3008 by task private_mem_con\/169\nCall Trace:\n  dump_stack_lvl\n  print_report\n  ? __virt_addr_valid\n  ? hugepage_has_attrs\n  ? hugepage_has_attrs\n  kasan_report\n  ? hugepage_has_attrs\n  hugepage_has_attrs\n  kvm_arch_post_set_memory_attributes\n  kvm_vm_ioctl\n\nIt is a little ambiguous whether the unaligned head page (in the bug case\nalso the tail page) should be expected to have KVM_LPAGE_MIXED_FLAG set.\nIt is not functionally required, as the unal\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: KVM: x86\/mmu: x86: no desborde lpage_info al verificar los atributos. Corrija KVM_SET_MEMORY_ATTRIBUTES para no desbordar la matriz lpage_info y activar KASAN splat, como se ve en la autoprueba private_mem_conversions_test. Cuando los atributos de memoria se configuran en un rango GFN, ese rango tendrá propiedades específicas aplicadas al TDP. No se puede utilizar una página enorme cuando los atributos son inconsistentes, por lo que están deshabilitados para aquellas páginas enormes específicas. Por razones internas de KVM, tampoco se permite que páginas grandes abarquen ranuras de memoria adyacentes, independientemente de si la memoria de respaldo podría asignarse como enorme. Qué GFN admite qué tamaños de página enormes se rastrea mediante una serie de matrices 'lpage_info' en el memslot, de estructuras 'kvm_lpage_info'. Cada índice de lpage_info contiene una matriz asignada por vmalloc para un tamaño de página compatible específico. kvm_lpage_info indica si se admite una página enorme específica (GFN y tamaño de página) en la ranura de memoria. Estas matrices incluyen índices para páginas grandes de cabecera y cola no alineadas. Para evitar que páginas grandes abarquen ranuras de memoria adyacentes, se incrementa el recuento en head y tail kvm_lpage_info cuando se asigna la ranura de memoria, pero no permitir páginas grandes para memoria que tenga atributos mixtos debe hacerse de una manera más complicada. Durante KVM_SET_MEMORY_ATTRIBUTES ioctl, KVM actualiza lpage_info para cada ranura de memoria en el rango que tiene atributos que no coinciden. KVM hace esto una ranura de memoria a la vez y marca un bit especial, KVM_LPAGE_MIXED_FLAG, en kvm_lpage_info para cualquier página grande. Este bit es esencialmente un recuento elevado permanentemente. Por lo tanto, las páginas grandes no se asignarán para GFN en ese tamaño de página si el recuento es elevado en cualquier caso: una página principal o final enorme no alineada con la ranura de memoria o si KVM_LPAGE_MIXED_FLAG está configurado porque tiene atributos mixtos. Para determinar si una página enorme tiene atributos consistentes, la operación KVM_SET_MEMORY_ATTRIBUTES verifica una matriz x para asegurarse de que tenga consistentemente el atributo entrante. Dado que las páginas grandes de nivel 1 están alineadas con las páginas grandes de nivel, se emplea una optimización. Siempre que se verifiquen primero las páginas grandes de nivel - 1, puede simplemente verificarlas y asumir que si cada página enorme de nivel - 1 contenida dentro de la página enorme de tamaño de nivel no está mezclada, entonces la página enorme de tamaño de nivel no está mezclada. Esta optimización ocurre en el ayudante Hugepage_has_attrs(). Desafortunadamente, aunque la matriz kvm_lpage_info que representa el tamaño de página 'nivel' contendrá una entrada para una página final no alineada de nivel de tamaño, la matriz para el nivel - 1 no contendrá una entrada para cada GFN en el nivel de tamaño de página. La matriz de nivel 1 solo contendrá un índice para cualquier región no alineada cubierta por el tamaño de página enorme de nivel 1, que puede ser una región más pequeña. Entonces, esto hace que la optimización desborde el nivel - 1 kvm_lpage_info y realice una lectura vmalloc fuera de los límites. En algunos casos de páginas principales y finales donde podría ocurrir un desbordamiento, las personas que llaman omiten la operación por completo ya que KVM_LPAGE_MIXED_FLAG no es necesario para evitar páginas grandes como se analizó anteriormente. Pero para las ranuras de memoria que son más pequeñas que el tamaño de página de 1 GB, llama a hugepage_has_attrs(). En este caso, la página enorme es tanto la página principal como la final. --truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/048cc4a028e635d339687ed968985d2d1669494c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/992b54bd083c5bee24ff7cc35991388ab08598c4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26992","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:16.957","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86\/pmu: Disable support for adaptive PEBS\n\nDrop support for virtualizing adaptive PEBS, as KVM's implementation is\narchitecturally broken without an obvious\/easy path forward, and because\nexposing adaptive PEBS can leak host LBRs to the guest, i.e. can leak\nhost kernel addresses to the guest.\n\nBug #1 is that KVM doesn't account for the upper 32 bits of\nIA32_FIXED_CTR_CTRL when (re)programming fixed counters, e.g\nfixed_ctrl_field() drops the upper bits, reprogram_fixed_counters()\nstores local variables as u8s and truncates the upper bits too, etc.\n\nBug #2 is that, because KVM _always_ sets precise_ip to a non-zero value\nfor PEBS events, perf will _always_ generate an adaptive record, even if\nthe guest requested a basic record.  Note, KVM will also enable adaptive\nPEBS in individual *counter*, even if adaptive PEBS isn't exposed to the\nguest, but this is benign as MSR_PEBS_DATA_CFG is guaranteed to be zero,\ni.e. the guest will only ever see Basic records.\n\nBug #3 is in perf.  intel_pmu_disable_fixed() doesn't clear the upper\nbits either, i.e. leaves ICL_FIXED_0_ADAPTIVE set, and\nintel_pmu_enable_fixed() effectively doesn't clear ICL_FIXED_0_ADAPTIVE\neither.  I.e. perf _always_ enables ADAPTIVE counters, regardless of what\nKVM requests.\n\nBug #4 is that adaptive PEBS *might* effectively bypass event filters set\nby the host, as \"Updated Memory Access Info Group\" records information\nthat might be disallowed by userspace via KVM_SET_PMU_EVENT_FILTER.\n\nBug #5 is that KVM doesn't ensure LBR MSRs hold guest values (or at least\nzeros) when entering a vCPU with adaptive PEBS, which allows the guest\nto read host LBRs, i.e. host RIPs\/addresses, by enabling \"LBR Entries\"\nrecords.\n\nDisable adaptive PEBS support as an immediate fix due to the severity of\nthe LBR leak in particular, and because fixing all of the bugs will be\nnon-trivial, e.g. not suitable for backporting to stable kernels.\n\nNote!  This will break live migration, but trying to make KVM play nice\nwith live migration would be quite complicated, wouldn't be guaranteed to\nwork (i.e. KVM might still kill\/confuse the guest), and it's not clear\nthat there are any publicly available VMMs that support adaptive PEBS,\nlet alone live migrate VMs that support adaptive PEBS, e.g. QEMU doesn't\nsupport PEBS in any capacity."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: x86\/pmu: deshabilitar el soporte para PEBS adaptativos. Eliminar el soporte para virtualizar PEBS adaptativos, ya que la implementación de KVM tiene una arquitectura rota sin un camino obvio\/fácil a seguir, y porque exponer PEBS adaptativos puede filtrar los LBR del host al huésped, es decir, puede filtrar las direcciones del kernel del host al huésped. El error número 1 es que KVM no tiene en cuenta los 32 bits superiores de IA32_FIXED_CTR_CTRL cuando (re)programa contadores fijos, por ejemplo, fix_ctrl_field() elimina los bits superiores, reprogram_fixed_counters() almacena variables locales como u8 y también trunca los bits superiores, etc. El error número 2 es que, debido a que KVM _siempre_ establece precision_ip en un valor distinto de cero para eventos PEBS, perf _siempre_ generará un registro adaptativo, incluso si el invitado solicitó un registro básico. Tenga en cuenta que KVM también habilitará PEBS adaptativo en *contador* individual, incluso si PEBS adaptativo no está expuesto al invitado, pero esto es benigno ya que se garantiza que MSR_PEBS_DATA_CFG será cero, es decir, el invitado solo verá registros básicos. El error número 3 está en rendimiento. intel_pmu_disable_fixed() tampoco borra los bits superiores, es decir, deja ICL_FIXED_0_ADAPTIVE configurado, e intel_pmu_enable_fixed() efectivamente tampoco borra ICL_FIXED_0_ADAPTIVE. Es decir, perf _siempre_ habilita contadores ADAPTIVOS, independientemente de lo que solicite KVM. El error número 4 es que los PEBS adaptables *podrían* omitir efectivamente los filtros de eventos establecidos por el host, ya que el \"Grupo de información de acceso a memoria actualizado\" registra información que podría no estar permitida por el espacio de usuario a través de KVM_SET_PMU_EVENT_FILTER. El error número 5 es que KVM no garantiza que los MSR LBR mantengan valores de invitado (o al menos ceros) al ingresar a una vCPU con PEBS adaptable, lo que permite al invitado leer los LBR del host, es decir, los RIP\/direcciones del host, al habilitar las \"Entradas LBR\". registros. Deshabilite el soporte PEBS adaptable como solución inmediata debido a la gravedad de la fuga de LBR en particular, y porque corregir todos los errores no será trivial, por ejemplo, no es adecuado para realizar backporting a núcleos estables. ¡Nota! Esto interrumpirá la migración en vivo, pero tratar de hacer que KVM funcione bien con la migración en vivo sería bastante complicado, no se garantizaría que funcione (es decir, KVM aún podría matar\/confundir al invitado) y no está claro si hay alguno disponible públicamente. Los VMM que admiten PEBS adaptables, y mucho menos migran en vivo las máquinas virtuales que admiten PEBS adaptables; por ejemplo, QEMU no admite PEBS de ninguna manera."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/037e48ceccf163899374b601afb6ae8d0bf1d2ac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0fb74c00d140a66128afc0003785dcc57e69d312","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7a7650b3ac23e5fc8c990f00e94f787dc84e3175","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9e985cbf2942a1bb8fcef9adc2a17d90fd7ca8ee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26993","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:17.110","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nfs: sysfs: Fix reference leak in sysfs_break_active_protection()\n\nThe sysfs_break_active_protection() routine has an obvious reference\nleak in its error path.  If the call to kernfs_find_and_get() fails then\nkn will be NULL, so the companion sysfs_unbreak_active_protection()\nroutine won't get called (and would only cause an access violation by\ntrying to dereference kn->parent if it was called).  As a result, the\nreference to kobj acquired at the start of the function will never be\nreleased.\n\nFix the leak by adding an explicit kobject_put() call when kn is NULL."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: fs: sysfs: corrige la fuga de referencia en sysfs_break_active_protection() La rutina sysfs_break_active_protection() tiene una fuga de referencia obvia en su ruta de error. Si la llamada a kernfs_find_and_get() falla, entonces kn será NULL, por lo que no se llamará a la rutina complementaria sysfs_unbreak_active_protection() (y solo causaría una infracción de acceso al intentar eliminar la referencia a kn-&gt;parent si se llamara). Como resultado, la referencia a kobj adquirida al inicio de la función nunca se publicará. Solucione la fuga agregando una llamada explícita a kobject_put() cuando kn sea NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/43f00210cb257bcb0387e8caeb4b46375d67f30c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5d43e072285e81b0b63cee7189b3357c7768a43b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a4c99b57d43bab45225ba92d574a8683f9edc8e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a90bca2228c0646fc29a72689d308e5fe03e6d78","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ac107356aabc362aaeb77463e814fc067a5d3957","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26994","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:17.207","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nspeakup: Avoid crash on very long word\n\nIn case a console is set up really large and contains a really long word\n(> 256 characters), we have to stop before the length of the word buffer."},{"lang":"es","value":"En el kernel de Linux se ha solucionado la siguiente vulnerabilidad: Speakup: Evitar crash en palabras muy largas En caso de que una consola esté configurada muy grande y contenga una palabra muy larga (&gt;256 caracteres), tenemos que detenernos antes de la longitud de la palabra. búfer de palabras."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0d130158db29f5e0b3893154908cf618896450a8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0efb15c14c493263cb3a5f65f5ddfd4603d19a76","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/89af25bd4b4bf6a71295f07e07a8ae7dc03c6595","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8defb1d22ba0395b81feb963b96e252b097ba76f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c8d2f34ea96ea3bce6ba2535f867f0d4ee3b22e1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26995","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:17.313","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: tcpm: Correct the PDO counting in pd_set\n\nOff-by-one errors happen because nr_snk_pdo and nr_src_pdo are\nincorrectly added one. The index of the loop is equal to the number of\nPDOs to be updated when leaving the loop and it doesn't need to be added\none.\n\nWhen doing the power negotiation, TCPM relies on the \"nr_snk_pdo\" as\nthe size of the local sink PDO array to match the Source capabilities\nof the partner port. If the off-by-one overflow occurs, a wrong RDO\nmight be sent and unexpected power transfer might happen such as over\nvoltage or over current (than expected).\n\n\"nr_src_pdo\" is used to set the Rp level when the port is in Source\nrole. It is also the array size of the local Source capabilities when\nfilling up the buffer which will be sent as the Source PDOs (such as\nin Power Negotiation). If the off-by-one overflow occurs, a wrong Rp\nlevel might be set and wrong Source PDOs will be sent to the partner\nport. This could potentially cause over current or port resets."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: typec: tcpm: corrija el recuento de PDO en pd_set Los errores off-by-one ocurren porque nr_snk_pdo y nr_src_pdo se agregaron incorrectamente. El índice del bucle es igual al número de PDO que se actualizarán al salir del bucle y no es necesario agregar uno. Al realizar la negociación de energía, TCPM se basa en \"nr_snk_pdo\" como el tamaño de la matriz de PDO del receptor local para que coincida con las capacidades de origen del puerto asociado. Si se produce un desbordamiento de uno a uno, es posible que se envíe un RDO incorrecto y que se produzca una transferencia de energía inesperada, como sobretensión o sobrecorriente (de lo esperado). \"nr_src_pdo\" se utiliza para establecer el nivel de Rp cuando el puerto está en la función de origen. También es el tamaño de la matriz de las capacidades de la Fuente local al llenar el búfer que se enviará como los PDO de la Fuente (como en la Negociación de Energía). Si se produce el desbordamiento de uno por uno, es posible que se establezca un nivel de Rp incorrecto y se enviarán PDO de origen incorrectos al puerto asociado. Esto podría causar sobrecorriente o restablecimientos de puertos."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/c4128304c2169b4664ed6fb6200f228cead2ab70","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f3da3192cdd3fefe213390e976eec424a8e270b5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26996","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:17.480","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: f_ncm: Fix UAF ncm object at re-bind after usb ep transport error\n\nWhen ncm function is working and then stop usb0 interface for link down,\neth_stop() is called. At this piont, accidentally if usb transport error\nshould happen in usb_ep_enable(), 'in_ep' and\/or 'out_ep' may not be enabled.\n\nAfter that, ncm_disable() is called to disable for ncm unbind\nbut gether_disconnect() is never called since 'in_ep' is not enabled.\n\nAs the result, ncm object is released in ncm unbind\nbut 'dev->port_usb' associated to 'ncm->port' is not NULL.\n\nAnd when ncm bind again to recover netdev, ncm object is reallocated\nbut usb0 interface is already associated to previous released ncm object.\n\nTherefore, once usb0 interface is up and eth_start_xmit() is called,\nreleased ncm object is dereferrenced and it might cause use-after-free memory.\n\n[function unlink via configfs]\n  usb0: eth_stop dev->port_usb=ffffff9b179c3200\n  --> error happens in usb_ep_enable().\n  NCM: ncm_disable: ncm=ffffff9b179c3200\n  --> no gether_disconnect() since ncm->port.in_ep->enabled is false.\n  NCM: ncm_unbind: ncm unbind ncm=ffffff9b179c3200\n  NCM: ncm_free: ncm free ncm=ffffff9b179c3200   <-- released ncm\n\n[function link via configfs]\n  NCM: ncm_alloc: ncm alloc ncm=ffffff9ac4f8a000\n  NCM: ncm_bind: ncm bind ncm=ffffff9ac4f8a000\n  NCM: ncm_set_alt: ncm=ffffff9ac4f8a000 alt=0\n  usb0: eth_open dev->port_usb=ffffff9b179c3200  <-- previous released ncm\n  usb0: eth_start dev->port_usb=ffffff9b179c3200 <--\n  eth_start_xmit()\n  --> dev->wrap()\n  Unable to handle kernel paging request at virtual address dead00000000014f\n\nThis patch addresses the issue by checking if 'ncm->netdev' is not NULL at\nncm_disable() to call gether_disconnect() to deassociate 'dev->port_usb'.\nIt's more reasonable to check 'ncm->netdev' to call gether_connect\/disconnect\nrather than check 'ncm->port.in_ep->enabled' since it might not be enabled\nbut the gether connection might be established."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: gadget: f_ncm: corrige el objeto UAF ncm al volver a vincularlo después del error de transporte usb ep Cuando la función ncm está funcionando y luego detiene la interfaz usb0 para desconectar el enlace, se llama a eth_stop() . En este punto, accidentalmente, si ocurre un error de transporte USB en usb_ep_enable(), es posible que 'in_ep' y\/o 'out_ep' no estén habilitados. Después de eso, se llama a ncm_disable() para deshabilitar ncm unbind, pero nunca se llama a gether_disconnect() ya que 'in_ep' no está habilitado. Como resultado, el objeto ncm se libera en ncm unbind pero 'dev-&gt;port_usb' asociado a 'ncm-&gt;port' no es NULL. Y cuando ncm se vincula nuevamente para recuperar netdev, el objeto ncm se reasigna pero la interfaz usb0 ya está asociada al objeto ncm lanzado anteriormente. Por lo tanto, una vez que la interfaz usb0 está activa y se llama a eth_start_xmit(), el objeto ncm liberado se desreferencia y podría causar memoria de use-after-free. [función de desvinculación a través de configfs] usb0: eth_stop dev-&gt;port_usb=ffffff9b179c3200 --&gt; el error ocurre en usb_ep_enable(). NCM: ncm_disable: ncm=ffffff9b179c3200 --&gt; no gether_disconnect() ya que ncm-&gt;port.in_ep-&gt;enabled es falso. NCM: ncm_unbind: ncm unbind ncm=ffffff9b179c3200 NCM: ncm_free: ncm free ncm=ffffff9b179c3200 &lt;-- ncm liberado [enlace de función a través de configfs] NCM: ncm_alloc: ncm alloc ncm=ffffff9ac4f8a000 NCM: ncm_bind: cm enlazar ncm=ffffff9ac4f8a000 NCM: ncm_set_alt : ncm=ffffff9ac4f8a000 alt=0 usb0: eth_open dev-&gt;port_usb=ffffff9b179c3200 &lt;-- ncm usb0 lanzado anteriormente: eth_start dev-&gt;port_usb=ffffff9b179c3200 &lt;-- eth_start_xmit() --&gt; dev-&gt;wrap() No se puede manejar el kernel solicitud de paginación en la dirección virtual dead00000000014f Este parche soluciona el problema verificando si 'ncm-&gt;netdev' no es NULL en ncm_disable() para llamar a gether_disconnect() para desasociar 'dev-&gt;port_usb'. Es más razonable marcar 'ncm-&gt;netdev' para llamar a gether_connect\/disconnect en lugar de marcar 'ncm-&gt;port.in_ep-&gt;enabled' ya que es posible que no esté habilitado pero que se pueda establecer la conexión conjunta."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0588bbbd718a8130b98c54518f1e0b569ce60a93","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6334b8e4553cc69f51e383c9de545082213d785e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7250326cbb1f4f90391ac511a126b936cefb5bb7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7f67c2020cb08499c400abf0fc32c65e4d9a09ca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f356fd0cbd9c9cbd0854657a80d1608d0d732db3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26997","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:17.637","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc2: host: Fix dereference issue in DDMA completion flow.\n\nFixed variable dereference issue in DDMA completion flow."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: usb: dwc2: host: solucionó el problema de desreferencia en el flujo de finalización de DDMA. Se solucionó el problema de desreferencia variable en el flujo de finalización de DDMA."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/55656b2afd5f1efcec4245f3e7e814c2a9ef53f6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a139fa44870e84ac228b7b76423a49610e5ba9a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8aa5c28ac65cb5e7f1b9c0c3238c00b661dd2b8c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9de10b59d16880a0a3ae2876c142fe54ce45d816","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eed04fa96c48790c1cce73c8a248e9d460b088f8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26998","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:17.780","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nserial: core: Clearing the circular buffer before NULLifying it\n\nThe circular buffer is NULLified in uart_tty_port_shutdown()\nunder the spin lock. However, the PM or other timer based callbacks\nmay still trigger after this event without knowning that buffer pointer\nis not valid. Since the serial code is a bit inconsistent in checking\nthe buffer state (some rely on the head-tail positions, some on the\nbuffer pointer), it's better to have both aligned, i.e. buffer pointer\nto be NULL and head-tail possitions to be the same, meaning it's empty.\nThis will prevent asynchronous calls to dereference NULL pointer as\nreported recently in 8250 case:\n\n  BUG: kernel NULL pointer dereference, address: 00000cf5\n  Workqueue: pm pm_runtime_work\n  EIP: serial8250_tx_chars (drivers\/tty\/serial\/8250\/8250_port.c:1809)\n  ...\n  ? serial8250_tx_chars (drivers\/tty\/serial\/8250\/8250_port.c:1809)\n  __start_tx (drivers\/tty\/serial\/8250\/8250_port.c:1551)\n  serial8250_start_tx (drivers\/tty\/serial\/8250\/8250_port.c:1654)\n  serial_port_runtime_suspend (include\/linux\/serial_core.h:667 drivers\/tty\/serial\/serial_port.c:63)\n  __rpm_callback (drivers\/base\/power\/runtime.c:393)\n  ? serial_port_remove (drivers\/tty\/serial\/serial_port.c:50)\n  rpm_suspend (drivers\/base\/power\/runtime.c:447)\n\nThe proposed change will prevent ->start_tx() to be called during\nsuspend on shut down port."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: serial: core: borrando el búfer circular antes de anularlo. El búfer circular se anula en uart_tty_port_shutdown() bajo el bloqueo de giro. Sin embargo, el PM u otras devoluciones de llamada basadas en temporizadores aún pueden activarse después de este evento sin saber que el puntero del búfer no es válido. Dado que el código de serie es un poco inconsistente al verificar el estado del búfer (algunos se basan en las posiciones de cabecera y cola, otros en el puntero del búfer), es mejor tener ambos alineados, es decir, que el puntero del búfer sea NULL y las posiciones de cabecera y cola sean lo mismo, lo que significa que está vacío. Esto evitará llamadas asincrónicas para desreferenciar el puntero NULL como se informó recientemente en el caso 8250: ERROR: desreferencia del puntero NULL del kernel, dirección: 00000cf5 Cola de trabajo: pm pm_runtime_work EIP: serial8250_tx_chars (drivers\/tty\/serial\/8250\/8250_port.c:1809). . serial8250_tx_chars (drivers\/tty\/serial\/8250\/8250_port.c:1809) __start_tx (drivers\/tty\/serial\/8250\/8250_port.c:1551) serial8250_start_tx (drivers\/tty\/serial\/8250\/8250_port.c:1654) serial_port_runtime_suspend ( incluir\/linux\/serial_core.h:667 controladores\/tty\/serial\/serial_port.c:63) __rpm_callback (drivers\/base\/power\/runtime.c:393)? serial_port_remove (drivers\/tty\/serial\/serial_port.c:50) rpm_suspend (drivers\/base\/power\/runtime.c:447) El cambio propuesto evitará que se llame a -&gt;start_tx() durante la suspensión al cerrar el puerto."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7ae7104d54342433a3a73975f6569beefdd86350","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9cf7ea2eeb745213dc2a04103e426b960e807940","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bb1118905e875c111d7ccef9aee86ac5e4e7f985","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-26999","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:17.870","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nserial\/pmac_zilog: Remove flawed mitigation for rx irq flood\n\nThe mitigation was intended to stop the irq completely. That may be\nbetter than a hard lock-up but it turns out that you get a crash anyway\nif you're using pmac_zilog as a serial console:\n\nttyPZ0: pmz: rx irq flood !\nBUG: spinlock recursion on CPU#0, swapper\/0\n\nThat's because the pr_err() call in pmz_receive_chars() results in\npmz_console_write() attempting to lock a spinlock already locked in\npmz_interrupt(). With CONFIG_DEBUG_SPINLOCK=y, this produces a fatal\nBUG splat. The spinlock in question is the one in struct uart_port.\n\nEven when it's not fatal, the serial port rx function ceases to work.\nAlso, the iteration limit doesn't play nicely with QEMU, as can be\nseen in the bug report linked below.\n\nA web search for other reports of the error message \"pmz: rx irq flood\"\ndidn't produce anything. So I don't think this code is needed any more.\nRemove it."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: serial\/pmac_zilog: eliminar la mitigación defectuosa para rx irq Flood La mitigación tenía como objetivo detener irq por completo. Esto puede ser mejor que un bloqueo duro, pero resulta que de todos modos se bloquea si estás usando pmac_zilog como consola serie: ttyPZ0: pmz: rx irq Flood ! ERROR: recursión de spinlock en CPU#0, swapper\/0 Esto se debe a que la llamada pr_err() en pmz_receive_chars() da como resultado que pmz_console_write() intente bloquear un spinlock ya bloqueado en pmz_interrupt(). Con CONFIG_DEBUG_SPINLOCK=y, esto produce un error fatal. El spinlock en cuestión es el de la estructura uart_port. Incluso cuando no es fatal, la función de recepción del puerto serie deja de funcionar. Además, el límite de iteración no funciona bien con QEMU, como se puede ver en el informe de error vinculado a continuación. Una búsqueda en la web de otros informes del mensaje de error \"pmz: rx irq Flood\" no produjo nada. Así que no creo que este código ya sea necesario. Retírelo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1be3226445362bfbf461c92a5bcdb1723f2e4907","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/52aaf1ff14622a04148dbb9ccce6d9de5d534ea7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7a3bbe41efa55323b6ea3c35fa15941d4dbecdef","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bbaafbb4651fede8d3c3881601ecaa4f834f9d3f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca09dfc3cfdf89e6af3ac24e1c6c0be5c575a729","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27000","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:18.140","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nserial: mxs-auart: add spinlock around changing cts state\n\nThe uart_handle_cts_change() function in serial_core expects the caller\nto hold uport->lock. For example, I have seen the below kernel splat,\nwhen the Bluetooth driver is loaded on an i.MX28 board.\n\n    [   85.119255] ------------[ cut here ]------------\n    [   85.124413] WARNING: CPU: 0 PID: 27 at \/drivers\/tty\/serial\/serial_core.c:3453 uart_handle_cts_change+0xb4\/0xec\n    [   85.134694] Modules linked in: hci_uart bluetooth ecdh_generic ecc wlcore_sdio configfs\n    [   85.143314] CPU: 0 PID: 27 Comm: kworker\/u3:0 Not tainted 6.6.3-00021-gd62a2f068f92 #1\n    [   85.151396] Hardware name: Freescale MXS (Device Tree)\n    [   85.156679] Workqueue: hci0 hci_power_on [bluetooth]\n    (...)\n    [   85.191765]  uart_handle_cts_change from mxs_auart_irq_handle+0x380\/0x3f4\n    [   85.198787]  mxs_auart_irq_handle from __handle_irq_event_percpu+0x88\/0x210\n    (...)"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: serial: mxs-auart: agrega spinlock para cambiar el estado de cts. La función uart_handle_cts_change() en serial_core espera que la persona que llama mantenga uport-&gt;lock. Por ejemplo, he visto el siguiente símbolo del kernel, cuando el controlador Bluetooth está cargado en una placa i.MX28. [85.119255] ------------[ cortar aquí ]------------ [ 85.124413] ADVERTENCIA: CPU: 0 PID: 27 en \/drivers\/tty\/serial\/ serial_core.c:3453 uart_handle_cts_change+0xb4\/0xec [85.134694] Módulos vinculados en: hci_uart bluetooth ecdh_generic ecc wlcore_sdio configfs [85.143314] CPU: 0 PID: 27 Comm: kworker\/u3:0 No contaminado 6.6.3-00021-gd6 2a2f068f92 #1 [85.151396] Nombre de hardware: Freescale MXS (árbol de dispositivos) [85.156679] Cola de trabajo: hci0 hci_power_on [bluetooth] (...) [85.191765] uart_handle_cts_change from mxs_auart_irq_handle+0x380\/0x3f4 [ 85.198787] q_handle de __handle_irq_event_percpu+0x88\/0x210 (.. .)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2c9b943e9924cf1269e44289bc5e60e51b0f5270","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/54c4ec5f8c471b7c1137a1f769648549c423c026","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5f40fd6ca2cf0bfbc5a5c9e403dfce8ca899ba37","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/94b0e65c75f4af888ab2dd6c90f060f762924e86","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27001","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:18.330","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncomedi: vmk80xx: fix incomplete endpoint checking\n\nWhile vmk80xx does have endpoint checking implemented, some things\ncan fall through the cracks. Depending on the hardware model,\nURBs can have either bulk or interrupt type, and current version\nof vmk80xx_find_usb_endpoints() function does not take that fully\ninto account. While this warning does not seem to be too harmful,\nat the very least it will crash systems with 'panic_on_warn' set on\nthem.\n\nFix the issue found by Syzkaller [1] by somewhat simplifying the\nendpoint checking process with usb_find_common_endpoints() and\nensuring that only expected endpoint types are present.\n\nThis patch has not been tested on real hardware.\n\n[1] Syzkaller report:\nusb 1-1: BOGUS urb xfer, pipe 1 != type 3\nWARNING: CPU: 0 PID: 781 at drivers\/usb\/core\/urb.c:504 usb_submit_urb+0xc4e\/0x18c0 drivers\/usb\/core\/urb.c:503\n...\nCall Trace:\n <TASK>\n usb_start_wait_urb+0x113\/0x520 drivers\/usb\/core\/message.c:59\n vmk80xx_reset_device drivers\/comedi\/drivers\/vmk80xx.c:227 [inline]\n vmk80xx_auto_attach+0xa1c\/0x1a40 drivers\/comedi\/drivers\/vmk80xx.c:818\n comedi_auto_config+0x238\/0x380 drivers\/comedi\/drivers.c:1067\n usb_probe_interface+0x5cd\/0xb00 drivers\/usb\/core\/driver.c:399\n...\n\nSimilar issue also found by Syzkaller:"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: comedi: vmk80xx: corrige la verificación de endpoints incompleta Si bien vmk80xx tiene implementada la verificación de endpoints, algunas cosas pueden pasar desapercibidas. Dependiendo del modelo de hardware, las URB pueden tener un tipo masivo o de interrupción, y la versión actual de la función vmk80xx_find_usb_endpoints() no lo tiene completamente en cuenta. Si bien esta advertencia no parece ser demasiado dañina, al menos bloqueará los sistemas que tengan configurado 'panic_on_warn'. Solucione el problema encontrado por Syzkaller [1] simplificando un poco el proceso de verificación de endpoints con usb_find_common_endpoints() y asegurándose de que solo estén presentes los tipos de endpoints esperados. Este parche no ha sido probado en hardware real. [1] Informe Syzkaller: usb 1-1: BOGUS urb xfer, tubería 1! = tipo 3 ADVERTENCIA: CPU: 0 PID: 781 en drivers\/usb\/core\/urb.c:504 usb_submit_urb+0xc4e\/0x18c0 drivers\/usb\/ core\/urb.c:503... Seguimiento de llamadas:  usb_start_wait_urb+0x113\/0x520 drivers\/usb\/core\/message.c:59 vmk80xx_reset_device drivers\/comedi\/drivers\/vmk80xx.c:227 [en línea] vmk80xx_auto_attach+0xa1c \/0x1a40 drivers\/comedi\/drivers\/vmk80xx.c:818 comedi_auto_config+0x238\/0x380 drivers\/comedi\/drivers.c:1067 usb_probe_interface+0x5cd\/0xb00 drivers\/usb\/core\/driver.c:399 ... También se encontró un problema similar por Syzkaller:"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/59f33af9796160f851641d960bd93937f282c696","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6ec3514a7d35ad9cfab600187612c29f669069d2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ac882d6b21bffecb57bcc4486701239eef5aa67b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0b268eeb087e324ef3ea71f8e6cabd07630517f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d1718530e3f640b7d5f0050e725216eab57a85d8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27002","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:18.437","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mediatek: Do a runtime PM get on controllers during probe\n\nmt8183-mfgcfg has a mutual dependency with genpd during the probing\nstage, which leads to a deadlock in the following call stack:\n\nCPU0:  genpd_lock --> clk_prepare_lock\ngenpd_power_off_work_fn()\n genpd_lock()\n generic_pm_domain::power_off()\n    clk_unprepare()\n      clk_prepare_lock()\n\nCPU1: clk_prepare_lock --> genpd_lock\nclk_register()\n  __clk_core_init()\n    clk_prepare_lock()\n    clk_pm_runtime_get()\n      genpd_lock()\n\nDo a runtime PM get at the probe function to make sure clk_register()\nwon't acquire the genpd lock. Instead of only modifying mt8183-mfgcfg,\ndo this on all mediatek clock controller probings because we don't\nbelieve this would cause any regression.\n\nVerified on MT8183 and MT8192 Chromebooks."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: clk: mediatek: realice un PM en tiempo de ejecución en los controladores durante la prueba mt8183-mfgcfg tiene una dependencia mutua con genpd durante la etapa de prueba, lo que conduce a un punto muerto en la siguiente pila de llamadas: CPU0: genpd_lock --&gt; clk_prepare_lock genpd_power_off_work_fn() genpd_lock() generic_pm_domain::power_off() clk_unprepare() clk_prepare_lock() CPU1: clk_prepare_lock --&gt; genpd_lock clk_register() __clk_core_init() clk_prepare_lock() clk_pm_runtime_get() genpd_lock() Hacer un tiempo de ejecución PM acceda a la función de sonda para asegurarse de que clk_register() no adquiera el bloqueo genpd. En lugar de modificar únicamente mt8183-mfgcfg, haga esto en todas las pruebas del controlador de reloj mediatek porque no creemos que esto cause ninguna regresión. Verificado en Chromebooks MT8183 y MT8192."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/165d226472575b213dd90dfda19d1605dd7c19a8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2f7b1d8b5505efb0057cd1ab85fca206063ea4c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b62ed25feb342eab052822eff0c554873799a4f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c0dcd5c072e2a3fff886f673e6a5d9bf8090c4cc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27003","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:18.597","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: Get runtime PM before walking tree for clk_summary\n\nSimilar to the previous commit, we should make sure that all devices are\nruntime resumed before printing the clk_summary through debugfs. Failure\nto do so would result in a deadlock if the thread is resuming a device\nto print clk state and that device is also runtime resuming in another\nthread, e.g the screen is turning on and the display driver is starting\nup. We remove the calls to clk_pm_runtime_{get,put}() in this path\nbecause they're superfluous now that we know the devices are runtime\nresumed. This also squashes a bug where the return value of\nclk_pm_runtime_get() wasn't checked, leading to an RPM count underflow\non error paths."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: clk: Obtenga PM en tiempo de ejecución antes de recorrer el árbol para clk_summary De manera similar a el commit anterior, debemos asegurarnos de que todos los dispositivos se reanuden en tiempo de ejecución antes de imprimir clk_summary a través de debugfs. No hacerlo resultaría en un punto muerto si el subproceso está reanudando un dispositivo para imprimir el estado de clk y ese dispositivo también está reanudando el tiempo de ejecución en otro subproceso, por ejemplo, la pantalla se enciende y el controlador de pantalla se está iniciando. Eliminamos las llamadas a clk_pm_runtime_{get,put}() en esta ruta porque son superfluas ahora que sabemos que los dispositivos se han reanudado en tiempo de ejecución. Esto también soluciona un error por el cual el valor de retorno de clk_pm_runtime_get() no se verificaba, lo que provocaba un desbordamiento insuficiente del recuento de RPM en las rutas de error."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2c077fdfd09dffb31a890e5095c8ab205138a42e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/83ada89e4a86e2b28ea2b5113c76d6dc7560a4d0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9d1e795f754db1ac3344528b7af0b17b8146f321","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b457105309d388e4081c716cf7b81d517ff74db4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27004","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:18.763","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: Get runtime PM before walking tree during disable_unused\n\nDoug reported [1] the following hung task:\n\n INFO: task swapper\/0:1 blocked for more than 122 seconds.\n       Not tainted 5.15.149-21875-gf795ebc40eb8 #1\n \"echo 0 > \/proc\/sys\/kernel\/hung_task_timeout_secs\" disables this message.\n task:swapper\/0       state:D stack:    0 pid:    1 ppid:     0 flags:0x00000008\n Call trace:\n  __switch_to+0xf4\/0x1f4\n  __schedule+0x418\/0xb80\n  schedule+0x5c\/0x10c\n  rpm_resume+0xe0\/0x52c\n  rpm_resume+0x178\/0x52c\n  __pm_runtime_resume+0x58\/0x98\n  clk_pm_runtime_get+0x30\/0xb0\n  clk_disable_unused_subtree+0x58\/0x208\n  clk_disable_unused_subtree+0x38\/0x208\n  clk_disable_unused_subtree+0x38\/0x208\n  clk_disable_unused_subtree+0x38\/0x208\n  clk_disable_unused_subtree+0x38\/0x208\n  clk_disable_unused+0x4c\/0xe4\n  do_one_initcall+0xcc\/0x2d8\n  do_initcall_level+0xa4\/0x148\n  do_initcalls+0x5c\/0x9c\n  do_basic_setup+0x24\/0x30\n  kernel_init_freeable+0xec\/0x164\n  kernel_init+0x28\/0x120\n  ret_from_fork+0x10\/0x20\n INFO: task kworker\/u16:0:9 blocked for more than 122 seconds.\n       Not tainted 5.15.149-21875-gf795ebc40eb8 #1\n \"echo 0 > \/proc\/sys\/kernel\/hung_task_timeout_secs\" disables this message.\n task:kworker\/u16:0   state:D stack:    0 pid:    9 ppid:     2 flags:0x00000008\n Workqueue: events_unbound deferred_probe_work_func\n Call trace:\n  __switch_to+0xf4\/0x1f4\n  __schedule+0x418\/0xb80\n  schedule+0x5c\/0x10c\n  schedule_preempt_disabled+0x2c\/0x48\n  __mutex_lock+0x238\/0x488\n  __mutex_lock_slowpath+0x1c\/0x28\n  mutex_lock+0x50\/0x74\n  clk_prepare_lock+0x7c\/0x9c\n  clk_core_prepare_lock+0x20\/0x44\n  clk_prepare+0x24\/0x30\n  clk_bulk_prepare+0x40\/0xb0\n  mdss_runtime_resume+0x54\/0x1c8\n  pm_generic_runtime_resume+0x30\/0x44\n  __genpd_runtime_resume+0x68\/0x7c\n  genpd_runtime_resume+0x108\/0x1f4\n  __rpm_callback+0x84\/0x144\n  rpm_callback+0x30\/0x88\n  rpm_resume+0x1f4\/0x52c\n  rpm_resume+0x178\/0x52c\n  __pm_runtime_resume+0x58\/0x98\n  __device_attach+0xe0\/0x170\n  device_initial_probe+0x1c\/0x28\n  bus_probe_device+0x3c\/0x9c\n  device_add+0x644\/0x814\n  mipi_dsi_device_register_full+0xe4\/0x170\n  devm_mipi_dsi_device_register_full+0x28\/0x70\n  ti_sn_bridge_probe+0x1dc\/0x2c0\n  auxiliary_bus_probe+0x4c\/0x94\n  really_probe+0xcc\/0x2c8\n  __driver_probe_device+0xa8\/0x130\n  driver_probe_device+0x48\/0x110\n  __device_attach_driver+0xa4\/0xcc\n  bus_for_each_drv+0x8c\/0xd8\n  __device_attach+0xf8\/0x170\n  device_initial_probe+0x1c\/0x28\n  bus_probe_device+0x3c\/0x9c\n  deferred_probe_work_func+0x9c\/0xd8\n  process_one_work+0x148\/0x518\n  worker_thread+0x138\/0x350\n  kthread+0x138\/0x1e0\n  ret_from_fork+0x10\/0x20\n\nThe first thread is walking the clk tree and calling\nclk_pm_runtime_get() to power on devices required to read the clk\nhardware via struct clk_ops::is_enabled(). This thread holds the clk\nprepare_lock, and is trying to runtime PM resume a device, when it finds\nthat the device is in the process of resuming so the thread schedule()s\naway waiting for the device to finish resuming before continuing. The\nsecond thread is runtime PM resuming the same device, but the runtime\nresume callback is calling clk_prepare(), trying to grab the\nprepare_lock waiting on the first thread.\n\nThis is a classic ABBA deadlock. To properly fix the deadlock, we must\nnever runtime PM resume or suspend a device with the clk prepare_lock\nheld. Actually doing that is near impossible today because the global\nprepare_lock would have to be dropped in the middle of the tree, the\ndevice runtime PM resumed\/suspended, and then the prepare_lock grabbed\nagain to ensure consistency of the clk tree topology. If anything\nchanges with the clk tree in the meantime, we've lost and will need to\nstart the operation all over again.\n\nLuckily, most of the time we're simply incrementing or decrementing the\nruntime PM count on an active device, so we don't have the chance to\nschedule away with the prepare_lock held. Let's fix this immediate\nproblem that can be\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: clk: Obtener PM en tiempo de ejecución antes de caminar por el árbol durante enable_unused Doug informó [1] la siguiente tarea colgada: INFORMACIÓN: intercambio de tareas\/0:1 bloqueado durante más de 122 segundos. No contaminado 5.15.149-21875-gf795ebc40eb8 #1 \"echo 0 &gt; \/proc\/sys\/kernel\/hung_task_timeout_secs\" desactiva este mensaje. tarea:swapper\/0 estado:D pila: 0 pid: 1 ppid: 0 banderas:0x00000008 Rastreo de llamadas: __switch_to+0xf4\/0x1f4 __schedule+0x418\/0xb80 Schedule+0x5c\/0x10c rpm_resume+0xe0\/0x52c rpm_resume+0x178\/0x52c __pm_run tiempo_resume+ 0x58\/0x98 clk_pm_runtime_get+0x30\/0xb0 clk_disable_unused_subtree+0x58\/0x208 clk_disable_unused_subtree+0x38\/0x208 clk_disable_unused_subtree+0x38\/0x208 clk_disable_unused_subtree+0x38\/0x208 _disable_unused_subtree+0x38\/0x208 clk_disable_unused+0x4c\/0xe4 do_one_initcall+0xcc\/0x2d8 do_initcall_level+0xa4\/0x148 do_initcalls+ 0x5c\/0x9c do_basic_setup+0x24\/0x30 kernel_init_freeable+0xec\/0x164 kernel_init+0x28\/0x120 ret_from_fork+0x10\/0x20 INFORMACIÓN: tarea kworker\/u16:0:9 bloqueada durante más de 122 segundos. No contaminado 5.15.149-21875-gf795ebc40eb8 #1 \"echo 0 &gt; \/proc\/sys\/kernel\/hung_task_timeout_secs\" desactiva este mensaje. tarea:kworker\/u16:0 estado:D pila: 0 pid: 9 ppid: 2 banderas:0x00000008 Cola de trabajo: events_unbound deferred_probe_work_func Rastreo de llamadas: __switch_to+0xf4\/0x1f4 __schedule+0x418\/0xb80 Schedule+0x5c\/0x10c Schedule_preempt_disabled+0x2c \/0x48 __mutex_lock +0x238\/0x488 __mutex_lock_slowpath+0x1c\/0x28 mutex_lock+0x50\/0x74 clk_prepare_lock+0x7c\/0x9c clk_core_prepare_lock+0x20\/0x44 clk_prepare+0x24\/0x30 clk_bulk_prepare+0x40\/0xb0 currículum+0x54\/0x1c8 pm_generic_runtime_resume+0x30\/0x44 __genpd_runtime_resume+0x68\/0x7c genpd_runtime_resume +0x108\/0x1f4 __rpm_callback+0x84\/0x144 rpm_callback+0x30\/0x88 rpm_resume+0x1f4\/0x52c rpm_resume+0x178\/0x52c __pm_runtime_resume+0x58\/0x98 __device_attach+0xe0\/0x170 dispositivo_initial_probe+0x 1c\/0x28 bus_probe_device+0x3c\/0x9c dispositivo_add+0x644\/0x814 mipi_dsi_device_register_full +0xe4\/0x170 devm_mipi_dsi_device_register_full+0x28\/0x70 ti_sn_bridge_probe+0x1dc\/0x2c0 auxiliar_bus_probe+0x4c\/0x94 very_probe+0xcc\/0x2c8 __driver_probe_device+0xa8\/0x130 driver_probe_device+0x48\/ 0x110 __device_attach_driver+0xa4\/0xcc bus_for_each_drv+0x8c\/0xd8 __device_attach+0xf8\/0x170 dispositivo_inicial_probe +0x1c\/0x28 bus_probe_device+0x3c\/0x9c deferred_probe_work_func+0x9c\/0xd8 Process_one_work+0x148\/0x518 Workers_thread+0x138\/0x350 kthread+0x138\/0x1e0 ret_from_fork+0x10\/0x20 El primer hilo está recorriendo el árbol clk y llamando clk_pm_runtime_get() para encender dispositivos necesarios para leer el hardware clk a través de struct clk_ops::is_enabled(). Este hilo contiene clk prepare_lock y está intentando ejecutar PM para reanudar un dispositivo, cuando descubre que el dispositivo está en proceso de reanudación, por lo que la programación del hilo está esperando a que el dispositivo termine de reanudarse antes de continuar. El segundo hilo es PM en tiempo de ejecución que reanuda el mismo dispositivo, pero la devolución de llamada de reanudación en tiempo de ejecución llama a clk_prepare(), intentando capturar el prepare_lock que espera en el primer hilo. Este es un clásico punto muerto de ABBA. Para solucionar correctamente el punto muerto, nunca debemos reanudar el PM en tiempo de ejecución ni suspender un dispositivo con clk prepare_lock retenido. En realidad, hacer eso es casi imposible hoy en día porque el prepare_lock global tendría que colocarse en el medio del árbol, el tiempo de ejecución del dispositivo PM se reanudaría\/suspendiría y luego el prepare_lock se tomaría nuevamente para garantizar la coherencia de la topología del árbol clk. Mientras tanto, si algo cambia con el árbol clk, habremos perdido y necesitaremos comenzar la operación de nuevo.  ---truncarse---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/115554862294397590088ba02f11f2aba6d5016c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/60ff482c4205a5aac3b0595ab794cfd62295dab5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a29ec0465dce0b871003698698ac6fa92c9a5034","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a424e713e0cc33d4b969cfda25b9f46df4d7b5bc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e581cf5d216289ef292d1a4036d53ce90e122469","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27005","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:18.883","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ninterconnect: Don't access req_list while it's being manipulated\n\nThe icc_lock mutex was split into separate icc_lock and icc_bw_lock\nmutexes in [1] to avoid lockdep splats. However, this didn't adequately\nprotect access to icc_node::req_list.\n\nThe icc_set_bw() function will eventually iterate over req_list while\nonly holding icc_bw_lock, but req_list can be modified while only\nholding icc_lock. This causes races between icc_set_bw(), of_icc_get(),\nand icc_put().\n\nExample A:\n\n  CPU0                               CPU1\n  ----                               ----\n  icc_set_bw(path_a)\n    mutex_lock(&icc_bw_lock);\n                                     icc_put(path_b)\n                                       mutex_lock(&icc_lock);\n    aggregate_requests()\n      hlist_for_each_entry(r, ...\n                                       hlist_del(...\n        <r = invalid pointer>\n\nExample B:\n\n  CPU0                               CPU1\n  ----                               ----\n  icc_set_bw(path_a)\n    mutex_lock(&icc_bw_lock);\n                                     path_b = of_icc_get()\n                                       of_icc_get_by_index()\n                                         mutex_lock(&icc_lock);\n                                         path_find()\n                                           path_init()\n    aggregate_requests()\n      hlist_for_each_entry(r, ...\n                                             hlist_add_head(...\n        <r = invalid pointer>\n\nFix this by ensuring icc_bw_lock is always held before manipulating\nicc_node::req_list. The additional places icc_bw_lock is held don't\nperform any memory allocations, so we should still be safe from the\noriginal lockdep splats that motivated the separate locks.\n\n[1] commit af42269c3523 (\"interconnect: Fix locking for runpm vs reclaim\")"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: interconexión: no acceder a req_list mientras se está manipulando. El mutex icc_lock se dividió en mutex icc_lock e icc_bw_lock separados en [1] para evitar símbolos de bloqueo. Sin embargo, esto no protegió adecuadamente el acceso a icc_node::req_list. La función icc_set_bw() eventualmente iterará sobre req_list mientras solo mantiene icc_bw_lock, pero req_list se puede modificar mientras solo mantiene icc_lock. Esto provoca ejecucións entre icc_set_bw(), of_icc_get() e icc_put(). Ejemplo A: CPU0 CPU1 ---- ---- icc_set_bw(path_a) mutex_lock(&amp;icc_bw_lock); icc_put(ruta_b) mutex_lock(&amp;icc_lock); agregado_requests() hlist_for_each_entry(r, ... hlist_del(...  Ejemplo B: CPU0 CPU1 ---- ---- icc_set_bw(path_a) mutex_lock(&amp;icc_bw_lock); path_b = of_icc_get() of_icc_get_by_index( ) mutex_lock(&amp;icc_lock); path_find() path_init() agregado_requests() hlist_for_each_entry(r, ... hlist_add_head(...  Solucione este problema asegurándose de que icc_bw_lock siempre se mantenga antes de manipular icc_node::req_list. El adicional Los lugares donde se mantiene icc_bw_lock no realizan ninguna asignación de memoria, por lo que aún deberíamos estar a salvo de los símbolos de bloqueo originales que motivaron los bloqueos separados [1] commit af42269c3523 (\"interconexión: arreglar el bloqueo para runpm vs reclaim\")"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4c65507121ea8e0b47fae6d2049c8688390d46b6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0d04efa2e367921654b5106cc5c05e3757c2b42","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/de1bf25b6d771abdb52d43546cf57ad775fb68a1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27006","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:19.053","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nthermal\/debugfs: Add missing count increment to thermal_debug_tz_trip_up()\n\nThe count field in struct trip_stats, representing the number of times\nthe zone temperature was above the trip point, needs to be incremented\nin thermal_debug_tz_trip_up(), for two reasons.\n\nFirst, if a trip point is crossed on the way up for the first time,\nthermal_debug_update_temp() called from update_temperature() does\nnot see it because it has not been added to trips_crossed[] array\nin the thermal zone's struct tz_debugfs object yet.  Therefore, when\nthermal_debug_tz_trip_up() is called after that, the trip point's\ncount value is 0, and the attempt to divide by it during the average\ntemperature computation leads to a divide error which causes the kernel\nto crash.  Setting the count to 1 before the division by incrementing it\nfixes this problem.\n\nSecond, if a trip point is crossed on the way up, but it has been\ncrossed on the way up already before, its count value needs to be\nincremented to make a record of the fact that the zone temperature is\nabove the trip now.  Without doing that, if the mitigations applied\nafter crossing the trip cause the zone temperature to drop below its\nthreshold, the count will not be updated for this episode at all and\nthe average temperature in the trip statistics record will be somewhat\nhigher than it should be.\n\nCc :6.8+ <stable@vger.kernel.org> # 6.8+"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: Thermal\/debugfs: agregue el incremento de conteo faltante a Thermal_debug_tz_trip_up() El campo de conteo en la estructura trip_stats, que representa la cantidad de veces que la temperatura de la zona estuvo por encima del punto de disparo, debe incrementarse en Thermal_debug_tz_trip_up(), por dos razones. Primero, si se cruza un punto de viaje en el camino hacia arriba por primera vez, Thermal_debug_update_temp() llamado desde update_temperature() no lo ve porque aún no se ha agregado a la matriz trips_crossed[] en el objeto struct tz_debugfs de la zona térmica. Por lo tanto, cuando se llama a Thermal_debug_tz_trip_up() después de eso, el valor de conteo del punto de disparo es 0, y el intento de dividirlo durante el cálculo de la temperatura promedio conduce a un error de división que provoca que el kernel falle. Establecer el conteo en 1 antes de la división incrementándolo soluciona este problema. En segundo lugar, si se cruza un punto de viaje en el camino hacia arriba, pero ya se ha cruzado en el camino hacia arriba, es necesario incrementar su valor de conteo para registrar el hecho de que la temperatura de la zona está por encima del viaje en este momento. Sin hacer eso, si las mitigaciones aplicadas después de cruzar el viaje hacen que la temperatura de la zona caiga por debajo de su umbral, el conteo no se actualizará para este episodio en absoluto y la temperatura promedio en el registro de estadísticas del viaje será algo mayor de lo que debería ser. . CC :6.8+  # 6.8+"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/9c8215d32e730b597c809a9d2090bf8ec1b79fcf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b552f63cd43735048bbe9bfbb7a9dcfce166fbdd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27007","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:19.180","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nuserfaultfd: change src_folio after ensuring it's unpinned in UFFDIO_MOVE\n\nCommit d7a08838ab74 (\"mm: userfaultfd: fix unexpected change to src_folio\nwhen UFFDIO_MOVE fails\") moved the src_folio->{mapping, index} changing to\nafter clearing the page-table and ensuring that it's not pinned.  This\navoids failure of swapout+migration and possibly memory corruption.\n\nHowever, the commit missed fixing it in the huge-page case."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: userfaultfd: cambie src_folio después de asegurarse de que no esté fijado en UFFDIO_MOVE Commit d7a08838ab74 (\"mm: userfaultfd: corrija el cambio inesperado en src_folio cuando UFFDIO_MOVE falla\") movió src_folio-&gt;{mapping, index} cambiando a después de borrar la tabla de páginas y asegurarse de que no esté fijada. Esto evita fallos en el intercambio+migración y posiblemente daños en la memoria. Sin embargo, la confirmación no solucionó el problema en el caso de la página enorme."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/c0205eaf3af9f5db14d4b5ee4abacf4a583c3c50","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df5f6e683e7f21a15d8be6e7a0c7a46436963ebe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27008","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:19.240","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: nv04: Fix out of bounds access\n\nWhen Output Resource (dcb->or) value is assigned in\nfabricate_dcb_output(), there may be out of bounds access to\ndac_users array in case dcb->or is zero because ffs(dcb->or) is\nused as index there.\nThe 'or' argument of fabricate_dcb_output() must be interpreted as a\nnumber of bit to set, not value.\n\nUtilize macros from 'enum nouveau_or' in calls instead of hardcoding.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm: nv04: corregir el acceso fuera de los límites Cuando se asigna el valor del recurso de salida (dcb-&gt;or) en fabricate_dcb_output(), puede haber acceso fuera de los límites a la matriz dac_users en caso de que dcb-&gt;or es cero porque ffs(dcb-&gt;or) se usa como índice allí. El argumento 'o' de fabricate_dcb_output() debe interpretarse como un número de bits a configurar, no como un valor. Utilice macros de 'enum nouveau_or' en las llamadas en lugar de codificarlas. Encontrado por el Centro de verificación de Linux (linuxtesting.org) con SVACE."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/26212da39ee14a52c76a202c6ae5153a84f579a5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5fd4b090304e450aa0e7cc9cc2b4873285c6face","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6690cc2732e2a8d0eaca44dcbac032a4b0148042","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cf92bb778eda7830e79452c6917efa8474a30c1e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df0991da7db846f7fa4ec6740350f743d3b69b04","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27009","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:19.360","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ns390\/cio: fix race condition during online processing\n\nA race condition exists in ccw_device_set_online() that can cause the\nonline process to fail, leaving the affected device in an inconsistent\nstate. As a result, subsequent attempts to set that device online fail\nwith return code ENODEV.\n\nThe problem occurs when a path verification request arrives after\na wait for final device state completed, but before the result state\nis evaluated.\n\nFix this by ensuring that the CCW-device lock is held between\ndetermining final state and checking result state.\n\nNote that since:\n\ncommit 2297791c92d0 (\"s390\/cio: dont unregister subchannel from child-drivers\")\n\npath verification requests are much more likely to occur during boot,\nresulting in an increased chance of this race condition occurring."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2d8527f2f911fab84aec04df4788c0c23af3df48","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2df56f4ea769ff81e51bbb05699989603bde9c49","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3076b3c38a704e10df5e143c213653309d532538","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/559f3a6333397ab6cd4a696edd65a70b6be62c6e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a4234decd0fe429832ca81c4637be7248b88b49e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27010","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:19.467","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/sched: Fix mirred deadlock on device recursion\n\nWhen the mirred action is used on a classful egress qdisc and a packet is\nmirrored or redirected to self we hit a qdisc lock deadlock.\nSee trace below.\n\n[..... other info removed for brevity....]\n[   82.890906]\n[   82.890906] ============================================\n[   82.890906] WARNING: possible recursive locking detected\n[   82.890906] 6.8.0-05205-g77fadd89fe2d-dirty #213 Tainted: G        W\n[   82.890906] --------------------------------------------\n[   82.890906] ping\/418 is trying to acquire lock:\n[   82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3}, at:\n__dev_queue_xmit+0x1778\/0x3550\n[   82.890906]\n[   82.890906] but task is already holding lock:\n[   82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3}, at:\n__dev_queue_xmit+0x1778\/0x3550\n[   82.890906]\n[   82.890906] other info that might help us debug this:\n[   82.890906]  Possible unsafe locking scenario:\n[   82.890906]\n[   82.890906]        CPU0\n[   82.890906]        ----\n[   82.890906]   lock(&sch->q.lock);\n[   82.890906]   lock(&sch->q.lock);\n[   82.890906]\n[   82.890906]  *** DEADLOCK ***\n[   82.890906]\n[..... other info removed for brevity....]\n\nExample setup (eth0->eth0) to recreate\ntc qdisc add dev eth0 root handle 1: htb default 30\ntc filter add dev eth0 handle 1: protocol ip prio 2 matchall \\\n     action mirred egress redirect dev eth0\n\nAnother example(eth0->eth1->eth0) to recreate\ntc qdisc add dev eth0 root handle 1: htb default 30\ntc filter add dev eth0 handle 1: protocol ip prio 2 matchall \\\n     action mirred egress redirect dev eth1\n\ntc qdisc add dev eth1 root handle 1: htb default 30\ntc filter add dev eth1 handle 1: protocol ip prio 2 matchall \\\n     action mirred egress redirect dev eth0\n\nWe fix this by adding an owner field (CPU id) to struct Qdisc set after\nroot qdisc is entered. When the softirq enters it a second time, if the\nqdisc owner is the same CPU, the packet is dropped to break the loop."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0f022d32c3eca477fbf79a205243a6123ed0fe11","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e6b90468da4dae2281a6e381107f411efb48b0ef","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27011","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:19.583","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: fix memleak in map from abort path\n\nThe delete set command does not rely on the transaction object for\nelement removal, therefore, a combination of delete element + delete set\nfrom the abort path could result in restoring twice the refcount of the\nmapping.\n\nCheck for inactive element in the next generation for the delete element\ncommand in the abort path, skip restoring state if next generation bit\nhas been already cleared. This is similar to the activate logic using\nthe set walk iterator.\n\n[ 6170.286929] ------------[ cut here ]------------\n[ 6170.286939] WARNING: CPU: 6 PID: 790302 at net\/netfilter\/nf_tables_api.c:2086 nf_tables_chain_destroy+0x1f7\/0x220 [nf_tables]\n[ 6170.287071] Modules linked in: [...]\n[ 6170.287633] CPU: 6 PID: 790302 Comm: kworker\/6:2 Not tainted 6.9.0-rc3+ #365\n[ 6170.287768] RIP: 0010:nf_tables_chain_destroy+0x1f7\/0x220 [nf_tables]\n[ 6170.287886] Code: df 48 8d 7d 58 e8 69 2e 3b df 48 8b 7d 58 e8 80 1b 37 df 48 8d 7d 68 e8 57 2e 3b df 48 8b 7d 68 e8 6e 1b 37 df 48 89 ef eb c4 <0f> 0b 48 83 c4 08 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc 0f\n[ 6170.287895] RSP: 0018:ffff888134b8fd08 EFLAGS: 00010202\n[ 6170.287904] RAX: 0000000000000001 RBX: ffff888125bffb28 RCX: dffffc0000000000\n[ 6170.287912] RDX: 0000000000000003 RSI: ffffffffa20298ab RDI: ffff88811ebe4750\n[ 6170.287919] RBP: ffff88811ebe4700 R08: ffff88838e812650 R09: fffffbfff0623a55\n[ 6170.287926] R10: ffffffff8311d2af R11: 0000000000000001 R12: ffff888125bffb10\n[ 6170.287933] R13: ffff888125bffb10 R14: dead000000000122 R15: dead000000000100\n[ 6170.287940] FS:  0000000000000000(0000) GS:ffff888390b00000(0000) knlGS:0000000000000000\n[ 6170.287948] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 6170.287955] CR2: 00007fd31fc00710 CR3: 0000000133f60004 CR4: 00000000001706f0\n[ 6170.287962] Call Trace:\n[ 6170.287967]  <TASK>\n[ 6170.287973]  ? __warn+0x9f\/0x1a0\n[ 6170.287986]  ? nf_tables_chain_destroy+0x1f7\/0x220 [nf_tables]\n[ 6170.288092]  ? report_bug+0x1b1\/0x1e0\n[ 6170.287986]  ? nf_tables_chain_destroy+0x1f7\/0x220 [nf_tables]\n[ 6170.288092]  ? report_bug+0x1b1\/0x1e0\n[ 6170.288104]  ? handle_bug+0x3c\/0x70\n[ 6170.288112]  ? exc_invalid_op+0x17\/0x40\n[ 6170.288120]  ? asm_exc_invalid_op+0x1a\/0x20\n[ 6170.288132]  ? nf_tables_chain_destroy+0x2b\/0x220 [nf_tables]\n[ 6170.288243]  ? nf_tables_chain_destroy+0x1f7\/0x220 [nf_tables]\n[ 6170.288366]  ? nf_tables_chain_destroy+0x2b\/0x220 [nf_tables]\n[ 6170.288483]  nf_tables_trans_destroy_work+0x588\/0x590 [nf_tables]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/49d0e656d19dfb2d4d7c230e4a720d37b3decff6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/86a1471d7cde792941109b93b558b5dc078b9ee9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27012","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:19.743","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: restore set elements when delete set fails\n\nFrom abort path, nft_mapelem_activate() needs to restore refcounters to\nthe original state. Currently, it uses the set->ops->walk() to iterate\nover these set elements. The existing set iterator skips inactive\nelements in the next generation, this does not work from the abort path\nto restore the original state since it has to skip active elements\ninstead (not inactive ones).\n\nThis patch moves the check for inactive elements to the set iterator\ncallback, then it reverses the logic for the .activate case which\nneeds to skip active elements.\n\nToggle next generation bit for elements when delete set command is\ninvoked and call nft_clear() from .activate (abort) path to restore the\nnext generation bit.\n\nThe splat below shows an object in mappings memleak:\n\n[43929.457523] ------------[ cut here ]------------\n[43929.457532] WARNING: CPU: 0 PID: 1139 at include\/net\/netfilter\/nf_tables.h:1237 nft_setelem_data_deactivate+0xe4\/0xf0 [nf_tables]\n[...]\n[43929.458014] RIP: 0010:nft_setelem_data_deactivate+0xe4\/0xf0 [nf_tables]\n[43929.458076] Code: 83 f8 01 77 ab 49 8d 7c 24 08 e8 37 5e d0 de 49 8b 6c 24 08 48 8d 7d 50 e8 e9 5c d0 de 8b 45 50 8d 50 ff 89 55 50 85 c0 75 86 <0f> 0b eb 82 0f 0b eb b3 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90\n[43929.458081] RSP: 0018:ffff888140f9f4b0 EFLAGS: 00010246\n[43929.458086] RAX: 0000000000000000 RBX: ffff8881434f5288 RCX: dffffc0000000000\n[43929.458090] RDX: 00000000ffffffff RSI: ffffffffa26d28a7 RDI: ffff88810ecc9550\n[43929.458093] RBP: ffff88810ecc9500 R08: 0000000000000001 R09: ffffed10281f3e8f\n[43929.458096] R10: 0000000000000003 R11: ffff0000ffff0000 R12: ffff8881434f52a0\n[43929.458100] R13: ffff888140f9f5f4 R14: ffff888151c7a800 R15: 0000000000000002\n[43929.458103] FS:  00007f0c687c4740(0000) GS:ffff888390800000(0000) knlGS:0000000000000000\n[43929.458107] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[43929.458111] CR2: 00007f58dbe5b008 CR3: 0000000123602005 CR4: 00000000001706f0\n[43929.458114] Call Trace:\n[43929.458118]  <TASK>\n[43929.458121]  ? __warn+0x9f\/0x1a0\n[43929.458127]  ? nft_setelem_data_deactivate+0xe4\/0xf0 [nf_tables]\n[43929.458188]  ? report_bug+0x1b1\/0x1e0\n[43929.458196]  ? handle_bug+0x3c\/0x70\n[43929.458200]  ? exc_invalid_op+0x17\/0x40\n[43929.458211]  ? nft_setelem_data_deactivate+0xd7\/0xf0 [nf_tables]\n[43929.458271]  ? nft_setelem_data_deactivate+0xe4\/0xf0 [nf_tables]\n[43929.458332]  nft_mapelem_deactivate+0x24\/0x30 [nf_tables]\n[43929.458392]  nft_rhash_walk+0xdd\/0x180 [nf_tables]\n[43929.458453]  ? __pfx_nft_rhash_walk+0x10\/0x10 [nf_tables]\n[43929.458512]  ? rb_insert_color+0x2e\/0x280\n[43929.458520]  nft_map_deactivate+0xdc\/0x1e0 [nf_tables]\n[43929.458582]  ? __pfx_nft_map_deactivate+0x10\/0x10 [nf_tables]\n[43929.458642]  ? __pfx_nft_mapelem_deactivate+0x10\/0x10 [nf_tables]\n[43929.458701]  ? __rcu_read_unlock+0x46\/0x70\n[43929.458709]  nft_delset+0xff\/0x110 [nf_tables]\n[43929.458769]  nft_flush_table+0x16f\/0x460 [nf_tables]\n[43929.458830]  nf_tables_deltable+0x501\/0x580 [nf_tables]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/86658fc7414d4b9e25c2699d751034537503d637","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e79b47a8615d42c68aaeb68971593333667382ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27013","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:19.857","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntun: limit printing rate when illegal packet received by tun dev\n\nvhost_worker will call tun call backs to receive packets. If too many\nillegal packets arrives, tun_do_read will keep dumping packet contents.\nWhen console is enabled, it will costs much more cpu time to dump\npacket and soft lockup will be detected.\n\nnet_ratelimit mechanism can be used to limit the dumping rate.\n\nPID: 33036    TASK: ffff949da6f20000  CPU: 23   COMMAND: \"vhost-32980\"\n #0 [fffffe00003fce50] crash_nmi_callback at ffffffff89249253\n #1 [fffffe00003fce58] nmi_handle at ffffffff89225fa3\n #2 [fffffe00003fceb0] default_do_nmi at ffffffff8922642e\n #3 [fffffe00003fced0] do_nmi at ffffffff8922660d\n #4 [fffffe00003fcef0] end_repeat_nmi at ffffffff89c01663\n    [exception RIP: io_serial_in+20]\n    RIP: ffffffff89792594  RSP: ffffa655314979e8  RFLAGS: 00000002\n    RAX: ffffffff89792500  RBX: ffffffff8af428a0  RCX: 0000000000000000\n    RDX: 00000000000003fd  RSI: 0000000000000005  RDI: ffffffff8af428a0\n    RBP: 0000000000002710   R8: 0000000000000004   R9: 000000000000000f\n    R10: 0000000000000000  R11: ffffffff8acbf64f  R12: 0000000000000020\n    R13: ffffffff8acbf698  R14: 0000000000000058  R15: 0000000000000000\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n #5 [ffffa655314979e8] io_serial_in at ffffffff89792594\n #6 [ffffa655314979e8] wait_for_xmitr at ffffffff89793470\n #7 [ffffa65531497a08] serial8250_console_putchar at ffffffff897934f6\n #8 [ffffa65531497a20] uart_console_write at ffffffff8978b605\n #9 [ffffa65531497a48] serial8250_console_write at ffffffff89796558\n #10 [ffffa65531497ac8] console_unlock at ffffffff89316124\n #11 [ffffa65531497b10] vprintk_emit at ffffffff89317c07\n #12 [ffffa65531497b68] printk at ffffffff89318306\n #13 [ffffa65531497bc8] print_hex_dump at ffffffff89650765\n #14 [ffffa65531497ca8] tun_do_read at ffffffffc0b06c27 [tun]\n #15 [ffffa65531497d38] tun_recvmsg at ffffffffc0b06e34 [tun]\n #16 [ffffa65531497d68] handle_rx at ffffffffc0c5d682 [vhost_net]\n #17 [ffffa65531497ed0] vhost_worker at ffffffffc0c644dc [vhost]\n #18 [ffffa65531497f10] kthread at ffffffff892d2e72\n #19 [ffffa65531497f50] ret_from_fork at ffffffff89c0022f"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/40f4ced305c6c47487d3cd8da54676e2acc1a6ad","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/52854101180beccdb9dc2077a3bea31b6ad48dfa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/62e27ef18eb4f0d33bbae8e9ef56b99696a74713","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a50dbeca28acf7051dfa92786b85f704c75db6eb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f8bbc07ac535593139c875ffa19af924b1084540","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27014","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:20.063","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/mlx5e: Prevent deadlock while disabling aRFS\n\nWhen disabling aRFS under the `priv->state_lock`, any scheduled\naRFS works are canceled using the `cancel_work_sync` function,\nwhich waits for the work to end if it has already started.\nHowever, while waiting for the work handler, the handler will\ntry to acquire the `state_lock` which is already acquired.\n\nThe worker acquires the lock to delete the rules if the state\nis down, which is not the worker's responsibility since\ndisabling aRFS deletes the rules.\n\nAdd an aRFS state variable, which indicates whether the aRFS is\nenabled and prevent adding rules when the aRFS is disabled.\n\nKernel log:\n\n======================================================\nWARNING: possible circular locking dependency detected\n6.7.0-rc4_net_next_mlx5_5483eb2 #1 Tainted: G          I\n------------------------------------------------------\nethtool\/386089 is trying to acquire lock:\nffff88810f21ce68 ((work_completion)(&rule->arfs_work)){+.+.}-{0:0}, at: __flush_work+0x74\/0x4e0\n\nbut task is already holding lock:\nffff8884a1808cc0 (&priv->state_lock){+.+.}-{3:3}, at: mlx5e_ethtool_set_channels+0x53\/0x200 [mlx5_core]\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 (&priv->state_lock){+.+.}-{3:3}:\n       __mutex_lock+0x80\/0xc90\n       arfs_handle_work+0x4b\/0x3b0 [mlx5_core]\n       process_one_work+0x1dc\/0x4a0\n       worker_thread+0x1bf\/0x3c0\n       kthread+0xd7\/0x100\n       ret_from_fork+0x2d\/0x50\n       ret_from_fork_asm+0x11\/0x20\n\n-> #0 ((work_completion)(&rule->arfs_work)){+.+.}-{0:0}:\n       __lock_acquire+0x17b4\/0x2c80\n       lock_acquire+0xd0\/0x2b0\n       __flush_work+0x7a\/0x4e0\n       __cancel_work_timer+0x131\/0x1c0\n       arfs_del_rules+0x143\/0x1e0 [mlx5_core]\n       mlx5e_arfs_disable+0x1b\/0x30 [mlx5_core]\n       mlx5e_ethtool_set_channels+0xcb\/0x200 [mlx5_core]\n       ethnl_set_channels+0x28f\/0x3b0\n       ethnl_default_set_doit+0xec\/0x240\n       genl_family_rcv_msg_doit+0xd0\/0x120\n       genl_rcv_msg+0x188\/0x2c0\n       netlink_rcv_skb+0x54\/0x100\n       genl_rcv+0x24\/0x40\n       netlink_unicast+0x1a1\/0x270\n       netlink_sendmsg+0x214\/0x460\n       __sock_sendmsg+0x38\/0x60\n       __sys_sendto+0x113\/0x170\n       __x64_sys_sendto+0x20\/0x30\n       do_syscall_64+0x40\/0xe0\n       entry_SYSCALL_64_after_hwframe+0x46\/0x4e\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(&priv->state_lock);\n                               lock((work_completion)(&rule->arfs_work));\n                               lock(&priv->state_lock);\n  lock((work_completion)(&rule->arfs_work));\n\n *** DEADLOCK ***\n\n3 locks held by ethtool\/386089:\n #0: ffffffff82ea7210 (cb_lock){++++}-{3:3}, at: genl_rcv+0x15\/0x40\n #1: ffffffff82e94c88 (rtnl_mutex){+.+.}-{3:3}, at: ethnl_default_set_doit+0xd3\/0x240\n #2: ffff8884a1808cc0 (&priv->state_lock){+.+.}-{3:3}, at: mlx5e_ethtool_set_channels+0x53\/0x200 [mlx5_core]\n\nstack backtrace:\nCPU: 15 PID: 386089 Comm: ethtool Tainted: G          I        6.7.0-rc4_net_next_mlx5_5483eb2 #1\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04\/01\/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x60\/0xa0\n check_noncircular+0x144\/0x160\n __lock_acquire+0x17b4\/0x2c80\n lock_acquire+0xd0\/0x2b0\n ? __flush_work+0x74\/0x4e0\n ? save_trace+0x3e\/0x360\n ? __flush_work+0x74\/0x4e0\n __flush_work+0x7a\/0x4e0\n ? __flush_work+0x74\/0x4e0\n ? __lock_acquire+0xa78\/0x2c80\n ? lock_acquire+0xd0\/0x2b0\n ? mark_held_locks+0x49\/0x70\n __cancel_work_timer+0x131\/0x1c0\n ? mark_held_locks+0x49\/0x70\n arfs_del_rules+0x143\/0x1e0 [mlx5_core]\n mlx5e_arfs_disable+0x1b\/0x30 [mlx5_core]\n mlx5e_ethtool_set_channels+0xcb\/0x200 [mlx5_core]\n ethnl_set_channels+0x28f\/0x3b0\n ethnl_default_set_doit+0xec\/0x240\n genl_family_rcv_msg_doit+0xd0\/0x120\n genl_rcv_msg+0x188\/0x2c0\n ? ethn\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0080bf99499468030248ebd25dd645e487dcecdc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/46efa4d5930cf3c2af8c01f75e0a47e4fc045e3b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/48c4bb81df19402d4346032353d0795260255e3b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fef965764cf562f28afb997b626fc7c3cec99693","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27015","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:20.230","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: flowtable: incorrect pppoe tuple\n\npppoe traffic reaching ingress path does not match the flowtable entry\nbecause the pppoe header is expected to be at the network header offset.\nThis bug causes a mismatch in the flow table lookup, so pppoe packets\nenter the classical forwarding path."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4ed82dd368ad883dc4284292937b882f044e625d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6db5dc7b351b9569940cd1cf445e237c42cd6d27","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e3f078103421642fcd5f05c5e70777feb10f000d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e719b52d0c56989b0f3475a03a6d64f182c85b56","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f1c3c61701a0b12f4906152c1626a5de580ea3d2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27016","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:20.360","lastModified":"2024-05-01T13:02:20.750","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: flowtable: validate pppoe header\n\nEnsure there is sufficient room to access the protocol field of the\nPPPoe header. Validate it once before the flowtable lookup, then use a\nhelper function to access protocol field."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/87b3593bed1868b2d9fe096c01bcdf0ea86cbebf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8bf7c76a2a207ca2b4cfda0a279192adf27678d7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a2471d271042ea18e8a6babc132a8716bb2f08b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cf366ee3bc1b7d1c76a882640ba3b3f8f1039163","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d06977b9a4109f8738bb276125eb6a0b772bc433","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27017","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:20.483","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_set_pipapo: walk over current view on netlink dump\n\nThe generation mask can be updated while netlink dump is in progress.\nThe pipapo set backend walk iterator cannot rely on it to infer what\nview of the datastructure is to be used. Add notation to specify if user\nwants to read\/update the set.\n\nBased on patch from Florian Westphal."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/29b359cf6d95fd60730533f7f10464e95bd17c73","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/721715655c72640567e8742567520c99801148ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27018","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:20.600","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: br_netfilter: skip conntrack input hook for promisc packets\n\nFor historical reasons, when bridge device is in promisc mode, packets\nthat are directed to the taps follow bridge input hook path. This patch\nadds a workaround to reset conntrack for these packets.\n\nJianbo Liu reports warning splats in their test infrastructure where\ncloned packets reach the br_netfilter input hook to confirm the\nconntrack object.\n\nScratch one bit from BR_INPUT_SKB_CB to annotate that this packet has\nreached the input hook because it is passed up to the bridge device to\nreach the taps.\n\n[   57.571874] WARNING: CPU: 1 PID: 0 at net\/bridge\/br_netfilter_hooks.c:616 br_nf_local_in+0x157\/0x180 [br_netfilter]\n[   57.572749] Modules linked in: xt_MASQUERADE nf_conntrack_netlink nfnetlink iptable_nat xt_addrtype xt_conntrack nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_isc si ib_umad rdma_cm ib_ipoib iw_cm ib_cm mlx5_ib ib_uverbs ib_core mlx5ctl mlx5_core\n[   57.575158] CPU: 1 PID: 0 Comm: swapper\/1 Not tainted 6.8.0+ #19\n[   57.575700] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04\/01\/2014\n[   57.576662] RIP: 0010:br_nf_local_in+0x157\/0x180 [br_netfilter]\n[   57.577195] Code: fe ff ff 41 bd 04 00 00 00 be 04 00 00 00 e9 4a ff ff ff be 04 00 00 00 48 89 ef e8 f3 a9 3c e1 66 83 ad b4 00 00 00 04 eb 91 <0f> 0b e9 f1 fe ff ff 0f 0b e9 df fe ff ff 48 89 df e8 b3 53 47 e1\n[   57.578722] RSP: 0018:ffff88885f845a08 EFLAGS: 00010202\n[   57.579207] RAX: 0000000000000002 RBX: ffff88812dfe8000 RCX: 0000000000000000\n[   57.579830] RDX: ffff88885f845a60 RSI: ffff8881022dc300 RDI: 0000000000000000\n[   57.580454] RBP: ffff88885f845a60 R08: 0000000000000001 R09: 0000000000000003\n[   57.581076] R10: 00000000ffff1300 R11: 0000000000000002 R12: 0000000000000000\n[   57.581695] R13: ffff8881047ffe00 R14: ffff888108dbee00 R15: ffff88814519b800\n[   57.582313] FS:  0000000000000000(0000) GS:ffff88885f840000(0000) knlGS:0000000000000000\n[   57.583040] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   57.583564] CR2: 000000c4206aa000 CR3: 0000000103847001 CR4: 0000000000370eb0\n[   57.584194] DR0: 0000000000000000 DR1: 0000000000000000 DR2:\n0000000000000000\n[   57.584820] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:\n0000000000000400\n[   57.585440] Call Trace:\n[   57.585721]  <IRQ>\n[   57.585976]  ? __warn+0x7d\/0x130\n[   57.586323]  ? br_nf_local_in+0x157\/0x180 [br_netfilter]\n[   57.586811]  ? report_bug+0xf1\/0x1c0\n[   57.587177]  ? handle_bug+0x3f\/0x70\n[   57.587539]  ? exc_invalid_op+0x13\/0x60\n[   57.587929]  ? asm_exc_invalid_op+0x16\/0x20\n[   57.588336]  ? br_nf_local_in+0x157\/0x180 [br_netfilter]\n[   57.588825]  nf_hook_slow+0x3d\/0xd0\n[   57.589188]  ? br_handle_vlan+0x4b\/0x110\n[   57.589579]  br_pass_frame_up+0xfc\/0x150\n[   57.589970]  ? br_port_flags_change+0x40\/0x40\n[   57.590396]  br_handle_frame_finish+0x346\/0x5e0\n[   57.590837]  ? ipt_do_table+0x32e\/0x430\n[   57.591221]  ? br_handle_local_finish+0x20\/0x20\n[   57.591656]  br_nf_hook_thresh+0x4b\/0xf0 [br_netfilter]\n[   57.592286]  ? br_handle_local_finish+0x20\/0x20\n[   57.592802]  br_nf_pre_routing_finish+0x178\/0x480 [br_netfilter]\n[   57.593348]  ? br_handle_local_finish+0x20\/0x20\n[   57.593782]  ? nf_nat_ipv4_pre_routing+0x25\/0x60 [nf_nat]\n[   57.594279]  br_nf_pre_routing+0x24c\/0x550 [br_netfilter]\n[   57.594780]  ? br_nf_hook_thresh+0xf0\/0xf0 [br_netfilter]\n[   57.595280]  br_handle_frame+0x1f3\/0x3d0\n[   57.595676]  ? br_handle_local_finish+0x20\/0x20\n[   57.596118]  ? br_handle_frame_finish+0x5e0\/0x5e0\n[   57.596566]  __netif_receive_skb_core+0x25b\/0xfc0\n[   57.597017]  ? __napi_build_skb+0x37\/0x40\n[   57.597418]  __netif_receive_skb_list_core+0xfb\/0x220"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3f59ac29dea0921637053908fe99268d157bbb9d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/43193174510ea4f3ce09b796e559a2fd9f148615","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/751de2012eafa4d46d8081056761fa0e9cc8a178","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b13db0d16bc7b2a52abcf5cb71334f63faa5dbd6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dceb683ab87ca3666a9bb5c0158528b646faedc4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27019","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:20.743","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: Fix potential data-race in __nft_obj_type_get()\n\nnft_unregister_obj() can concurrent with __nft_obj_type_get(),\nand there is not any protection when iterate over nf_tables_objects\nlist in __nft_obj_type_get(). Therefore, there is potential data-race\nof nf_tables_objects list entry.\n\nUse list_for_each_entry_rcu() to iterate over nf_tables_objects\nlist in __nft_obj_type_get(), and use rcu_read_lock() in the caller\nnft_obj_type_get() to protect the entire type query process."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/379bf7257bc5f2a1b1ca8514e08a871b7bf6d920","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4ca946b19caf655a08d5e2266d4d5526025ebb73","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad333578f736d56920e090d7db1f8dec891d815e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d78d867dcea69c328db30df665be5be7d0148484","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df7c0fb8c2b9f9cac65659332581b19682a71349","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27020","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:20.840","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: Fix potential data-race in __nft_expr_type_get()\n\nnft_unregister_expr() can concurrent with __nft_expr_type_get(),\nand there is not any protection when iterate over nf_tables_expressions\nlist in __nft_expr_type_get(). Therefore, there is potential data-race\nof nf_tables_expressions list entry.\n\nUse list_for_each_entry_rcu() to iterate over nf_tables_expressions\nlist in __nft_expr_type_get(), and use rcu_read_lock() in the caller\nnft_expr_type_get() to protect the entire type query process."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/01f1a678b05ade4b1248019c2dcca773aebbeb7f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0b6de00206adbbfc6373b3ae38d2a6f197987907","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8d56bad42ac4c43c6c72ddd6a654a2628bf839c5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a9ebf340d123ae12582210407f879d6a5a1bc25b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f969eb84ce482331a991079ab7a5c4dc3b7f89bf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27021","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:20.960","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nr8169: fix LED-related deadlock on module removal\n\nBinding devm_led_classdev_register() to the netdev is problematic\nbecause on module removal we get a RTNL-related deadlock. Fix this\nby avoiding the device-managed LED functions.\n\nNote: We can safely call led_classdev_unregister() for a LED even\nif registering it failed, because led_classdev_unregister() detects\nthis and is a no-op in this case."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/19fa4f2a85d777a8052e869c1b892a2f7556569d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/53d986f39acd8ea11c9e460732bfa5add66360d9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27022","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T06:15:21.110","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nfork: defer linking file vma until vma is fully initialized\n\nThorvald reported a WARNING [1]. And the root cause is below race:\n\n CPU 1\t\t\t\t\tCPU 2\n fork\t\t\t\t\thugetlbfs_fallocate\n  dup_mmap\t\t\t\t hugetlbfs_punch_hole\n   i_mmap_lock_write(mapping);\n   vma_interval_tree_insert_after -- Child vma is visible through i_mmap tree.\n   i_mmap_unlock_write(mapping);\n   hugetlb_dup_vma_private -- Clear vma_lock outside i_mmap_rwsem!\n\t\t\t\t\t i_mmap_lock_write(mapping);\n   \t\t\t\t\t hugetlb_vmdelete_list\n\t\t\t\t\t  vma_interval_tree_foreach\n\t\t\t\t\t   hugetlb_vma_trylock_write -- Vma_lock is cleared.\n   tmp->vm_ops->open -- Alloc new vma_lock outside i_mmap_rwsem!\n\t\t\t\t\t   hugetlb_vma_unlock_write -- Vma_lock is assigned!!!\n\t\t\t\t\t i_mmap_unlock_write(mapping);\n\nhugetlb_dup_vma_private() and hugetlb_vm_op_open() are called outside\ni_mmap_rwsem lock while vma lock can be used in the same time.  Fix this\nby deferring linking file vma until vma is fully initialized.  Those vmas\nshould be initialized first before they can be used."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/35e351780fa9d8240dd6f7e4f245f9ea37e96c19","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/abdb88dd272bbeb93efe01d8e0b7b17e24af3a34","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-32966","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T06:15:21.277","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Static Web Server (SWS) is a tiny and fast production-ready web server suitable to serve static web files or assets. In affected versions if directory listings are enabled for a directory that an untrusted user has upload privileges for, a malicious file name like `<img src=x onerror=alert(1)>.txt` will allow JavaScript code execution in the context of the web server’s domain. SWS generally does not perform escaping of HTML entities on any values inserted in the directory listing. At the very least `file_name` and `current_path` could contain malicious data however. `file_uri` could also be malicious but the relevant scenarios seem to be all caught by hyper. For any web server that allow users to upload files or create directories under a name of their choosing this becomes a stored Cross-site Scripting vulnerability. Users are advised to upgrade. There are no known workarounds for this vulnerability."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:R\/S:C\/C:L\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":5.8,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.6,"impactScore":3.7}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-79"},{"lang":"en","value":"CWE-80"}]}],"references":[{"url":"https:\/\/github.com\/static-web-server\/static-web-server\/security\/advisories\/GHSA-rwfq-v4hq-h7fg","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-3591","sourceIdentifier":"contact@wpscan.com","published":"2024-05-01T06:15:21.887","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Geo Controller WordPress plugin before 8.6.5 unserializes user input via some of its AJAX actions and REST API routes, which could allow unauthenticated users to perform PHP Object Injection when a suitable gadget is present on the blog."}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/f85d8b61-eaeb-433c-b857-06ee4db5c7d5\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-23335","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T07:15:38.240","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"MyBB is a free and open source forum software. The backup management module of the Admin CP may accept `.htaccess` as the name of the backup file to be deleted, which may expose the stored backup files over HTTP on Apache servers. MyBB 1.8.38 resolves this issue. Users are advised to upgrade. There are no known workarounds for this vulnerability"}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:H\/UI:N\/S:U\/C:L\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":4.7,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.2,"impactScore":3.4}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-20"}]}],"references":[{"url":"https:\/\/github.com\/mybb\/mybb\/commit\/450259e501b94c9d483efb167cb2bf875605e111.patch","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/mybb\/mybb\/security\/advisories\/GHSA-94xr-g4ww-j47r","source":"security-advisories@github.com"},{"url":"https:\/\/mybb.com\/versions\/1.8.38","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-23336","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T07:15:38.660","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"MyBB is a free and open source forum software. The default list of disallowed remote hosts does not contain the `127.0.0.0\/8` block, which may result in a Server-Side Request Forgery (SSRF) vulnerability. The Configuration File's _Disallowed Remote Addresses_ list (`$config['disallowed_remote_addresses']`) contains the address `127.0.0.1`, but does not include the complete block `127.0.0.0\/8`. MyBB 1.8.38 resolves this issue in default installations. Administrators of installed boards should update the existing configuration (`inc\/config.php`) to include all addresses blocked by default. Additionally, users are advised to verify that it includes any other IPv4 addresses resolving to the server and other internal resources. Users unable to upgrade may manually add 127.0.0.0\/8' to their disallowed address list."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:L\/UI:N\/S:U\/C:L\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":5.0,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.6,"impactScore":3.4}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-184"},{"lang":"en","value":"CWE-918"}]}],"references":[{"url":"https:\/\/docs.mybb.com\/1.8\/administration\/configuration-file","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/mybb\/mybb\/commit\/d6a96019025de9149014e06b1df252e6122e5630","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/mybb\/mybb\/security\/advisories\/GHSA-qfrj-65mv-h75h","source":"security-advisories@github.com"},{"url":"https:\/\/mybb.com\/versions\/1.8.38","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-31225","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T07:15:38.977","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"RIOT is a real-time multi-threading operating system that supports a range of devices that are typically 8-bit, 16-bit and 32-bit microcontrollers. The `_on_rd_init()` function does not implement a size check before copying data to the `_result_buf` static buffer. If an attacker can craft a long enough payload, they could cause a buffer overflow. If the unchecked input above is attacker-controlled and crosses a security boundary, the impact of the buffer overflow vulnerability could range from denial of service to arbitrary code execution. This issue has yet to be patched. Users are advised to add manual bounds checking."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:R\/S:C\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":8.3,"baseSeverity":"HIGH"},"exploitabilityScore":1.6,"impactScore":6.0}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-120"}]}],"references":[{"url":"https:\/\/github.com\/RIOT-OS\/RIOT\/blob\/master\/sys\/net\/application_layer\/cord\/lc\/cord_lc.c#L218","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/RIOT-OS\/RIOT\/security\/advisories\/GHSA-2572-7q7c-3965","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-32017","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T07:15:39.280","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"RIOT is a real-time multi-threading operating system that supports a range of devices that are typically 8-bit, 16-bit and 32-bit microcontrollers. The size check in the `gcoap_dns_server_proxy_get()` function contains a small typo that may lead to a buffer overflow in the subsequent `strcpy()`. In detail, the length of the `_uri` string is checked instead of the length of the `_proxy` string. The `_gcoap_forward_proxy_copy_options()` function does not implement an explicit size check before copying data to the `cep->req_etag` buffer that is `COAP_ETAG_LENGTH_MAX` bytes long. If an attacker can craft input so that `optlen` becomes larger than `COAP_ETAG_LENGTH_MAX`, they can cause a buffer overflow. If the input above is attacker-controlled and crosses a security boundary, the impact of the buffer overflow vulnerabilities could range from denial of service to arbitrary code execution. This issue has yet to be patched. Users are advised to add manual bounds checking."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.8,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.9}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-120"}]}],"references":[{"url":"https:\/\/github.com\/RIOT-OS\/RIOT\/blob\/master\/sys\/net\/application_layer\/gcoap\/dns.c#L319-L325","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/RIOT-OS\/RIOT\/blob\/master\/sys\/net\/application_layer\/gcoap\/forward_proxy.c#L352","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/RIOT-OS\/RIOT\/security\/advisories\/GHSA-v97j-w9m6-c4h3","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-32018","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T07:15:39.590","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"RIOT is a real-time multi-threading operating system that supports a range of devices that are typically 8-bit, 16-bit and 32-bit microcontrollers. Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks. In detail, in the `nimble_scanlist_update()` function below, `len` is checked in an assertion and subsequently used in a call to `memcpy()`. If an attacker is able to provide a larger `len` value while assertions are compiled-out, they can write past the end of the fixed-length `e->ad` buffer. If the unchecked input above is attacker-controlled and crosses a security boundary, the impact of the buffer overflow vulnerability could range from denial of service to arbitrary code execution. This issue has not yet been patched. Users are advised to add manual `len` checking."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":8.8,"baseSeverity":"HIGH"},"exploitabilityScore":2.8,"impactScore":5.9}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-120"}]}],"references":[{"url":"https:\/\/github.com\/RIOT-OS\/RIOT\/blob\/master\/pkg\/nimble\/scanlist\/nimble_scanlist.c#L74-L87","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/RIOT-OS\/RIOT\/security\/advisories\/GHSA-899m-q6pp-hmp3","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-32890","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T07:15:39.900","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"librespeed\/speedtest is an open source, self-hosted speed test for HTML5. In affected versions missing neutralization of the ISP information in a speedtest result leads to stored Cross-site scripting in the JSON API. The `processedString` field in the `ispinfo` parameter is missing neutralization. It is stored when a user submits a speedtest result to the telemetry API (`results\/telemetry.php`) and returned in the JSON API (`results\/json.php`). This vulnerability has been introduced in commit 3937b94. This vulnerability affects LibreSpeed speedtest instances running version 5.2.5 or higher which have telemetry enabled and has been addressed in version 5.3.1. Users are advised to upgrade. There are no known workarounds for this vulnerability."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.1,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":2.7}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-79"}]}],"references":[{"url":"https:\/\/github.com\/librespeed\/speedtest\/commit\/3937b940e80b734acae36cd41a2a31819593e728","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/librespeed\/speedtest\/commit\/dd1ce2cb8830d94dcaa0b8e70b9406144a0e5f8d","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/librespeed\/speedtest\/security\/advisories\/GHSA-3954-xrwh-fq4q","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-32963","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T07:15:40.217","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Navidrome is an open source web-based music collection server and streamer. In affected versions of Navidrome are subject to a parameter tampering vulnerability where an attacker has the ability to manipulate parameter values in the HTTP requests. The attacker is able to change the parameter values in the body and successfully impersonate another user. In this case, the attacker created a playlist, added song, posted arbitrary comment, set the playlist to be public, and put the admin as the owner of the playlist. The attacker must be able to intercept http traffic for this attack. Each known user is impacted. An attacker can obtain the ownerId from shared playlist information, meaning every user who has shared a playlist is also impacted, as they can be impersonated. This issue has been addressed in version 0.52.0 and users are advised to upgrade. There are no known workarounds for this vulnerability.\n"}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:L\/UI:N\/S:U\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":4.2,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.6,"impactScore":2.5}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-200"}]}],"references":[{"url":"https:\/\/github.com\/navidrome\/navidrome\/security\/advisories\/GHSA-4jrx-5w4h-3gpm","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-32967","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T07:15:40.537","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Zitadel is an open source identity management system. In case ZITADEL could not connect to the database, connection information including db name, username and db host name could be returned to the user. This has been addressed in all supported release branches in a point release. There is no workaround since a patch is already available. Users are advised to upgrade."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:L\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":1.4}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-200"}]}],"references":[{"url":"https:\/\/github.com\/zitadel\/zitadel\/commit\/b918603b576d156a08b90917c14c2d019c82ffc6","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/zitadel\/zitadel\/releases\/tag\/v2.45.7","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/zitadel\/zitadel\/releases\/tag\/v2.46.7","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/zitadel\/zitadel\/releases\/tag\/v2.47.10","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/zitadel\/zitadel\/releases\/tag\/v2.48.5","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/zitadel\/zitadel\/releases\/tag\/v2.49.5","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/zitadel\/zitadel\/releases\/tag\/v2.50.3","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/zitadel\/zitadel\/security\/advisories\/GHSA-q5qj-x2h5-3945","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-32973","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T11:15:46.200","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Pluto is a superset of Lua 5.4 with a focus on general-purpose programming. In affected versions an attacker with the ability to actively intercept network traffic would be able to use a specifically-crafted certificate to fool Pluto into trusting it to be the intended remote for the TLS session. This results in the HTTP library and socket.starttls providing less transport integrity than expected. This issue has been patched in pull request #851 which has been included in version 0.9.3. Users are advised to upgrade. there are no known workarounds for this vulnerability."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:A\/AC:H\/PR:N\/UI:R\/S:U\/C:N\/I:H\/A:N","attackVector":"ADJACENT_NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"HIGH","availabilityImpact":"NONE","baseScore":4.8,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.2,"impactScore":3.6}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-284"}]}],"references":[{"url":"https:\/\/github.com\/PlutoLang\/Pluto\/pull\/851","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/PlutoLang\/Pluto\/security\/advisories\/GHSA-84hj-7j2v-w665","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-32979","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T11:15:47.407","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Nautobot is a Network Source of Truth and Network Automation Platform built as a web application atop the Django Python framework with a PostgreSQL or MySQL database. It was discovered that due to improper handling and escaping of user-provided query parameters, a maliciously crafted Nautobot URL could potentially be used to execute a Reflected Cross-Site Scripting (Reflected XSS) attack against users. All filterable object-list views in Nautobot are vulnerable. This issue has been fixed in Nautobot versions 1.6.20 and 2.2.3. There are no known workarounds for this vulnerability.\n"}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:R\/S:C\/C:L\/I:H\/A:L","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"HIGH","availabilityImpact":"LOW","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":1.6,"impactScore":5.3}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-79"}]}],"references":[{"url":"https:\/\/github.com\/nautobot\/nautobot\/commit\/42440ebd9b381534ad89d62420ebea00d703d64e","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/nautobot\/nautobot\/pull\/5646","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/nautobot\/nautobot\/pull\/5647","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/nautobot\/nautobot\/security\/advisories\/GHSA-jxgr-gcj5-cqqg","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-32984","sourceIdentifier":"security-advisories@github.com","published":"2024-05-01T11:15:47.633","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Yamux is a stream multiplexer over reliable, ordered connections such as TCP\/IP. The Rust implementation of the Yamux stream multiplexer uses a vector for pending frames. This vector is not bounded in length. Every time the Yamux protocol requires sending of a new frame, this frame gets appended to this vector. This can be remotely triggered in a number of ways, for example by: 1. Opening a new libp2p Identify stream. This causes the node to send its Identify message. Of course, every other protocol that causes the sending of data also works. The larger the response, the more data is enqueued. 2. Sending a Yamux Ping frame. This causes a Pong frame to be enqueued. Under normal circumstances, this queue of pending frames would be drained once they’re sent out over the network. However, the attacker can use TCP’s receive window mechanism to prevent the victim from sending out any data: By not reading from the TCP connection, the receive window will never be increased, and the victim won’t be able to send out any new data (this is how TCP implements backpressure). Once this happens, Yamux’s queue of pending frames will start growing indefinitely. The queue will only be drained once the underlying TCP connection is closed. An attacker can cause a remote node to run out of memory, which will result in the corresponding process getting terminated by the operating system.\n"}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":3.6}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-400"}]}],"references":[{"url":"https:\/\/github.com\/libp2p\/rust-yamux\/blob\/yamux-v0.13.1\/yamux\/src\/connection.rs#L289","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/libp2p\/rust-yamux\/security\/advisories\/GHSA-3999-5ffv-wp2r","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/sigp\/rust-yamux\/commit\/6689e227a48258a52347cd1d984adfc94afc6f7a","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-33835","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T11:15:47.827","lastModified":"2024-05-01T13:01:51.263","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Tenda AC18 V15.03.05.05 has a stack overflow vulnerability in the remoteIp parameter from formSetSafeWanWebMan function."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/isBigChen\/iot\/blob\/main\/tenda\/formSetSafeWanWebMan.md","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2022-38386","sourceIdentifier":"psirt@us.ibm.com","published":"2024-05-01T13:15:47.960","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"IBM Cloud Pak for Security (CP4S) 1.10.0.0 through 1.10.11.0 and IBM QRadar Suite for Software 1.10.12.0 through 1.10.19.0 does not set the SameSite attribute for sensitive cookies which could allow an attacker to obtain sensitive information using man-in-the-middle techniques.  IBM X-Force ID:  233778."},{"lang":"es","value":"IBM Cloud Pak for Security (CP4S) 1.10.0.0 a 1.10.11.0 e IBM QRadar Suite for Software 1.10.12.0 a 1.10.19.0 no configuran el atributo SameSite para cookies confidenciales que podrían permitir a un atacante obtener información confidencial mediante técnicas man-in-the-middle. ID de IBM X-Force: 233778."}],"metrics":{"cvssMetricV31":[{"source":"psirt@us.ibm.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:N\/S:U\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":5.9,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.2,"impactScore":3.6}]},"weaknesses":[{"source":"psirt@us.ibm.com","type":"Primary","description":[{"lang":"en","value":"CWE-1275"}]}],"references":[{"url":"https:\/\/exchange.xforce.ibmcloud.com\/vulnerabilities\/233778","source":"psirt@us.ibm.com"},{"url":"https:\/\/www.ibm.com\/support\/pages\/node\/7149811","source":"psirt@us.ibm.com"}]}},{"cve":{"id":"CVE-2022-48669","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.220","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc\/pseries: Fix potential memleak in papr_get_attr()\n\n`buf` is allocated in papr_get_attr(), and krealloc() of `buf`\ncould fail. We need to free the original `buf` in the case of failure."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: powerpc\/pseries: corrija una posible fuga de mem en papr_get_attr() `buf` está asignado en papr_get_attr(), y krealloc() de `buf` podría fallar. Necesitamos liberar el \"buf\" original en caso de falla."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1699fb915b9f61794d559b55114c09a390aaf234","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7f7d39fe3d80d6143404940b2413010cf6527029","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a3f22feb2220a945d1c3282e34199e8bcdc5afc4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cda9c0d556283e2d4adaa9960b2dc19b16156bae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0647c3e81eff62b66d46fd4e475318cb8cb3610","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52649","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.280","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/vkms: Avoid reading beyond LUT array\n\nWhen the floor LUT index (drm_fixp2int(lut_index) is the last\nindex of the array the ceil LUT index will point to an entry\nbeyond the array. Make sure we guard against it and use the\nvalue of the floor LUT index.\n\nv3:\n - Drop bits from commit description that didn't contribute\n   anything of value"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/vkms: Evite leer más allá de la matriz LUT Cuando el índice LUT de piso (drm_fixp2int(lut_index) es el último índice de la matriz, el índice LUT de techo apuntará a una entrada más allá de la matriz Asegúrese de protegernos contra esto y usar el valor del índice LUT de piso v3: - Elimine los bits de la descripción de confirmación que no contribuyeron con nada de valor."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/046c1184ce60b0a37d48134f17ddbc1f32ce02bd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2fee84030d12d9fddfa874e4562d71761a129277","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/92800aaeff51b8358d1e0a7eb74daf8aa2d7ce9d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9556c167673057d48ce4a0da675026fe046654c1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52650","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.323","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/tegra: dsi: Add missing check for of_find_device_by_node\n\nAdd check for the return value of of_find_device_by_node() and return\nthe error if it fails in order to avoid NULL pointer dereference."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/tegra: dsi: Agregar verificación faltante para of_find_device_by_node Agregue verificación para el valor de retorno de of_find_device_by_node() y devuelva el error si falla para evitar la desreferencia al puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3169eaf1365541fd8e521091010c44fbe14691fc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/47a13d0b9d8527518639ab5c39667f69d6203e80","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/50c0ad785a780c72a2fdaba10b38c645ffb4eae6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/52aa507148c4aad41436e2005d742ffcafad9976","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/92003981a6df5dc84af8a5904f8ee112fa324129","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/93128052bf832359531c3c0a9e3567b2b8682a2d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/afe6fcb9775882230cd29b529203eabd5d2a638d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c5d2342d24ef6e08fc90a529fe3dc59de421a2b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f05631a8525c3b5e5994ecb1304d2d878956c0f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52651","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.377","lastModified":"2024-05-02T10:15:07.500","vulnStatus":"Rejected","descriptions":[{"lang":"en","value":"Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority."}],"metrics":{},"references":[]}},{"cve":{"id":"CVE-2023-52652","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.427","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nNTB: fix possible name leak in ntb_register_device()\n\nIf device_register() fails in ntb_register_device(), the device name\nallocated by dev_set_name() should be freed. As per the comment in\ndevice_register(), callers should use put_device() to give up the\nreference in the error path. So fix this by calling put_device() in the\nerror path so that the name can be freed in kobject_cleanup().\n\nAs a result of this, put_device() in the error path of\nntb_register_device() is removed and the actual error is returned.\n\n[mani: reworded commit message]"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: NTB: corrige una posible fuga de nombre en ntb_register_device() Si device_register() falla en ntb_register_device(), se debe liberar el nombre del dispositivo asignado por dev_set_name(). Según el comentario en device_register(), las personas que llaman deben usar put_device() para abandonar la referencia en la ruta de error. Así que solucione este problema llamando a put_device() en la ruta del error para que el nombre pueda liberarse en kobject_cleanup(). Como resultado de esto, put_device() en la ruta de error de ntb_register_device() se elimina y se devuelve el error real. [mani: mensaje de confirmación reformulado]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6632a54ac8057cc0b0d789c6f73883e871bcd25c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/913421f9f7fd8324dcc41753d0f28b52e177ef04","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a039690d323221eb5865f1f31db3ec264e7a14b6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a62b9f3d7bbfac874cc0c638bc1776dcf1f8ec06","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aebfdfe39b9327a3077d0df8db3beb3160c9bdd0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e8025439ef8e16029dc313d78a351ef192469b7b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52653","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.470","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nSUNRPC: fix a memleak in gss_import_v2_context\n\nThe ctx->mech_used.data allocated by kmemdup is not freed in neither\ngss_import_v2_context nor it only caller gss_krb5_import_sec_context,\nwhich frees ctx on error.\n\nThus, this patch reform the last call of gss_import_v2_context to the\ngss_krb5_import_ctx_v2, preventing the memleak while keepping the return\nformation."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: SUNRPC: corrige una fuga de memport en gss_import_v2_context El ctx-&gt;mech_used.data asignado por kmemdup no se libera ni en gss_import_v2_context ni solo en el llamador gss_krb5_import_sec_context, lo que libera a ctx en caso de error. Por lo tanto, este parche reforma la última llamada de gss_import_v2_context a gss_krb5_import_ctx_v2, evitando la fuga de memoria y manteniendo la formación de retorno."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/47ac11db93e74ac49cd6c3fc69bcbc5964c4a8b4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/99044c01ed5329e73651c054d8a4baacdbb1a27c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d111e30d9cd846bb368faf3637dc0f71fcbcf822","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e67b652d8e8591d3b1e569dbcdfcee15993e91fa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-0334","sourceIdentifier":"security@wordfence.com","published":"2024-05-01T13:15:48.517","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Jeg Elementor Kit plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the custom attribute of a link in several Elementor widgets in all versions up to, and including, 2.6.4 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":"El complemento Jeg Elementor Kit para WordPress es vulnerable a Cross-Site Scripting Almacenado a través del atributo personalizado de un enlace en varios widgets de Elementor en todas las versiones hasta la 2.6.4 incluida debido a una sanitización de entrada insuficiente y a un escape de salida en los atributos proporcionados por el usuario. Esto hace posible que atacantes autenticados, con acceso de nivel de colaborador y superior, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3077328\/jeg-elementor-kit","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/950e9042-1364-4200-8f57-171346075764?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-23597","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-01T13:15:48.693","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Cross-site request forgery (CSRF) vulnerability exists in TvRock 0.9t8a. If a logged-in user of TVRock accesses a specially crafted page, unintended operations may be performed. Note that the developer was unreachable, therefore, users should consider stop using TvRock 0.9t8a."},{"lang":"es","value":"Existe una vulnerabilidad de Cross-Site Request Forgery (CSRF) en TvRock 0.9t8a. Si un usuario de TVRock que ha iniciado sesión accede a una página especialmente manipulada, se pueden realizar operaciones no deseadas. Tenga en cuenta que el desarrollador era inalcanzable, por lo tanto, los usuarios deberían considerar dejar de usar TvRock 0.9t8a."}],"metrics":{},"references":[{"url":"https:\/\/jvn.jp\/en\/jp\/JVN24683352\/","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-24978","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-01T13:15:48.753","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Denial-of-service (DoS) vulnerability exists in TvRock 0.9t8a. Receiving a specially crafted request by a remote attacker or having a user of TvRock click a specially crafted request may lead to ABEND (abnormal end). Note that the developer was unreachable, therefore, users should consider stop using TvRock 0.9t8a."},{"lang":"es","value":"Existe una vulnerabilidad de denegación de servicio (DoS) en TvRock 0.9t8a. Recibir una solicitud especialmente manipulada por un atacante remoto o hacer que un usuario de TvRock haga clic en una solicitud especialmente manipulada puede provocar ABEND (final anormal). Tenga en cuenta que el desarrollador era inalcanzable, por lo tanto, los usuarios deberían considerar dejar de usar TvRock 0.9t8a."}],"metrics":{},"references":[{"url":"https:\/\/jvn.jp\/en\/jp\/JVN40079147\/","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-27023","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.797","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmd: Fix missing release of 'active_io' for flush\n\nsubmit_flushes\n atomic_set(&mddev->flush_pending, 1);\n rdev_for_each_rcu(rdev, mddev)\n  atomic_inc(&mddev->flush_pending);\n  bi->bi_end_io = md_end_flush\n  submit_bio(bi);\n                        \/* flush io is done first *\/\n                        md_end_flush\n                         if (atomic_dec_and_test(&mddev->flush_pending))\n                          percpu_ref_put(&mddev->active_io)\n                          -> active_io is not released\n\n if (atomic_dec_and_test(&mddev->flush_pending))\n  -> missing release of active_io\n\nFor consequence, mddev_suspend() will wait for 'active_io' to be zero\nforever.\n\nFix this problem by releasing 'active_io' in submit_flushes() if\n'flush_pending' is decreased to zero."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: md: Se corrigió la versión faltante de 'active_io' para descarga submit_flushes atomic_set(&amp;mddev-&gt;flush_pending, 1); rdev_for_each_rcu(rdev, mddev) atomic_inc(&amp;mddev-&gt;flush_pending); bi-&gt;bi_end_io = md_end_flush submit_bio(bi); \/* purgar io se realiza primero *\/ md_end_flush if (atomic_dec_and_test(&amp;mddev-&gt;flush_pending)) percpu_ref_put(&amp;mddev-&gt;active_io) -&gt; active_io no se publica si (atomic_dec_and_test(&amp;mddev-&gt;flush_pending)) -&gt; falta la versión de active_io para Como consecuencia, mddev_suspend() esperará a que 'active_io' sea cero para siempre. Solucione este problema liberando 'active_io' en submit_flushes() si 'flush_pending' se reduce a cero."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/02dad157ba11064d073f5499dc33552b227d5d3a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/11f81438927f84edfaaeb5d5f10856c3a1c1fc82","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6b2ff10390b19a2364af622b6666b690443f9f3f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/855678ed8534518e2b428bcbcec695de9ba248e8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27024","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.847","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/rds: fix WARNING in rds_conn_connect_if_down\n\nIf connection isn't established yet, get_mr() will fail, trigger connection after\nget_mr()."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: net\/rds: solucione la ADVERTENCIA en rds_conn_connect_if_down Si la conexión aún no se ha establecido, get_mr() fallará, activará la conexión después de get_mr()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2b505d05280739ce31d5708da840f42df827cb85","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/786854141057751bc08eb26f1b02e97c1631c8f4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/907761307469adecb02461a14120e9a1812a5fb1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/997efea2bf3a4adb96c306b9ad6a91442237bf5b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/998fd719e6d6468b930ac0c44552ea9ff8b07b80","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9dfc15a10dfd44f8ff7f27488651cb5be6af83c2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b562ebe21ed9adcf42242797dd6cb75beef12bf0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c055fc00c07be1f0df7375ab0036cebd1106ed38","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27025","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.890","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: null check for nla_nest_start\n\nnla_nest_start() may fail and return NULL. Insert a check and set errno\nbased on other call sites within the same source code."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nbd: la comprobación nula de nla_nest_start nla_nest_start() puede fallar y devolver NULL. Inserte una marca y establezca errno según otros sitios de llamadas dentro del mismo código fuente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/31edf4bbe0ba27fd03ac7d87eb2ee3d2a231af6d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/44214d744be32a4769faebba764510888f1eb19e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4af837db0fd3679fabc7b7758397090b0c06dced","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/96436365e5d80d0106ea785a4f80a58e7c9edff8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/98e60b538e66c90b9a856828c71d4e975ebfa797","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7f5aed55829f376e4f7e5ea5b80ccdcb023e983","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ba6a9970ce9e284cbc04099361c58731e308596a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e803040b368d046434fbc8a91945c690332c4fcf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27026","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.940","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nvmxnet3: Fix missing reserved tailroom\n\nUse rbi->len instead of rcd->len for non-dataring packet.\n\nFound issue:\n  XDP_WARN: xdp_update_frame_from_buff(line:278): Driver BUG: missing reserved tailroom\n  WARNING: CPU: 0 PID: 0 at net\/core\/xdp.c:586 xdp_warn+0xf\/0x20\n  CPU: 0 PID: 0 Comm: swapper\/0 Tainted: G        W  O       6.5.1 #1\n  RIP: 0010:xdp_warn+0xf\/0x20\n  ...\n  ? xdp_warn+0xf\/0x20\n  xdp_do_redirect+0x15f\/0x1c0\n  vmxnet3_run_xdp+0x17a\/0x400 [vmxnet3]\n  vmxnet3_process_xdp+0xe4\/0x760 [vmxnet3]\n  ? vmxnet3_tq_tx_complete.isra.0+0x21e\/0x2c0 [vmxnet3]\n  vmxnet3_rq_rx_complete+0x7ad\/0x1120 [vmxnet3]\n  vmxnet3_poll_rx_only+0x2d\/0xa0 [vmxnet3]\n  __napi_poll+0x20\/0x180\n  net_rx_action+0x177\/0x390"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: vmxnet3: corrige la falta de espacio reservado. Use rbi-&gt;len en lugar de rcd-&gt;len para paquetes que no son de datos. Problema encontrado: XDP_WARN: xdp_update_frame_from_buff(line:278): ERROR del controlador: falta el cuarto de cola reservado ADVERTENCIA: CPU: 0 PID: 0 en net\/core\/xdp.c:586 xdp_warn+0xf\/0x20 CPU: 0 PID: 0 Comm: swapper \/0 Contaminado: GWO 6.5.1 #1 RIP: 0010:xdp_warn+0xf\/0x20 ... ? xdp_warn+0xf\/0x20 xdp_do_redirect+0x15f\/0x1c0 vmxnet3_run_xdp+0x17a\/0x400 [vmxnet3] vmxnet3_process_xdp+0xe4\/0x760 [vmxnet3] ? vmxnet3_tq_tx_complete.isra.0+0x21e\/0x2c0 [vmxnet3] vmxnet3_rq_rx_complete+0x7ad\/0x1120 [vmxnet3] vmxnet3_poll_rx_only+0x2d\/0xa0 [vmxnet3] __napi_poll+0x20\/0x180 net_rx_action+0x177\/ 0x390"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7c8505ecc2d15473d679b8e06335434b84fffe86","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/91d017d19d5a9ad153e2dc23ed3c0e2e79ef5262","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aba8659caf88017507419feea06069f529329ea6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e127ce7699c1e05279ee5ee61f00893e7bfa9671","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27027","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:48.987","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndpll: fix dpll_xa_ref_*_del() for multiple registrations\n\nCurrently, if there are multiple registrations of the same pin on the\nsame dpll device, following warnings are observed:\nWARNING: CPU: 5 PID: 2212 at drivers\/dpll\/dpll_core.c:143 dpll_xa_ref_pin_del.isra.0+0x21e\/0x230\nWARNING: CPU: 5 PID: 2212 at drivers\/dpll\/dpll_core.c:223 __dpll_pin_unregister+0x2b3\/0x2c0\n\nThe problem is, that in both dpll_xa_ref_dpll_del() and\ndpll_xa_ref_pin_del() registration is only removed from list in case the\nreference count drops to zero. That is wrong, the registration has to\nbe removed always.\n\nTo fix this, remove the registration from the list and free\nit unconditionally, instead of doing it only when the ref reference\ncounter reaches zero."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: dpll: corrige dpll_xa_ref_*_del() para múltiples registros Actualmente, si hay múltiples registros del mismo pin en el mismo dispositivo dpll, se observan las siguientes advertencias: ADVERTENCIA: CPU: 5 PID: 2212 en drivers\/dpll\/dpll_core.c:143 dpll_xa_ref_pin_del.isra.0+0x21e\/0x230 ADVERTENCIA: CPU: 5 PID: 2212 en drivers\/dpll\/dpll_core.c:223 __dpll_pin_unregister+0x2b3\/0x2c0 El problema es que Tanto en dpll_xa_ref_dpll_del() como en dpll_xa_ref_pin_del() el registro solo se elimina de la lista en caso de que el recuento de referencias caiga a cero. Eso está mal, siempre hay que eliminar el registro. Para solucionar este problema, elimine el registro de la lista y libérelo incondicionalmente, en lugar de hacerlo sólo cuando el contador de referencia de referencia llegue a cero."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/769324eb35143462542cdb15483cdaf4877bf661","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b27e32e9367dac024cd6f61f22655714f483fd67","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b446631f355ece73b13c311dd712c47381a23172","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27028","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.030","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nspi: spi-mt65xx: Fix NULL pointer access in interrupt handler\n\nThe TX buffer in spi_transfer can be a NULL pointer, so the interrupt\nhandler may end up writing to the invalid memory and cause crashes.\n\nAdd a check to trans->tx_buf before using it."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: spi: spi-mt65xx: corrige el acceso al puntero NULL en el controlador de interrupciones. El búfer TX en spi_transfer puede ser un puntero NULL, por lo que el controlador de interrupciones puede terminar escribiendo en la memoria no válida y causar accidentes. Agregue una marca a trans-&gt;tx_buf antes de usarlo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1784053cf10a14c4ebd8a890bad5cfe1bee51713","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2342b05ec5342a519e00524a507f7a6ea6791a38","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/55f8ea6731aa64871ee6aef7dba53ee9f9f3b2f6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/62b1f837b15cf3ec2835724bdf8577e47d14c753","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/766ec94cc57492eab97cbbf1595bd516ab0cb0e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a20ad45008a7c82f1184dc6dee280096009ece55","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bcfcdf19698024565eff427706ebbd8df65abd11","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bea82355df9e1c299625405b1947fc9b26b4c6d4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c10fed329c1c104f375a75ed97ea3abef0786d62","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27029","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.083","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu: fix mmhub client id out-of-bounds access\n\nProperly handle cid 0x140."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amdgpu: corrige el acceso fuera de los límites del ID del cliente mmhub. Maneja correctamente el cid 0x140."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1f24b3040f2b6ffcb97151fabb3070328254d923","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6540ff6482c1a5a6890ae44b23d0852ba1986d9e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e1e076bda4fd6378ae650f2c6ef1a4ff93c5aea5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27030","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.137","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nocteontx2-af: Use separate handlers for interrupts\n\nFor PF to AF interrupt vector and VF to AF vector same\ninterrupt handler is registered which is causing race condition.\nWhen two interrupts are raised to two CPUs at same time\nthen two cores serve same event corrupting the data."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: octeontx2-af: utilice controladores separados para las interrupciones. Para el vector de interrupción PF a AF y el vector VF a AF, se registra el mismo controlador de interrupciones, lo que provoca la condición de ejecución. Cuando se generan dos interrupciones en dos CPU al mismo tiempo, dos núcleos atienden el mismo evento y corrompen los datos."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/29d2550d79a8cbd31e0fbaa5c0e2a2efdc444e44","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4fedae8f9eafa2ac8cdaca58e315f52a7e2a8701","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/50e60de381c342008c0956fd762e1c26408f372c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/766c2627acb2d9d1722cce2e24837044d52d888a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/772f18ded0e240cc1fa2b7020cc640e3e5c32b70","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/94cb17e5cf3a3c484063abc0ce4b8a2b2e8c1cb2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad6759e233db6fcc131055f8e23b4eafbe81053c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dc29dd00705a62c77de75b6d752259b869aac49d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27031","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.180","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix nfs_netfs_issue_read() xarray locking for writeback interrupt\n\nThe loop inside nfs_netfs_issue_read() currently does not disable\ninterrupts while iterating through pages in the xarray to submit\nfor NFS read.  This is not safe though since after taking xa_lock,\nanother page in the mapping could be processed for writeback inside\nan interrupt, and deadlock can occur.  The fix is simple and clean\nif we use xa_for_each_range(), which handles the iteration with RCU\nwhile reducing code complexity.\n\nThe problem is easily reproduced with the following test:\n mount -o vers=3,fsc 127.0.0.1:\/export \/mnt\/nfs\n dd if=\/dev\/zero of=\/mnt\/nfs\/file1.bin bs=4096 count=1\n echo 3 > \/proc\/sys\/vm\/drop_caches\n dd if=\/mnt\/nfs\/file1.bin of=\/dev\/null\n umount \/mnt\/nfs\n\nOn the console with a lockdep-enabled kernel a message similar to\nthe following will be seen:\n\n ================================\n WARNING: inconsistent lock state\n 6.7.0-lockdbg+ #10 Not tainted\n --------------------------------\n inconsistent {IN-SOFTIRQ-W} -> {SOFTIRQ-ON-W} usage.\n test5\/1708 [HC0[0]:SC0[0]:HE1:SE1] takes:\n ffff888127baa598 (&xa->xa_lock#4){+.?.}-{3:3}, at:\nnfs_netfs_issue_read+0x1b2\/0x4b0 [nfs]\n {IN-SOFTIRQ-W} state was registered at:\n   lock_acquire+0x144\/0x380\n   _raw_spin_lock_irqsave+0x4e\/0xa0\n   __folio_end_writeback+0x17e\/0x5c0\n   folio_end_writeback+0x93\/0x1b0\n   iomap_finish_ioend+0xeb\/0x6a0\n   blk_update_request+0x204\/0x7f0\n   blk_mq_end_request+0x30\/0x1c0\n   blk_complete_reqs+0x7e\/0xa0\n   __do_softirq+0x113\/0x544\n   __irq_exit_rcu+0xfe\/0x120\n   irq_exit_rcu+0xe\/0x20\n   sysvec_call_function_single+0x6f\/0x90\n   asm_sysvec_call_function_single+0x1a\/0x20\n   pv_native_safe_halt+0xf\/0x20\n   default_idle+0x9\/0x20\n   default_idle_call+0x67\/0xa0\n   do_idle+0x2b5\/0x300\n   cpu_startup_entry+0x34\/0x40\n   start_secondary+0x19d\/0x1c0\n   secondary_startup_64_no_verify+0x18f\/0x19b\n irq event stamp: 176891\n hardirqs last  enabled at (176891): [<ffffffffa67a0be4>]\n_raw_spin_unlock_irqrestore+0x44\/0x60\n hardirqs last disabled at (176890): [<ffffffffa67a0899>]\n_raw_spin_lock_irqsave+0x79\/0xa0\n softirqs last  enabled at (176646): [<ffffffffa515d91e>]\n__irq_exit_rcu+0xfe\/0x120\n softirqs last disabled at (176633): [<ffffffffa515d91e>]\n__irq_exit_rcu+0xfe\/0x120\n\n other info that might help us debug this:\n  Possible unsafe locking scenario:\n\n        CPU0\n        ----\n   lock(&xa->xa_lock#4);\n   <Interrupt>\n     lock(&xa->xa_lock#4);\n\n  *** DEADLOCK ***\n\n 2 locks held by test5\/1708:\n  #0: ffff888127baa498 (&sb->s_type->i_mutex_key#22){++++}-{4:4}, at:\n      nfs_start_io_read+0x28\/0x90 [nfs]\n  #1: ffff888127baa650 (mapping.invalidate_lock#3){.+.+}-{4:4}, at:\n      page_cache_ra_unbounded+0xa4\/0x280\n\n stack backtrace:\n CPU: 6 PID: 1708 Comm: test5 Kdump: loaded Not tainted 6.7.0-lockdbg+\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-1.fc39\n04\/01\/2014\n Call Trace:\n  dump_stack_lvl+0x5b\/0x90\n  mark_lock+0xb3f\/0xd20\n  __lock_acquire+0x77b\/0x3360\n  _raw_spin_lock+0x34\/0x80\n  nfs_netfs_issue_read+0x1b2\/0x4b0 [nfs]\n  netfs_begin_read+0x77f\/0x980 [netfs]\n  nfs_netfs_readahead+0x45\/0x60 [nfs]\n  nfs_readahead+0x323\/0x5a0 [nfs]\n  read_pages+0xf3\/0x5c0\n  page_cache_ra_unbounded+0x1c8\/0x280\n  filemap_get_pages+0x38c\/0xae0\n  filemap_read+0x206\/0x5e0\n  nfs_file_read+0xb7\/0x140 [nfs]\n  vfs_read+0x2a9\/0x460\n  ksys_read+0xb7\/0x140"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: NFS: corrige el bloqueo de matriz x de nfs_netfs_issue_read() para interrupción de escritura regresiva. El bucle dentro de nfs_netfs_issue_read() actualmente no deshabilita las interrupciones mientras se itera a través de páginas en la matriz x para enviarlas a lectura NFS. Sin embargo, esto no es seguro ya que después de tomar xa_lock, otra página en el mapeo podría procesarse para reescritura dentro de una interrupción, y puede ocurrir un punto muerto. La solución es simple y limpia si usamos xa_for_each_range(), que maneja la iteración con RCU mientras reduce la complejidad del código. El problema se reproduce fácilmente con la siguiente prueba: mount -o vers=3,fsc 127.0.0.1:\/export \/mnt\/nfs dd if=\/dev\/zero of=\/mnt\/nfs\/file1.bin bs=4096 count= 1 echo 3 &gt; \/proc\/sys\/vm\/drop_caches dd if=\/mnt\/nfs\/file1.bin of=\/dev\/null umount \/mnt\/nfs En la consola con un kernel habilitado para lockdep aparecerá un mensaje similar al siguiente ser visto: ================================ ADVERTENCIA: estado de bloqueo inconsistente 6.7.0-lockdbg+ #10 No contaminado - ------------------------------- Uso inconsistente de {IN-SOFTIRQ-W} -&gt; {SOFTIRQ-ON-W}. test5\/1708 [HC0[0]:SC0[0]:HE1:SE1] toma: ffff888127baa598 (&amp;xa-&gt;xa_lock#4){+.?.}-{3:3}, en: nfs_netfs_issue_read+0x1b2\/0x4b0 [ nfs] El estado {IN-SOFTIRQ-W} se registró en: lock_acquire+0x144\/0x380 _raw_spin_lock_irqsave+0x4e\/0xa0 __folio_end_writeback+0x17e\/0x5c0 folio_end_writeback+0x93\/0x1b0 iomap_finish_ioend+0xeb\/0x6a0 blk_update_request+ 0x204\/0x7f0 blk_mq_end_request+0x30\/0x1c0 blk_complete_reqs +0x7e\/0xa0 __do_softirq+0x113\/0x544 __irq_exit_rcu+0xfe\/0x120 irq_exit_rcu+0xe\/0x20 sysvec_call_function_single+0x6f\/0x90 asm_sysvec_call_function_single+0x1a\/0x20 +0xf\/0x20 default_idle+0x9\/0x20 default_idle_call+0x67\/0xa0 do_idle+0x2b5\/0x300 cpu_startup_entry +0x34\/0x40 start_secondary+0x19d\/0x1c0 second_startup_64_no_verify+0x18f\/0x19b sello de evento irq: 176891 hardirqs habilitado por última vez en (176891): [] _raw_spin_unlock_irqrestore+0x44\/0x60 hardirqs deshabilitado por última vez en ( 176890): [] _raw_spin_lock_irqsave+0x79\/0xa0 softirqs habilitado por última vez en (176646): [] __irq_exit_rcu+0xfe\/0x120 softirqs deshabilitado por última vez en (176633): [] __irq_exit_rcu+0xfe\/0x120 Otra información que podría ayudarnos a depurar esto: Posible escenario de bloqueo inseguro: CPU0 ---- lock(&amp;xa-&gt;xa_lock#4);  bloqueo(&amp;xa-&gt;xa_lock#4); *** DEADLOCK *** 2 bloqueos mantenidos por test5\/1708: #0: ffff888127baa498 (&amp;sb-&gt;s_type-&gt;i_mutex_key#22){++++}-{4:4}, en: nfs_start_io_read+0x28\/0x90 [nfs] #1: ffff888127baa650 (mapping.invalidate_lock#3){.+.+}-{4:4}, en: page_cache_ra_unbounded+0xa4\/0x280 seguimiento de pila: CPU: 6 PID: 1708 Comm: test5 Kdump: cargado No tainted 6.7.0-lockdbg+ Nombre del hardware: PC estándar QEMU (Q35 + ICH9, 2009), BIOS 1.16.3-1.fc39 01\/04\/2014 Seguimiento de llamadas: dump_stack_lvl+0x5b\/0x90 mark_lock+0xb3f\/0xd20 __lock_acquire+0x77b\/ 0x3360 _raw_spin_lock+0x34\/0x80 nfs_netfs_issue_read+0x1b2\/0x4b0 [nfs] netfs_begin_read+0x77f\/0x980 [netfs] nfs_netfs_readahead+0x45\/0x60 [nfs_readahead+0x323\/0x5 a0 [nfs] read_pages+0xf3\/0x5c0 page_cache_ra_unbounded+0x1c8\/0x280 filemap_get_pages+ 0x38c\/0xae0 filemap_read+0x206\/0x5e0 nfs_file_read+0xb7\/0x140 [nfs] vfs_read+0x2a9\/0x460 ksys_read+0xb7\/0x140"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/8a2e5977cecd3cde6a0e3e86b7b914d00240e5dc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8df1678c021ffeb20ef8a203bd9413f3ed9b0e9a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad27382f8495f8ef6d2c66c413d756bfd13c0598","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fd5860ab6341506004219b080aea40213b299d2e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27032","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.230","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to avoid potential panic during recovery\n\nDuring recovery, if FAULT_BLOCK is on, it is possible that\nf2fs_reserve_new_block() will return -ENOSPC during recovery,\nthen it may trigger panic.\n\nAlso, if fault injection rate is 1 and only FAULT_BLOCK fault\ntype is on, it may encounter deadloop in loop of block reservation.\n\nLet's change as below to fix these issues:\n- remove bug_on() to avoid panic.\n- limit the loop count of block reservation to avoid potential\ndeadloop."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: f2fs: corrección para evitar un posible pánico durante la recuperación. Durante la recuperación, si FAULT_BLOCK está activado, es posible que f2fs_reserve_new_block() devuelva -ENOSPC durante la recuperación, lo que puede provocar pánico. Además, si la tasa de inyección de fallas es 1 y solo el tipo de falla FAULT_BLOCK está activado, es posible que se produzca un bucle muerto en el bucle de reserva de bloque. Cambiemos como se muestra a continuación para solucionar estos problemas: - elimine bug_on() para evitar el pánico. - limitar el número de bucles de reserva de bloques para evitar posibles bucles muertos."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/21ec68234826b1b54ab980a8df6e33c74cfbee58","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8844b2f8a3f0c428b74672f9726f9950b1a7764c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d034810d02a5af8eb74debe29877dcaf5f00fdd1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f26091a981318b5b7451d61f99bc073a6af8db67","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fe4de493572a4263554903bf9c3afc5c196e15f0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27033","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.273","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to remove unnecessary f2fs_bug_on() to avoid panic\n\nverify_blkaddr() will trigger panic once we inject fault into\nf2fs_is_valid_blkaddr(), fix to remove this unnecessary f2fs_bug_on()."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: f2fs: solución para eliminar f2fs_bug_on() innecesario para evitar el pánico. verificar_blkaddr() provocará pánico una vez que inyectemos el error en f2fs_is_valid_blkaddr(), solución para eliminar este f2fs_bug_on() innecesario."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0386408036bfc8b50296d9e544ff91c4d52af2db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6633cdc8b2ebefcddcfcdacfd063105e60f39a49","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/abe98a05e7162f64759bf9111108ebcb11322dec","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b896e302f79678451a94769ddd9e52e954c64fbb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27034","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.317","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: compress: fix to cover normal cluster write with cp_rwsem\n\nWhen we overwrite compressed cluster w\/ normal cluster, we should\nnot unlock cp_rwsem during f2fs_write_raw_pages(), otherwise data\nwill be corrupted if partial blocks were persisted before CP & SPOR,\ndue to cluster metadata wasn't updated atomically."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: f2fs: compress: corrección para cubrir la escritura normal del clúster con cp_rwsem Cuando sobrescribimos el clúster comprimido con el clúster normal, no debemos desbloquear cp_rwsem durante f2fs_write_raw_pages(); de lo contrario, los datos se dañarán si Los bloques parciales persistieron antes de CP y SPOR, debido a que los metadatos del clúster no se actualizaron atómicamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2b1b14d9fc94b8feae20808684c8af28ec80f45b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/52982edfcefd475cc34af663d5c47c0cddaa5739","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/542c8b3c774a480bfd0804291a12f6f2391b0cd1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/75abfd61392b1db391bde6d738a30d685b843286","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7d420eaaa18ec8e2bb4eeab8c65c00492ef6f416","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fd244524c2cf07b5f4c3fe8abd6a99225c76544b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27035","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.360","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: compress: fix to guarantee persisting compressed blocks by CP\n\nIf data block in compressed cluster is not persisted with metadata\nduring checkpoint, after SPOR, the data may be corrupted, let's\nguarantee to write compressed page by checkpoint."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: f2fs: compress: corrección para garantizar la persistencia de los bloques comprimidos por CP. Si el bloque de datos en el clúster comprimido no persiste con los metadatos durante el punto de control, después de SPOR, los datos pueden estar dañados, garanticemos que escribir página comprimida por punto de control."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/57e8b17d0522c8f4daf0c4d9969b4d7358033532","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/82704e598d7b33c7e45526e34d3c585426319bed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a430dd49e9cb021372b0ad91e60aeef9c6ced00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c3311694b9bcced233548574d414c91d39214684","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e54cce8137258a550b49cae45d09e024821fb28d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27036","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.407","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix writeback data corruption\n\ncifs writeback doesn't correctly handle the case where\ncifs_extend_writeback() hits a point where it is considering an additional\nfolio, but this would overrun the wsize - at which point it drops out of\nthe xarray scanning loop and calls xas_pause().  The problem is that\nxas_pause() advances the loop counter - thereby skipping that page.\n\nWhat needs to happen is for xas_reset() to be called any time we decide we\ndon't want to process the page we're looking at, but rather send the\nrequest we are building and start a new one.\n\nFix this by copying and adapting the netfslib writepages code as a\ntemporary measure, with cifs writeback intending to be offloaded to\nnetfslib in the near future.\n\nThis also fixes the issue with the use of filemap_get_folios_tag() causing\nretry of a bunch of pages which the extender already dealt with.\n\nThis can be tested by creating, say, a 64K file somewhere not on cifs\n(otherwise copy-offload may get underfoot), mounting a cifs share with a\nwsize of 64000, copying the file to it and then comparing the original file\nand the copy:\n\n        dd if=\/dev\/urandom of=\/tmp\/64K bs=64k count=1\n        mount \/\/192.168.6.1\/test \/mnt -o user=...,pass=...,wsize=64000\n        cp \/tmp\/64K \/mnt\/64K\n        cmp \/tmp\/64K \/mnt\/64K\n\nWithout the fix, the cmp fails at position 64000 (or shortly thereafter)."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: cifs: corrige la corrupción de datos de reescritura cifs writeback no maneja correctamente el caso en el que cifs_extend_writeback() llega a un punto en el que está considerando una publicación adicional, pero esto sobrepasaría el tamaño de wsize - en momento en el que sale del ciclo de escaneo de xarray y llama a xas_pause(). El problema es que xas_pause() avanza el contador de bucle, omitiendo así esa página. Lo que debe suceder es que se llame a xas_reset() cada vez que decidamos que no queremos procesar la página que estamos viendo, sino enviar la solicitud que estamos creando y comenzar una nueva. Solucione este problema copiando y adaptando el código de escritura de netfslib como medida temporal, y la escritura diferida de cifs se descargará a netfslib en un futuro próximo. Esto también soluciona el problema con el uso de filemap_get_folios_tag() que provocaba un reintento de un grupo de páginas que el extensor ya había tratado. Esto se puede probar creando, por ejemplo, un archivo de 64 K en algún lugar que no esté en cif (de lo contrario, la descarga de copia podría complicarse), montando un recurso compartido cif con un tamaño de 64000, copiando el archivo en él y luego comparando el archivo original y la copia. : dd if=\/dev\/urandom of=\/tmp\/64K bs=64k count=1 mount \/\/192.168.6.1\/test \/mnt -o user=...,pass=...,wsize=64000 cp \/tmp \/64K \/mnt\/64K cmp \/tmp\/64K \/mnt\/64K Sin la corrección, el cmp falla en la posición 64000 (o poco después)."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/65f2ced695982ccd516196d0a9447d85dbe2eed5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/844b4e132f57f1333dc79feaa035075a096762e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e45deec35bf7f1f4f992a707b2d04a8c162f2240","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f3dc1bdb6b0b0693562c7c54a6c28bafa608ba3c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27037","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.450","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: zynq: Prevent null pointer dereference caused by kmalloc failure\n\nThe kmalloc() in zynq_clk_setup() will return null if the\nphysical memory has run out. As a result, if we use snprintf()\nto write data to the null address, the null pointer dereference\nbug will happen.\n\nThis patch uses a stack variable to replace the kmalloc()."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: zynq: evita la desreferencia del puntero nulo causada por una falla de kmalloc. El kmalloc() en zynq_clk_setup() devolverá nulo si la memoria física se ha agotado. Como resultado, si usamos snprintf() para escribir datos en la dirección nula, se producirá el error de desreferencia del puntero nulo. Este parche utiliza una variable de pila para reemplazar kmalloc()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/01511ac7be8e45f80e637f6bf61af2d3d2dee9db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0801c893fd48cdba66a3c8f44c3fe43cc67d3b85","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/58a946ab43501f2eba058d24d96af0ad1122475b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7938e9ce39d6779d2f85d822cc930f73420e54a6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8c4889a9ea861d7be37463c10846eb75e1b49c9d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca976c6a592f789700200069ef9052493c0b73d8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27038","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.507","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: Fix clk_core_get NULL dereference\n\nIt is possible for clk_core_get to dereference a NULL in the following\nsequence:\n\nclk_core_get()\n    of_clk_get_hw_from_clkspec()\n        __of_clk_get_hw_from_provider()\n            __clk_get_hw()\n\n__clk_get_hw() can return NULL which is dereferenced by clk_core_get() at\nhw->core.\n\nPrior to commit dde4eff47c82 (\"clk: Look for parents with clkdev based\nclk_lookups\") the check IS_ERR_OR_NULL() was performed which would have\ncaught the NULL.\n\nReading the description of this function it talks about returning NULL but\nthat cannot be so at the moment.\n\nUpdate the function to check for hw before dereferencing it and return NULL\nif hw is NULL."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: corrige la desreferencia de clk_core_get NULL Es posible que clk_core_get elimine la referencia a un NULL en la siguiente secuencia: clk_core_get() of_clk_get_hw_from_clkspec() __of_clk_get_hw_from_provider() __clk_get_hw() __clk_get_hw() puede devolver NULL que es desreferenciado por clk_core_get() en hw-&gt;core. Antes de confirmar dde4eff47c82 (\"clk: buscar padres con clk_lookups basado en clkdev\") se realizó la verificación IS_ERR_OR_NULL() que habría detectado el NULL. Leyendo la descripción de esta función se habla de devolver NULL pero eso no puede ser así por el momento. Actualice la función para verificar hw antes de eliminar la referencia y devuelva NULL si hw es NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0efb9ef6fb95384ba631d6819e66f10392aabfa2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/239174535dba11f7b83de0eaaa27909024f8c185","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6f073b24a9e2becd25ac4505a9780a87e621bb51","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a5d9b1aa61b401867b9066d54086b3e4ee91f8ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a8b2b26fdd011ebe36d68a9a321ca45801685959","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c554badcae9c45b737a22d23454170c6020b90e6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d7ae7d1265686b55832a445b1db8cdd69738ac07","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e97fe4901e0f59a0bfd524578fe3768f8ca42428","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27039","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.557","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: hisilicon: hi3559a: Fix an erroneous devm_kfree()\n\n'p_clk' is an array allocated just before the for loop for all clk that\nneed to be registered.\nIt is incremented at each loop iteration.\n\nIf a clk_register() call fails, 'p_clk' may point to something different\nfrom what should be freed.\n\nThe best we can do, is to avoid this wrong release of memory."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: clk: hisilicon: hi3559a: corrige un devm_kfree() erróneo 'p_clk' es una matriz asignada justo antes del bucle for para todos los clk que deben registrarse. Se incrementa en cada iteración del bucle. Si falla una llamada a clk_register(), 'p_clk' puede señalar algo diferente de lo que debería liberarse. Lo mejor que podemos hacer es evitar esta liberación incorrecta de memoria."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2cc572e0085ebd4b662b74a0f43222bc00df9a00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3f8445f1c746fda180a7f75372ed06b24e9cefe2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/64c6a38136b74a2f18c42199830975edd9fbc379","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/95d1f1228c1bb54803ae57525b76db60e99b37e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d575765b1b62e8bdb00af11caa1aabeb01763d9f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e0b0d1c46a2ce1e46b79d004a7270fdef872e097","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27040","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.600","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/display: Add 'replay' NULL check in 'edp_set_replay_allow_active()'\n\nIn the first if statement, we're checking if 'replay' is NULL. But in\nthe second if statement, we're not checking if 'replay' is NULL again\nbefore calling replay->funcs->replay_set_power_opt().\n\nif (replay == NULL && force_static)\n    return false;\n\n...\n\nif (link->replay_settings.replay_feature_enabled &&\n    replay->funcs->replay_set_power_opt) {\n\treplay->funcs->replay_set_power_opt(replay, *power_opts, panel_inst);\n\tlink->replay_settings.replay_power_opt_active = *power_opts;\n}\n\nIf 'replay' is NULL, this will cause a null pointer dereference.\n\nFixes the below found by smatch:\ndrivers\/gpu\/drm\/amd\/amdgpu\/..\/display\/dc\/link\/protocols\/link_edp_panel_control.c:895 edp_set_replay_allow_active() error: we previously assumed 'replay' could be null (see line 887)"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amd\/display: agregue la verificación NULL 'replay' en 'edp_set_replay_allow_active()' En la primera declaración if, estamos verificando si 'replay' es NULL. Pero en la segunda declaración if, no estamos verificando si 'replay' es NULL nuevamente antes de llamar a replay-&gt;funcs-&gt;replay_set_power_opt(). si (repetición == NULL &amp;&amp; force_static) devuelve falso; ... if (enlace-&gt;replay_settings.replay_feature_enabled &amp;&amp; replay-&gt;funcs-&gt;replay_set_power_opt) { replay-&gt;funcs-&gt;replay_set_power_opt(replay, *power_opts, panel_inst); enlace-&gt;replay_settings.replay_power_opt_active = *power_opts; } Si 'repetición' es NULL, esto provocará una desreferencia del puntero nulo. Corrige el siguiente error encontrado por smatch: drivers\/gpu\/drm\/amd\/amdgpu\/..\/display\/dc\/link\/protocols\/link_edp_panel_control.c:895 edp_set_replay_allow_active(): previamente asumimos que 'repetir' podría ser nulo (ver línea 887)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/d0e94f4807ff0df66cf447d6b4bbb8ac830e99c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e7cadd5d3a8ffe334d0229ba9eda4290138d56e7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f610c46771ef1047e46d61807aa7c69cd29e63d8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f6aed043ee5d75b3d1bfc452b1a9584b63c8f76b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27041","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.647","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/display: fix NULL checks for adev->dm.dc in amdgpu_dm_fini()\n\nSince 'adev->dm.dc' in amdgpu_dm_fini() might turn out to be NULL\nbefore the call to dc_enable_dmub_notifications(), check\nbeforehand to ensure there will not be a possible NULL-ptr-deref\nthere.\n\nAlso, since commit 1e88eb1b2c25 (\"drm\/amd\/display: Drop\nCONFIG_DRM_AMD_DC_HDCP\") there are two separate checks for NULL in\n'adev->dm.dc' before dc_deinit_callbacks() and dc_dmub_srv_destroy().\nClean up by combining them all under one 'if'.\n\nFound by Linux Verification Center (linuxtesting.org) with static\nanalysis tool SVACE."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amd\/display: corrige comprobaciones NULL para adev-&gt;dm.dc en amdgpu_dm_fini() Dado que 'adev-&gt;dm.dc' en amdgpu_dm_fini() podría resultar ser NULL antes de llamar a dc_enable_dmub_notifications(), verifique de antemano para asegurarse de que no habrá un posible NULL-ptr-deref allí. Además, desde la confirmación 1e88eb1b2c25 (\"drm\/amd\/display: Drop CONFIG_DRM_AMD_DC_HDCP\") hay dos comprobaciones separadas para NULL en 'adev-&gt;dm.dc' antes de dc_deinit_callbacks() y dc_dmub_srv_destroy(). Limpia combinándolos todos bajo un solo \"si\". Encontrado por el Centro de verificación de Linux (linuxtesting.org) con la herramienta de análisis estático SVACE."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1c62697e4086de988b31124fb8c79c244ea05f2b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2a3cfb9a24a28da9cc13d2c525a76548865e182c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca2eb375db76fd50f31afdd67d6ca4f833254957","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e040f1fbe9abae91b12b074cfc3bbb5367b79811","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27042","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.690","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu: Fix potential out-of-bounds access in 'amdgpu_discovery_reg_base_init()'\n\nThe issue arises when the array 'adev->vcn.vcn_config' is accessed\nbefore checking if the index 'adev->vcn.num_vcn_inst' is within the\nbounds of the array.\n\nThe fix involves moving the bounds check before the array access. This\nensures that 'adev->vcn.num_vcn_inst' is within the bounds of the array\nbefore it is used as an index.\n\nFixes the below:\ndrivers\/gpu\/drm\/amd\/amdgpu\/amdgpu_discovery.c:1289 amdgpu_discovery_reg_base_init() error: testing array offset 'adev->vcn.num_vcn_inst' after use."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amdgpu: corrige el posible acceso fuera de los límites en 'amdgpu_discovery_reg_base_init()'. El problema surge cuando se accede a la matriz 'adev-&gt;vcn.vcn_config' antes de verificar si el El índice 'adev-&gt;vcn.num_vcn_inst' está dentro de los límites de la matriz. La solución implica mover la verificación de los límites antes del acceso a la matriz. Esto garantiza que 'adev-&gt;vcn.num_vcn_inst' esté dentro de los límites de la matriz antes de usarlo como índice. Corrige lo siguiente: drivers\/gpu\/drm\/amd\/amdgpu\/amdgpu_discovery.c:1289 error amdgpu_discovery_reg_base_init(): prueba de desplazamiento de matriz 'adev-&gt;vcn.num_vcn_inst' después de su uso."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/8db10cee51e3e11a6658742465edc21986cf1e8d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f3e68c6a3fff53c2240762a47a0045d89371775","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b33d4af102b9c1f7a83d3f0ad3cab7d2bab8f058","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cdb637d339572398821204a1142d8d615668f1e9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27043","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.740","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: edia: dvbdev: fix a use-after-free\n\nIn dvb_register_device, *pdvbdev is set equal to dvbdev, which is freed\nin several error-handling paths. However, *pdvbdev is not set to NULL\nafter dvbdev's deallocation, causing use-after-frees in many places,\nfor example, in the following call chain:\n\nbudget_register\n  |-> dvb_dmxdev_init\n        |-> dvb_register_device\n  |-> dvb_dmxdev_release\n        |-> dvb_unregister_device\n              |-> dvb_remove_device\n                    |-> dvb_device_put\n                          |-> kref_put\n\nWhen calling dvb_unregister_device, dmxdev->dvbdev (i.e. *pdvbdev in\ndvb_register_device) could point to memory that had been freed in\ndvb_register_device. Thereafter, this pointer is transferred to\nkref_put and triggering a use-after-free."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: medios: edia: dvbdev: corregir un use-after-free En dvb_register_device, *pdvbdev se establece igual a dvbdev, que se libera en varias rutas de manejo de errores. Sin embargo, *pdvbdev no se establece en NULL después de la desasignación de dvbdev, lo que provoca use-after-free en muchos lugares, por ejemplo, en la siguiente cadena de llamadas: Budget_register |-&gt; dvb_dmxdev_init |-&gt; dvb_register_device |-&gt; dvb_dmxdev_release |-&gt; dvb_unregister_device | -&gt; dvb_remove_device |-&gt; dvb_device_put |-&gt; kref_put Al llamar a dvb_unregister_device, dmxdev-&gt;dvbdev (es decir, *pdvbdev en dvb_register_device) podría apuntar a la memoria que se había liberado en dvb_register_device. A partir de entonces, este puntero se transfiere a kref_put y se activa un use-after-free."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/096237039d00c839f3e3a5fe6d001bf0db45b644","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0d3fe80b6d175c220b3e252efc6c6777e700e98e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/35674111a043b0482a9bc69da8850a83f465b07d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/437a111f79a2f5b2a5f21e27fdec6f40c8768712","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/779e8db7efb22316c8581d6c229636d2f5694a62","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8c64f4cdf4e6cc5682c52523713af8c39c94e6d5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7586e902128e4fb7bfbb661cb52e4215a65637b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0f5c28333822f9baa5280d813124920720fd856","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f20c3270f3ed5aa6919a87e4de9bf6c05fb57086","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27044","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.783","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/display: Fix potential NULL pointer dereferences in 'dcn10_set_output_transfer_func()'\n\nThe 'stream' pointer is used in dcn10_set_output_transfer_func() before\nthe check if 'stream' is NULL.\n\nFixes the below:\ndrivers\/gpu\/drm\/amd\/amdgpu\/..\/display\/dc\/hwss\/dcn10\/dcn10_hwseq.c:1892 dcn10_set_output_transfer_func() warn: variable dereferenced before check 'stream' (see line 1875)"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amd\/display: corrige posibles desreferencias del puntero NULL en 'dcn10_set_output_transfer_func()'. El puntero 'stream' se usa en dcn10_set_output_transfer_func() antes de verificar si 'stream' es NULL. Corrige lo siguiente: drivers\/gpu\/drm\/amd\/amdgpu\/..\/display\/dc\/hwss\/dcn10\/dcn10_hwseq.c:1892 dcn10_set_output_transfer_func() advertencia: variable desreferenciada antes de verificar 'flujo' (ver línea 1875)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/14613d52bc7fc180df6d2c65ba65fc921fc1dda7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/29fde8895b2fcc33f44aea28c644ce2d9b62f9e0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2d9fe7787af01188dc470a649bdbb842d6511fd7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/330caa061af53ea6d287d7c43d0703714e510e08","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6ac7c7a3a9ab57aba0fe78ecb922d2b20e16efeb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7874ab3105ca4657102fee1cc14b0af70883c484","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9ccfe80d022df7c595f1925afb31de2232900656","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e019d87e02f1e539ae48b99187f253847744ca7a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27045","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.837","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/display: Fix a potential buffer overflow in 'dp_dsc_clock_en_read()'\n\nTell snprintf() to store at most 10 bytes in the output buffer\ninstead of 30.\n\nFixes the below:\ndrivers\/gpu\/drm\/amd\/amdgpu\/..\/display\/amdgpu_dm\/amdgpu_dm_debugfs.c:1508 dp_dsc_clock_en_read() error: snprintf() is printing too much 30 vs 10"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amd\/display: soluciona un posible desbordamiento del búfer en 'dp_dsc_clock_en_read()' Dile a snprintf() que almacene como máximo 10 bytes en el búfer de salida en lugar de 30. Corrige lo siguiente : drivers\/gpu\/drm\/amd\/amdgpu\/..\/display\/amdgpu_dm\/amdgpu_dm_debugfs.c:1508 dp_dsc_clock_en_read() error: snprintf() está imprimiendo demasiado 30 vs 10"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/440f059837418fac1695b65d3ebc6080d33be877","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4b09715f1504f1b6e8dff0e9643630610bc05141","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad76fd30557d6a106c481e4606a981221ca525f7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cf114d8d4a8d78df272116a745bb43b48cef65f4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d346b3e5b25c95d504478507eb867cd3818775ab","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb9327af3621d26b1d83f767c97a3fe8191a3a65","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ff28893c96c5e0927a4da10cd24a3522ca663515","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27046","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.880","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnfp: flower: handle acti_netdevs allocation failure\n\nThe kmalloc_array() in nfp_fl_lag_do_work() will return null, if\nthe physical memory has run out. As a result, if we dereference\nthe acti_netdevs, the null pointer dereference bugs will happen.\n\nThis patch adds a check to judge whether allocation failure occurs.\nIf it happens, the delayed work will be rescheduled and try again."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nfp: flor: manejar el error de asignación de acti_netdevs El kmalloc_array() en nfp_fl_lag_do_work() devolverá nulo, si la memoria física se ha agotado. Como resultado, si eliminamos la referencia a acti_netdevs, se producirán errores de desreferencia del puntero nulo. Este parche agrega una verificación para juzgar si se produce una falla en la asignación. Si esto sucede, el trabajo retrasado se reprogramará y se intentará nuevamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0d387dc503f9a53e6d1f6e9dd0292d38f083eba5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3b1e8a617eb0f4cdc19def530047a95b5abde07d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/408ba7fd04f959c61b50db79c983484312fea642","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/84e95149bd341705f0eca6a7fcb955c548805002","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/928705e341010dd910fdece61ccb974f494a758f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9d8eb1238377cd994829f9162ae396a84ae037b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c8df9203bf22c66fa26e8d8c7f8ce181cf88099d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c9b4e220dd18f79507803f38a55d53b483f6c9c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d746889db75a76aeee95fb705b8e1ac28c684a2e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27047","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.930","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: phy: fix phy_get_internal_delay accessing an empty array\n\nThe phy_get_internal_delay function could try to access to an empty\narray in the case that the driver is calling phy_get_internal_delay\nwithout defining delay_values and rx-internal-delay-ps or\ntx-internal-delay-ps is defined to 0 in the device-tree.\nThis will lead to \"unable to handle kernel NULL pointer dereference at\nvirtual address 0\". To avoid this kernel oops, the test should be delay\n>= 0. As there is already delay < 0 test just before, the test could\nonly be size == 0."},{"lang":"es","value":"En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: net:phy: fix phy_get_internal_delay accediendo a un array vacío La función phy_get_internal_delay podría intentar acceder a un array vacío en el caso de que el driver esté llamando a phy_get_internal_delay sin definir delay_values y rx-internal- delay-ps o tx-internal-delay-ps se define en 0 en el árbol de dispositivos. Esto provocará que \"no se pueda manejar la desreferencia del puntero NULL del kernel en la dirección virtual 0\". Para evitar este problema del kernel, la prueba debe tener un retraso &gt;= 0. Como ya hay un retraso &lt; 0 en la prueba justo antes, la prueba solo podría tener un tamaño == 0."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0307cf443308ecc6be9b2ca312bb31bae5e5a7ad","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/06dd21045a7e8bc8701b0ebedcd9a30a6325878b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0e939a002c8a7d66e60bd0ea6b281fb39d713c1a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2a2ff709511617de9c6c072eeee82bcbbdfecaf8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4469c0c5b14a0919f5965c7ceac96b523eb57b79","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/589ec16174dd9378953b8232ae76fad0a96e1563","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c0691de7df1d51482a52cac93b7fe82fd9dd296b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27048","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:49.977","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcm80211: handle pmk_op allocation failure\n\nThe kzalloc() in brcmf_pmksa_v3_op() will return null if the\nphysical memory has run out. As a result, if we dereference\nthe null value, the null pointer dereference bug will happen.\n\nReturn -ENOMEM from brcmf_pmksa_v3_op() if kzalloc() fails\nfor pmk_op."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: wifi: brcm80211: maneja el error de asignación de pmk_op El kzalloc() en brcmf_pmksa_v3_op() devolverá nulo si la memoria física se ha agotado. Como resultado, si eliminamos la referencia del valor nulo, se producirá el error de desreferencia del puntero nulo. Devuelve -ENOMEM de brcmf_pmksa_v3_op() si kzalloc() falla para pmk_op."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6138a82f3bccfc67ed7ac059493579fc326c02e5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9975908315c13bae2f2ed5ba92870fa935180b0e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4152222e04cb8afeeca239c90e3fcaf4c553b42","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df62e22c2e27420e8990a4f09e30d7bf56c2036f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27049","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.020","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mt76: mt7925e: fix use-after-free in free_irq()\n\nFrom commit a304e1b82808 (\"[PATCH] Debug shared irqs\"), there is a test\nto make sure the shared irq handler should be able to handle the unexpected\nevent after deregistration. For this case, let's apply MT76_REMOVED flag to\nindicate the device was removed and do not run into the resource access\nanymore."},{"lang":"es","value":"En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: wifi: mt76: mt7925e: fix use-after-free in free_irq() Desde el commit a304e1b82808 (\"[PATCH] Depurar irqs compartidas\"), existe una prueba para asegurarse de que El controlador de irq compartido debería poder manejar el evento inesperado después de la cancelación del registro. Para este caso, apliquemos el indicador MT76_REMOVED para indicar que el dispositivo fue eliminado y que ya no se puede acceder al recurso."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6d9930096e1f13cf6d9aabfbf95d0e05fb04144f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/84470b48af03a818039d587478b415cbcb264ff5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a5a5f4413d91f395cb2d89829d376d7393ad48b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27050","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.070","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nlibbpf: Use OPTS_SET() macro in bpf_xdp_query()\n\nWhen the feature_flags and xdp_zc_max_segs fields were added to the libbpf\nbpf_xdp_query_opts, the code writing them did not use the OPTS_SET() macro.\nThis causes libbpf to write to those fields unconditionally, which means\nthat programs compiled against an older version of libbpf (with a smaller\nsize of the bpf_xdp_query_opts struct) will have its stack corrupted by\nlibbpf writing out of bounds.\n\nThe patch adding the feature_flags field has an early bail out if the\nfeature_flags field is not part of the opts struct (via the OPTS_HAS)\nmacro, but the patch adding xdp_zc_max_segs does not. For consistency, this\nfix just changes the assignments to both fields to use the OPTS_SET()\nmacro."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: libbpf: use la macro OPTS_SET() en bpf_xdp_query() Cuando los campos feature_flags y xdp_zc_max_segs se agregaron a libbpf bpf_xdp_query_opts, el código que los escribió no usó la macro OPTS_SET(). Esto hace que libbpf escriba en esos campos incondicionalmente, lo que significa que los programas compilados con una versión anterior de libbpf (con un tamaño más pequeño de la estructura bpf_xdp_query_opts) tendrán su pila dañada por la escritura de libbpf fuera de los límites. El parche que agrega el campo feature_flags tiene un rescate anticipado si el campo feature_flags no es parte de la estructura opts (a través de la macro OPTS_HAS), pero el parche que agrega xdp_zc_max_segs no lo hace. Para mantener la coherencia, esta solución simplemente cambia las asignaciones a ambos campos para usar la macro OPTS_SET()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/682ddd62abd4bdcee7584246903e7a2df005fe0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/92a871ab9fa59a74d013bc04f321026a057618e7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cd3be9843247edb8fc6fcd8d8237cbce2bc19f5e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fa5bef5e80c6a3321b2b1a7070436f3bc5daf07c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27051","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.120","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq: brcmstb-avs-cpufreq: add check for cpufreq_cpu_get's return value\n\ncpufreq_cpu_get may return NULL. To avoid NULL-dereference check it\nand return 0 in case of error.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: cpufreq: brcmstb-avs-cpufreq: agregar verificación para el valor de retorno de cpufreq_cpu_get cpufreq_cpu_get puede devolver NULL. Para evitar la desreferencia NULL, verifíquelo y devuelva 0 en caso de error. Encontrado por el Centro de verificación de Linux (linuxtesting.org) con SVACE."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/74b84d0d71180330efe67c82f973a87f828323e5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9127599c075caff234359950117018a010dd01db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b25b64a241d769e932a022e5c780cf135ef56035","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d951cf510fb0df91d3abac0121a59ebbc63c0567","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e6e3e51ffba0784782b1a076d7441605697ea3c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e72160cb6e23b78b41999d6885a34ce8db536095","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f661017e6d326ee187db24194cabb013d81bc2a6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27052","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.170","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtl8xxxu: add cancel_work_sync() for c2hcmd_work\n\nThe workqueue might still be running, when the driver is stopped. To\navoid a use-after-free, call cancel_work_sync() in rtl8xxxu_stop()."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: wifi: rtl8xxxu: agregue cancel_work_sync() para c2hcmd_work Es posible que la cola de trabajo aún esté ejecutándose cuando se detiene el controlador. Para evitar un use-after-free, llame a cancel_work_sync() en rtl8xxxu_stop()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1213acb478a7181cd73eeaf00db430f1e45b1361","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/156012667b85ca7305cb363790d3ae8519a6f41e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3518cea837de4d106efa84ddac18a07b6de1384e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/58fe3bbddfec10c6b216096d8c0e517cd8463e3a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7059cdb69f8e1a2707dd1e2f363348b507ed7707","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ac512507ac89c01ed6cd4ca53032f52cdb23ea59","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dddedfa3b29a63c2ca4336663806a6128b8545b4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27053","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.223","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: wilc1000: fix RCU usage in connect path\n\nWith lockdep enabled, calls to the connect function from cfg802.11 layer\nlead to the following warning:\n\n=============================\nWARNING: suspicious RCU usage\n6.7.0-rc1-wt+ #333 Not tainted\n-----------------------------\ndrivers\/net\/wireless\/microchip\/wilc1000\/hif.c:386\nsuspicious rcu_dereference_check() usage!\n[...]\nstack backtrace:\nCPU: 0 PID: 100 Comm: wpa_supplicant Not tainted 6.7.0-rc1-wt+ #333\nHardware name: Atmel SAMA5\n unwind_backtrace from show_stack+0x18\/0x1c\n show_stack from dump_stack_lvl+0x34\/0x48\n dump_stack_lvl from wilc_parse_join_bss_param+0x7dc\/0x7f4\n wilc_parse_join_bss_param from connect+0x2c4\/0x648\n connect from cfg80211_connect+0x30c\/0xb74\n cfg80211_connect from nl80211_connect+0x860\/0xa94\n nl80211_connect from genl_rcv_msg+0x3fc\/0x59c\n genl_rcv_msg from netlink_rcv_skb+0xd0\/0x1f8\n netlink_rcv_skb from genl_rcv+0x2c\/0x3c\n genl_rcv from netlink_unicast+0x3b0\/0x550\n netlink_unicast from netlink_sendmsg+0x368\/0x688\n netlink_sendmsg from ____sys_sendmsg+0x190\/0x430\n ____sys_sendmsg from ___sys_sendmsg+0x110\/0x158\n ___sys_sendmsg from sys_sendmsg+0xe8\/0x150\n sys_sendmsg from ret_fast_syscall+0x0\/0x1c\n\nThis warning is emitted because in the connect path, when trying to parse\ntarget BSS parameters, we dereference a RCU pointer whithout being in RCU\ncritical section.\nFix RCU dereference usage by moving it to a RCU read critical section. To\navoid wrapping the whole wilc_parse_join_bss_param under the critical\nsection, just use the critical section to copy ies data"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: wifi: wilc1000: corrige el uso de RCU en la ruta de conexión Con lockdep habilitado, las llamadas a la función de conexión desde la capa cfg802.11 generan la siguiente advertencia: ======== ====================== ADVERTENCIA: uso sospechoso de RCU 6.7.0-rc1-wt+ #333 No contaminado ------------- ---------------- drivers\/net\/wireless\/microchip\/wilc1000\/hif.c:386 ¡uso sospechoso de rcu_dereference_check()! [...] pila backtrace: CPU: 0 PID: 100 Comm: wpa_supplicant No está contaminado 6.7.0-rc1-wt+ #333 Nombre de hardware: Atmel SAMA5 unwind_backtrace from show_stack+0x18\/0x1c show_stack from dump_stack_lvl+0x34\/0x48 dump_stack_lvl from wilc_parse_join_bss_para m +0x7dc\/0x7f4 wilc_parse_join_bss_param desde connect+0x2c4\/0x648 conectar desde cfg80211_connect+0x30c\/0xb74 cfg80211_connect desde nl80211_connect+0x860\/0xa94 nl80211_connect desde genl_rcv_msg+0x3fc \/0x59c genl_rcv_msg de netlink_rcv_skb+0xd0\/0x1f8 netlink_rcv_skb de genl_rcv+0x2c\/0x3c genl_rcv de netlink_unicast+ 0x3b0\/0x550 netlink_unicast de netlink_sendmsg+0x368\/0x688 netlink_sendmsg de ____sys_sendmsg+0x190\/0x430 ____sys_sendmsg de ___sys_sendmsg+0x110\/0x158 ___sys_sendmsg de sys_sendmsg +0xe8\/0x150 sys_sendmsg de ret_fast_syscall+0x0\/0x1c Esta advertencia se emite porque en la ruta de conexión, al intentar Para analizar los parámetros BSS de destino, eliminamos la referencia a un puntero de RCU sin estar en la sección crítica de RCU. Corrija el uso de desreferenciación de RCU moviéndolo a una sección crítica de lectura de RCU. Para evitar incluir todo el wilc_parse_join_bss_param en la sección crítica, simplemente use la sección crítica para copiar datos de ies"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/205c50306acf58a335eb19fa84e40140f4fe814f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4bfd20d5f5c62b5495d6c0016ee6933bd3add7ce","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5800ec78775c0cd646f71eb9bf8402fb794807de","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/745003b5917b610352f52fe0d11ef658d6471ec2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4bbf38c350acb6500cbe667b1e2e68f896e4b38","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d80fc436751cfa6b02a8eda74eb6cce7dadfe5a2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dd50d3ead6e3707bb0a5df7cc832730c93ace3a7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e556006de4ea93abe2b46cba202a2556c544b8b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27054","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.270","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ns390\/dasd: fix double module refcount decrement\n\nOnce the discipline is associated with the device, deleting the device\ntakes care of decrementing the module's refcount.  Doing it manually on\nthis error path causes refcount to artificially decrease on each error\nwhile it should just stay the same."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: s390\/dasd: corrige la disminución del doble recuento del módulo Una vez que la disciplina está asociada con el dispositivo, eliminar el dispositivo se encarga de disminuir el recuento del módulo. Hacerlo manualmente en esta ruta de error hace que el recuento disminuya artificialmente en cada error, mientras que debería permanecer igual."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/ad999aa18103fa038787b6a8a55020abcf34df1a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c3116e62ddeff79cae342147753ce596f01fcf06","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ebc5a3bd79e54f98c885c26f0862a27a02c487c5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ec09bcab32fc4765e0cc97e1b72cdd067135f37e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/edbdb0d94143db46edd373cc93e433832d29fe19","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fa18aa507ea71d8914b6acb2c94db311c757c650","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27055","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.317","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nworkqueue: Don't call cpumask_test_cpu() with -1 CPU in wq_update_node_max_active()\n\nFor wq_update_node_max_active(), @off_cpu of -1 indicates that no CPU is\ngoing down. The function was incorrectly calling cpumask_test_cpu() with -1\nCPU leading to oopses like the following on some archs:\n\n  Unable to handle kernel paging request at virtual address ffff0002100296e0\n  ..\n  pc : wq_update_node_max_active+0x50\/0x1fc\n  lr : wq_update_node_max_active+0x1f0\/0x1fc\n  ...\n  Call trace:\n    wq_update_node_max_active+0x50\/0x1fc\n    apply_wqattrs_commit+0xf0\/0x114\n    apply_workqueue_attrs_locked+0x58\/0xa0\n    alloc_workqueue+0x5ac\/0x774\n    workqueue_init_early+0x460\/0x540\n    start_kernel+0x258\/0x684\n    __primary_switched+0xb8\/0xc0\n  Code: 9100a273 35000d01 53067f00 d0016dc1 (f8607a60)\n  ---[ end trace 0000000000000000 ]---\n  Kernel panic - not syncing: Attempted to kill the idle task!\n  ---[ end Kernel panic - not syncing: Attempted to kill the idle task! ]---\n\nFix it."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: cola de trabajo: no llame a cpumask_test_cpu() con -1 CPU en wq_update_node_max_active() Para wq_update_node_max_active(), @off_cpu de -1 indica que no hay ninguna CPU fallando. La función llamaba incorrectamente a cpumask_test_cpu() con -1 CPU, lo que provocaba errores como los siguientes en algunos arcos: No se puede manejar la solicitud de paginación del kernel en la dirección virtual ffff0002100296e0 .. pc: wq_update_node_max_active+0x50\/0x1fc lr: wq_update_node_max_active+0x1f0\/0x1fc .. Seguimiento de llamadas: wq_update_node_max_active+0x50\/0x1fc apply_wqattrs_commit+0xf0\/0x114 apply_workqueue_attrs_locked+0x58\/0xa0 alloc_workqueue+0x5ac\/0x774 workqueue_init_early+0x460\/0x540 start_kernel+0x258\/0x68. 4 __primary_switched+0xb8\/0xc0 Código: 9100a273 35000d01 53067f00 d0016dc1 (f8607a60) -- -[ end trace 0000000000000000 ]--- Pánico del kernel - no se sincroniza: ¡Se intentó finalizar la tarea inactiva! ---[ fin del pánico del kernel: no se sincroniza: ¡se intentó finalizar la tarea inactiva! ]--- Arreglalo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/15930da42f8981dc42c19038042947b475b19f47","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/38c19c44cc05ec1e84d2e31a9a289b83b6c7ec85","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7df62b8cca38aa452b508b477b16544cba615084","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9fc557d489f8163c1aabcb89114b8eba960f4097","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a75ac2693d734d20724f0e10e039ca85f1fcfc4e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/adc646d2126988a64234502f579e4bc2b080d7cf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27056","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.360","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: mvm: ensure offloading TID queue exists\n\nThe resume code path assumes that the TX queue for the offloading TID\nhas been configured. At resume time it then tries to sync the write\npointer as it may have been updated by the firmware.\n\nIn the unusual event that no packets have been send on TID 0, the queue\nwill not have been allocated and this causes a crash. Fix this by\nensuring the queue exist at suspend time."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: wifi: iwlwifi: mvm: asegúrese de que exista la cola de descarga TID La ruta del código de reanudación supone que se ha configurado la cola de TX para la descarga de TID. En el momento de la reanudación, intenta sincronizar el puntero de escritura, ya que es posible que el firmware lo haya actualizado. En el caso inusual de que no se hayan enviado paquetes en el TID 0, la cola no se habrá asignado y esto provocará una falla. Solucione este problema asegurándose de que la cola exista en el momento de la suspensión."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/78f65fbf421a61894c14a1b91fe2fb4437b3fe5f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ed35a509390ef4011ea2226da5dd6f62b73873b5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27057","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.400","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: SOF: ipc4-pcm: Workaround for crashed firmware on system suspend\n\nWhen the system is suspended while audio is active, the\nsof_ipc4_pcm_hw_free() is invoked to reset the pipelines since during\nsuspend the DSP is turned off, streams will be re-started after resume.\n\nIf the firmware crashes during while audio is running (or when we reset\nthe stream before suspend) then the sof_ipc4_set_multi_pipeline_state()\nwill fail with IPC error and the state change is interrupted.\nThis will cause misalignment between the kernel and firmware state on next\nDSP boot resulting errors returned by firmware for IPC messages, eventually\nfailing the audio resume.\nOn stream close the errors are ignored so the kernel state will be\ncorrected on the next DSP boot, so the second boot after the DSP panic.\n\nIf sof_ipc4_trigger_pipelines() is called from sof_ipc4_pcm_hw_free() then\nstate parameter is SOF_IPC4_PIPE_RESET and only in this case.\n\nTreat a forced pipeline reset similarly to how we treat a pcm_free by\nignoring error on state sending to allow the kernel's state to be\nconsistent with the state the firmware will have after the next boot."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ASoC: SOF: ipc4-pcm: workaround para firmware bloqueado en suspensión del sistema Cuando el sistema se suspende mientras el audio está activo, se invoca sof_ipc4_pcm_hw_free() para restablecer las canalizaciones desde durante la suspensión el DSP está apagado, las transmisiones se reiniciarán después de reanudarse. Si el firmware falla mientras se ejecuta el audio (o cuando reiniciamos la transmisión antes de suspenderla), entonces sof_ipc4_set_multi_pipeline_state() fallará con un error de IPC y se interrumpirá el cambio de estado. Esto provocará una desalineación entre el estado del kernel y del firmware en el siguiente arranque del DSP, lo que provocará errores devueltos por el firmware para los mensajes IPC, lo que eventualmente provocará un error en la reanudación del audio. Al cerrar la transmisión, los errores se ignoran, por lo que el estado del kernel se corregirá en el siguiente inicio del DSP, es decir, en el segundo inicio después del pánico del DSP. Si se llama a sof_ipc4_trigger_pipelines() desde sof_ipc4_pcm_hw_free() entonces el parámetro de estado es SOF_IPC4_PIPE_RESET y solo en este caso. Trate un reinicio forzado de canalización de manera similar a como tratamos un pcm_free ignorando el error en el envío del estado para permitir que el estado del kernel sea consistente con el estado que tendrá el firmware después del siguiente arranque."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3cac6eebea9b4bc5f041e157e45c76e212ad6759","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c40aad7c81e5fba34b70123ed7ce3397fa62a4d2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d153e8b154f9746ac969c85a4e6474760453647c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27058","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.450","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntmpfs: fix race on handling dquot rbtree\n\nA syzkaller reproducer found a race while attempting to remove dquot\ninformation from the rb tree.\n\nFetching the rb_tree root node must also be protected by the\ndqopt->dqio_sem, otherwise, giving the right timing, shmem_release_dquot()\nwill trigger a warning because it couldn't find a node in the tree, when\nthe real reason was the root node changing before the search starts:\n\nThread 1\t\t\t\tThread 2\n- shmem_release_dquot()\t\t\t- shmem_{acquire,release}_dquot()\n\n- fetch ROOT\t\t\t\t- Fetch ROOT\n\n\t\t\t\t\t- acquire dqio_sem\n- wait dqio_sem\n\n\t\t\t\t\t- do something, triger a tree rebalance\n\t\t\t\t\t- release dqio_sem\n\n- acquire dqio_sem\n- start searching for the node, but\n  from the wrong location, missing\n  the node, and triggering a warning."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: tmpfs: corrige la ejecución al manejar dquot rbtree Un reproductor syzkaller encontró una ejecución al intentar eliminar información de dquot del árbol rb. La recuperación del nodo raíz de rb_tree también debe estar protegida por dqopt-&gt;dqio_sem; de lo contrario, si se da el momento adecuado, shmem_release_dquot() activará una advertencia porque no pudo encontrar un nodo en el árbol, cuando la verdadera razón era el nodo raíz. cambiando antes de que comience la búsqueda: Hilo 1 Hilo 2 - shmem_release_dquot() - shmem_{acquire,release}_dquot() - buscar ROOT - Obtener ROOT - adquirir dqio_sem - esperar dqio_sem - hacer algo, activar un reequilibrio de árbol - liberar dqio_sem - adquirir dqio_sem - comienza a buscar el nodo, pero desde la ubicación incorrecta, pierde el nodo y genera una advertencia."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0a69b6b3a026543bc215ccc866d0aea5579e6ce2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/617d55b90e73c7b4aa2733ca6cc3f9b72d1124bb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c7077f43f30d817d10a9f8245e51576ac114b2f0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f82f184874d2761ebaa60dccf577921a0dbb3810","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27059","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.493","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: usb-storage: Prevent divide-by-0 error in isd200_ata_command\n\nThe isd200 sub-driver in usb-storage uses the HEADS and SECTORS values\nin the ATA ID information to calculate cylinder and head values when\ncreating a CDB for READ or WRITE commands.  The calculation involves\ndivision and modulus operations, which will cause a crash if either of\nthese values is 0.  While this never happens with a genuine device, it\ncould happen with a flawed or subversive emulation, as reported by the\nsyzbot fuzzer.\n\nProtect against this possibility by refusing to bind to the device if\neither the ATA_ID_HEADS or ATA_ID_SECTORS value in the device's ID\ninformation is 0.  This requires isd200_Initialization() to return a\nnegative error code when initialization fails; currently it always\nreturns 0 (even when there is an error)."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: USB: almacenamiento-usb: evita el error de división por 0 en isd200_ata_command El subcontrolador isd200 en almacenamiento-usb utiliza los valores HEADS y SECTORES en la información de ID de ATA para calcular el cilindro y valores principales al crear un CDB para comandos LEER o ESCRIBIR. El cálculo implica operaciones de división y módulo, lo que provocará un bloqueo si cualquiera de estos valores es 0. Si bien esto nunca sucede con un dispositivo genuino, podría suceder con una emulación defectuosa o subversiva, según lo informado por syzbot fuzzer. Protéjase contra esta posibilidad negándose a vincularse al dispositivo si el valor ATA_ID_HEADS o ATA_ID_SECTORS en la información de ID del dispositivo es 0. Esto requiere que isd200_Initialization() devuelva un código de error negativo cuando falla la inicialización; actualmente siempre devuelve 0 (incluso cuando hay un error)."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/014bcf41d946b36a8f0b8e9b5d9529efbb822f49","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/284fb1003d5da111019b9e0bf99b084fd71ac133","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3a67d4ab9e730361d183086dfb0ddd8c61f01636","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6c1f36d92c0a8799569055012665d2bb066fb964","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/871fd7b10b56d280990b7e754f43d888382ca325","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9968c701cba7eda42e5f0052b040349d6222ae34","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb7b01ca778170654e1c76950024270ba74b121f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f42ba916689f5c7b1642092266d2f53cf527aaaa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27060","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.543","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nthunderbolt: Fix NULL pointer dereference in tb_port_update_credits()\n\nOlliver reported that his system crashes when plugging in Thunderbolt 1\ndevice:\n\n BUG: kernel NULL pointer dereference, address: 0000000000000020\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n RIP: 0010:tb_port_do_update_credits+0x1b\/0x130 [thunderbolt]\n Call Trace:\n  <TASK>\n  ? __die+0x23\/0x70\n  ? page_fault_oops+0x171\/0x4e0\n  ? exc_page_fault+0x7f\/0x180\n  ? asm_exc_page_fault+0x26\/0x30\n  ? tb_port_do_update_credits+0x1b\/0x130\n  ? tb_switch_update_link_attributes+0x83\/0xd0\n  tb_switch_add+0x7a2\/0xfe0\n  tb_scan_port+0x236\/0x6f0\n  tb_handle_hotplug+0x6db\/0x900\n  process_one_work+0x171\/0x340\n  worker_thread+0x27b\/0x3a0\n  ? __pfx_worker_thread+0x10\/0x10\n  kthread+0xe5\/0x120\n  ? __pfx_kthread+0x10\/0x10\n  ret_from_fork+0x31\/0x50\n  ? __pfx_kthread+0x10\/0x10\n  ret_from_fork_asm+0x1b\/0x30\n  <\/TASK>\n\nThis is due the fact that some Thunderbolt 1 devices only have one lane\nadapter. Fix this by checking for the lane 1 before we read its credits."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: Thunderbolt: corrige la desreferencia del puntero NULL en tb_port_update_credits() Olliver informó que su sistema falla al conectar el dispositivo Thunderbolt 1: ERROR: desreferencia del puntero NULL del kernel, dirección: 0000000000000020 #PF: supervisor leído acceso en modo kernel #PF: error_code(0x0000) - página no presente PGD 0 P4D 0 Vaya: 0000 [#1] PREEMPT SMP NOPTI RIP: 0010:tb_port_do_update_credits+0x1b\/0x130 [thunderbolt] Seguimiento de llamadas:  ? __morir+0x23\/0x70 ? page_fault_oops+0x171\/0x4e0? exc_page_fault+0x7f\/0x180? asm_exc_page_fault+0x26\/0x30? tb_port_do_update_credits+0x1b\/0x130 ? tb_switch_update_link_attributes+0x83\/0xd0 tb_switch_add+0x7a2\/0xfe0 tb_scan_port+0x236\/0x6f0 tb_handle_hotplug+0x6db\/0x900 Process_one_work+0x171\/0x340 Workers_thread+0x27b\/0x3a0 ? __pfx_worker_thread+0x10\/0x10 kthread+0xe5\/0x120 ? __pfx_kthread+0x10\/0x10 ret_from_fork+0x31\/0x50 ? __pfx_kthread+0x10\/0x10 ret_from_fork_asm+0x1b\/0x30  Esto se debe al hecho de que algunos dispositivos Thunderbolt 1 solo tienen un adaptador de línea. Solucione este problema comprobando el carril 1 antes de leer sus créditos."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/ce64ba1f6ec3439e4b4d880b4db99673f4507228","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d3d17e23d1a0d1f959b4fa55b35f1802d9c584fa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27061","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.593","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: sun8i-ce - Fix use after free in unprepare\n\nsun8i_ce_cipher_unprepare should be called before\ncrypto_finalize_skcipher_request, because client callbacks may\nimmediately free memory, that isn't needed anymore. But it will be\nused by unprepare after free. Before removing prepare\/unprepare\ncallbacks it was handled by crypto engine in crypto_finalize_request.\n\nUsually that results in a pointer dereference problem during a in\ncrypto selftest.\n Unable to handle kernel NULL pointer dereference at\n                                      virtual address 0000000000000030\n Mem abort info:\n   ESR = 0x0000000096000004\n   EC = 0x25: DABT (current EL), IL = 32 bits\n   SET = 0, FnV = 0\n   EA = 0, S1PTW = 0\n   FSC = 0x04: level 0 translation fault\n Data abort info:\n   ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000\n   CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\n user pgtable: 4k pages, 48-bit VAs, pgdp=000000004716d000\n [0000000000000030] pgd=0000000000000000, p4d=0000000000000000\n Internal error: Oops: 0000000096000004 [#1] SMP\n\nThis problem is detected by KASAN as well.\n ==================================================================\n BUG: KASAN: slab-use-after-free in sun8i_ce_cipher_do_one+0x6e8\/0xf80 [sun8i_ce]\n Read of size 8 at addr ffff00000dcdc040 by task 1c15000.crypto-\/373\n\n Hardware name: Pine64 PinePhone (1.2) (DT)\n Call trace:\n  dump_backtrace+0x9c\/0x128\n  show_stack+0x20\/0x38\n  dump_stack_lvl+0x48\/0x60\n  print_report+0xf8\/0x5d8\n  kasan_report+0x90\/0xd0\n  __asan_load8+0x9c\/0xc0\n  sun8i_ce_cipher_do_one+0x6e8\/0xf80 [sun8i_ce]\n  crypto_pump_work+0x354\/0x620 [crypto_engine]\n  kthread_worker_fn+0x244\/0x498\n  kthread+0x168\/0x178\n  ret_from_fork+0x10\/0x20\n\n Allocated by task 379:\n  kasan_save_stack+0x3c\/0x68\n  kasan_set_track+0x2c\/0x40\n  kasan_save_alloc_info+0x24\/0x38\n  __kasan_kmalloc+0xd4\/0xd8\n  __kmalloc+0x74\/0x1d0\n  alg_test_skcipher+0x90\/0x1f0\n  alg_test+0x24c\/0x830\n  cryptomgr_test+0x38\/0x60\n  kthread+0x168\/0x178\n  ret_from_fork+0x10\/0x20\n\n Freed by task 379:\n  kasan_save_stack+0x3c\/0x68\n  kasan_set_track+0x2c\/0x40\n  kasan_save_free_info+0x38\/0x60\n  __kasan_slab_free+0x100\/0x170\n  slab_free_freelist_hook+0xd4\/0x1e8\n  __kmem_cache_free+0x15c\/0x290\n  kfree+0x74\/0x100\n  kfree_sensitive+0x80\/0xb0\n  alg_test_skcipher+0x12c\/0x1f0\n  alg_test+0x24c\/0x830\n  cryptomgr_test+0x38\/0x60\n  kthread+0x168\/0x178\n  ret_from_fork+0x10\/0x20\n\n The buggy address belongs to the object at ffff00000dcdc000\n  which belongs to the cache kmalloc-256 of size 256\n The buggy address is located 64 bytes inside of\n  freed 256-byte region [ffff00000dcdc000, ffff00000dcdc100)"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: crypto: sun8i-ce: se corrige el use after free en unprepare. Se debe llamar a sun8i_ce_cipher_unprepare antes de crypto_finalize_skcipher_request, porque las devoluciones de llamada del cliente pueden liberar inmediatamente memoria, que ya no es necesaria. Pero será utilizado por los que no estén preparados después de ser gratuito. Antes de eliminar las devoluciones de llamada de preparación\/despreparación, el motor criptográfico lo manejaba en crypto_finalize_request. Por lo general, esto resulta en un problema de desreferencia del puntero durante una autoprueba en criptografía. No se puede manejar la desreferencia del puntero NULL del kernel en la dirección virtual 0000000000000030 Información de cancelación de memoria: ESR = 0x0000000096000004 EC = 0x25: DABT (EL actual), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x04: falla de traducción de nivel 0 Información de cancelación de datos: ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 CM = 0, WnR = 0, TnD = 0, TagAccess = 0 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 usuario pgtable: páginas de 4k, VA de 48 bits, pgdp=000000004716d000 [0000000000000030] pgd=0000000000000000, p4d=000000000000000000 Error interno: Ups: 0000000096000004 [# 1] SMP Este problema también lo detecta KASAN. ==================================================== ================ ERROR: KASAN: slab-use-after-free en sun8i_ce_cipher_do_one+0x6e8\/0xf80 [sun8i_ce] Lectura de tamaño 8 en la dirección ffff00000dcdc040 por tarea 1c15000.crypto-\/ 373 Nombre del hardware: Pine64 PinePhone (1.2) (DT) Rastreo de llamadas: dump_backtrace+0x9c\/0x128 show_stack+0x20\/0x38 dump_stack_lvl+0x48\/0x60 print_report+0xf8\/0x5d8 kasan_report+0x90\/0xd0 __asan_load8+0x9c\/0xc0 _cipher_do_one+0x6e8\/0xf80 [sun8i_ce] crypto_pump_work+0x354\/0x620 [crypto_engine] kthread_worker_fn+0x244\/0x498 kthread+0x168\/0x178 ret_from_fork+0x10\/0x20 Asignado por tarea 379: kasan_save_stack+0x3c\/0x68 c\/0x40 kasan_save_alloc_info+0x24\/0x38 __kasan_kmalloc+0xd4\/ 0xd8 __kmalloc+0x74\/0x1d0 alg_test_skcipher+0x90\/0x1f0 alg_test+0x24c\/0x830 cryptomgr_test+0x38\/0x60 kthread+0x168\/0x178 ret_from_fork+0x10\/0x20 Liberado por la tarea 379: 3c\/0x68 kasan_set_track+0x2c\/0x40 kasan_save_free_info+0x38\/ 0x60 __kasan_slab_free+0x100\/0x170 slab_free_freelist_hook+0xd4\/0x1e8 __kmem_cache_free+0x15c\/0x290 kfree+0x74\/0x100 kfree_SENSITIVE+0x80\/0xb0 alg_test_skcipher+0x12c\/0x1f0 24c\/0x830 cryptomgr_test+0x38\/0x60 kthread+0x168\/0x178 ret_from_fork+0x10\/ 0x20 La dirección con errores pertenece al objeto en ffff00000dcdc000 que pertenece al caché kmalloc-256 de tamaño 256. La dirección con errores se encuentra a 64 bytes dentro de la región liberada de 256 bytes [ffff00000dcdc000, ffff00000dcdc100)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/183420038444547c149a0fc5f58e792c2752860c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/51a7d338c212e0640b1aca52ba6590d5bea49879","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dc60b25540c82fc4baa95d1458ae96ead21859e0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27062","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.660","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnouveau: lock the client object tree.\n\nIt appears the client object tree has no locking unless I've missed\nsomething else. Fix races around adding\/removing client objects,\nmostly vram bar mappings.\n\n 4562.099306] general protection fault, probably for non-canonical address 0x6677ed422bceb80c: 0000 [#1] PREEMPT SMP PTI\n[ 4562.099314] CPU: 2 PID: 23171 Comm: deqp-vk Not tainted 6.8.0-rc6+ #27\n[ 4562.099324] Hardware name: Gigabyte Technology Co., Ltd. Z390 I AORUS PRO WIFI\/Z390 I AORUS PRO WIFI-CF, BIOS F8 11\/05\/2021\n[ 4562.099330] RIP: 0010:nvkm_object_search+0x1d\/0x70 [nouveau]\n[ 4562.099503] Code: 90 90 90 90 90 90 90 90 90 90 90 90 90 66 0f 1f 00 0f 1f 44 00 00 48 89 f8 48 85 f6 74 39 48 8b 87 a0 00 00 00 48 85 c0 74 12 <48> 8b 48 f8 48 39 ce 73 15 48 8b 40 10 48 85 c0 75 ee 48 c7 c0 fe\n[ 4562.099506] RSP: 0000:ffffa94cc420bbf8 EFLAGS: 00010206\n[ 4562.099512] RAX: 6677ed422bceb814 RBX: ffff98108791f400 RCX: ffff9810f26b8f58\n[ 4562.099517] RDX: 0000000000000000 RSI: ffff9810f26b9158 RDI: ffff98108791f400\n[ 4562.099519] RBP: ffff9810f26b9158 R08: 0000000000000000 R09: 0000000000000000\n[ 4562.099521] R10: ffffa94cc420bc48 R11: 0000000000000001 R12: ffff9810f02a7cc0\n[ 4562.099526] R13: 0000000000000000 R14: 00000000000000ff R15: 0000000000000007\n[ 4562.099528] FS:  00007f629c5017c0(0000) GS:ffff98142c700000(0000) knlGS:0000000000000000\n[ 4562.099534] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 4562.099536] CR2: 00007f629a882000 CR3: 000000017019e004 CR4: 00000000003706f0\n[ 4562.099541] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 4562.099542] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[ 4562.099544] Call Trace:\n[ 4562.099555]  <TASK>\n[ 4562.099573]  ? die_addr+0x36\/0x90\n[ 4562.099583]  ? exc_general_protection+0x246\/0x4a0\n[ 4562.099593]  ? asm_exc_general_protection+0x26\/0x30\n[ 4562.099600]  ? nvkm_object_search+0x1d\/0x70 [nouveau]\n[ 4562.099730]  nvkm_ioctl+0xa1\/0x250 [nouveau]\n[ 4562.099861]  nvif_object_map_handle+0xc8\/0x180 [nouveau]\n[ 4562.099986]  nouveau_ttm_io_mem_reserve+0x122\/0x270 [nouveau]\n[ 4562.100156]  ? dma_resv_test_signaled+0x26\/0xb0\n[ 4562.100163]  ttm_bo_vm_fault_reserved+0x97\/0x3c0 [ttm]\n[ 4562.100182]  ? __mutex_unlock_slowpath+0x2a\/0x270\n[ 4562.100189]  nouveau_ttm_fault+0x69\/0xb0 [nouveau]\n[ 4562.100356]  __do_fault+0x32\/0x150\n[ 4562.100362]  do_fault+0x7c\/0x560\n[ 4562.100369]  __handle_mm_fault+0x800\/0xc10\n[ 4562.100382]  handle_mm_fault+0x17c\/0x3e0\n[ 4562.100388]  do_user_addr_fault+0x208\/0x860\n[ 4562.100395]  exc_page_fault+0x7f\/0x200\n[ 4562.100402]  asm_exc_page_fault+0x26\/0x30\n[ 4562.100412] RIP: 0033:0x9b9870\n[ 4562.100419] Code: 85 a8 f7 ff ff 8b 8d 80 f7 ff ff 89 08 e9 18 f2 ff ff 0f 1f 84 00 00 00 00 00 44 89 32 e9 90 fa ff ff 0f 1f 84 00 00 00 00 00 <44> 89 32 e9 f8 f1 ff ff 0f 1f 84 00 00 00 00 00 66 44 89 32 e9 e7\n[ 4562.100422] RSP: 002b:00007fff9ba2dc70 EFLAGS: 00010246\n[ 4562.100426] RAX: 0000000000000004 RBX: 000000000dd65e10 RCX: 000000fff0000000\n[ 4562.100428] RDX: 00007f629a882000 RSI: 00007f629a882000 RDI: 0000000000000066\n[ 4562.100432] RBP: 00007fff9ba2e570 R08: 0000000000000000 R09: 0000000123ddf000\n[ 4562.100434] R10: 0000000000000001 R11: 0000000000000246 R12: 000000007fffffff\n[ 4562.100436] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n[ 4562.100446]  <\/TASK>\n[ 4562.100448] Modules linked in: nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink cmac bnep sunrpc iwlmvm intel_rapl_msr intel_rapl_common snd_sof_pci_intel_cnl x86_pkg_temp_thermal intel_powerclamp snd_sof_intel_hda_common mac80211 coretemp snd_soc_acpi_intel_match kvm_intel snd_soc_acpi snd_soc_hdac_hda snd_sof_pci snd_sof_xtensa_dsp snd_sof_intel_hda_mlink \n---truncated---"},{"lang":"es","value":"En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: nouveau: bloquea el árbol de objetos del cliente. Parece que el árbol de objetos del cliente no tiene bloqueo a menos que me haya perdido algo más. Se corrigieron ejecucións para agregar o eliminar objetos de cliente, principalmente asignaciones de barras de vram. 4562.099306] falla de protección general, probablemente para dirección no canónica 0x6677ed422bceb80c: 0000 [#1] PREEMPT SMP PTI [ 4562.099314] CPU: 2 PID: 23171 Comm: deqp-vk Not tainted 6.8.0-rc6+ #27 [ 4562.09932 4]Nombre del hardware : Gigabyte Technology Co., Ltd. Z390 I AORUS PRO WIFI\/Z390 I AORUS PRO WIFI-CF, BIOS F8 05\/11\/2021 [4562.099330] RIP: 0010:nvkm_object_search+0x1d\/0x70 [nuevo] [4562.099503] Código: 90 90 90 90 90 90 90 90 90 90 90 90 90 66 0f 1f 00 0f 1f 44 00 00 48 89 f8 48 85 f6 74 39 48 8b 87 a0 00 00 00 48 85 c0 74 12 &lt;48&gt; 8b 48 f8 48 39 ce 73 15 48 8b 40 10 48 85 c0 75 ee 48 c7 c0 fe [ 4562.099506] RSP: 0000:ffffa94cc420bbf8 EFLAGS: 00010206 [ 4562.099512] RAX: 6677ed422bceb814 ffff98108791f400 RCX: ffff9810f26b8f58 [ 4562.099517] RDX: 0000000000000000 RSI: ffff9810f26b9158 RDI: ffff98108791f400 [ 4562.099519] RBP: ffff9810f26b9158 R08: 0000000000000000 R09: 0000000000000000 [ 4562.099521] R10: ffffa94cc420bc48 R11: 00000000000000 01 R12: ffff9810f02a7cc0 [ 4562.099526] R13: 0000000000000000 R14: 00000000000000ff R15: 0000000000000007 [ 4562.099528] FS: 00007f629c 5017c0(0000) GS:ffff98142c700000(0000 ) knlGS:0000000000000000 [ 4562.099534] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 4562.099536] CR2: 00007f629a882000 CR3: 17019e004 CR4: 00000000003706f0 [ 4562.099541] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 4562.099542] DR3: 0000000000000 DR6 : 00000000fffe0ff0 DR7: 0000000000000400 [ 4562.099544] Seguimiento de llamadas: [ 4562.099555]  [ 4562.099573] ? die_addr+0x36\/0x90 [4562.099583]? exc_general_protection+0x246\/0x4a0 [4562.099593]? asm_exc_general_protection+0x26\/0x30 [4562.099600]? nvkm_object_search+0x1d\/0x70 [nuevo] [ 4562.099730] nvkm_ioctl+0xa1\/0x250 [nuevo] [ 4562.099861] nvif_object_map_handle+0xc8\/0x180 [nuevo] [ 4562.099986] _io_mem_reserve+0x122\/0x270 [nuevo] [ 4562.100156] ? dma_resv_test_signaled+0x26\/0xb0 [4562.100163] ttm_bo_vm_fault_reserved+0x97\/0x3c0 [ttm] [4562.100182]? __mutex_unlock_slowpath+0x2a\/0x270 [ 4562.100189] nouveau_ttm_fault+0x69\/0xb0 [nuevo] [ 4562.100356] __do_fault+0x32\/0x150 [ 4562.100362] do_fault+0x7c\/0x560 [ 4 562.100369] __handle_mm_fault+0x800\/0xc10 [ 4562.100382] handle_mm_fault+0x17c\/0x3e0 [ 4562.100388 ] do_user_addr_fault+0x208\/0x860 [ 4562.100395] exc_page_fault+0x7f\/0x200 [ 4562.100402] asm_exc_page_fault+0x26\/0x30 [ 4562.100412] RIP: 0033:0x9b9870 [ 4562.100419] Código: 85 a8 f7 ff ff 8b 8d 80 f7 ff ff 89 08 e9 18 f2 ff ff 0f 1f 84 00 00 00 00 00 44 89 32 e9 90 fa ff ff 0f 1f 84 00 00 00 00 00 &lt;44&gt; 89 32 e9 f8 f1 ff ff 0f 1f 84 00 00 00 00 00 66 89 32 e9 e7 [ 4562.100422] RSP: 002b:00007fff9ba2dc70 EFLAGS: 00010246 [ 4562.100426] RAX: 00000000000000004 RBX: 000000000dd65e10 RCX: 000000fff0000 000 [4562.100428] RDX: 00007f629a882000 RSI: 00007f629a882000 RDI: 0000000000000066 [4562.100432] RBP: 00007fff9ba2e570 R08: 0000000 R09: 0000000123ddf000 [4562.100434 ] R10: 0000000000000001 R11: 00000000000000246 R12: 000000007ffffff [ 4562.100436] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 [ 4562.100446]  [ 4562.100448] Módulos vinculados en: nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink cmac bnep sunrpc iwlmvm intel_rapl_msr intel_rapl_common snd_sof_pci_intel_cnl x86_pkg_temp_thermal intel_powerclamp snd_sof_intel_hda_common mac802 11 coretemp snd_soc_acpi_intel_match kvm_intel snd_soc_acpi snd_soc_hdac_hda snd_sof_pci snd_sof_xtensa_dsp snd_sof_intel_hda_mlink ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6887314f5356389fc219b8152e951ac084a10ef7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/96c8751844171af4b3898fee3857ee180586f589","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7cc4ff787a572edf2c55caeffaa88cd801eb135","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27063","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.707","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nleds: trigger: netdev: Fix kernel panic on interface rename trig notify\n\nCommit d5e01266e7f5 (\"leds: trigger: netdev: add additional specific link\nspeed mode\") in the various changes, reworked the way to set the LINKUP\nmode in commit cee4bd16c319 (\"leds: trigger: netdev: Recheck\nNETDEV_LED_MODE_LINKUP on dev rename\") and moved it to a generic function.\n\nThis changed the logic where, in the previous implementation the dev\nfrom the trigger event was used to check if the carrier was ok, but in\nthe new implementation with the generic function, the dev in\ntrigger_data is used instead.\n\nThis is problematic and cause a possible kernel panic due to the fact\nthat the dev in the trigger_data still reference the old one as the\nnew one (passed from the trigger event) still has to be hold and saved\nin the trigger_data struct (done in the NETDEV_REGISTER case).\n\nOn calling of get_device_state(), an invalid net_dev is used and this\ncause a kernel panic.\n\nTo handle this correctly, move the call to get_device_state() after the\nnew net_dev is correctly set in trigger_data (in the NETDEV_REGISTER\ncase) and correctly parse the new dev."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: leds: trigger: netdev: corrige el pánico del kernel al cambiar el nombre de la interfaz, notifica el trigono. Commit d5e01266e7f5 (\"leds: trigger: netdev: agrega un modo de velocidad de enlace específico adicional\") en los diversos cambios, reelaborados la forma de configurar el modo LINKUP en el commit cee4bd16c319 (\"leds: trigger: netdev: Recheck NETDEV_LED_MODE_LINKUP on dev rename\") y lo moví a una función genérica. Esto cambió la lógica donde, en la implementación anterior, se usaba el desarrollo del evento desencadenante para verificar si el operador estaba bien, pero en la nueva implementación con la función genérica, se usa el desarrollo en trigger_data. Esto es problemático y causa un posible pánico en el kernel debido al hecho de que el desarrollador en trigger_data aún hace referencia al anterior, ya que el nuevo (pasado desde el evento desencadenante) aún debe retenerse y guardarse en la estructura trigger_data (hecho en el caso NETDEV_REGISTER). Al llamar a get_device_state(), se utiliza un net_dev no válido y esto provoca un pánico en el kernel. Para manejar esto correctamente, mueva la llamada a get_device_state() después de que el nuevo net_dev esté configurado correctamente en trigger_data (en el caso NETDEV_REGISTER) y analice correctamente el nuevo dev."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/10f2af1af8ab8a7064f193446abd5579d3def7e3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3f360227cb46edb2cd2494128e1e06ed5768a62e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/415798bc07dd1c1ae3a656aa026580816e0b9fe8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/acd025c7a7d151261533016a6ca2d38f2de04e87","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27064","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.757","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: Fix a memory leak in nf_tables_updchain\n\nIf nft_netdev_register_hooks() fails, the memory associated with\nnft_stats is not freed, causing a memory leak.\n\nThis patch fixes it by moving nft_stats_alloc() down after\nnft_netdev_register_hooks() succeeds."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: netfilter: nf_tables: corrige una pérdida de memoria en nf_tables_updchain Si nft_netdev_register_hooks() falla, la memoria asociada con nft_stats no se libera, lo que provoca una pérdida de memoria. Este parche lo soluciona moviendo nft_stats_alloc() hacia abajo después de que nft_netdev_register_hooks() tenga éxito."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4e4623a4f6e133e671f65f9ac493bddaaf63e250","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/79846fdcc548d617b0b321addc6a3821d3b75b20","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7eaf837a4eb5f74561e2486972e7f5184b613f6e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e77a6b53a3a547b6dedfc40c37cee4f310701090","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27065","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.803","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: do not compare internal table flags on updates\n\nRestore skipping transaction if table update does not modify flags."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: netfilter: nf_tables: no comparar indicadores de tablas internas en las actualizaciones Restaurar la transacción omitida si la actualización de la tabla no modifica los indicadores."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2531f907d3e40a6173090f10670ae76d117ab27b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3443e57654f90c9a843ab6a6040c10709fd033aa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4a0e7f2decbf9bd72461226f1f5f7dcc4b08f139","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4d37f12707ee965d338028732575f0b85f6d9e4f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/640dbf688ba955e83e03de84fbdda8e570b7cce4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9683cb6c2c6c0f45537bf0b8868b5d38fcb63fc7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df257c435e51651c43b86326d112ddadda76350e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fcf32a5bfcb8a57ac0ce717fcfa4d688c91f1005","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27066","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.850","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio: packed: fix unmap leak for indirect desc table\n\nWhen use_dma_api and premapped are true, then the do_unmap is false.\n\nBecause the do_unmap is false, vring_unmap_extra_packed is not called by\ndetach_buf_packed.\n\n  if (unlikely(vq->do_unmap)) {\n                curr = id;\n                for (i = 0; i < state->num; i++) {\n                        vring_unmap_extra_packed(vq,\n                                                 &vq->packed.desc_extra[curr]);\n                        curr = vq->packed.desc_extra[curr].next;\n                }\n  }\n\nSo the indirect desc table is not unmapped. This causes the unmap leak.\n\nSo here, we check vq->use_dma_api instead. Synchronously, dma info is\nupdated based on use_dma_api judgment\n\nThis bug does not occur, because no driver use the premapped with\nindirect."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: virtio: empaquetado: corrige la fuga de desasignación para la tabla desc indirecta Cuando use_dma_api y premapped son verdaderos, entonces do_unmap es falso. Debido a que do_unmap es falso, detach_buf_packed no llama a vring_unmap_extra_packed. if (improbable(vq-&gt;do_unmap)) { curr = id; for (i = 0; i &lt; estado-&gt;num; i++) { vring_unmap_extra_packed(vq, &amp;vq-&gt;packed.desc_extra[curr]); curr = vq-&gt;packed.desc_extra[curr].next; } } Por lo tanto, la tabla de descripción indirecta no está desasignada. Esto provoca la fuga de desasignación. Así que aquí marcamos vq-&gt;use_dma_api en su lugar. Sincrónicamente, la información de dma se actualiza según el criterio use_dma_api. Este error no ocurre porque ningún controlador utiliza el preasignado con indirecto."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/51bacd9d29bf98c3ebc65e4a0477bb86306b4140","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/75450ff8c6fe8755bf5b139b238eaf9739cfd64e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d5c0ed17fea60cca9bc3bf1278b49ba79242bbcd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e142169aca5546ae6619c39a575cda8105362100","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27067","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.893","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nxen\/evtchn: avoid WARN() when unbinding an event channel\n\nWhen unbinding a user event channel, the related handler might be\ncalled a last time in case the kernel was built with\nCONFIG_DEBUG_SHIRQ. This might cause a WARN() in the handler.\n\nAvoid that by adding an \"unbinding\" flag to struct user_event which\nwill short circuit the handler."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: xen\/evtchn: evite WARN() al desvincular un canal de eventos Al desvincular un canal de eventos de usuario, es posible que se llame al controlador relacionado por última vez en caso de que el kernel se haya compilado con CONFIG_DEBUG_SHIRQ. Esto podría provocar un WARN() en el controlador. Evite esto agregando un indicador de \"desvinculación\" a la estructura user_event que provocará un cortocircuito en el controlador."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/35485dad6e28f9b17884764d4692b1655cb848d0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/51c23bd691c0f1fb95b29731c356c6fd69925d17","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/99e425032c6ec13584d3cd33846e0c7307501b47","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9e2d4b58c1da48a32905802aaeadba7084b46895","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27068","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.937","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nthermal\/drivers\/mediatek\/lvts_thermal: Fix a memory leak in an error handling path\n\nIf devm_krealloc() fails, then 'efuse' is leaking.\nSo free it to avoid a leak."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: Thermal\/drivers\/mediatek\/lvts_thermal: corrige una pérdida de memoria en una ruta de manejo de errores. Si devm_krealloc() falla, entonces 'efuse' tiene una fuga. Así que libérelo para evitar una fuga."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2db869da91afd48e5b9ec76814709be49662b07d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9b02197596671800dd934609384b1aca7c6ad218","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a37f3652bee468f879d35fe2da9ede3f1dcbb7be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca93bf607a44c1f009283dac4af7df0d9ae5e357","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27069","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:50.987","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\novl: relax WARN_ON in ovl_verify_area()\n\nsyzbot hit an assertion in copy up data loop which looks like it is\nthe result of a lower file whose size is being changed underneath\noverlayfs.\n\nThis type of use case is documented to cause undefined behavior, so\nreturning EIO error for the copy up makes sense, but it should not be\ncausing a WARN_ON assertion."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ovl: relax WARN_ON en ovl_verify_area() syzbot alcanzó una afirmación en el bucle de copia de datos que parece ser el resultado de un archivo inferior cuyo tamaño se está cambiando debajo de overlayfs. Está documentado que este tipo de caso de uso causa un comportamiento indefinido, por lo que devolver un error EIO para la copia tiene sentido, pero no debería causar una afirmación WARN_ON."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/77a28aa476873048024ad56daf8f4f17d58ee48e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c3c85aefc0da1e5074a06c682542a54ccc99bdca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27070","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.037","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to avoid use-after-free issue in f2fs_filemap_fault\n\nsyzbot reports a f2fs bug as below:\n\nBUG: KASAN: slab-use-after-free in f2fs_filemap_fault+0xd1\/0x2c0 fs\/f2fs\/file.c:49\nRead of size 8 at addr ffff88807bb22680 by task syz-executor184\/5058\n\nCPU: 0 PID: 5058 Comm: syz-executor184 Not tainted 6.7.0-syzkaller-09928-g052d534373b7 #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 11\/17\/2023\nCall Trace:\n <TASK>\n __dump_stack lib\/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1e7\/0x2d0 lib\/dump_stack.c:106\n print_address_description mm\/kasan\/report.c:377 [inline]\n print_report+0x163\/0x540 mm\/kasan\/report.c:488\n kasan_report+0x142\/0x170 mm\/kasan\/report.c:601\n f2fs_filemap_fault+0xd1\/0x2c0 fs\/f2fs\/file.c:49\n __do_fault+0x131\/0x450 mm\/memory.c:4376\n do_shared_fault mm\/memory.c:4798 [inline]\n do_fault mm\/memory.c:4872 [inline]\n do_pte_missing mm\/memory.c:3745 [inline]\n handle_pte_fault mm\/memory.c:5144 [inline]\n __handle_mm_fault+0x23b7\/0x72b0 mm\/memory.c:5285\n handle_mm_fault+0x27e\/0x770 mm\/memory.c:5450\n do_user_addr_fault arch\/x86\/mm\/fault.c:1364 [inline]\n handle_page_fault arch\/x86\/mm\/fault.c:1507 [inline]\n exc_page_fault+0x456\/0x870 arch\/x86\/mm\/fault.c:1563\n asm_exc_page_fault+0x26\/0x30 arch\/x86\/include\/asm\/idtentry.h:570\n\nThe root cause is: in f2fs_filemap_fault(), vmf->vma may be not alive after\nfilemap_fault(), so it may cause use-after-free issue when accessing\nvmf->vma->vm_flags in trace_f2fs_filemap_fault(). So it needs to keep vm_flags\nin separated temporary variable for tracepoint use."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: f2fs: solución para evitar el problema de use-after-free en f2fs_filemap_fault syzbot informa un error de f2fs como se muestra a continuación: ERROR: KASAN: slab-use-after-free en f2fs_filemap_fault+0xd1\/0x2c0 fs\/f2fs\/file.c:49 Lectura de tamaño 8 en la dirección ffff88807bb22680 por tarea syz-executor184\/5058 CPU: 0 PID: 5058 Comm: syz-executor184 Not tainted 6.7.0-syzkaller-09928-g052d534373b7 #0 Nombre de hardware: Google Google Compute Engine\/Google Compute Engine, BIOS Google 17\/11\/2023 Seguimiento de llamadas:  __dump_stack lib\/dump_stack.c:88 [en línea] dump_stack_lvl+0x1e7\/0x2d0 lib\/dump_stack.c:106 print_address_description mm\/kasan\/ report.c:377 [en línea] print_report+0x163\/0x540 mm\/kasan\/report.c:488 kasan_report+0x142\/0x170 mm\/kasan\/report.c:601 f2fs_filemap_fault+0xd1\/0x2c0 fs\/f2fs\/file.c:49 __do_fault+0x131\/0x450 mm\/memory.c:4376 do_shared_fault mm\/memory.c:4798 [en línea] do_fault mm\/memory.c:4872 [en línea] do_pte_missing mm\/memory.c:3745 [en línea] handle_pte_fault mm\/memory. c:5144 [en línea] __handle_mm_fault+0x23b7\/0x72b0 mm\/memory.c:5285 handle_mm_fault+0x27e\/0x770 mm\/memory.c:5450 do_user_addr_fault arch\/x86\/mm\/fault.c:1364 [en línea] handle_page_fault arch\/x86\/ mm\/fault.c:1507 [en línea] exc_page_fault+0x456\/0x870 arch\/x86\/mm\/fault.c:1563 asm_exc_page_fault+0x26\/0x30 arch\/x86\/include\/asm\/idtentry.h:570 La causa raíz es: en f2fs_filemap_fault(), es posible que vmf-&gt;vma no esté activo después de filemap_fault(), por lo que puede causar un problema de use-after-free al acceder a vmf-&gt;vma-&gt;vm_flags en trace_f2fs_filemap_fault(). Por lo tanto, debe mantener vm_flags en una variable temporal separada para su uso en puntos de seguimiento."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/8186e16a766d709a08f188d2f4e84098f364bea1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb70d5a6c932d9d23f4bb3e7b83782c21ac4b064","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27071","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.083","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbacklight: hx8357: Fix potential NULL pointer dereference\n\nThe \"im\" pins are optional. Add missing check in the hx8357_probe()."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: retroiluminación: hx8357: corrige una posible desreferencia del puntero NULL Los pines \"im\" son opcionales. Agregue el cheque que falta en hx8357_probe()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/67e578c8ff2d7df03bf8ca9a7f5436b1796f6ad1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b1ba8bcb2d1ffce11b308ce166c9cc28d989e3b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27072","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.127","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: usbtv: Remove useless locks in usbtv_video_free()\n\nRemove locks calls in usbtv_video_free() because\nare useless and may led to a deadlock as reported here:\nhttps:\/\/syzkaller.appspot.com\/x\/bisect.txt?x=166dc872180000\nAlso remove usbtv_stop() call since it will be called when\nunregistering the device.\n\nBefore 'c838530d230b' this issue would only be noticed if you\ndisconnect while streaming and now it is noticeable even when\ndisconnecting while not streaming.\n\n\n[hverkuil: fix minor spelling mistake in log message]"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: medios: usbtv: Eliminar bloqueos inútiles en usbtv_video_free() Eliminar llamadas de bloqueos en usbtv_video_free() porque son inútiles y pueden provocar un punto muerto como se informa aquí: https:\/\/syzkaller.appspot .com\/x\/bisect.txt?x=166dc872180000 También elimine la llamada usbtv_stop() ya que se llamará al cancelar el registro del dispositivo. Antes de 'c838530d230b', este problema solo se notaba si se desconectaba mientras se transmitía y ahora se nota incluso cuando se desconecta mientras no se transmite. [hverkuil: corrige un error ortográfico menor en el mensaje de registro]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3e7d82ebb86e94643bdb30b0b5b077ed27dce1c2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/65e6a2773d655172143cc0b927cdc89549842895","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27073","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.167","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: ttpci: fix two memleaks in budget_av_attach\n\nWhen saa7146_register_device and saa7146_vv_init fails, budget_av_attach\nshould free the resources it allocates, like the error-handling of\nttpci_budget_init does. Besides, there are two fixme comment refers to\nsuch deallocations."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: medios: ttpci: corrige dos fugas de mem en Budget_av_attach Cuando fallan saa7146_register_device y saa7146_vv_init, Budget_av_attach debería liberar los recursos que asigna, como lo hace el manejo de errores de ttpci_budget_init. Además, hay dos comentarios fijos que se refieren a dichas desasignaciones."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1597cd1a88cfcdc4bf8b1b44cd458fed9a5a5d63","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/24e51d6eb578b82ff292927f14b9f5ec05a46beb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/55ca0c7eae8499bb96f4e5d9b26af95e89c4e6a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/656b8cc123d7635dd399d9f02594f27aa797ac3c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7393c681f9aa05ffe2385e8716989565eed2fe06","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/910363473e4bf97da3c350e08d915546dd6cc30b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/af37aed04997e644f7e1b52b696b62dcae3cc016","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0b07f712bf61e1a3cf23c87c663791c42e50837","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27074","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.207","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: go7007: fix a memleak in go7007_load_encoder\n\nIn go7007_load_encoder, bounce(i.e. go->boot_fw), is allocated without\na deallocation thereafter. After the following call chain:\n\nsaa7134_go7007_init\n  |-> go7007_boot_encoder\n        |-> go7007_load_encoder\n  |-> kfree(go)\n\ngo is freed and thus bounce is leaked."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: medios: go7007: corrige una fuga de memoria en go7007_load_encoder En go7007_load_encoder, el rebote (es decir, go-&gt;boot_fw) se asigna sin una desasignación posterior. Después de la siguiente cadena de llamadas: saa7134_go7007_init |-&gt; go7007_boot_encoder |-&gt; go7007_load_encoder |-&gt; kfree(go) go se libera y, por lo tanto, se filtra el rebote."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/291cda0b805fc0d6e90d201710311630c8667159","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7405a0d4442792988e9ae834e7d84f9d163731a4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/790fa2c04dfb9f095ec372bf17909424d6e864b3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7f11dd3d165b178e738fe73dfeea513e383bedb5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b49fe84c6cefcc1c2336d793b53442e716c95073","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b9b683844b01d171a72b9c0419a2d760d946ee12","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d43988a23c32588ccd0c74219637afb96cd78661","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e04d15c8bb3e111dd69f98894acd92d63e87aac3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f31c1cc37411f5f7bcb266133f9a7e1b4bdf2975","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27075","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.257","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: dvb-frontends: avoid stack overflow warnings with clang\n\nA previous patch worked around a KASAN issue in stv0367, now a similar\nproblem showed up with clang:\n\ndrivers\/media\/dvb-frontends\/stv0367.c:1222:12: error: stack frame size (3624) exceeds limit (2048) in 'stv0367ter_set_frontend' [-Werror,-Wframe-larger-than]\n 1214 | static int stv0367ter_set_frontend(struct dvb_frontend *fe)\n\nRework the stv0367_writereg() function to be simpler and mark both\nregister access functions as noinline_for_stack so the temporary\ni2c_msg structures do not get duplicated on the stack when KASAN_STACK\nis enabled."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: media: dvb-frontends: evita advertencias de desbordamiento de pila con clang. Un parche anterior solucionó un problema de KASAN en stv0367, ahora apareció un problema similar con clang: drivers\/media\/dvb- frontends\/stv0367.c:1222:12: error: el tamaño del marco de pila (3624) excede el límite (2048) en 'stv0367ter_set_frontend' [-Werror,-Wframe-larger-than] 1214 | static int stv0367ter_set_frontend(struct dvb_frontend *fe) Vuelva a trabajar la función stv0367_writereg() para que sea más simple y marque ambas funciones de acceso a registros como noinline_for_stack para que las estructuras temporales i2c_msg no se dupliquen en la pila cuando KASAN_STACK esté habilitado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/107052a8cfeff3a97326277192b4f052e4860a8a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7a4cf27d1f0538f779bf31b8c99eda394e277119","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8fad9c5bb00d3a9508d18bbfe832e33a47377730","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c073c8cede5abd3836e83d70d72606d11d0759d4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d20b64f156de5d10410963fe238d82a4e7e97a2f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d6b4895197ab5a47cb81c6852d49320b05052960","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ed514ecf4f29c80a2f09ae3c877059b401efe893","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fa8b472952ef46eb632825051078c21ce0cafe55","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fb07104a02e87c06c39914d13ed67fd8f839ca82","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27076","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.307","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: imx: csc\/scaler: fix v4l2_ctrl_handler memory leak\n\nFree the memory allocated in v4l2_ctrl_handler_init on release."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: medios: imx: csc\/scaler: corrige la pérdida de memoria v4l2_ctrl_handler Libere la memoria asignada en v4l2_ctrl_handler_init en el lanzamiento."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/42492b00156c03a79fd4851190aa63045d6a15ce","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4797a3dd46f220e6d83daf54d70c5b33db6deb01","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5d9fe604bf9b5b09d2215225df55f22a4cbbc684","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6c92224721a439d6350db5933a1060768dcd565e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8c2e4efe1278cd2b230cdbf90a6cefbf00acc282","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8df9a3c7044b847e9c4dc7e683fd64c6b873f328","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b1d0eebaf87cc9ccd05f779ec4a0589f95d6c18b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d164ddc21e986dd9ad614b4b01746e5457aeb24f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27077","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.350","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: v4l2-mem2mem: fix a memleak in v4l2_m2m_register_entity\n\nThe entity->name (i.e. name) is allocated in v4l2_m2m_register_entity\nbut isn't freed in its following error-handling paths. This patch\nadds such deallocation to prevent memleak of entity->name."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: medio: v4l2-mem2mem: corrige una fuga de mem en v4l2_m2m_register_entity La entidad-&gt;nombre (es decir, nombre) se asigna en v4l2_m2m_register_entity pero no se libera en las siguientes rutas de manejo de errores. Este parche agrega dicha desasignación para evitar la fuga de memoria de entidad-&gt;nombre."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0175f2d34c85744f9ad6554f696cf0afb5bd04e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0c9550b032de48d6a7fa6a4ddc09699d64d9300d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3dd8abb0ed0e0a7c66d6d677c86ccb188cc39333","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5dc319cc3c4f7b74f7dfba349aa26f87efb52458","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f94b49a5b5d386c038e355bef6347298aabd211","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90029b9c979b60de5cb2b70ade4bbf61d561bc5d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9c23ef30e840fedc66948299509f6c2777c9cf4f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/afd2a82fe300032f63f8be5d6cd6981e75f8bbf2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dc866b69cc51af9b8509b4731b8ce2a4950cd0ef","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27078","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.393","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: v4l2-tpg: fix some memleaks in tpg_alloc\n\nIn tpg_alloc, resources should be deallocated in each and every\nerror-handling paths, since they are allocated in for statements.\nOtherwise there would be memleaks because tpg_free is called only when\ntpg_alloc return 0."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: medio: v4l2-tpg: corrige algunas fugas de memoria en tpg_alloc En tpg_alloc, los recursos deben desasignarse en todas y cada una de las rutas de manejo de errores, ya que se asignan en declaraciones for. De lo contrario, habría memleaks porque se llama a tpg_free solo cuando tpg_alloc devuelve 0."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0de691ff547d86dd54c24b40a81f9c925df8dd77","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/31096da07933598da8522c54bd007376fb152a09","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4c86c772fef06f5d7a66151bac42366825db0941","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/622b1cf38521569869c8f7b9fbe9e4f1a289add7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6bf5c2fade8ed53b2d26fa9875e5b04f36c7145d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/770a57922ce36a8476c43f7400b6501c554ea511","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8269ab16415f2065cd792c49b0475543936cbd79","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8cf9c5051076e0eb958f4361d50d8b0c3ee6691c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/94303a06e1852a366e9671fff46d19459f88cb28","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27079","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.443","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\niommu\/vt-d: Fix NULL domain on device release\n\nIn the kdump kernel, the IOMMU operates in deferred_attach mode. In this\nmode, info->domain may not yet be assigned by the time the release_device\nfunction is called. It leads to the following crash in the crash kernel:\n\n    BUG: kernel NULL pointer dereference, address: 000000000000003c\n    ...\n    RIP: 0010:do_raw_spin_lock+0xa\/0xa0\n    ...\n    _raw_spin_lock_irqsave+0x1b\/0x30\n    intel_iommu_release_device+0x96\/0x170\n    iommu_deinit_device+0x39\/0xf0\n    __iommu_group_remove_device+0xa0\/0xd0\n    iommu_bus_notifier+0x55\/0xb0\n    notifier_call_chain+0x5a\/0xd0\n    blocking_notifier_call_chain+0x41\/0x60\n    bus_notify+0x34\/0x50\n    device_del+0x269\/0x3d0\n    pci_remove_bus_device+0x77\/0x100\n    p2sb_bar+0xae\/0x1d0\n    ...\n    i801_probe+0x423\/0x740\n\nUse the release_domain mechanism to fix it. The scalable mode context\nentry which is not part of release domain should be cleared in\nrelease_device()."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: iommu\/vt-d: corrige el dominio NULL al lanzar el dispositivo. En el kernel kdump, IOMMU opera en modo deferred_attach. En este modo, es posible que info-&gt;dominio aún no esté asignado cuando se llama a la función release_device. Conduce al siguiente bloqueo en el kernel bloqueado: ERROR: desreferencia del puntero NULL del kernel, dirección: 000000000000003c ... RIP: 0010:do_raw_spin_lock+0xa\/0xa0 ... _raw_spin_lock_irqsave+0x1b\/0x30 intel_iommu_release_device+0x96\/0x170 +0x39\/ 0xf0 __iommu_group_remove_device+0xa0\/0xd0 iommu_bus_notifier+0x55\/0xb0 notifier_call_chain+0x5a\/0xd0 blocking_notifier_call_chain+0x41\/0x60 bus_notify+0x34\/0x50 device_del+0x269\/0x3d0 vice+0x77\/0x100 p2sb_bar+0xae\/0x1d0 ... i801_probe+0x423\/0x740 Uso el mecanismo release_domain para solucionarlo. La entrada de contexto del modo escalable que no forma parte del dominio de lanzamiento debe borrarse en release_device()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/333fe86968482ca701c609af590003bcea450e8f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/81e921fd321614c2ad8ac333b041aae1da7a1c6d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27080","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.497","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix race when detecting delalloc ranges during fiemap\n\nFor fiemap we recently stopped locking the target extent range for the\nwhole duration of the fiemap call, in order to avoid a deadlock in a\nscenario where the fiemap buffer happens to be a memory mapped range of\nthe same file. This use case is very unlikely to be useful in practice but\nit may be triggered by fuzz testing (syzbot, etc).\n\nThis however introduced a race that makes us miss delalloc ranges for\nfile regions that are currently holes, so the caller of fiemap will not\nbe aware that there's data for some file regions. This can be quite\nserious for some use cases - for example in coreutils versions before 9.0,\nthe cp program used fiemap to detect holes and data in the source file,\ncopying only regions with data (extents or delalloc) from the source file\nto the destination file in order to preserve holes (see the documentation\nfor its --sparse command line option). This means that if cp was used\nwith a source file that had delalloc in a hole, the destination file could\nend up without that data, which is effectively a data loss issue, if it\nhappened to hit the race described below.\n\nThe race happens like this:\n\n1) Fiemap is called, without the FIEMAP_FLAG_SYNC flag, for a file that\n   has delalloc in the file range [64M, 65M[, which is currently a hole;\n\n2) Fiemap locks the inode in shared mode, then starts iterating the\n   inode's subvolume tree searching for file extent items, without having\n   the whole fiemap target range locked in the inode's io tree - the\n   change introduced recently by commit b0ad381fa769 (\"btrfs: fix\n   deadlock with fiemap and extent locking\"). It only locks ranges in\n   the io tree when it finds a hole or prealloc extent since that\n   commit;\n\n3) Note that fiemap clones each leaf before using it, and this is to\n   avoid deadlocks when locking a file range in the inode's io tree and\n   the fiemap buffer is memory mapped to some file, because writing\n   to the page with btrfs_page_mkwrite() will wait on any ordered extent\n   for the page's range and the ordered extent needs to lock the range\n   and may need to modify the same leaf, therefore leading to a deadlock\n   on the leaf;\n\n4) While iterating the file extent items in the cloned leaf before\n   finding the hole in the range [64M, 65M[, the delalloc in that range\n   is flushed and its ordered extent completes - meaning the corresponding\n   file extent item is in the inode's subvolume tree, but not present in\n   the cloned leaf that fiemap is iterating over;\n\n5) When fiemap finds the hole in the [64M, 65M[ range by seeing the gap in\n   the cloned leaf (or a file extent item with disk_bytenr == 0 in case\n   the NO_HOLES feature is not enabled), it will lock that file range in\n   the inode's io tree and then search for delalloc by checking for the\n   EXTENT_DELALLOC bit in the io tree for that range and ordered extents\n   (with btrfs_find_delalloc_in_range()). But it finds nothing since the\n   delalloc in that range was already flushed and the ordered extent\n   completed and is gone - as a result fiemap will not report that there's\n   delalloc or an extent for the range [64M, 65M[, so user space will be\n   mislead into thinking that there's a hole in that range.\n\nThis could actually be sporadically triggered with test case generic\/094\nfrom fstests, which reports a missing extent\/delalloc range like this:\n\n  generic\/094 2s ... - output mismatch (see \/home\/fdmanana\/git\/hub\/xfstests\/results\/\/generic\/094.out.bad)\n      --- tests\/generic\/094.out\t2020-06-10 19:29:03.830519425 +0100\n      +++ \/home\/fdmanana\/git\/hub\/xfstests\/results\/\/generic\/094.out.bad\t2024-02-28 11:00:00.381071525 +0000\n      @@ -1,3 +1,9 @@\n       QA output created by 094\n       fiemap run with sync\n       fiemap run without sync\n      +ERROR: couldn't find extent at 7\n      +map is 'HHDDHPPDPHPH'\n      +logical: [       5..       6] phys:\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: btrfs: corrige la ejecución al detectar rangos de delalloc durante fiemap Para fiemap recientemente dejamos de bloquear el rango de extensión objetivo durante toda la duración de la llamada a fiemap, para evitar un punto muerto en un escenario donde el búfer fiemap resulta ser un rango mapeado en memoria del mismo archivo. Es muy poco probable que este caso de uso sea útil en la práctica, pero puede activarse mediante pruebas difusas (syzbot, etc.). Sin embargo, esto introdujo una ejecución que nos hace perder rangos de delalloc para regiones de archivos que actualmente están vacías, por lo que quien llama a fiemap no sabrá que hay datos para algunas regiones de archivos. Esto puede ser bastante grave en algunos casos de uso; por ejemplo, en las versiones de Coreutils anteriores a la 9.0, el programa cp utilizaba fiemap para detectar agujeros y datos en el archivo de origen, copiando solo regiones con datos (extensiones o delalloc) del archivo de origen al destino. archivo para preservar los agujeros (consulte la documentación para conocer su opción de línea de comando --sparse). Esto significa que si se usó cp con un archivo de origen que tenía delalloc en un agujero, el archivo de destino podría terminar sin esos datos, lo que efectivamente es un problema de pérdida de datos, si llegara a la ejecución que se describe a continuación. La ejecución ocurre así: 1) Se llama a Fiemap, sin el indicador FIEMAP_FLAG_SYNC, para un archivo que tiene delalloc en el rango de archivos [64M, 65M[, que actualmente es un agujero; 2) Fiemap bloquea el inodo en modo compartido, luego comienza a iterar el árbol de subvolumen del inodo buscando elementos de extensión de archivo, sin tener todo el rango objetivo de fiemap bloqueado en el árbol io del inodo - el cambio introducido recientemente por el commit b0ad381fa769 (\"btrfs: fix deadlock\" con fiemap y bloqueo de extensión\"). Solo bloquea rangos en el árbol io cuando encuentra un agujero o una extensión de asignación previa desde esa confirmación; 3) Tenga en cuenta que fiemap clona cada hoja antes de usarla, y esto es para evitar interbloqueos al bloquear un rango de archivos en el árbol io del inodo y el búfer de fiemap está asignado en memoria a algún archivo, porque escribir en la página con btrfs_page_mkwrite() esperará en cualquier extensión ordenada para el rango de la página y la extensión ordenada necesita bloquear el rango y puede necesitar modificar la misma hoja, lo que lleva a un punto muerto en la hoja; 4) Mientras se iteran los elementos de extensión del archivo en la hoja clonada antes de encontrar el hueco en el rango [64M, 65M[, la delalloc en ese rango se vacía y su extensión ordenada se completa, lo que significa que el elemento de extensión del archivo correspondiente está en el árbol de subvolumen del inodo. , pero no está presente en la hoja clonada sobre la que fiemap está iterando; 5) Cuando fiemap encuentra el agujero en el rango [64M, 65M[ al ver el espacio en la hoja clonada (o un elemento de extensión de archivo con disk_bytenr == 0 en caso de que la función NO_HOLES no esté habilitada), bloqueará ese rango de archivos. en el árbol io del inodo y luego busque delalloc verificando el bit EXTENT_DELALLOC en el árbol io para ese rango y extensiones ordenadas (con btrfs_find_delalloc_in_range()). Pero no encuentra nada ya que la delalloc en ese rango ya se vació y la extensión ordenada se completó y desapareció; como resultado, fiemap no informará que hay delalloc o una extensión para el rango [64M, 65M[, por lo que el espacio del usuario será engañoso a pensar que hay un agujero en ese rango. En realidad, esto podría activarse esporádicamente con el caso de prueba generic\/094 de fstests, que informa que falta un rango de extensión\/delalloc como este: generic\/094 2s ... - falta de coincidencia de salida (consulte \/home\/fdmanana\/git\/hub\/xfstests\/results \/\/generic\/094.out.bad) ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/49d640d2946c35a17b051d54171a032dd95b0f50","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/978b63f7464abcfd364a6c95f734282c50f3decf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ced63fffd63072c0ca55d5a451010d71bf08c0b3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27388","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.550","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nSUNRPC: fix some memleaks in gssx_dec_option_array\n\nThe creds and oa->data need to be freed in the error-handling paths after\ntheir allocation. So this patch add these deallocations in the\ncorresponding paths."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: SUNRPC: corrige algunas fugas de mem en gssx_dec_option_array Los creds y oa-&gt;data deben liberarse en las rutas de manejo de errores después de su asignación. Entonces este parche agrega estas desasignaciones en las rutas correspondientes."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3cfcfc102a5e57b021b786a755a38935e357797d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5e6013ae2c8d420faea553d363935f65badd32c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/934212a623cbab851848b6de377eb476718c3e4c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9806c2393cd2ab0a8e7bb9ffae02ce20e3112ec4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/996997d1fb2126feda550d6adcedcbd94911fc69","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b97c37978ca825557d331c9012e0c1ddc0e42364","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bb336cd8d5ecb69c430ebe3e7bcff68471d93fa8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bfa9d86d39a0fe4685f90c3529aa9bd62a9d97a8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dd292e884c649f9b1c18af0ec75ca90b390cd044","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27389","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.653","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npstore: inode: Only d_invalidate() is needed\n\nUnloading a modular pstore backend with records in pstorefs would\ntrigger the dput() double-drop warning:\n\n  WARNING: CPU: 0 PID: 2569 at fs\/dcache.c:762 dput.part.0+0x3f3\/0x410\n\nUsing the combo of d_drop()\/dput() (as mentioned in\nDocumentation\/filesystems\/vfs.rst) isn't the right approach here, and\nleads to the reference counting problem seen above. Use d_invalidate()\nand update the code to not bother checking for error codes that can\nnever happen.\n\n---"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: pstore: inode: solo se necesita d_invalidate(). La descarga de un backend modular de pstore con registros en pstorefs activaría la advertencia de doble caída de dput(): ADVERTENCIA: CPU: 0 PID: 2569 en fs\/dcache.c:762 dput.part.0+0x3f3\/0x410 Usar la combinación de d_drop()\/dput() (como se menciona en Documentation\/filesystems\/vfs.rst) no es el enfoque correcto aquí, y conduce al problema de recuento de referencias visto anteriormente. Utilice d_invalidate() y actualice el código para no molestarse en buscar códigos de error que nunca sucederán. ---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/340682ed1932b8e3bd0bfc6c31a0c6354eb57cc6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4cdf9006fc095af71da80e9b5f48a32e991b9ed3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a43e0fc5e9134a46515de2f2f8d4100b74e50de3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cb9e802e49c24eeb3af35e9e8c04d526f35f112a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/db6e5e16f1ee9e3b01d2f71c7f0ba945f4bf0f4e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27390","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.697","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: mcast: remove one synchronize_net() barrier in ipv6_mc_down()\n\nAs discussed in the past (commit 2d3916f31891 (\"ipv6: fix skb drops\nin igmp6_event_query() and igmp6_event_report()\")) I think the\nsynchronize_net() call in ipv6_mc_down() is not needed.\n\nUnder load, synchronize_net() can last between 200 usec and 5 ms.\n\nKASAN seems to agree as well."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ipv6: mcast: elimina una barrera de sincronización_net() en ipv6_mc_down() Como se discutió en el pasado (commit 2d3916f31891 (\"ipv6: corrige caídas de skb en igmp6_event_query() e igmp6_event_report()\" )) Creo que la llamada sincronizar_net() en ipv6_mc_down() no es necesaria. Bajo carga, sincronizar_net() puede durar entre 200 usos y 5 ms. KASAN parece estar de acuerdo también."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/17ef8efc00b34918b966388b2af0993811895a8c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/26d4bac55750d535f1f0b8790dc26daf6089e373","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5da9a218340a2bc804dc4327e5804392e24a0b88","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7eb06ee5921189812e6b4bfe7b0f1e878be16df7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9d159d6637ccce25f879d662a480541ef4ba3a50","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a03ede2282ebbd181bd6f5c38cbfcb5765afcd04","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27391","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.750","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: wilc1000: do not realloc workqueue everytime an interface is added\n\nCommit 09ed8bfc5215 (\"wilc1000: Rename workqueue from \"WILC_wq\" to\n\"NETDEV-wq\"\") moved workqueue creation in wilc_netdev_ifc_init in order to\nset the interface name in the workqueue name. However, while the driver\nneeds only one workqueue, the wilc_netdev_ifc_init is called each time we\nadd an interface over a phy, which in turns overwrite the workqueue with a\nnew one. This can be observed with the following commands:\n\nfor i in $(seq 0 10)\ndo\n  iw phy phy0 interface add wlan1 type managed\n  iw dev wlan1 del\ndone\nps -eo pid,comm|grep wlan\n\n 39 kworker\/R-wlan0\n 98 kworker\/R-wlan1\n102 kworker\/R-wlan1\n105 kworker\/R-wlan1\n108 kworker\/R-wlan1\n111 kworker\/R-wlan1\n114 kworker\/R-wlan1\n117 kworker\/R-wlan1\n120 kworker\/R-wlan1\n123 kworker\/R-wlan1\n126 kworker\/R-wlan1\n129 kworker\/R-wlan1\n\nFix this leakage by putting back hif_workqueue allocation in\nwilc_cfg80211_init. Regarding the workqueue name, it is indeed relevant to\nset it lowercase, however it is not  attached to a specific netdev, so\nenforcing netdev name in the name is not so relevant. Still, enrich the\nname with the wiphy name to make it clear which phy is using the workqueue."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: wifi: wilc1000: no reasignar la cola de trabajo cada vez que se agrega una interfaz. Commit 09ed8bfc5215 (\"wilc1000: cambiar el nombre de la cola de trabajo de \"WILC_wq\" a \"NETDEV-wq\"\") movió la creación de la cola de trabajo en wilc_netdev_ifc_init para configurar el nombre de la interfaz en el nombre de la cola de trabajo. Sin embargo, aunque el controlador solo necesita una cola de trabajo, se llama a wilc_netdev_ifc_init cada vez que agregamos una interfaz a través de un phy, lo que a su vez sobrescribe la cola de trabajo con una nueva. Esto se puede observar con los siguientes comandos: for i in $(seq 0 10) do iw phy phy0 interfaz add wlan1 tipo administrado iw dev wlan1 del done ps -eo pid,comm|grep wlan 39 kworker\/R-wlan0 98 kworker\/ R-wlan1 102 ktrabajador\/R-wlan1 105 ktrabajador\/R-wlan1 108 ktrabajador\/R-wlan1 111 ktrabajador\/R-wlan1 114 ktrabajador\/R-wlan1 117 ktrabajador\/R-wlan1 120 ktrabajador\/R-wlan1 123 ktrabajador\/R- wlan1 126 kworker\/R-wlan1 129 kworker\/R-wlan1 Solucione esta fuga volviendo a colocar la asignación hif_workqueue en wilc_cfg80211_init. Con respecto al nombre de la cola de trabajo, es relevante establecerlo en minúsculas; sin embargo, no está adjunto a un netdev específico, por lo que hacer cumplir el nombre de netdev en el nombre no es tan relevante. Aún así, enriquezca el nombre con el nombre de wiphy para dejar claro qué phy está usando la cola de trabajo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/328efda22af81130c2ad981c110518cb29ff2f1d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4041c60a9d543b3ad50225385b072ba68e96166e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/515cc676dfbce40d93c92b1ff3c1070e917f4e52","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90ae293d1d255f622318fce6eeea2e18f9fde5c1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9ab0c303ccabfd6bdce14432792d41090070008c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-27392","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-01T13:15:51.793","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnvme: host: fix double-free of struct nvme_id_ns in ns_update_nuse()\n\nWhen nvme_identify_ns() fails, it frees the pointer to the struct\nnvme_id_ns before it returns. However, ns_update_nuse() calls kfree()\nfor the pointer even when nvme_identify_ns() fails. This results in\nKASAN double-free, which was observed with blktests nvme\/045 with\nproposed patches [1] on the kernel v6.8-rc7. Fix the double-free by\nskipping kfree() when nvme_identify_ns() fails."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: nvme: host: corrige la doble liberación de la estructura nvme_id_ns en ns_update_nuse() Cuando nvme_identify_ns() falla, libera el puntero a la estructura nvme_id_ns antes de que regrese. Sin embargo, ns_update_nuse() llama a kfree() para el puntero incluso cuando nvme_identify_ns() falla. Esto da como resultado KASAN double-free, que se observó con blktests nvme\/045 con parches propuestos [1] en el kernel v6.8-rc7. Corrija el doble libre omitiendo kfree() cuando falla nvme_identify_ns()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/534f9dc7fe495b3f9cc84363898ac50c5a25fccb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8d0d2447394b13fb22a069f0330f9c49b7fff9d3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-28775","sourceIdentifier":"psirt@us.ibm.com","published":"2024-05-01T13:15:51.837","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"IBM WebSphere Automation 1.7.0 is vulnerable to cross-site scripting. This vulnerability allows users to embed arbitrary JavaScript code in the Web UI thus altering the intended functionality potentially leading to credentials disclosure within a trusted session.  IBM X-Force ID:  285648."},{"lang":"es","value":"IBM WebSphere Automation 1.7.0 es vulnerable a Cross Site Scripting. Esta vulnerabilidad permite a los usuarios incrustar código JavaScript arbitrario en la interfaz de usuario web, alterando así la funcionalidad prevista, lo que podría conducir a la divulgación de credenciales dentro de una sesión confiable. ID de IBM X-Force: 285648."}],"metrics":{"cvssMetricV31":[{"source":"psirt@us.ibm.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:L\/UI:R\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"LOW","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":4.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.3,"impactScore":2.7}]},"weaknesses":[{"source":"psirt@us.ibm.com","type":"Primary","description":[{"lang":"en","value":"CWE-79"}]}],"references":[{"url":"https:\/\/exchange.xforce.ibmcloud.com\/vulnerabilities\/285648","source":"psirt@us.ibm.com"},{"url":"https:\/\/www.ibm.com\/support\/pages\/node\/7149856","source":"psirt@us.ibm.com"}]}},{"cve":{"id":"CVE-2024-31412","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-01T13:15:52.030","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Out-of-bounds read vulnerability exists in CX-Programmer included in CX-One CXONE-AL[][]D-V4 Ver. 9.81 or lower. Opening a specially crafted project file may lead to information disclosure and\/or the product being crashed."},{"lang":"es","value":"Existe una vulnerabilidad de lectura fuera de los límites en CX-Programmer incluido en CX-One CXONE-AL[][]D-V4 Ver. 9.81 o menor. Abrir un archivo de proyecto especialmente manipulado puede provocar la divulgación de información y\/o el bloqueo del producto."}],"metrics":{},"references":[{"url":"https:\/\/jvn.jp\/en\/vu\/JVNVU98274902\/","source":"vultures@jpcert.or.jp"},{"url":"https:\/\/www.fa.omron.co.jp\/product\/security\/assets\/pdf\/en\/OMSR-2024-003_en.pdf","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-31413","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-01T13:15:52.080","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Free of pointer not at start of buffer vulnerability exists in CX-One CX-One CXONE-AL[][]D-V4 (The version which was installed with a DVD ver. 4.61.1 or lower, and was updated through CX-One V4 auto update in January 2024 or prior) and Sysmac Studio SYSMAC-SE2[][][] (The version which was installed with a DVD ver. 1.56 or lower, and was updated through Sysmac Studio V1 auto update in January 2024 or prior). Opening a specially crafted project file may lead to arbitrary code execution."},{"lang":"es","value":"Existe una vulnerabilidad libre de puntero que no está al inicio del búfer en CX-One CX-One CXONE-AL[][]D-V4 (la versión que se instaló con un DVD versión 4.61.1 o inferior y se actualizó a través de CX- Una actualización automática de V4 en enero de 2024 o antes) y Sysmac Studio SYSMAC-SE2[][][] (la versión que se instaló con un DVD versión 1.56 o anterior y se actualizó mediante la actualización automática de Sysmac Studio V1 en enero de 2024 o antes). previo). Abrir un archivo de proyecto especialmente manipulado puede provocar la ejecución de código arbitrario."}],"metrics":{},"references":[{"url":"https:\/\/jvn.jp\/en\/vu\/JVNVU98274902\/","source":"vultures@jpcert.or.jp"},{"url":"https:\/\/www.fa.omron.co.jp\/product\/security\/assets\/pdf\/en\/OMSR-2024-002_en.pdf","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-33775","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T13:15:52.130","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue with the Autodiscover component in Nagios XI 2024R1.01 allows a remote attacker to escalate privileges via a crafted Dashlet."},{"lang":"es","value":"Un problema con el componente Autodiscover en Nagios XI 2024R1.01 permite a un atacante remoto escalar privilegios a través de un Dashlet manipulado."}],"metrics":{},"references":[{"url":"https:\/\/www.nagios.com\/changelog\/#nagios-xi","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-4058","sourceIdentifier":"chrome-cve-admin@google.com","published":"2024-05-01T13:15:52.200","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Type confusion in ANGLE in Google Chrome prior to 124.0.6367.78 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: Critical)"},{"lang":"es","value":"La confusión de tipos en ANGLE en Google Chrome anterior a 124.0.6367.78 permitía a un atacante remoto explotar potencialmente la corrupción del montón a través de una página HTML manipulada. (Severidad de seguridad de Chromium: crítica)"}],"metrics":{},"references":[{"url":"https:\/\/chromereleases.googleblog.com\/2024\/04\/stable-channel-update-for-desktop_24.html","source":"chrome-cve-admin@google.com"},{"url":"https:\/\/issues.chromium.org\/issues\/332546345","source":"chrome-cve-admin@google.com"}]}},{"cve":{"id":"CVE-2024-4059","sourceIdentifier":"chrome-cve-admin@google.com","published":"2024-05-01T13:15:52.253","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Out of bounds read in V8 API in Google Chrome prior to 124.0.6367.78 allowed a remote attacker to leak cross-site data via a crafted HTML page. (Chromium security severity: High)"},{"lang":"es","value":"La lectura fuera de los límites en la API V8 en Google Chrome anterior a 124.0.6367.78 permitió a un atacante remoto filtrar datos entre sitios a través de una página HTML manipulada. (Severidad de seguridad de Chrome: alta)"}],"metrics":{},"references":[{"url":"https:\/\/chromereleases.googleblog.com\/2024\/04\/stable-channel-update-for-desktop_24.html","source":"chrome-cve-admin@google.com"},{"url":"https:\/\/issues.chromium.org\/issues\/333182464","source":"chrome-cve-admin@google.com"}]}},{"cve":{"id":"CVE-2024-4060","sourceIdentifier":"chrome-cve-admin@google.com","published":"2024-05-01T13:15:52.300","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Use after free in Dawn in Google Chrome prior to 124.0.6367.78 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)"},{"lang":"es","value":"El use after free en Dawn en Google Chrome anterior a 124.0.6367.78 permitía a un atacante remoto explotar potencialmente la corrupción del montón a través de una página HTML manipulada. (Severidad de seguridad de Chrome: alta)"}],"metrics":{},"references":[{"url":"https:\/\/chromereleases.googleblog.com\/2024\/04\/stable-channel-update-for-desktop_24.html","source":"chrome-cve-admin@google.com"},{"url":"https:\/\/issues.chromium.org\/issues\/333420620","source":"chrome-cve-admin@google.com"}]}},{"cve":{"id":"CVE-2024-4331","sourceIdentifier":"chrome-cve-admin@google.com","published":"2024-05-01T13:15:52.343","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Use after free in Picture In Picture in Google Chrome prior to 124.0.6367.118 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)"},{"lang":"es","value":"El use after free en Picture In Picture en Google Chrome anterior a 124.0.6367.118 permitía a un atacante remoto explotar potencialmente la corrupción del montón a través de una página HTML manipulada. (Severidad de seguridad de Chrome: alta)"}],"metrics":{},"references":[{"url":"https:\/\/chromereleases.googleblog.com\/2024\/04\/stable-channel-update-for-desktop_30.html","source":"chrome-cve-admin@google.com"},{"url":"https:\/\/issues.chromium.org\/issues\/335003891","source":"chrome-cve-admin@google.com"}]}},{"cve":{"id":"CVE-2024-4368","sourceIdentifier":"chrome-cve-admin@google.com","published":"2024-05-01T13:15:52.390","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Use after free in Dawn in Google Chrome prior to 124.0.6367.118 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)"},{"lang":"es","value":"El use after free en Dawn en Google Chrome anterior a 124.0.6367.118 permitía a un atacante remoto explotar potencialmente la corrupción del montón a través de una página HTML manipulada. (Severidad de seguridad de Chrome: alta)"}],"metrics":{},"references":[{"url":"https:\/\/chromereleases.googleblog.com\/2024\/04\/stable-channel-update-for-desktop_30.html","source":"chrome-cve-admin@google.com"},{"url":"https:\/\/issues.chromium.org\/issues\/333508731","source":"chrome-cve-admin@google.com"}]}},{"cve":{"id":"CVE-2024-24912","sourceIdentifier":"cve@checkpoint.com","published":"2024-05-01T14:15:06.323","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A local privilege escalation vulnerability has been identified in Harmony Endpoint Security Client for Windows versions E88.10 and below. To exploit this vulnerability, an attacker must first obtain the ability to execute local privileged code on the target system."},{"lang":"es","value":"Se ha identificado una vulnerabilidad de escalada de privilegios local en Harmony Endpoint Security Client para las versiones E88.10 y anteriores de Windows. Para aprovechar esta vulnerabilidad, un atacante primero debe obtener la capacidad de ejecutar código privilegiado local en el sistema de destino."}],"metrics":{},"weaknesses":[{"source":"cve@checkpoint.com","type":"Secondary","description":[{"lang":"en","value":"CWE-732"}]}],"references":[{"url":"https:\/\/support.checkpoint.com\/results\/sk\/sk182244","source":"cve@checkpoint.com"}]}},{"cve":{"id":"CVE-2024-26304","sourceIdentifier":"security-alert@hpe.com","published":"2024-05-01T15:15:14.680","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"There is a buffer overflow vulnerability in the underlying L2\/L3 Management service that could lead to unauthenticated remote code execution by sending specially crafted packets destined to the PAPI (Aruba's access point management protocol) UDP port (8211). Successful exploitation of this vulnerability results in the ability to execute arbitrary code as a privileged user on the underlying operating system. \n\n"},{"lang":"es","value":"Existe una vulnerabilidad de desbordamiento de búfer en el servicio de administración L2\/L3 subyacente que podría provocar la ejecución remota de código no autenticado mediante el envío de paquetes especialmente manipulados destinados al puerto UDP (8211) PAPI (protocolo de administración de puntos de acceso de Aruba). La explotación exitosa de esta vulnerabilidad da como resultado la capacidad de ejecutar código arbitrario como usuario privilegiado en el sistema operativo subyacente."}],"metrics":{"cvssMetricV31":[{"source":"security-alert@hpe.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.8,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.9}]},"references":[{"url":"https:\/\/www.arubanetworks.com\/assets\/alert\/ARUBA-PSA-2024-004.txt","source":"security-alert@hpe.com"}]}},{"cve":{"id":"CVE-2024-26305","sourceIdentifier":"security-alert@hpe.com","published":"2024-05-01T15:15:14.863","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"There is a buffer overflow vulnerability in the underlying Utility daemon that could lead to unauthenticated remote code execution by sending specially crafted packets destined to the PAPI (Aruba's access point management protocol) UDP port (8211). Successful exploitation of this vulnerability results in the ability to execute arbitrary code as a privileged user on the underlying operating system. \n\n"},{"lang":"es","value":"Existe una vulnerabilidad de desbordamiento de búfer en el daemon de utilidad subyacente que podría conducir a la ejecución remota de código no autenticado mediante el envío de paquetes especialmente manipulados destinados al puerto UDP (8211) PAPI (protocolo de administración de puntos de acceso de Aruba). La explotación exitosa de esta vulnerabilidad da como resultado la capacidad de ejecutar código arbitrario como usuario privilegiado en el sistema operativo subyacente."}],"metrics":{"cvssMetricV31":[{"source":"security-alert@hpe.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.8,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.9}]},"references":[{"url":"https:\/\/www.arubanetworks.com\/assets\/alert\/ARUBA-PSA-2024-004.txt","source":"security-alert@hpe.com"}]}},{"cve":{"id":"CVE-2024-33511","sourceIdentifier":"security-alert@hpe.com","published":"2024-05-01T15:15:15.060","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"There is a buffer overflow vulnerability in the underlying Automatic Reporting service that could lead to unauthenticated remote code execution by sending specially crafted packets destined to the PAPI (Aruba's access point management protocol) UDP port (8211). Successful exploitation of this vulnerability results in the ability to execute arbitrary code as a privileged user on the underlying operating system. \n\n"},{"lang":"es","value":"Existe una vulnerabilidad de desbordamiento del búfer en el servicio de informes automáticos subyacente que podría provocar la ejecución remota de código no autenticado mediante el envío de paquetes especialmente manipulados destinados al puerto UDP (8211) PAPI (protocolo de administración de puntos de acceso de Aruba). La explotación exitosa de esta vulnerabilidad da como resultado la capacidad de ejecutar código arbitrario como usuario privilegiado en el sistema operativo subyacente."}],"metrics":{"cvssMetricV31":[{"source":"security-alert@hpe.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.8,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.9}]},"references":[{"url":"https:\/\/www.arubanetworks.com\/assets\/alert\/ARUBA-PSA-2024-004.txt","source":"security-alert@hpe.com"}]}},{"cve":{"id":"CVE-2024-33512","sourceIdentifier":"security-alert@hpe.com","published":"2024-05-01T15:15:15.257","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"There is a buffer overflow vulnerability in the underlying Local User Authentication Database service that could lead to unauthenticated remote code execution by sending specially crafted packets destined to the PAPI (Aruba's access point management protocol) UDP port (8211). Successful exploitation of this vulnerability results in the ability to execute arbitrary code as a privileged user on the underlying operating system.\n\n"},{"lang":"es","value":"Existe una vulnerabilidad de desbordamiento de búfer en el servicio de base de datos de autenticación de usuario local subyacente que podría provocar la ejecución remota de código no autenticado mediante el envío de paquetes especialmente manipulados destinados al puerto UDP (8211) PAPI (protocolo de administración de puntos de acceso de Aruba). La explotación exitosa de esta vulnerabilidad da como resultado la capacidad de ejecutar código arbitrario como usuario privilegiado en el sistema operativo subyacente."}],"metrics":{"cvssMetricV31":[{"source":"security-alert@hpe.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.8,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.9}]},"references":[{"url":"https:\/\/www.arubanetworks.com\/assets\/alert\/ARUBA-PSA-2024-004.txt","source":"security-alert@hpe.com"}]}},{"cve":{"id":"CVE-2023-40533","sourceIdentifier":"talos-cna@cisco.com","published":"2024-05-01T16:15:06.590","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An uninitialized memory use vulnerability exists in Tinyproxy 1.11.1 while parsing HTTP requests. In certain configurations, a specially crafted HTTP request can result in disclosure of data allocated on the heap, which could contain sensitive information. An attacker can make an unauthenticated HTTP request to trigger this vulnerability."},{"lang":"es","value":"Existe una vulnerabilidad de uso de memoria no inicializada en Tinyproxy 1.11.1 al analizar solicitudes HTTP. En determinadas configuraciones, una solicitud HTTP especialmente manipulada puede dar lugar a la divulgación de datos asignados en el montón, que podrían contener información confidencial. Un atacante puede realizar una solicitud HTTP no autenticada para desencadenar esta vulnerabilidad."}],"metrics":{"cvssMetricV31":[{"source":"talos-cna@cisco.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:N\/S:U\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":5.9,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.2,"impactScore":3.6}]},"weaknesses":[{"source":"talos-cna@cisco.com","type":"Primary","description":[{"lang":"en","value":"CWE-457"}]}],"references":[{"url":"https:\/\/talosintelligence.com\/vulnerability_reports\/TALOS-2023-1902","source":"talos-cna@cisco.com"}]}},{"cve":{"id":"CVE-2023-47166","sourceIdentifier":"talos-cna@cisco.com","published":"2024-05-01T16:15:06.807","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A firmware update vulnerability exists in the luci2-io file-import functionality of Milesight UR32L v32.3.0.7-r2. A specially crafted network request can lead to arbitrary firmware update. An attacker can send a network request to trigger this vulnerability."},{"lang":"es","value":"Existe una vulnerabilidad de actualización de firmware en la funcionalidad de importación de archivos luci2-io de Milesight UR32L v32.3.0.7-r2. Una solicitud de red especialmente manipulada puede provocar una actualización de firmware arbitraria. Un atacante puede enviar una solicitud de red para desencadenar esta vulnerabilidad."}],"metrics":{"cvssMetricV31":[{"source":"talos-cna@cisco.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":8.8,"baseSeverity":"HIGH"},"exploitabilityScore":2.8,"impactScore":5.9}]},"weaknesses":[{"source":"talos-cna@cisco.com","type":"Primary","description":[{"lang":"en","value":"CWE-285"}]}],"references":[{"url":"https:\/\/talosintelligence.com\/vulnerability_reports\/TALOS-2023-1852","source":"talos-cna@cisco.com"}]}},{"cve":{"id":"CVE-2023-47212","sourceIdentifier":"talos-cna@cisco.com","published":"2024-05-01T16:15:07.033","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A heap-based buffer overflow vulnerability exists in the comment functionality of stb _vorbis.c v1.22. A specially crafted .ogg file can lead to an out-of-bounds write. An attacker can provide a malicious file to trigger this vulnerability."},{"lang":"es","value":"Existe una vulnerabilidad de desbordamiento de búfer de almacenamiento dinámico en la funcionalidad de comentarios de stb _vorbis.c v1.22. Un archivo .ogg especialmente manipulado puede provocar una escritura fuera de los límites. Un atacante puede proporcionar un archivo malicioso para desencadenar esta vulnerabilidad."}],"metrics":{"cvssMetricV31":[{"source":"talos-cna@cisco.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.8,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.9}]},"weaknesses":[{"source":"talos-cna@cisco.com","type":"Primary","description":[{"lang":"en","value":"CWE-190"}]}],"references":[{"url":"https:\/\/talosintelligence.com\/vulnerability_reports\/TALOS-2023-1846","source":"talos-cna@cisco.com"}]}},{"cve":{"id":"CVE-2023-49606","sourceIdentifier":"talos-cna@cisco.com","published":"2024-05-01T16:15:07.257","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A use-after-free vulnerability exists in the HTTP Connection Headers parsing in Tinyproxy 1.11.1 and Tinyproxy 1.10.0. A specially crafted HTTP header can trigger reuse of previously freed memory, which leads to memory corruption and could lead to remote code execution. An attacker needs to make an unauthenticated HTTP request to trigger this vulnerability."},{"lang":"es","value":"Existe una vulnerabilidad de use-after-free en el análisis de los encabezados de conexión HTTP en Tinyproxy 1.11.1 y Tinyproxy 1.10.0. Un encabezado HTTP especialmente manipulado puede provocar la reutilización de la memoria previamente liberada, lo que provoca daños en la memoria y podría provocar la ejecución remota de código. Un atacante necesita realizar una solicitud HTTP no autenticada para activar esta vulnerabilidad."}],"metrics":{"cvssMetricV31":[{"source":"talos-cna@cisco.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.8,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.9}]},"weaknesses":[{"source":"talos-cna@cisco.com","type":"Primary","description":[{"lang":"en","value":"CWE-416"}]}],"references":[{"url":"https:\/\/talosintelligence.com\/vulnerability_reports\/TALOS-2023-1889","source":"talos-cna@cisco.com"}]}},{"cve":{"id":"CVE-2024-28893","sourceIdentifier":"hp-security-alert@hp.com","published":"2024-05-01T16:15:07.553","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Certain HP software packages (SoftPaqs) are potentially vulnerable to arbitrary code execution when the SoftPaq configuration file has been modified after extraction. HP has released updated software packages (SoftPaqs)."},{"lang":"es","value":"Ciertos paquetes de software de HP (SoftPaqs) son potencialmente vulnerables a la ejecución de código arbitrario cuando el archivo de configuración del SoftPaq se modifica después de la extracción. HP ha lanzado paquetes de software actualizados (SoftPaqs)."}],"metrics":{},"references":[{"url":"https:\/\/support.hp.com\/us-en\/document\/ish_10502451-10502508-16\/hpsbhf03931","source":"hp-security-alert@hp.com"}]}},{"cve":{"id":"CVE-2024-33820","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T16:15:07.837","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Totolink AC1200 Wireless Dual Band Gigabit Router A3002R_V4 Firmware V4.0.0-B20230531.1404 is vulnerable to Buffer Overflow via the formWlEncrypt function of the boa server. Specifically, they exploit the length of the wlan_ssid field triggers the overflow."},{"lang":"es","value":"El Router Gigabit inalámbrico de banda dual Totolink AC1200 A3002R_V4 Firmware V4.0.0-B20230531.1404 es vulnerable al desbordamiento del búfer a través de la función formWlEncrypt del servidor boa. Específicamente, explotan la longitud del campo wlan_ssid que desencadena el desbordamiento."}],"metrics":{},"references":[{"url":"https:\/\/gist.github.com\/Swind1er\/ee095fbfe13f77a5b45b39a5aa82bd17","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2023-7241","sourceIdentifier":"security@opentext.com","published":"2024-05-01T17:15:27.860","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Privilege Escalation in WRSA.EXE in Webroot Antivirus 8.0.1X- 9.0.35.12 on \n\nWindows64 bit and 32 bit allows malicious software to abuse WRSA.EXE to delete arbitrary and protected files.\n"},{"lang":"es","value":"La escalada de privilegios en WRSA.EXE en Webroot Antivirus 8.0.1X-9.0.35.12 en Windows de 64 y 32 bits permite que software malicioso abuse de WRSA.EXE para eliminar archivos arbitrarios y protegidos."}],"metrics":{"cvssMetricV31":[{"source":"security@opentext.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:L\/PR:L\/UI:R\/S:C\/C:N\/I:H\/A:H","attackVector":"LOCAL","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"NONE","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":7.9,"baseSeverity":"HIGH"},"exploitabilityScore":1.5,"impactScore":5.8}]},"weaknesses":[{"source":"security@opentext.com","type":"Secondary","description":[{"lang":"en","value":"CWE-269"}]}],"references":[{"url":"https:\/\/answers.webroot.com\/Webroot\/ukp.aspx?&app=vw&vw=1&login=1&solutionid=4258","source":"security@opentext.com"},{"url":"https:\/\/www.webroot.com\/us\/en\/business\/support\/release-notes#heading-endpoint","source":"security@opentext.com"},{"url":"https:\/\/www.webroot.com\/us\/en\/support\/support-consumer-release-notes","source":"security@opentext.com"}]}},{"cve":{"id":"CVE-2024-20357","sourceIdentifier":"ykramarz@cisco.com","published":"2024-05-01T17:15:28.143","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A vulnerability in the XML service of Cisco IP Phone firmware could allow an unauthenticated, remote attacker to initiate phone calls on an affected device.  \r\n\r This vulnerability exists because bounds-checking does not occur while parsing XML requests. An attacker could exploit this vulnerability by sending a crafted XML request to an affected device. A successful exploit could allow the attacker to initiate calls or play sounds on the device."},{"lang":"es","value":"Una vulnerabilidad en el servicio XML del firmware del teléfono IP de Cisco podría permitir que un atacante remoto no autenticado inicie llamadas telefónicas en un dispositivo afectado. Esta vulnerabilidad existe porque la verificación de los límites no se produce al analizar solicitudes XML. Un atacante podría aprovechar esta vulnerabilidad enviando una solicitud XML manipulada a un dispositivo afectado. Un exploit exitoso podría permitir al atacante iniciar llamadas o reproducir sonidos en el dispositivo."}],"metrics":{"cvssMetricV31":[{"source":"ykramarz@cisco.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:N\/S:U\/C:N\/I:H\/A:N","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"HIGH","availabilityImpact":"NONE","baseScore":5.9,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.2,"impactScore":3.6}]},"weaknesses":[{"source":"ykramarz@cisco.com","type":"Secondary","description":[{"lang":"en","value":"CWE-787"}]}],"references":[{"url":"https:\/\/sec.cloudapps.cisco.com\/security\/center\/content\/CiscoSecurityAdvisory\/cisco-sa-ipphone-multi-vulns-cXAhCvS","source":"ykramarz@cisco.com"}]}},{"cve":{"id":"CVE-2024-20376","sourceIdentifier":"ykramarz@cisco.com","published":"2024-05-01T17:15:28.407","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A vulnerability in the web-based management interface of Cisco IP Phone firmware could allow an unauthenticated, remote attacker to cause an affected device to reload, resulting in a DoS condition.  \r\n\r This vulnerability is due to insufficient validation of user-supplied input. An attacker could exploit this vulnerability by sending a crafted request to the web-based management interface of an affected device. A successful exploit could allow the attacker to cause the affected device to reload."},{"lang":"es","value":"Una vulnerabilidad en la interfaz de administración basada en web del firmware del teléfono IP de Cisco podría permitir que un atacante remoto no autenticado provoque la recarga de un dispositivo afectado, lo que resultaría en una condición DoS. Esta vulnerabilidad se debe a una validación insuficiente de la entrada proporcionada por el usuario. Un atacante podría aprovechar esta vulnerabilidad enviando una solicitud manipulada a la interfaz de administración basada en web de un dispositivo afectado. Un exploit exitoso podría permitir al atacante hacer que el dispositivo afectado se recargue."}],"metrics":{"cvssMetricV31":[{"source":"ykramarz@cisco.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":3.6}]},"weaknesses":[{"source":"ykramarz@cisco.com","type":"Secondary","description":[{"lang":"en","value":"CWE-787"}]}],"references":[{"url":"https:\/\/sec.cloudapps.cisco.com\/security\/center\/content\/CiscoSecurityAdvisory\/cisco-sa-ipphone-multi-vulns-cXAhCvS","source":"ykramarz@cisco.com"}]}},{"cve":{"id":"CVE-2024-20378","sourceIdentifier":"ykramarz@cisco.com","published":"2024-05-01T17:15:28.660","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A vulnerability in the web-based management interface of Cisco IP Phone firmware could allow an unauthenticated, remote attacker to retrieve sensitive information from an affected device.  \r\n\r This vulnerability is due to a lack of authentication for specific endpoints of the web-based management interface on an affected device. An attacker could exploit this vulnerability by connecting to the affected device. A successful exploit could allow the attacker to gain unauthorized access to the device, enabling the recording of user credentials and traffic to and from the affected device, including VoIP calls that could be replayed."},{"lang":"es","value":"Una vulnerabilidad en la interfaz de administración basada en web del firmware del teléfono IP de Cisco podría permitir que un atacante remoto no autenticado recupere información confidencial de un dispositivo afectado. Esta vulnerabilidad se debe a la falta de autenticación para endpoints específicos de la interfaz de administración basada en web en un dispositivo afectado. Un atacante podría aprovechar esta vulnerabilidad conectándose al dispositivo afectado. Un exploit exitoso podría permitir al atacante obtener acceso no autorizado al dispositivo, lo que permitiría registrar las credenciales del usuario y el tráfico hacia y desde el dispositivo afectado, incluidas las llamadas VoIP que podrían reproducirse."}],"metrics":{"cvssMetricV31":[{"source":"ykramarz@cisco.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":3.6}]},"weaknesses":[{"source":"ykramarz@cisco.com","type":"Secondary","description":[{"lang":"en","value":"CWE-305"}]}],"references":[{"url":"https:\/\/sec.cloudapps.cisco.com\/security\/center\/content\/CiscoSecurityAdvisory\/cisco-sa-ipphone-multi-vulns-cXAhCvS","source":"ykramarz@cisco.com"}]}},{"cve":{"id":"CVE-2024-23457","sourceIdentifier":"cve@zscaler.com","published":"2024-05-01T17:15:28.853","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The anti-tampering functionality of the Zscaler Client Connector can be disabled under certain conditions when an uninstall password is enforced. This affects Zscaler Client Connector on Windows prior to 4.2.0.209\n\n"},{"lang":"es","value":"La funcionalidad antimanipulación de Zscaler Client Connector se puede desactivar bajo ciertas condiciones cuando se aplica una contraseña de desinstalación. Esto afecta a Zscaler Client Connector en Windows anteriores a 4.2.0.209"}],"metrics":{"cvssMetricV31":[{"source":"cve@zscaler.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:L\/PR:L\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"LOCAL","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":7.8,"baseSeverity":"HIGH"},"exploitabilityScore":1.8,"impactScore":5.9}]},"weaknesses":[{"source":"cve@zscaler.com","type":"Secondary","description":[{"lang":"en","value":"CWE-269"}]}],"references":[{"url":"https:\/\/help.zscaler.com\/client-connector\/client-connector-app-release-summary-2023","source":"cve@zscaler.com"}]}},{"cve":{"id":"CVE-2024-23480","sourceIdentifier":"cve@zscaler.com","published":"2024-05-01T17:15:29.033","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A fallback mechanism in code sign checking on macOS may allow arbitrary code execution. This issue affects Zscaler Client Connector on MacOS prior to 4.2.\n"},{"lang":"es","value":"Un mecanismo alternativo en la verificación de signos de código en macOS puede permitir la ejecución de código arbitrario. Este problema afecta a Zscaler Client Connector en MacOS anteriores a 4.2."}],"metrics":{"cvssMetricV31":[{"source":"cve@zscaler.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:H\/PR:L\/UI:N\/S:C\/C:H\/I:H\/A:N","attackVector":"LOCAL","attackComplexity":"HIGH","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"NONE","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":1.1,"impactScore":5.8}]},"weaknesses":[{"source":"cve@zscaler.com","type":"Secondary","description":[{"lang":"en","value":"CWE-347"}]}],"references":[{"url":"https:\/\/help.zscaler.com\/client-connector\/client-connector-app-release-summary-2023?applicable_category=macos&applicable_version=4.2","source":"cve@zscaler.com"}]}},{"cve":{"id":"CVE-2024-25015","sourceIdentifier":"psirt@us.ibm.com","published":"2024-05-01T17:15:29.720","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"IBM MQ 9.2 LTS, 9.3 LTS, and 9.3 CD Internet Pass-Thru could allow a remote user to cause a denial of service by sending HTTP requests that would consume all available resources.  IBM X-Force ID:  281278."},{"lang":"es","value":"IBM MQ 9.2 LTS, 9.3 LTS y 9.3 CD Internet Pass-Thru podría permitir que un usuario remoto provoque una denegación de servicio enviando solicitudes HTTP que consumirían todos los recursos disponibles. ID de IBM X-Force: 281278."}],"metrics":{"cvssMetricV31":[{"source":"psirt@us.ibm.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":3.6}]},"weaknesses":[{"source":"psirt@us.ibm.com","type":"Primary","description":[{"lang":"en","value":"CWE-406"}]}],"references":[{"url":"https:\/\/exchange.xforce.ibmcloud.com\/vulnerabilities\/281278","source":"psirt@us.ibm.com"},{"url":"https:\/\/www.ibm.com\/support\/pages\/node\/7149583","source":"psirt@us.ibm.com"}]}},{"cve":{"id":"CVE-2024-28764","sourceIdentifier":"psirt@us.ibm.com","published":"2024-05-01T17:15:31.083","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"IBM WebSphere Automation 1.7.0 could allow an attacker with privileged access to the network to conduct a CSV injection.  An attacker could execute arbitrary commands on the system, caused by improper validation of csv file contents.  IBM X-Force ID:  285623."},{"lang":"es","value":"IBM WebSphere Automation 1.7.0 podría permitir que un atacante con acceso privilegiado a la red realice una inyección CSV. Un atacante podría ejecutar comandos arbitrarios en el sistema, causados por una validación inadecuada del contenido del archivo csv. ID de IBM X-Force: 285623."}],"metrics":{"cvssMetricV31":[{"source":"psirt@us.ibm.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:L\/PR:H\/UI:R\/S:U\/C:H\/I:H\/A:H","attackVector":"LOCAL","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"REQUIRED","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":6.5,"baseSeverity":"MEDIUM"},"exploitabilityScore":0.6,"impactScore":5.9}]},"weaknesses":[{"source":"psirt@us.ibm.com","type":"Primary","description":[{"lang":"en","value":"CWE-1236"}]}],"references":[{"url":"https:\/\/exchange.xforce.ibmcloud.com\/vulnerabilities\/285623","source":"psirt@us.ibm.com"},{"url":"https:\/\/www.ibm.com\/support\/pages\/node\/7149857","source":"psirt@us.ibm.com"}]}},{"cve":{"id":"CVE-2024-33513","sourceIdentifier":"security-alert@hpe.com","published":"2024-05-01T17:15:36.510","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Unauthenticated Denial-of-Service (DoS) vulnerabilities exist in the AP Management service accessed via the PAPI protocol. Successful exploitation of these vulnerabilities results in the ability to interrupt the normal operation of the affected service.\n\n"},{"lang":"es","value":"Existen vulnerabilidades de denegación de servicio (DoS) no autenticadas en el servicio de administración de AP al que se accede a través del protocolo PAPI. La explotación exitosa de estas vulnerabilidades da como resultado la capacidad de interrumpir el funcionamiento normal del servicio afectado."}],"metrics":{"cvssMetricV31":[{"source":"security-alert@hpe.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:H","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":5.9,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.2,"impactScore":3.6}]},"references":[{"url":"https:\/\/www.arubanetworks.com\/assets\/alert\/ARUBA-PSA-2024-004.txt","source":"security-alert@hpe.com"}]}},{"cve":{"id":"CVE-2024-33514","sourceIdentifier":"security-alert@hpe.com","published":"2024-05-01T17:15:36.673","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Unauthenticated Denial-of-Service (DoS) vulnerabilities exist in the AP Management service accessed via the PAPI protocol. Successful exploitation of these vulnerabilities results in the ability to interrupt the normal operation of the affected service.\n\n"},{"lang":"es","value":"Existen vulnerabilidades de denegación de servicio (DoS) no autenticadas en el servicio de administración de AP al que se accede a través del protocolo PAPI. La explotación exitosa de estas vulnerabilidades da como resultado la capacidad de interrumpir el funcionamiento normal del servicio afectado."}],"metrics":{"cvssMetricV31":[{"source":"security-alert@hpe.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"LOW","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":1.4}]},"references":[{"url":"https:\/\/www.arubanetworks.com\/assets\/alert\/ARUBA-PSA-2024-004.txt","source":"security-alert@hpe.com"}]}},{"cve":{"id":"CVE-2024-33515","sourceIdentifier":"security-alert@hpe.com","published":"2024-05-01T17:15:36.837","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Unauthenticated Denial-of-Service (DoS) vulnerabilities exist in the AP Management service accessed via the PAPI protocol. Successful exploitation of these vulnerabilities results in the ability to interrupt the normal operation of the affected service.\n\n"},{"lang":"es","value":"Existen vulnerabilidades de denegación de servicio (DoS) no autenticadas en el servicio de administración de AP al que se accede a través del protocolo PAPI. La explotación exitosa de estas vulnerabilidades da como resultado la capacidad de interrumpir el funcionamiento normal del servicio afectado."}],"metrics":{"cvssMetricV31":[{"source":"security-alert@hpe.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"LOW","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":1.4}]},"references":[{"url":"https:\/\/www.arubanetworks.com\/assets\/alert\/ARUBA-PSA-2024-004.txt","source":"security-alert@hpe.com"}]}},{"cve":{"id":"CVE-2024-33516","sourceIdentifier":"security-alert@hpe.com","published":"2024-05-01T17:15:37.000","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An unauthenticated Denial of Service (DoS) vulnerability exists in the Auth service accessed via the PAPI protocol provided  by ArubaOS. Successful exploitation of this vulnerability results in the ability to interrupt the normal operation of the controller.\n\n"},{"lang":"es","value":"Existe una vulnerabilidad de denegación de servicio (DoS) no autenticada en el servicio de autenticación al que se accede a través del protocolo PAPI proporcionado por ArubaOS. La explotación exitosa de esta vulnerabilidad da como resultado la capacidad de interrumpir el funcionamiento normal del controlador."}],"metrics":{"cvssMetricV31":[{"source":"security-alert@hpe.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"LOW","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":1.4}]},"references":[{"url":"https:\/\/www.arubanetworks.com\/assets\/alert\/ARUBA-PSA-2024-004.txt","source":"security-alert@hpe.com"}]}},{"cve":{"id":"CVE-2024-33517","sourceIdentifier":"security-alert@hpe.com","published":"2024-05-01T17:15:37.163","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An unauthenticated Denial-of-Service (DoS) vulnerability exists in the Radio Frequency Manager service accessed via the PAPI protocol. Successful exploitation of this vulnerability results in the ability to interrupt the normal operation of the affected service.\n\n"},{"lang":"es","value":"Existe una vulnerabilidad de denegación de servicio (DoS) no autenticada en el servicio Radio Frequency Manager al que se accede a través del protocolo PAPI. La explotación exitosa de esta vulnerabilidad da como resultado la capacidad de interrumpir el funcionamiento normal del servicio afectado."}],"metrics":{"cvssMetricV31":[{"source":"security-alert@hpe.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"LOW","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":1.4}]},"references":[{"url":"https:\/\/www.arubanetworks.com\/assets\/alert\/ARUBA-PSA-2024-004.txt","source":"security-alert@hpe.com"}]}},{"cve":{"id":"CVE-2024-33518","sourceIdentifier":"security-alert@hpe.com","published":"2024-05-01T17:15:37.323","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An unauthenticated Denial-of-Service (DoS) vulnerability exists in the Radio Frequency Manager service accessed via the PAPI protocol. Successful exploitation of this vulnerability results in the ability to interrupt the normal operation of the affected service.\n\n"},{"lang":"es","value":"Existe una vulnerabilidad de denegación de servicio (DoS) no autenticada en el servicio Radio Frequency Manager al que se accede a través del protocolo PAPI. La explotación exitosa de esta vulnerabilidad da como resultado la capacidad de interrumpir el funcionamiento normal del servicio afectado."}],"metrics":{"cvssMetricV31":[{"source":"security-alert@hpe.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"LOW","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":1.4}]},"references":[{"url":"https:\/\/www.arubanetworks.com\/assets\/alert\/ARUBA-PSA-2024-004.txt","source":"security-alert@hpe.com"}]}},{"cve":{"id":"CVE-2024-29010","sourceIdentifier":"PSIRT@sonicwall.com","published":"2024-05-01T18:15:17.873","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The XML document processed in the GMS ECM URL endpoint is vulnerable to XML external entity (XXE) injection, potentially resulting in the disclosure of sensitive information.\n\nThis issue affects GMS: 9.3.4 and earlier versions.\n\n"},{"lang":"es","value":"El documento XML procesado en el endpoint URL de GMS ECM es vulnerable a la inyección de entidad externa XML (XXE), lo que podría resultar en la divulgación de información confidencial. Este problema afecta a GMS: 9.3.4 y versiones anteriores."}],"metrics":{"cvssMetricV31":[{"source":"PSIRT@sonicwall.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:H\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":7.1,"baseSeverity":"HIGH"},"exploitabilityScore":2.8,"impactScore":4.2}]},"weaknesses":[{"source":"PSIRT@sonicwall.com","type":"Secondary","description":[{"lang":"en","value":"CWE-611"}]}],"references":[{"url":"https:\/\/psirt.global.sonicwall.com\/vuln-detail\/SNWLID-2024-0007","source":"PSIRT@sonicwall.com"}]}},{"cve":{"id":"CVE-2024-30176","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T18:15:19.500","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In Logpoint before 7.4.0, an attacker can enumerate a valid list of usernames by using publicly exposed URLs of shared widgets."},{"lang":"es","value":"En Logpoint anterior a 7.4.0, un atacante puede enumerar una lista válida de nombres de usuario utilizando URL de widgets compartidos expuestas públicamente."}],"metrics":{},"references":[{"url":"https:\/\/logpoint.com","source":"cve@mitre.org"},{"url":"https:\/\/servicedesk.logpoint.com\/hc\/en-us\/articles\/18435146614301-Username-Enumeration-on-Shared-Widgets","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-32210","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T18:15:23.930","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The LoMag WareHouse Management application version 1.0.20.120 and older were to utilize hard-coded passwords by default for forms and SQL connections."},{"lang":"es","value":"La versión 1.0.20.120 y anteriores de la aplicación LoMag WareHouse Management debían utilizar contraseñas codificadas de forma predeterminada para formularios y conexiones SQL."}],"metrics":{},"references":[{"url":"https:\/\/gainsec.com\/2024\/04\/28\/cve-2024-32210-cve-2024-32211-cve-2024-32212-cve-2024-32213-lomag-integrator-ce-warehouse-management\/","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-32211","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T18:15:23.987","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in LOGINT LoMag Inventory Management v1.0.20.120 and before allows a local attacker to obtain sensitive information via the UserClass.cs and Settings.cs components."},{"lang":"es","value":"Un problema en LOGINT LoMag Inventory Management v1.0.20.120 y anteriores permite a un atacante local obtener información confidencial a través de los componentes UserClass.cs y Settings.cs."}],"metrics":{},"references":[{"url":"https:\/\/gainsec.com\/2024\/04\/28\/cve-2024-32210-cve-2024-32211-cve-2024-32212-cve-2024-32213-lomag-integrator-ce-warehouse-management\/","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-32212","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T18:15:24.037","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"SQL Injection vulnerability in LOGINT LoMag Inventory Management v1.0.20.120 and before allows an attacker to execute arbitrary code via the ArticleGetGroups, DocAddDocument, ClassClickShop and frmSettings components."},{"lang":"es","value":"Vulnerabilidad de inyección SQL en LOGINT LoMag Inventory Management v1.0.20.120 y anteriores permite a un atacante ejecutar código arbitrario a través de los componentes ArticleGetGroups, DocAddDocument, ClassClickShop y frmSettings."}],"metrics":{},"references":[{"url":"https:\/\/gainsec.com\/2024\/04\/28\/cve-2024-32210-cve-2024-32211-cve-2024-32212-cve-2024-32213-lomag-integrator-ce-warehouse-management\/","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-32213","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T18:15:24.090","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The LoMag WareHouse Management application version 1.0.20.120 and older were found to allow weak passwords. By default, hard-coded passwords of 10 characters with little or no complexity are allowed."},{"lang":"es","value":"Se descubrió que la aplicación LoMag WareHouse Management versión 1.0.20.120 y anteriores permitía contraseñas débiles. De forma predeterminada, se permiten contraseñas codificadas de 10 caracteres con poca o ninguna complejidad."}],"metrics":{},"references":[{"url":"https:\/\/gainsec.com\/2024\/04\/28\/cve-2024-32210-cve-2024-32211-cve-2024-32212-cve-2024-32213-lomag-integrator-ce-warehouse-management\/","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33078","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T18:15:24.283","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Tencent Libpag v4.3 is vulnerable to Buffer Overflow. A user can send a crafted image to trigger a overflow leading to remote code execution."},{"lang":"es","value":"Tencent Lippag v4.3 es vulnerable al desbordamiento de búfer. Un usuario puede enviar una imagen manipulada para desencadenar un desbordamiento que conduzca a la ejecución remota de código."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/HBLocker\/CVE-2024-33078\/","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33442","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T18:15:24.337","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in flusity-CMS v.2.33 allows a remote attacker to execute arbitrary code via the add_post.php component."},{"lang":"es","value":"Un problema en flusity-CMS v.2.33 permite a un atacante remoto ejecutar código arbitrario a través del componente add_post.php."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/summerwayace\/cms\/blob\/main\/1.md","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2023-23019","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:20.963","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Cross site scripting (XSS) vulnerability in file main.php in sourcecodester oretnom23 Blog Site 1.0 via the name and email parameters to function user_add.\\"},{"lang":"es","value":"Vulnerabilidad de Cross Site Scripting (XSS) en el archivo main.php en sourcecodester oretnom23 Blog Site 1.0 a través del nombre y los parámetros de correo electrónico para funcionar user_add.\\"}],"metrics":{},"references":[{"url":"https:\/\/gist.github.com\/enferas\/fc3a1b4b3826d0e10cc4a021e5ec1822","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2023-23021","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:21.027","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Cross Site Scripting (XSS) vulnerability in sourcecodester oretnom23 pos point sale system 1.0, allows attackers to execute arbitrary code via the code, name, and description inputs in file Main.php."},{"lang":"es","value":"Vulnerabilidad de Cross Site Scripting (XSS) en sourcecodester oretnom23 pos point sale system 1.0, permite a atacantes ejecutar código arbitrario a través de las entradas de código, nombre y descripción en el archivo Main.php."}],"metrics":{},"references":[{"url":"https:\/\/gist.github.com\/enferas\/fe381bcc4a020f22cec31cb00e73f43c","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2023-23022","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:21.073","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Cross site scripting (XSS) vulnerability in sourcecodester oretnom23 employee's payroll management system 1.0, allows attackers to execute arbitrary code via the code, title, from_date and to_date inputs in file Main.php."},{"lang":"es","value":"Vulnerabilidad de Cross Site Scripting (XSS) en sourcecodester oretnom23 employee's payroll management system 1.0, permite a atacantes ejecutar código arbitrario a través de las entradas código, título, desde_fecha y hasta_fecha en el archivo Main.php."}],"metrics":{},"references":[{"url":"https:\/\/gist.github.com\/enferas\/ffc4d8e38e238709a3dedf3002cb321d","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2023-26793","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:21.123","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"libmodbus v3.1.10 has a heap-based buffer overflow vulnerability in read_io_status function in src\/modbus.c."},{"lang":"es","value":"libmodbus v3.1.10 tiene una vulnerabilidad de desbordamiento de búfer de almacenamiento dinámico en la función read_io_status en src\/modbus.c."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/stephane\/libmodbus\/issues\/683","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-22830","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:22.030","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Anti-Cheat Expert's Windows kernel module \"ACE-BASE.sys\" version 1.0.2202.6217 does not perform proper access control when handling system resources. This allows a local attacker to escalate privileges from regular user to System or PPL level."}],"metrics":{},"references":[{"url":"http:\/\/anti-cheat.com","source":"cve@mitre.org"},{"url":"https:\/\/intl.anticheatexpert.com\/#\/tool-center","source":"cve@mitre.org"},{"url":"https:\/\/www.defencetech.it\/wp-content\/uploads\/2024\/04\/Report-CVE-2024-22830.pdf","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-24312","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:22.087","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"SQL injection vulnerability in Vaales Technologies V_QRS v.2024-01-17 allows a remote attacker to obtain sensitive information via the Models\/UserModel.php component."},{"lang":"es","value":"Vulnerabilidad de inyección SQL en Vaales Technologies V_QRS v.2024-01-17 permite a un atacante remoto obtener información confidencial a través del componente Models\/UserModel.php."}],"metrics":{},"references":[{"url":"https:\/\/www2.deloitte.com\/xe\/en\/pages\/about-deloitte\/articles\/sustainable-strategies\/unveiling-vulnerabilities-in-cybersecurity.html","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-24313","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:22.140","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in Vaales Technologies V_QRS v.2024-01-17 allows a remote attacker to obtain sensitive information via the Models\/FormModel.php and QRModel.php component."},{"lang":"es","value":"Un problema en Vaales Technologies V_QRS v.2024-01-17 permite a un atacante remoto obtener información confidencial a través del componente Models\/FormModel.php y QRModel.php."}],"metrics":{},"references":[{"url":"https:\/\/www2.deloitte.com\/xe\/en\/pages\/about-deloitte\/articles\/sustainable-strategies\/unveiling-vulnerabilities-in-cybersecurity.html","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-25355","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:22.283","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"s3-url-parser 1.0.3 is vulnerable to Denial of service via the regexes component."},{"lang":"es","value":"s3-url-parser 1.0.3 es vulnerable a la denegación de servicio a través del componente de expresiones regulares."}],"metrics":{},"references":[{"url":"https:\/\/gist.github.com\/6en6ar\/a4977866c59cbcfc716f0f2717b812bf","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-25458","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:22.333","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in CYCZCAM, SHIX ZHAO, SHIXCAM A9 Camera (circuit board identifier A9-48B-V1.0) firmware v.CYCAM_48B_BC01_v87_0903 allows a remote attacker to obtain sensitive information via a crafted request to a UDP port."},{"lang":"es","value":"Un problema en el firmware de la cámara CYCZCAM, SHIX ZHAO, SHIXCAM A9 (identificador de placa de circuito A9-48B-V1.0) v.CYCAM_48B_BC01_v87_0903 permite a un atacante remoto obtener información confidencial a través de una solicitud manipulada a un puerto UDP."}],"metrics":{},"references":[{"url":"https:\/\/tanzhuyin.com\/posts\/cve-2024-25458\/","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-26504","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:22.390","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in Wifire Hotspot v.4.5.3 allows a local attacker to execute arbitrary code via a crafted payload to the dst parameter."},{"lang":"es","value":"Un problema en Wifire Hotspot v.4.5.3 permite a un atacante local ejecutar código arbitrario a través de un payload manipulado en el parámetro dst."}],"metrics":{},"references":[{"url":"https:\/\/cwe.mitre.org\/data\/definitions\/601.html","source":"cve@mitre.org"},{"url":"https:\/\/portswigger.net\/kb\/issues\/00500100_open-redirection-reflected","source":"cve@mitre.org"},{"url":"https:\/\/tomiodarim.io\/posts\/cve-2024-26504\/","source":"cve@mitre.org"},{"url":"https:\/\/wifire.me\/en\/hotspot","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-29011","sourceIdentifier":"PSIRT@sonicwall.com","published":"2024-05-01T19:15:22.627","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Use of hard-coded password in the GMS ECM endpoint leading to authentication bypass vulnerability.\n\nThis issue affects GMS: 9.3.4 and earlier versions.\n"},{"lang":"es","value":"El uso de una contraseña codificada en el endpoint de GMS ECM genera una vulnerabilidad de omisión de autenticación. Este problema afecta a GMS: 9.3.4 y versiones anteriores."}],"metrics":{"cvssMetricV31":[{"source":"PSIRT@sonicwall.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":3.6}]},"weaknesses":[{"source":"PSIRT@sonicwall.com","type":"Primary","description":[{"lang":"en","value":"CWE-259"}]}],"references":[{"url":"https:\/\/psirt.global.sonicwall.com\/vuln-detail\/SNWLID-2024-0007","source":"PSIRT@sonicwall.com"}]}},{"cve":{"id":"CVE-2024-33292","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:26.857","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"SQL Injection vulnerability in Realisation MGSD v.1.0 allows a remote attacker to obtain sensitive information via the id parameter."},{"lang":"es","value":"Vulnerabilidad de inyección SQL en Realization MGSD v.1.0 permite a un atacante remoto obtener información confidencial a través del parámetro id."}],"metrics":{},"references":[{"url":"https:\/\/gist.github.com\/JayChousfan\/6a3a8e5a0fa5f1088d83ee21ed2dbb4a","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33300","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:26.910","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Typora v1.0.0 through v1.7 version (below) Markdown editor has a cross-site scripting (XSS) vulnerability, which allows attackers to execute arbitrary code by uploading Markdown files."},{"lang":"es","value":"Typora v1.0.0 a la versión v1.7 (a continuación) El editor Markdown tiene una vulnerabilidad de Cross Site Scripting (XSS), que permite a los atacantes ejecutar código arbitrario cargando archivos Markdown."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/whoisoo6\/Stored-xss-vulnerability-exists-in-Typra","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33304","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:26.970","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"SourceCodester Product Show Room 1.0 is vulnerable to Cross Site Scripting (XSS) via \"Last Name\" under Add Users."},{"lang":"es","value":"SourceCodester Product Show Room 1.0 es vulnerable a Cross Site Scripting (XSS) a través de \"Apellido\" en Agregar usuarios."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Mohitkumar0786\/CVE\/blob\/main\/CVE-2024-33304.md","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33393","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:27.020","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in spidernet-io spiderpool v.0.9.3 and before allows a local attacker to execute arbitrary code via a crafted command to get the token component."},{"lang":"es","value":"Un problema en spidernet-io spiderpool v.0.9.3 y anteriores permite a un atacante local ejecutar código arbitrario mediante un comando manipulado para obtener el componente token."}],"metrics":{},"references":[{"url":"https:\/\/gist.github.com\/HouqiyuA\/fdb09caea44c80a5681ca1d30bcd6777","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33424","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:27.070","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A cross-site scripting (XSS) vulnerability in the Settings menu of CMSimple v5.15 allows attackers to execute arbitrary web scripts or HTML via a crafted payload injected into the Downloads parameter under the Language section."},{"lang":"es","value":"Una vulnerabilidad de Cross Site Scripting (XSS) en el menú Configuración de CMSimple v5.15 permite a los atacantes ejecutar script web o HTML arbitrarios a través de un payload manipulado inyectado en el parámetro Descargas en la sección Idioma."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/adiapera\/xss_language_cmsimple_5.15","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33428","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:27.120","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Buffer-Overflow vulnerability at conv.c:68 of stsaz phiola v2.0-rc22 allows a remote attacker to execute arbitrary code via the a crafted .wav file."},{"lang":"es","value":"Vulnerabilidad de desbordamiento de búfer en conv.c:68 de stsaz phiola v2.0-rc22 permite a un atacante remoto ejecutar código arbitrario a través de un archivo .wav manipulado."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/heap-buffer-overflow-1\/heap-buffer-overflow-1.assets\/image-20240420005017430.png","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/heap-buffer-overflow-1\/heap-buffer-overflow-1.md","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/heap-buffer-overflow-1\/poc","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/tree\/master\/phiola\/heap-buffer-overflow-1","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/stsaz\/phiola\/issues\/29","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33429","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:27.170","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Buffer-Overflow vulnerability at pcm_convert.h:513 of phiola v2.0-rc22 allows a remote attacker to execute arbitrary code via a crafted .wav file."},{"lang":"es","value":"Vulnerabilidad de desbordamiento de búfer en pcm_convert.h:513 de phiola v2.0-rc22 permite a un atacante remoto ejecutar código arbitrario a través de un archivo .wav manipulado."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/heap-buffer-overflow-2\/heap-buffer-overflow-2.assets\/image-20240420011116818.png","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/heap-buffer-overflow-2\/heap-buffer-overflow-2.md","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/heap-buffer-overflow-2\/poc\/","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/tree\/master\/phiola\/heap-buffer-overflow-2","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/stsaz\/phiola\/","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/stsaz\/phiola\/issues\/30","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33430","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:27.223","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in phiola\/src\/afilter\/pcm_convert.h:513 of phiola v2.0-rc22 allows a remote attacker to execute arbitrary code via the a crafted .wav file."},{"lang":"es","value":"Un problema en phiola\/src\/afilter\/pcm_convert.h:513 de phiola v2.0-rc22 permite a un atacante remoto ejecutar código arbitrario a través de un archivo .wav manipulado."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/segmentFault-1\/poc\/I2ZFI3~5","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/segmentFault-1\/segmentFault-1.assets\/image-20240420011601263.png","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/segmentFault-1\/segmentFault-1.md","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/tree\/master\/phiola\/segmentFault-1","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/tree\/master\/phiola\/segmentFault-1\/poc","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/stsaz\/phiola\/","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/stsaz\/phiola\/issues\/28","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33431","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T19:15:27.283","lastModified":"2024-05-01T19:50:25.633","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in phiola\/src\/afilter\/conv.c:115 of phiola v2.0-rc22 allows a remote attacker to cause a denial of service via a crafted .wav file."},{"lang":"es","value":"Un problema en phiola\/src\/afilter\/conv.c:115 de phiola v2.0-rc22 permite a un atacante remoto provocar una denegación de servicio a través de un archivo .wav manipulado."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/flowPointException-1\/flowPointException-1.assets\/image-20240420004701828.png","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/flowPointException-1\/flowPointException-1.md","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/blob\/master\/phiola\/flowPointException-1\/poc\/I0I72U~G","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/tree\/master\/phiola\/flowPointException-1","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/Helson-S\/FuzzyTesting\/tree\/master\/phiola\/flowPointException-1\/poc","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/stsaz\/phiola\/","source":"cve@mitre.org"},{"url":"https:\/\/github.com\/stsaz\/phiola\/issues\/27","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2023-46294","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T20:15:12.267","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue was discovered in Teledyne FLIR M300 2.00-19. User account passwords are encrypted locally, and can be decrypted to cleartext passwords using the utility umSetup. This utility requires root permissions to execute."},{"lang":"es","value":"Se descubrió un problema en Teledyne FLIR M300 2.00-19. Las contraseñas de las cuentas de usuario se cifran localmente y se pueden descifrar en contraseñas de texto plano mediante la utilidad umSetup. Esta utilidad requiere permisos de root para ejecutarse."}],"metrics":{},"references":[{"url":"https:\/\/Loudmouth.io","source":"cve@mitre.org"},{"url":"https:\/\/gitlab.com\/loudmouth-security\/vulnerability-disclosures\/cve-2023-46294","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2023-46295","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T20:15:12.330","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue was discovered in Teledyne FLIR M300 2.00-19. Unauthenticated remote code execution can occur in the web server. An attacker can exploit this by sending a POST request to the vulnerable PHP page. An attacker can elevate to root permissions with Sudo."},{"lang":"es","value":"Se descubrió un problema en Teledyne FLIR M300 2.00-19. Puede ocurrir una ejecución remota de código no autenticado en el servidor web. Un atacante puede aprovechar esto enviando una solicitud POST a la página PHP vulnerable. Un atacante puede elevar los permisos a root con Sudo."}],"metrics":{},"references":[{"url":"https:\/\/gitlab.com\/loudmouth-security\/vulnerability-disclosures\/cve-2023-46295","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-24403","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T20:15:12.510","lastModified":"2024-05-01T20:15:12.510","vulnStatus":"Rejected","descriptions":[{"lang":"en","value":"Rejected reason: DO NOT USE THIS CVE RECORD. ConsultIDs: CVE-2024-30176. Reason: This record is a reservation duplicate of CVE-2024-30176. Notes: All CVE users should reference CVE-2024-30176 instead of this record. All references and descriptions in this record have been removed to prevent accidental usage."}],"metrics":{},"references":[]}},{"cve":{"id":"CVE-2024-25676","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T20:15:12.733","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue was discovered in ViewerJS 0.5.8. A script from the component loads content via URL TAGs without properly sanitizing it. This leads to both open redirection and out-of-band resource loading."},{"lang":"es","value":"Se descubrió un problema en ViewerJS 0.5.8. Un script del componente carga contenido a través de ETIQUETAS URL sin sanitizarlo adecuadamente. Esto conduce tanto a la redirección abierta como a la carga de recursos fuera de banda."}],"metrics":{},"references":[{"url":"https:\/\/excellium-services.com\/cert-xlm-advisory\/cve-2024-25676","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33306","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T20:15:12.787","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"SourceCodester Laboratory Management System 1.0 is vulnerable to Cross Site Scripting (XSS) via \"First Name\" parameter in Create User."},{"lang":"es","value":"SourceCodester Laboratory Management System 1.0 es vulnerable a Cross Site Scripting (XSS) a través del parámetro \"Nombre\" en Crear usuario."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Mohitkumar0786\/CVE\/blob\/main\/CVE-2024-33306.md","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33307","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T20:15:12.837","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"SourceCodester Laboratory Management System 1.0 is vulnerable to Cross Site Scripting (XSS) via \"Last Name\" parameter in Create User."},{"lang":"es","value":"SourceCodester Laboratory Management System 1.0 es vulnerable a Cross Site Scripting (XSS) a través del parámetro \"Apellido\" en Crear usuario."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Mohitkumar0786\/CVE\/blob\/main\/CVE-2024-33307.md","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33423","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T20:15:12.887","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Cross-Site Scripting (XSS) vulnerability in the Settings menu of CMSimple v5.15 allows attackers to execute arbitrary web scripts or HTML via a crafted payload injected into the Logout parameter under the Language section."},{"lang":"es","value":"La vulnerabilidad de Cross Site Scripting (XSS) en el menú Configuración de CMSimple v5.15 permite a los atacantes ejecutar script web o HTML arbitrarios a través de un payload manipulado inyectado en el parámetro Cerrar sesión en la sección Idioma."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/adiapera\/xss_language_cmsimple_5.15","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-4142","sourceIdentifier":"reefs@jfrog.com","published":"2024-05-01T21:15:51.000","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An Improper input validation vulnerability that could potentially lead to privilege escalation was discovered in JFrog Artifactory.\n\nDue to this vulnerability, users with low privileges may gain administrative access to the system.\n\nThis issue can also be exploited in Artifactory platforms with anonymous access enabled.\n\n"},{"lang":"es","value":"Se descubrió en JFrog Artifactory una vulnerabilidad de validación de entrada incorrecta que podría conducir a una escalada de privilegios. Debido a esta vulnerabilidad, los usuarios con privilegios bajos pueden obtener acceso administrativo al sistema. Este problema también se puede aprovechar en plataformas Artifactory con acceso anónimo habilitado."}],"metrics":{"cvssMetricV31":[{"source":"reefs@jfrog.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:N\/S:C\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.0,"baseSeverity":"CRITICAL"},"exploitabilityScore":2.2,"impactScore":6.0}]},"weaknesses":[{"source":"reefs@jfrog.com","type":"Primary","description":[{"lang":"en","value":"CWE-20"}]}],"references":[{"url":"https:\/\/jfrog.com\/help\/r\/jfrog-release-information\/jfrog-security-advisories","source":"reefs@jfrog.com"}]}},{"cve":{"id":"CVE-2021-36593","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T22:15:09.340","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Oxwall 1.8.7 (11111) is vulnerable to Incorrect Access Control. Unauthenticated file upload allows an attacker to upload image files."}],"metrics":{},"references":[{"url":"https:\/\/gist.github.com\/mir-hossein\/7a1e44f4d2519e743392c97a76232d1f","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2021-36594","sourceIdentifier":"cve@mitre.org","published":"2024-05-01T22:15:09.413","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"SSRF in Oxwall 1.8.7 (11111) allows an attacker to execute arbitrary commands via Phar deserialization or internal API server or ... (via url parameter)"}],"metrics":{},"references":[{"url":"https:\/\/gist.github.com\/mir-hossein\/7a1e44f4d2519e743392c97a76232d1f","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2023-51631","sourceIdentifier":"zdi-disclosures@trendmicro.com","published":"2024-05-02T00:15:07.270","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"D-Link DIR-X3260 prog.cgi SetUsersSettings Stack-based Buffer Overflow Remote Code Execution Vulnerability. This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of D-Link DIR-X3260 routers. Authentication is required to exploit this vulnerability.\n\nThe specific flaw exists within the prog.cgi binary, which handles HNAP requests made to the lighttpd webserver listening on TCP ports 80 and 443. The issue results from the lack of proper validation of a user-supplied string before copying it to a fixed-size stack-based buffer. An attacker can leverage this vulnerability to execute code in the context of root. Was ZDI-CAN-21675."}],"metrics":{"cvssMetricV30":[{"source":"zdi-disclosures@trendmicro.com","type":"Secondary","cvssData":{"version":"3.0","vectorString":"CVSS:3.0\/AV:A\/AC:L\/PR:H\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"ADJACENT_NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":6.8,"baseSeverity":"MEDIUM"},"exploitabilityScore":0.9,"impactScore":5.9}]},"weaknesses":[{"source":"zdi-disclosures@trendmicro.com","type":"Secondary","description":[{"lang":"en","value":"CWE-121"}]}],"references":[{"url":"https:\/\/supportannouncement.us.dlink.com\/announcement\/publication.aspx?name=SAP10365","source":"zdi-disclosures@trendmicro.com"},{"url":"https:\/\/www.zerodayinitiative.com\/advisories\/ZDI-24-050\/","source":"zdi-disclosures@trendmicro.com"}]}},{"cve":{"id":"CVE-2024-2405","sourceIdentifier":"contact@wpscan.com","published":"2024-05-02T06:15:49.947","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Float menu  WordPress plugin before 6.0.1 does not have CSRF check in its bulk actions, which could allow attackers to make logged in admin delete arbitrary menu via a CSRF attack."}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/c42ffa15-6ebe-4c70-9e51-b95bd05ea04d\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-3471","sourceIdentifier":"contact@wpscan.com","published":"2024-05-02T06:15:50.350","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Button Generator  WordPress plugin before 3.0 does not have CSRF check in place when bulk deleting, which could allow attackers to make a logged in admin delete buttons via a CSRF attack"}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/a3c282fb-81b8-48bf-8c18-8366ea8ad9af\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-3472","sourceIdentifier":"contact@wpscan.com","published":"2024-05-02T06:15:50.453","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Modal Window  WordPress plugin before 5.3.10 does not have CSRF check in place when bulk deleting modals, which could allow attackers to make a logged in admin delete them via a CSRF attack"}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/d42f74dd-520f-40aa-9cf0-3544db9562c7\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-3474","sourceIdentifier":"contact@wpscan.com","published":"2024-05-02T06:15:50.527","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Wow Skype Buttons WordPress plugin before 4.0.4 does not have CSRF checks in some bulk actions, which could allow attackers to make logged in admins perform unwanted actions, such as deleting buttons via CSRF attacks"}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/e5c3e145-6738-4d85-8507-43ca1b1d5877\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-3475","sourceIdentifier":"contact@wpscan.com","published":"2024-05-02T06:15:50.660","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Sticky Buttons  WordPress plugin before 3.2.4 does not have CSRF checks in some bulk actions, which could allow attackers to make logged in admins perform unwanted actions, such as deleting buttons via CSRF attacks"}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/bf540242-5306-4c94-ad50-782d0d5b127f\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-3476","sourceIdentifier":"contact@wpscan.com","published":"2024-05-02T06:15:50.887","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Side Menu Lite  WordPress plugin before 4.2.1 does not have CSRF checks in some bulk actions, which could allow attackers to make logged in admins perform unwanted actions, such as deleting buttons via CSRF attacks"}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/46f74493-9082-48b2-90bc-2c1d1db64ccd\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-3477","sourceIdentifier":"contact@wpscan.com","published":"2024-05-02T06:15:50.950","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Popup Box  WordPress plugin before 2.2.7 does not have CSRF checks in some bulk actions, which could allow attackers to make logged in admins perform unwanted actions, such as deleting popups via CSRF attacks"}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/ca5e59e6-c500-4129-997b-391cdf9aa9c7\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-3478","sourceIdentifier":"contact@wpscan.com","published":"2024-05-02T06:15:51.033","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Herd Effects  WordPress plugin before 5.2.7 does not have CSRF checks in some bulk actions, which could allow attackers to make logged in admins perform unwanted actions, such as deleting effects via CSRF attacks"}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/09f1a696-86ee-47cc-99de-57cfd2a3219d\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-3481","sourceIdentifier":"contact@wpscan.com","published":"2024-05-02T06:15:51.130","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Counter Box  WordPress plugin before 1.2.4 does not have CSRF checks in some bulk actions, which could allow attackers to make logged in admins perform unwanted actions, such deleting counters via CSRF attacks"}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/0c441293-e7f9-4634-8f3a-09925cd2b696\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-32882","sourceIdentifier":"security-advisories@github.com","published":"2024-05-02T07:15:20.967","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Wagtail is an open source content management system built on Django. In affected versions if a model has been made available for editing through the `wagtail.contrib.settings` module or `ModelViewSet`, and the `permission` argument on `FieldPanel` has been used to further restrict access to one or more fields of the model, a user with edit permission over the model but not the specific field can craft an HTTP POST request that bypasses the permission check on the individual field, allowing them to update its value. This vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin, or by a user who has not been granted edit access to the model in question. The editing interfaces for pages and snippets are also unaffected. Patched versions have been released as Wagtail 6.0.3 and 6.1. Wagtail releases prior to 6.0 are unaffected. Users are advised to upgrade. Site owners who are unable to upgrade to a patched version can avoid the vulnerability as follows: 1.For models registered through `ModelViewSet`, register the model as a snippet instead; 2. For settings models, place the restricted fields in a separate settings model, and configure permission at the model level."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:H\/UI:N\/S:U\/C:N\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":2.7,"baseSeverity":"LOW"},"exploitabilityScore":1.2,"impactScore":1.4}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-280"},{"lang":"en","value":"CWE-281"}]}],"references":[{"url":"https:\/\/docs.wagtail.org\/en\/stable\/extending\/generic_views.html#modelviewset","source":"security-advisories@github.com"},{"url":"https:\/\/docs.wagtail.org\/en\/stable\/reference\/contrib\/settings.html","source":"security-advisories@github.com"},{"url":"https:\/\/docs.wagtail.org\/en\/stable\/reference\/pages\/panels.html#wagtail.admin.panels.FieldPanel.permission","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/wagtail\/wagtail\/commit\/ab2a5d82b4ee3c909d2456704388ccf90e367c9b","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/wagtail\/wagtail\/security\/advisories\/GHSA-w2v8-php4-p8hc","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-32962","sourceIdentifier":"security-advisories@github.com","published":"2024-05-02T07:15:21.420","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"xml-crypto is an xml digital signature and encryption library for Node.js. In affected versions the default configuration does not check authorization of the signer, it only checks the validity of the signature per section 3.2.2 of the w3 xmldsig-core-20080610 spec. As such, without additional validation steps, the default configuration allows a malicious actor to re-sign an XML document, place the certificate in a `<KeyInfo \/>` element, and pass `xml-crypto` default validation checks. As a result `xml-crypto` trusts by default any certificate provided via digitally signed XML document's `<KeyInfo \/>`. `xml-crypto` prefers to use any certificate provided via digitally signed XML document's `<KeyInfo \/>` even if library was configured to use specific certificate (`publicCert`) for signature verification purposes.  An attacker can spoof signature verification by modifying XML document and replacing existing signature with signature generated with malicious private key (created by attacker) and by attaching that private key's certificate to `<KeyInfo \/>` element. This vulnerability is combination of changes introduced to `4.0.0` on pull request 301 \/ commit `c2b83f98` and has been addressed in version 6.0.0 with pull request 445 \/ commit `21201723d`. Users are advised to upgrade. Users unable to upgrade may either check the certificate extracted via `getCertFromKeyInfo` against trusted certificates before accepting the results of the validation or set `xml-crypto's getCertFromKeyInfo` to `() => undefined` forcing `xml-crypto` to use an explicitly configured `publicCert` or `privateKey` for signature verification."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:C\/C:H\/I:H\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"NONE","baseScore":10.0,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.8}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-347"}]}],"references":[{"url":"https:\/\/github.com\/node-saml\/xml-crypto\/commit\/21201723d2ca9bc11288f62cf72552b7d659b000","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/node-saml\/xml-crypto\/commit\/c2b83f984049edb68ad1d7c6ad0739ec92af11ca","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/node-saml\/xml-crypto\/pull\/301","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/node-saml\/xml-crypto\/pull\/445","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/node-saml\/xml-crypto\/security\/advisories\/GHSA-2xp3-57p7-qf4v","source":"security-advisories@github.com"},{"url":"https:\/\/www.w3.org\/TR\/2008\/REC-xmldsig-core-20080610\/#sec-CoreValidation","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-32971","sourceIdentifier":"security-advisories@github.com","published":"2024-05-02T07:15:21.733","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Apollo Router is a configurable, graph router written in Rust to run a federated supergraph that uses Apollo Federation 2. The affected versions of Apollo Router contain a bug that in limited circumstances, could lead to unexpected operations being executed which can result in unintended data or effects. This only affects Router instances configured to use distributed query plan caching. The root cause of this defect is a bug in Apollo Router’s cache retrieval logic: When this defect is present and distributed query planning caching is enabled, asking the Router to execute an operation (whether it is a query, a mutation, or a subscription) may result in an unexpected variation of that operation being executed or the generation of unexpected errors. The issue stems from inadvertently executing a modified version of a previously executed operation, whose query plan is stored in the underlying cache (specifically, Redis). Depending on the type of the operation, the result may vary. For a query, results may be fetched that don’t match what was requested (e.g., rather than running `fetchUsers(type: ENTERPRISE)` the Router may run `fetchUsers(type: TRIAL)`. For a mutation, this may result in incorrect mutations being sent to underlying subgraph servers (e.g., rather than sending `deleteUser(id: 10)` to a subgraph, the Router may run `deleteUser(id: 12)`. Users who are using distributed query plan caching, are advised to either upgrade to version 1.45.1 or above or downgrade to version 1.43.2 of the Apollo Router. Apollo Router versions 1.44.0 or 1.45.0 are not recommended for use and have been withdrawn. Users unable to upgrade can disable distributed query plan caching to mitigate this issue."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:N\/S:C\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.0,"baseSeverity":"CRITICAL"},"exploitabilityScore":2.2,"impactScore":6.0}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-440"},{"lang":"en","value":"CWE-670"}]}],"references":[{"url":"https:\/\/github.com\/apollographql\/router\/commit\/ff9f666598cd17661880fe7fc6e9c9611316e529","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/apollographql\/router\/releases\/tag\/v1.45.1","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/apollographql\/router\/security\/advisories\/GHSA-q9p4-hw9m-fj2v","source":"security-advisories@github.com"},{"url":"https:\/\/www.apollographql.com\/docs\/router\/configuration\/distributed-caching\/#distributed-query-plan-caching","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-3490","sourceIdentifier":"security@wordfence.com","published":"2024-05-02T07:15:22.040","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The WP Recipe Maker plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's wprm-recipe-roundup-item shortcode in all versions up to, and including, 9.3.1 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3078644\/wp-recipe-maker","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/69cc7b6c-b6c2-4bba-afb4-86ba1b36b295?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-3280","sourceIdentifier":"security@wordfence.com","published":"2024-05-02T08:15:08.270","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Follow Us Badges plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's wpsite_follow_us_badges shortcode in all versions up to, and including, 3.1.10 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3078718\/wpsite-follow-us-badges","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/ef1ccef8-9066-4f5c-b5c5-9fa6e54f0e87?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-32114","sourceIdentifier":"security@apache.org","published":"2024-05-02T09:15:06.990","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In Apache ActiveMQ 6.x, the default configuration doesn't secure the API web context (where the Jolokia JMX REST API and the Message REST API are located).\nIt means that anyone can use these layers without any required authentication. Potentially, anyone can interact with the broker (using Jolokia JMX REST API) and\/or produce\/consume messages or purge\/delete destinations (using the Message REST API).\n\nTo mitigate, users can update the default conf\/jetty.xml configuration file to add authentication requirement:\n<bean id=\"securityConstraintMapping\" class=\"org.eclipse.jetty.security.ConstraintMapping\">\n  <property name=\"constraint\" ref=\"securityConstraint\" \/>\n  <property name=\"pathSpec\" value=\"\/\" \/>\n<\/bean>\n\nOr we encourage users to upgrade to Apache ActiveMQ 6.1.2 where the default configuration has been updated with authentication by default.\n"}],"metrics":{"cvssMetricV31":[{"source":"security@apache.org","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:A\/AC:L\/PR:N\/UI:R\/S:C\/C:H\/I:N\/A:H","attackVector":"ADJACENT_NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":8.5,"baseSeverity":"HIGH"},"exploitabilityScore":2.1,"impactScore":5.8}]},"weaknesses":[{"source":"security@apache.org","type":"Primary","description":[{"lang":"en","value":"CWE-1188"}]}],"references":[{"url":"https:\/\/activemq.apache.org\/security-advisories.data\/CVE-2024-32114-announcement.txt","source":"security@apache.org"}]}},{"cve":{"id":"CVE-2024-3883","sourceIdentifier":"security@wordfence.com","published":"2024-05-02T09:15:07.233","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The 3D FlipBook plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the Bookmark URL field in all versions up to, and including, 1.15.4 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with author-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3079536\/interactive-3d-flipbook-powered-physics-engine","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/016462cf-abe9-4c90-abd2-b5bb69348d7e?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-32638","sourceIdentifier":"security@apache.org","published":"2024-05-02T10:15:08.443","lastModified":"2024-05-02T14:15:09.830","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling') vulnerability in Apache APISIX when using `forward-auth` plugin.This issue affects Apache APISIX: from 3.8.0, 3.9.0.\n\nUsers are recommended to upgrade to version 3.8.1, 3.9.1 or higher, which fixes the issue.\n\n"}],"metrics":{},"weaknesses":[{"source":"security@apache.org","type":"Primary","description":[{"lang":"en","value":"CWE-444"}]}],"references":[{"url":"http:\/\/www.openwall.com\/lists\/oss-security\/2024\/05\/02\/2","source":"security@apache.org"},{"url":"https:\/\/lists.apache.org\/thread\/ngvgxllw4zn4hgngkqw2o225kf9wotov","source":"security@apache.org"}]}},{"cve":{"id":"CVE-2024-3955","sourceIdentifier":"cvd@cert.pl","published":"2024-05-02T10:15:08.630","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"URL GET parameter \"logtime\" utilized within the \"downloadlog\" function from \"cbpi\/http_endpoints\/http_system.py\" is subsequently passed to the \"os.system\" function in \"cbpi\/controller\/system_controller.py\" without prior validation allowing to execute arbitrary code.This issue affects CraftBeerPi 4: from 4.0.0.58 (commit 563fae9) before 4.4.1.a1 (commit 57572c7).\n\n"}],"metrics":{},"weaknesses":[{"source":"cvd@cert.pl","type":"Secondary","description":[{"lang":"en","value":"CWE-94"}]}],"references":[{"url":"https:\/\/cert.pl\/en\/posts\/2024\/05\/CVE-2024-3955\/","source":"cvd@cert.pl"},{"url":"https:\/\/cert.pl\/posts\/2024\/05\/CVE-2024-3955\/","source":"cvd@cert.pl"},{"url":"https:\/\/github.com\/PiBrewing\/craftbeerpi4\/issues\/132","source":"cvd@cert.pl"}]}},{"cve":{"id":"CVE-2024-33911","sourceIdentifier":"audit@patchstack.com","published":"2024-05-02T11:15:45.663","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') vulnerability in Weblizar School Management Pro.This issue affects School Management Pro: from n\/a through 10.3.4.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"audit@patchstack.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:H\/UI:N\/S:C\/C:H\/I:N\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"LOW","baseScore":7.6,"baseSeverity":"HIGH"},"exploitabilityScore":2.3,"impactScore":4.7}]},"weaknesses":[{"source":"audit@patchstack.com","type":"Primary","description":[{"lang":"en","value":"CWE-89"}]}],"references":[{"url":"https:\/\/patchstack.com\/database\/vulnerability\/school-management-pro\/wordpress-the-school-management-pro-plugin-10-3-4-sql-injection-vulnerability?_s_id=cve","source":"audit@patchstack.com"}]}},{"cve":{"id":"CVE-2024-33913","sourceIdentifier":"audit@patchstack.com","published":"2024-05-02T11:15:45.883","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Cross-Site Request Forgery (CSRF) vulnerability leading to Arbitrary File Upload in Xserver Migrator.This issue affects Xserver Migrator: from n\/a through 1.6.1.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"audit@patchstack.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:C\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.6,"baseSeverity":"CRITICAL"},"exploitabilityScore":2.8,"impactScore":6.0}]},"weaknesses":[{"source":"audit@patchstack.com","type":"Primary","description":[{"lang":"en","value":"CWE-352"}]}],"references":[{"url":"https:\/\/patchstack.com\/database\/vulnerability\/xserver-migrator\/wordpress-xserver-migrator-plugin-1-6-1-csrf-to-arbitrary-file-upload-vulnerability?_s_id=cve","source":"audit@patchstack.com"}]}},{"cve":{"id":"CVE-2024-33922","sourceIdentifier":"audit@patchstack.com","published":"2024-05-02T11:15:46.080","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Insertion of Sensitive Information into Log File vulnerability in Jordy Meow WP Media Cleaner.This issue affects WP Media Cleaner: from n\/a through 6.7.2.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"audit@patchstack.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:L\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":1.4}]},"weaknesses":[{"source":"audit@patchstack.com","type":"Primary","description":[{"lang":"en","value":"CWE-532"}]}],"references":[{"url":"https:\/\/patchstack.com\/database\/vulnerability\/media-cleaner\/wordpress-wp-media-cleaner-plugin-6-7-2-sensitive-data-exposure-via-log-file-vulnerability?_s_id=cve","source":"audit@patchstack.com"}]}},{"cve":{"id":"CVE-2024-33930","sourceIdentifier":"audit@patchstack.com","published":"2024-05-02T11:15:46.273","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"URL Redirection to Untrusted Site ('Open Redirect') vulnerability in ILLID Share This Image.This issue affects Share This Image: from n\/a through 1.97.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"audit@patchstack.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:C\/C:L\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":4.7,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":1.4}]},"weaknesses":[{"source":"audit@patchstack.com","type":"Secondary","description":[{"lang":"en","value":"CWE-601"}]}],"references":[{"url":"https:\/\/patchstack.com\/database\/vulnerability\/share-this-image\/wordpress-share-this-image-plugin-1-97-open-redirection-vulnerability?_s_id=cve","source":"audit@patchstack.com"}]}},{"cve":{"id":"CVE-2024-3005","sourceIdentifier":"security@wordfence.com","published":"2024-05-02T11:15:46.477","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The LA-Studio Element Kit for Elementor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's LaStudioKit Post Author widget in all versions up to, and including, 1.3.7.5 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3079793\/lastudio-element-kit","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/544db0d5-1760-4229-8429-d2391e328304?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-33944","sourceIdentifier":"audit@patchstack.com","published":"2024-05-02T13:15:26.240","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Missing Authorization vulnerability in Kestrel WooCommerce AWeber Newsletter Subscription.This issue affects WooCommerce AWeber Newsletter Subscription: from n\/a through 4.0.2.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"audit@patchstack.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":6.5,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":2.5}]},"weaknesses":[{"source":"audit@patchstack.com","type":"Secondary","description":[{"lang":"en","value":"CWE-862"}]}],"references":[{"url":"https:\/\/patchstack.com\/database\/vulnerability\/woocommerce-aweber-newsletter-subscription\/wordpress-woocommerce-aweber-newsletter-subscription-plugin-4-0-1-unauthenticated-access-token-change-reset-vulnerability?_s_id=cve","source":"audit@patchstack.com"}]}},{"cve":{"id":"CVE-2023-28798","sourceIdentifier":"cve@zscaler.com","published":"2024-05-02T13:23:05.807","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An out-of-bounds write to heap in the pacparser library on Zscaler Client Connector on Mac may lead to arbitrary code execution."}],"metrics":{"cvssMetricV31":[{"source":"cve@zscaler.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:N\/S:C\/C:L\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":6.5,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.2,"impactScore":3.7}]},"weaknesses":[{"source":"cve@zscaler.com","type":"Secondary","description":[{"lang":"en","value":"CWE-122"}]}],"references":[{"url":"https:\/\/help.zscaler.com\/client-connector\/client-connector-app-release-summary-2022?applicable_category=macOS&applicable_version=3.7&deployment_date=2022-08-19&id=1414851","source":"cve@zscaler.com"}]}},{"cve":{"id":"CVE-2023-41970","sourceIdentifier":"cve@zscaler.com","published":"2024-05-02T13:23:06.003","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An Improper Validation of Integrity Check Value vulnerability in Zscaler Client Connector on Windows during the Repair App functionality may allow Local Execution of Code.This issue affects Client Connector on Windows: before 4.1.0.62.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"cve@zscaler.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:H\/PR:H\/UI:N\/S:U\/C:H\/I:H\/A:L","attackVector":"LOCAL","attackComplexity":"HIGH","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"LOW","baseScore":6.0,"baseSeverity":"MEDIUM"},"exploitabilityScore":0.5,"impactScore":5.5}]},"weaknesses":[{"source":"cve@zscaler.com","type":"Secondary","description":[{"lang":"en","value":"CWE-354"}]}],"references":[{"url":"https:\/\/help.zscaler.com\/client-connector\/client-connector-app-release-summary-2022?applicable_category=windows&applicable_version=4.1","source":"cve@zscaler.com"}]}},{"cve":{"id":"CVE-2023-41971","sourceIdentifier":"cve@zscaler.com","published":"2024-05-02T13:23:06.180","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An Improper Link Resolution Before File Access ('Link Following') vulnerability in Zscaler Client Connector on Windows allows a system file to be overwritten.This issue affects Client Connector on Windows: before 3.7.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"cve@zscaler.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:H\/PR:L\/UI:N\/S:U\/C:N\/I:L\/A:H","attackVector":"LOCAL","attackComplexity":"HIGH","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"HIGH","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.0,"impactScore":4.2}]},"weaknesses":[{"source":"cve@zscaler.com","type":"Secondary","description":[{"lang":"en","value":"CWE-59"}]}],"references":[{"url":"https:\/\/help.zscaler.com\/zscaler-client-connector\/client-connector-app-release-summary-2021??applicable_category=windows&applicable_version=3.7","source":"cve@zscaler.com"}]}},{"cve":{"id":"CVE-2024-23459","sourceIdentifier":"cve@zscaler.com","published":"2024-05-02T13:23:06.363","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An Improper Link Resolution Before File Access ('Link Following') vulnerability in Zscaler Client Connector on Mac allows a system file to be overwritten.This issue affects Zscaler Client Connector on Mac : before 3.7.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"cve@zscaler.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:L\/PR:L\/UI:N\/S:U\/C:N\/I:H\/A:H","attackVector":"LOCAL","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":7.1,"baseSeverity":"HIGH"},"exploitabilityScore":1.8,"impactScore":5.2}]},"weaknesses":[{"source":"cve@zscaler.com","type":"Secondary","description":[{"lang":"en","value":"CWE-59"}]}],"references":[{"url":"https:\/\/help.zscaler.com\/client-connector\/client-connector-app-release-summary-2022?applicable_category=macos&applicable_version=3.7","source":"cve@zscaler.com"}]}},{"cve":{"id":"CVE-2024-23461","sourceIdentifier":"cve@zscaler.com","published":"2024-05-02T13:23:06.567","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An Improper Validation of Integrity Check Value vulnerability in Zscaler Client Connector on MacOS during the upgrade process may allow a Local Execution of Code.This issue affects Client Connector on MacOS: before 3.4.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"cve@zscaler.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:A\/AC:H\/PR:H\/UI:N\/S:U\/C:N\/I:N\/A:H","attackVector":"ADJACENT_NETWORK","attackComplexity":"HIGH","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":4.2,"baseSeverity":"MEDIUM"},"exploitabilityScore":0.5,"impactScore":3.6}]},"weaknesses":[{"source":"cve@zscaler.com","type":"Secondary","description":[{"lang":"en","value":"CWE-354"}]}],"references":[{"url":"https:\/\/help.zscaler.com\/zscaler-client-connector\/client-connector-app-release-summary-2021?applicable_category=macos&applicable_version=3.4","source":"cve@zscaler.com"}]}},{"cve":{"id":"CVE-2024-23462","sourceIdentifier":"cve@zscaler.com","published":"2024-05-02T13:23:06.810","lastModified":"2024-05-02T13:27:25.103","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An Improper Validation of Integrity Check Value vulnerability in Zscaler Client Connector on MacOS allows a denial of service of the Client Connector binary and thus removing client functionality.This issue affects Client Connector on MacOS: before 3.4.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"cve@zscaler.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:L\/PR:L\/UI:N\/S:U\/C:N\/I:N\/A:L","attackVector":"LOCAL","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"LOW","baseScore":3.3,"baseSeverity":"LOW"},"exploitabilityScore":1.8,"impactScore":1.4}]},"weaknesses":[{"source":"cve@zscaler.com","type":"Secondary","description":[{"lang":"en","value":"CWE-354"}]}],"references":[{"url":"https:\/\/help.zscaler.com\/zscaler-client-connector\/client-connector-app-release-summary-2021?applicable_category=macos&applicable_version=3.4","source":"cve@zscaler.com"}]}},{"cve":{"id":"CVE-2023-37244","sourceIdentifier":"cve-coordination@google.com","published":"2024-05-02T14:15:09.410","lastModified":"2024-05-02T14:15:09.410","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The affected AutomationManager.AgentService.exe application contains a TOCTOU race condition vulnerability that allows standard users to create a pseudo-symlink at C:\\ProgramData\\N-Able Technologies\\AutomationManager\\Temp, which could be leveraged by an attacker to manipulate the process into performing arbitrary file deletions. We recommend upgrading to version 2.91.0.0"}],"metrics":{"cvssMetricV31":[{"source":"cve-coordination@google.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:L\/UI:N\/S:U\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.6,"impactScore":3.6}]},"weaknesses":[{"source":"cve-coordination@google.com","type":"Secondary","description":[{"lang":"en","value":"CWE-362"}]}],"references":[{"url":"https:\/\/github.com\/mandiant\/Vulnerability-Disclosures\/blob\/master\/2023\/MNDT-2023-0016.md","source":"cve-coordination@google.com"}]}},{"cve":{"id":"CVE-2024-30251","sourceIdentifier":"security-advisories@github.com","published":"2024-05-02T14:15:09.627","lastModified":"2024-05-02T15:15:06.920","vulnStatus":"Received","descriptions":[{"lang":"en","value":"aiohttp is an asynchronous HTTP client\/server framework for asyncio and Python. In affected versions an attacker can send a specially crafted POST (multipart\/form-data) request. When the aiohttp server processes it, the server will enter an infinite loop and be unable to process any further requests. An attacker can stop the application from serving requests after sending a single request. This issue has been addressed in version 3.9.4. Users are advised to upgrade. Users unable to upgrade may manually apply a patch to their systems. Please see the linked GHSA for instructions."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":3.6}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-835"}]}],"references":[{"url":"http:\/\/www.openwall.com\/lists\/oss-security\/2024\/05\/02\/4","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/aio-libs\/aiohttp\/commit\/7eecdff163ccf029fbb1ddc9de4169d4aaeb6597","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/aio-libs\/aiohttp\/commit\/cebe526b9c34dc3a3da9140409db63014bc4cf19","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/aio-libs\/aiohttp\/commit\/f21c6f2ca512a026ce7f0f6c6311f62d6a638866","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/aio-libs\/aiohttp\/security\/advisories\/GHSA-5m98-qgg9-wh84","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-33302","sourceIdentifier":"cve@mitre.org","published":"2024-05-02T14:15:09.883","lastModified":"2024-05-02T14:15:09.883","vulnStatus":"Received","descriptions":[{"lang":"en","value":"SourceCodester Product Show Room 1.0 and before is vulnerable to Cross Site Scripting (XSS) via \"Middle Name\" under Add Users."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Mohitkumar0786\/CVE\/blob\/main\/CVE-2024-33302.md","source":"cve@mitre.org"},{"url":"https:\/\/portswigger.net\/web-security\/cross-site-scripting\/stored","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33303","sourceIdentifier":"cve@mitre.org","published":"2024-05-02T14:15:09.950","lastModified":"2024-05-02T14:15:09.950","vulnStatus":"Received","descriptions":[{"lang":"en","value":"SourceCodester Product Show Room 1.0 is vulnerable to Cross Site Scripting (XSS) via \"First Name\" under Add Users."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Mohitkumar0786\/CVE\/blob\/main\/CVE-2024-33303.md","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33305","sourceIdentifier":"cve@mitre.org","published":"2024-05-02T14:15:10.023","lastModified":"2024-05-02T14:15:10.023","vulnStatus":"Received","descriptions":[{"lang":"en","value":"SourceCodester Laboratory Management System 1.0 is vulnerable to Cross Site Scripting (XSS) via \"Middle Name\" parameter in Create User."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Mohitkumar0786\/CVE\/blob\/main\/CVE-2024-33305.md","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-34061","sourceIdentifier":"security-advisories@github.com","published":"2024-05-02T14:15:10.083","lastModified":"2024-05-02T14:15:10.083","vulnStatus":"Received","descriptions":[{"lang":"en","value":"changedetection.io is a free open source web page change detection, website watcher, restock monitor and notification service. In affected versions Input in parameter notification_urls is not processed resulting in javascript execution in the application. A reflected XSS vulnerability happens when the user input from a URL or POST data is reflected on the page without being stored, thus allowing the attacker to inject malicious content. This issue has been addressed in version 0.45.22. Users are advised to upgrade. There are no known workarounds for this vulnerability."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:U\/C:N\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":4.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":1.4}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-79"}]}],"references":[{"url":"https:\/\/github.com\/dgtlmoon\/changedetection.io\/commit\/c0f000b1d1ce03733460805dbbedde445fe2c762","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/dgtlmoon\/changedetection.io\/security\/advisories\/GHSA-pwgc-w4x9-gw67","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-34144","sourceIdentifier":"jenkinsci-cert@googlegroups.com","published":"2024-05-02T14:15:10.280","lastModified":"2024-05-02T14:15:10.280","vulnStatus":"Received","descriptions":[{"lang":"en","value":"A sandbox bypass vulnerability involving crafted constructor bodies in Jenkins Script Security Plugin 1335.vf07d9ce377a_e and earlier allows attackers with permission to define and run sandboxed scripts, including Pipelines, to bypass the sandbox protection and execute arbitrary code in the context of the Jenkins controller JVM."}],"metrics":{},"references":[{"url":"http:\/\/www.openwall.com\/lists\/oss-security\/2024\/05\/02\/3","source":"jenkinsci-cert@googlegroups.com"},{"url":"https:\/\/www.jenkins.io\/security\/advisory\/2024-05-02\/#SECURITY-3341","source":"jenkinsci-cert@googlegroups.com"}]}},{"cve":{"id":"CVE-2024-34145","sourceIdentifier":"jenkinsci-cert@googlegroups.com","published":"2024-05-02T14:15:10.330","lastModified":"2024-05-02T14:15:10.330","vulnStatus":"Received","descriptions":[{"lang":"en","value":"A sandbox bypass vulnerability involving sandbox-defined classes that shadow specific non-sandbox-defined classes in Jenkins Script Security Plugin 1335.vf07d9ce377a_e and earlier allows attackers with permission to define and run sandboxed scripts, including Pipelines, to bypass the sandbox protection and execute arbitrary code in the context of the Jenkins controller JVM."}],"metrics":{},"references":[{"url":"http:\/\/www.openwall.com\/lists\/oss-security\/2024\/05\/02\/3","source":"jenkinsci-cert@googlegroups.com"},{"url":"https:\/\/www.jenkins.io\/security\/advisory\/2024-05-02\/#SECURITY-3341","source":"jenkinsci-cert@googlegroups.com"}]}},{"cve":{"id":"CVE-2024-34146","sourceIdentifier":"jenkinsci-cert@googlegroups.com","published":"2024-05-02T14:15:10.380","lastModified":"2024-05-02T14:15:10.380","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Jenkins Git server Plugin 114.v068a_c7cc2574 and earlier does not perform a permission check for read access to a Git repository over SSH, allowing attackers with a previously configured SSH public key but lacking Overall\/Read permission to access these repositories."}],"metrics":{},"references":[{"url":"http:\/\/www.openwall.com\/lists\/oss-security\/2024\/05\/02\/3","source":"jenkinsci-cert@googlegroups.com"},{"url":"https:\/\/www.jenkins.io\/security\/advisory\/2024-05-02\/#SECURITY-3342","source":"jenkinsci-cert@googlegroups.com"}]}},{"cve":{"id":"CVE-2024-34147","sourceIdentifier":"jenkinsci-cert@googlegroups.com","published":"2024-05-02T14:15:10.447","lastModified":"2024-05-02T14:15:10.447","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Jenkins Telegram Bot Plugin 1.4.0 and earlier stores the Telegram Bot token unencrypted in its global configuration file on the Jenkins controller where it can be viewed by users with access to the Jenkins controller file system."}],"metrics":{},"references":[{"url":"http:\/\/www.openwall.com\/lists\/oss-security\/2024\/05\/02\/3","source":"jenkinsci-cert@googlegroups.com"},{"url":"https:\/\/www.jenkins.io\/security\/advisory\/2024-05-02\/#SECURITY-3294","source":"jenkinsci-cert@googlegroups.com"}]}},{"cve":{"id":"CVE-2024-34148","sourceIdentifier":"jenkinsci-cert@googlegroups.com","published":"2024-05-02T14:15:10.523","lastModified":"2024-05-02T14:15:10.523","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Jenkins Subversion Partial Release Manager Plugin 1.0.1 and earlier programmatically disables the fix for CVE-2016-3721 whenever a build is triggered from a release tag, by setting the Java system property 'hudson.model.ParametersAction.keepUndefinedParameters'."}],"metrics":{},"references":[{"url":"http:\/\/www.openwall.com\/lists\/oss-security\/2024\/05\/02\/3","source":"jenkinsci-cert@googlegroups.com"},{"url":"https:\/\/www.jenkins.io\/security\/advisory\/2024-05-02\/#SECURITY-3331","source":"jenkinsci-cert@googlegroups.com"}]}},{"cve":{"id":"CVE-2024-3543","sourceIdentifier":"security@progress.com","published":"2024-05-02T14:15:10.573","lastModified":"2024-05-02T15:15:06.993","vulnStatus":"Received","descriptions":[{"lang":"en","value":"\nUse of reversible password encryption algorithm allows attackers to decrypt passwords.  Sensitive information can be easily unencrypted by the attacker, stolen credentials can be used for arbitrary actions to corrupt the system.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"security@progress.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:A\/AC:H\/PR:H\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"ADJACENT_NETWORK","attackComplexity":"HIGH","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":0.5,"impactScore":5.9}]},"weaknesses":[{"source":"security@progress.com","type":"Secondary","description":[{"lang":"en","value":"CWE-257"}]}],"references":[{"url":"https:\/\/kemptechnologies.com\/","source":"security@progress.com"},{"url":"https:\/\/support.kemptechnologies.com\/hc\/en-us\/articles\/25724813518605-ECS-Connection-Manager-Security-Vulnerabilities-CVE-2024-3544-and-CVE-2024-3543","source":"security@progress.com"}]}},{"cve":{"id":"CVE-2024-4128","sourceIdentifier":"cve-coordination@google.com","published":"2024-05-02T14:15:10.753","lastModified":"2024-05-02T14:15:10.753","vulnStatus":"Received","descriptions":[{"lang":"en","value":"This vulnerability was a potential CSRF attack. When running the Firebase emulator suite, there is an export endpoint that is used normally to export data from running emulators. If a user was running the emulator and navigated to a malicious website with the exploit on a browser that allowed calls to localhost (ie Chrome before v94), the website could exfiltrate emulator data. We recommend upgrading past version 13.6.0 or commit  068a2b08dc308c7ab4b569617f5fc8821237e3a0 https:\/\/github.com\/firebase\/firebase-tools\/commit\/068a2b08dc308c7ab4b569617f5fc8821237e3a0 \n"}],"metrics":{"cvssMetricV31":[{"source":"cve-coordination@google.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:L\/UI:R\/S:U\/C:L\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"LOW","userInteraction":"REQUIRED","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":2.6,"baseSeverity":"LOW"},"exploitabilityScore":1.2,"impactScore":1.4}]},"weaknesses":[{"source":"cve-coordination@google.com","type":"Secondary","description":[{"lang":"en","value":"CWE-352"}]}],"references":[{"url":"https:\/\/github.com\/firebase\/firebase-tools\/commit\/068a2b08dc308c7ab4b569617f5fc8821237e3a0","source":"cve-coordination@google.com"},{"url":"https:\/\/github.com\/firebase\/firebase-tools\/pull\/6944","source":"cve-coordination@google.com"}]}},{"cve":{"id":"CVE-2023-47727","sourceIdentifier":"psirt@us.ibm.com","published":"2024-05-02T15:15:06.680","lastModified":"2024-05-02T15:15:06.680","vulnStatus":"Received","descriptions":[{"lang":"en","value":"IBM Cloud Pak for Security 1.10.0.0 through 1.10.11.0 and IBM QRadar Suite Software 1.10.12.0 through 1.10.20.0 could allow an authenticated user to modify dashboard parameters due to improper input validation.  IBM X-Force ID:  272089."}],"metrics":{"cvssMetricV31":[{"source":"psirt@us.ibm.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:N\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":4.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":1.4}]},"weaknesses":[{"source":"psirt@us.ibm.com","type":"Primary","description":[{"lang":"en","value":"CWE-1287"}]}],"references":[{"url":"https:\/\/exchange.xforce.ibmcloud.com\/vulnerabilities\/272089","source":"psirt@us.ibm.com"},{"url":"https:\/\/www.ibm.com\/support\/pages\/node\/7149968","source":"psirt@us.ibm.com"}]}},{"cve":{"id":"CVE-2024-3544","sourceIdentifier":"security@progress.com","published":"2024-05-02T15:15:07.053","lastModified":"2024-05-02T15:15:07.053","vulnStatus":"Received","descriptions":[{"lang":"en","value":"\nUnauthenticated attackers can perform actions, using SSH private keys, by knowing the IP address and having access to the same network of one of the machines in the HA or Cluster group. This vulnerability has been closed by enhancing LoadMaster partner communications to require a shared secret that must be exchanged between the partners before communication can proceed.\n\n"}],"metrics":{"cvssMetricV31":[{"source":"security@progress.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:A\/AC:H\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"ADJACENT_NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":1.6,"impactScore":5.9}]},"weaknesses":[{"source":"security@progress.com","type":"Secondary","description":[{"lang":"en","value":"CWE-798"}]}],"references":[{"url":"https:\/\/kemptechnologies.com\/","source":"security@progress.com"},{"url":"https:\/\/support.kemptechnologies.com\/hc\/en-us\/articles\/25724813518605-ECS-Connection-Manager-Security-Vulnerabilities-CVE-2024-3544-and-CVE-2024-3543","source":"security@progress.com"}]}},{"cve":{"id":"CVE-2024-4029","sourceIdentifier":"secalert@redhat.com","published":"2024-05-02T15:15:07.227","lastModified":"2024-05-02T15:15:07.227","vulnStatus":"Received","descriptions":[{"lang":"en","value":"A vulnerability was found in Wildfly’s management interface. Due to the lack of limitation of sockets for the management interface, it may be possible to cause a denial of service hitting the nofile limit as there is no possibility to configure or set a maximum number of connections."}],"metrics":{"cvssMetricV31":[{"source":"secalert@redhat.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:H\/PR:H\/UI:N\/S:U\/C:N\/I:N\/A:H","attackVector":"LOCAL","attackComplexity":"HIGH","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":4.1,"baseSeverity":"MEDIUM"},"exploitabilityScore":0.5,"impactScore":3.6}]},"weaknesses":[{"source":"secalert@redhat.com","type":"Secondary","description":[{"lang":"en","value":"CWE-770"}]}],"references":[{"url":"https:\/\/access.redhat.com\/security\/cve\/CVE-2024-4029","source":"secalert@redhat.com"},{"url":"https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=2278615","source":"secalert@redhat.com"}]}},{"cve":{"id":"CVE-2024-4405","sourceIdentifier":"zdi-disclosures@trendmicro.com","published":"2024-05-02T15:15:07.427","lastModified":"2024-05-02T15:15:07.427","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Xiaomi Pro 13 mimarket manual-upgrade Cross-Site Scripting Remote Code Execution Vulnerability. This vulnerability allows remote attackers to execute arbitrary code on affected installations of Xiaomi Pro 13 smartphones. User interaction is required to exploit this vulnerability in that the target must visit a malicious page or open a malicious file.\n\nThe specific flaw exists within the manual-upgrade.html file. When parsing the manualUpgradeInfo parameter, the process does not properly sanitize user-supplied data, which can lead to the injection of an arbitrary script. An attacker can leverage this vulnerability to execute code in the context of the current user. Was ZDI-CAN-22379."}],"metrics":{"cvssMetricV30":[{"source":"zdi-disclosures@trendmicro.com","type":"Secondary","cvssData":{"version":"3.0","vectorString":"CVSS:3.0\/AV:N\/AC:L\/PR:N\/UI:R\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":8.8,"baseSeverity":"HIGH"},"exploitabilityScore":2.8,"impactScore":5.9}]},"weaknesses":[{"source":"zdi-disclosures@trendmicro.com","type":"Secondary","description":[{"lang":"en","value":"CWE-79"}]}],"references":[{"url":"https:\/\/www.zerodayinitiative.com\/advisories\/ZDI-24-418\/","source":"zdi-disclosures@trendmicro.com"}]}},{"cve":{"id":"CVE-2024-4406","sourceIdentifier":"zdi-disclosures@trendmicro.com","published":"2024-05-02T15:15:07.670","lastModified":"2024-05-02T15:15:07.670","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Xiaomi Pro 13 GetApps integral-dialog-page Cross-Site Scripting Remote Code Execution Vulnerability. This vulnerability allows remote attackers to execute arbitrary code on affected installations of Xiaomi Pro 13 smartphones. User interaction is required to exploit this vulnerability in that the target must visit a malicious page or open a malicious file.\n\nThe specific flaw exists within the integral-dialog-page.html file. When parsing the integralInfo parameter, the process does not properly sanitize user-supplied data, which can lead to the injection of an arbitrary script. An attacker can leverage this vulnerability to execute code in the context of the current user. Was ZDI-CAN-22332."}],"metrics":{"cvssMetricV30":[{"source":"zdi-disclosures@trendmicro.com","type":"Secondary","cvssData":{"version":"3.0","vectorString":"CVSS:3.0\/AV:N\/AC:L\/PR:N\/UI:R\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":8.8,"baseSeverity":"HIGH"},"exploitabilityScore":2.8,"impactScore":5.9}]},"weaknesses":[{"source":"zdi-disclosures@trendmicro.com","type":"Secondary","description":[{"lang":"en","value":"CWE-79"}]}],"references":[{"url":"https:\/\/www.zerodayinitiative.com\/advisories\/ZDI-24-419\/","source":"zdi-disclosures@trendmicro.com"}]}}]}