{"resultsPerPage":568,"startIndex":0,"totalResults":568,"format":"NVD_CVE","version":"2.0","timestamp":"2024-05-22T12:19:44.437","vulnerabilities":[{"cve":{"id":"CVE-2023-37929","sourceIdentifier":"security@zyxel.com.tw","published":"2024-05-21T02:15:08.470","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The buffer overflow vulnerability in the CGI program of the VMG3625-T50B firmware version V5.50(ABPM.8)C0 could allow an authenticated remote attacker to cause denial of service (DoS) conditions by sending a crafted HTTP request to a vulnerable device."},{"lang":"es","value":"La vulnerabilidad de desbordamiento del búfer en el programa CGI de la versión de firmware VMG3625-T50B V5.50(ABPM.8)C0 podría permitir que un atacante remoto autenticado cause condiciones de denegación de servicio (DoS) enviando una solicitud HTTP manipulada a un dispositivo vulnerable."}],"metrics":{"cvssMetricV31":[{"source":"security@zyxel.com.tw","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:N\/I:N\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":6.5,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":3.6}]},"weaknesses":[{"source":"security@zyxel.com.tw","type":"Primary","description":[{"lang":"en","value":"CWE-120"}]}],"references":[{"url":"https:\/\/www.zyxel.com\/global\/en\/support\/security-advisories\/zyxel-security-advisory-for-buffer-overflow-vulnerabilities-in-some-5g-nr-4g-lte-cpe-dsl-ethernet-cpe-fiber-ont-wifi-extender-and-home-router-devices-05-21-2024","source":"security@zyxel.com.tw"}]}},{"cve":{"id":"CVE-2024-0816","sourceIdentifier":"security@zyxel.com.tw","published":"2024-05-21T02:15:08.743","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The buffer overflow vulnerability in the DX3300-T1 firmware version V5.50(ABVY.4)C0 could allow an authenticated local attacker to cause denial of service (DoS) conditions by executing the CLI command with crafted strings on an affected device."},{"lang":"es","value":" La vulnerabilidad de desbordamiento del búfer en la versión de firmware V5.50(ABVY.4)C0 del DX3300-T1 podría permitir que un atacante local autenticado provoque condiciones de denegación de servicio (DoS) ejecutando el comando CLI con cadenas manipuladas en un dispositivo afectado."}],"metrics":{"cvssMetricV31":[{"source":"security@zyxel.com.tw","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:L\/PR:L\/UI:N\/S:U\/C:N\/I:N\/A:H","attackVector":"LOCAL","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":5.5,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.8,"impactScore":3.6}]},"weaknesses":[{"source":"security@zyxel.com.tw","type":"Primary","description":[{"lang":"en","value":"CWE-120"}]}],"references":[{"url":"https:\/\/www.zyxel.com\/global\/en\/support\/security-advisories\/zyxel-security-advisory-for-buffer-overflow-vulnerabilities-in-some-5g-nr-4g-lte-cpe-dsl-ethernet-cpe-fiber-ont-wifi-extender-and-home-router-devices-05-21-2024","source":"security@zyxel.com.tw"}]}},{"cve":{"id":"CVE-2024-3155","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T03:15:08.323","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Post Grid, Form Maker, Popup Maker, WooCommerce Blocks, Post Blocks, Post Carousel – Combo Blocks plugin for WordPress is vulnerable to Stored Cross-Site Scripting via several parameters in all versions up to, and including, 2.2.80 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with contributor access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":" El complemento Post Grid, Form Maker, Popup Maker, WooCommerce Blocks, Post Blocks, Post Carousel – Combo Blocks para WordPress es vulnerable al Cross Site Scripting Almacenado a través de varios parámetros en todas las versiones hasta la 2.2.80 incluida debido a insuficiencia de sanitización y escape de salida. Esto hace posible que atacantes autenticados, con acceso de colaborador y superior, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset?sfp_email=&sfph_mail=&reponame=&new=3084503%40post-grid%2Ftrunk&old=3078364%40post-grid%2Ftrunk&sfp_email=&sfph_mail=","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/84bc611c-c38a-4282-9a9b-5bb9157fb1de?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4943","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T03:15:08.540","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Blocksy theme for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘has_field_link_rel’ parameter in all versions up to, and including, 2.0.46 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with Contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":" El tema Blocksy para WordPress es vulnerable a Cross Site Scripting Almacenado a través del parámetro 'has_field_link_rel' en todas las versiones hasta la 2.0.46 incluida debido a una sanitización de entrada y un escape de salida insuficientes. Esto hace posible que atacantes autenticados, con acceso de nivel de Colaborador y superior, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/themes.trac.wordpress.org\/changeset?sfp_email=&sfph_mail=&reponame=&new=227333%40blocksy%2F2.0.47&old=227242%40blocksy%2F2.0.46","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/dc7099d7-94fd-42be-a921-bfcad43ae252?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-2189","sourceIdentifier":"contact@wpscan.com","published":"2024-05-21T06:15:08.540","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Social Icons Widget & Block by WPZOOM WordPress plugin before 4.2.18 does not sanitise and escape some of its Widget settings, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup)"},{"lang":"es","value":" El complemento de WordPress Social Icons Widget &amp; Block de WPZOOM anterior a 4.2.18 no sanitiza ni escapa a algunas de las configuraciones de su widget, lo que podría permitir a usuarios con altos privilegios, como el administrador, realizar ataques de Cross Site Scripting Almacenado incluso cuando la capacidad unfiltered_html no está permitida ( por ejemplo en configuración multisitio)"}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/b8661fbe-78b9-4d29-90bf-5b68af468eb6\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-4061","sourceIdentifier":"contact@wpscan.com","published":"2024-05-21T06:15:09.247","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Survey Maker  WordPress plugin before 4.2.9 does not sanitise and escape some of its settings, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup)"},{"lang":"es","value":" El complemento Survey Maker de WordPress anterior a 4.2.9 no sanitiza ni escapa a algunas de sus configuraciones, lo que podría permitir a usuarios con privilegios elevados, como el administrador, realizar ataques de Cross Site Scripting Almacenado incluso cuando la capacidad unfiltered_html no está permitida (por ejemplo, en una configuración multisitio)."}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/175a9f3a-1f8d-44d1-8a12-e037251b025d\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-4289","sourceIdentifier":"contact@wpscan.com","published":"2024-05-21T06:15:09.517","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Sailthru Triggermail WordPress plugin through 1.1 does not sanitise and escape various parameters before outputting them back in pages and attributes, leading to a Reflected Cross-Site Scripting which could be used against high privilege users such as admin"},{"lang":"es","value":" El complemento de WordPress Sailthru Triggermail hasta la versión 1.1 no sanitiza ni escapa varios parámetros antes de devolverlos a páginas y atributos, lo que genera Cross Site Scripting Reflejado que podría usarse contra usuarios con altos privilegios, como administradores."}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/072785de-0ce5-42a4-a3fd-4eb1d1a2f1be\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-4290","sourceIdentifier":"contact@wpscan.com","published":"2024-05-21T06:15:09.767","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Sailthru Triggermail WordPress plugin through 1.1 does not sanitise and escape some of its settings, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup)"},{"lang":"es","value":" El complemento de WordPress Sailthru Triggermail  hasta la versión 1.1 no sanitiza ni escapa a algunas de sus configuraciones, lo que podría permitir a usuarios con privilegios elevados, como el administrador, realizar ataques de Cross Site Scripting Almacenado incluso cuando la capacidad unfiltered_html no está permitida (por ejemplo, en una configuración multisitio)."}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/a9a10d0f-d8f2-4f3e-92bf-94fc08416d87\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-4372","sourceIdentifier":"contact@wpscan.com","published":"2024-05-21T06:15:10.000","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Carousel Slider WordPress plugin before 2.2.11 does not sanitise and escape some parameters, which could allow users with a role as low as editor to perform Cross-Site Scripting attacks"},{"lang":"es","value":"El complemento Carousel Slider de WordPress anterior a 2.2.11 no sanitiza ni escapa a algunos parámetros, lo que podría permitir a los usuarios con un rol tan bajo como el de editor realizar ataques de Cross Site Scripting."}],"metrics":{},"references":[{"url":"https:\/\/wpscan.com\/vulnerability\/13dcfd8a-e378-44b4-af6f-940bc41539a4\/","source":"contact@wpscan.com"}]}},{"cve":{"id":"CVE-2024-4442","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T07:15:08.460","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Salon booking system plugin for WordPress is vulnerable to arbitrary file deletion in all versions up to, and including, 9.8. This is due to the plugin not properly validating the path of an uploaded file prior to deleting it. This makes it possible for unauthenticated attackers to delete arbitrary files, including the wp-config.php file, which can make site takeover and remote code execution possible."},{"lang":"es","value":" El complemento Salon booking system para WordPress es vulnerable a la eliminación arbitraria de archivos en todas las versiones hasta la 9.8 incluida. Esto se debe a que el complemento no valida correctamente la ruta de un archivo cargado antes de eliminarlo. Esto hace posible que atacantes no autenticados eliminen archivos arbitrarios, incluido el archivo wp-config.php, lo que puede hacer posible la toma de control del sitio y la ejecución remota de código."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.1,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.2}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/salon-booking-system\/tags\/9.8\/src\/SLN\/Action\/Ajax\/RemoveUploadedFile.php#L5","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088196\/salon-booking-system#file14","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/eaafeadd-f44c-49b1-b900-ef40800c629e?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4470","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T07:15:08.810","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Master Slider – Responsive Touch Slider plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'ms_slide_info' shortcode in all versions up to, and including, 3.9.9 due to insufficient input sanitization and output escaping on user supplied 'tag_name' attribute. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":" El complemento Master Slider – Responsive Touch Slider para WordPress es vulnerable a Cross Site Scripting Almacenado a través del código corto 'ms_slide_info' del complemento en todas las versiones hasta la 3.9.9 incluida debido a una sanitización de entrada insuficiente y a un escape de salida en el atributo 'tag_name' proporcionado por el usuario. Esto hace posible que atacantes autenticados, con acceso de nivel de colaborador y superior, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/master-slider\/tags\/3.9.9\/includes\/msp-shortcodes.php#L1078","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3084860\/#file2","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/cd59bee7-5de5-406d-8c1b-654306d68ab8?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4710","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T07:15:09.087","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The UberMenu plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's ubermenu-col, ubermenu_mobile_close_button, ubermenu_toggle, ubermenu-search shortcodes in all versions up to, and including, 3.8.2 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":"El complemento UberMenu para WordPress es vulnerable a Cross Site Scripting Almacenado a través de los códigos cortos ubermenu-col, ubermenu_mobile_close_button, ubermenu_toggle y ubermenu-search del complemento en todas las versiones hasta la 3.8.2 incluida debido a una sanitización de entrada insuficiente y a que la salida se escape al usuario. atributos proporcionados. Esto hace posible que atacantes autenticados, con acceso de nivel de colaborador y superior, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/codecanyon.net\/item\/ubermenu-wordpress-mega-menu-plugin\/154703","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/96161594-9513-49f7-91ab-9ad05b900a81?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-3345","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T09:15:08.533","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The ShopLentor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's woolentorsearch shortcode in all versions up to, and including, 2.8.8 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":" El complemento ShopLentor para WordPress es vulnerable a Cross Site Scripting Almacenado a través del código corto woolentorsearch del complemento en todas las versiones hasta la 2.8.8 incluida debido a una sanitización de entrada insuficiente y a un escape de salida en los atributos proporcionados por el usuario. Esto hace posible que atacantes autenticados, con acceso de nivel de colaborador y superior, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/woolentor-addons\/tags\/2.8.3\/includes\/modules\/ajax-search\/base.php#L137","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088881\/woolentor-addons\/trunk\/includes\/modules\/ajax-search\/base.php","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/d6a73a7f-53ac-4930-a1cd-c39818f64678?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4566","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T09:15:08.890","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The ShopLentor plugin for WordPress is vulnerable to unauthorized modification of data due to a missing capability check on the ajax_dismiss function in all versions up to, and including, 2.8.8. This makes it possible for authenticated attackers, with contributor-level access and above, to set arbitrary WordPress options to \"true\". NOTE: This vulnerability can be exploited by attackers with subscriber- or customer-level access and above if (1) the WooCommerce plugin is deactivated or (2) access to the default WordPress admin dashboard is explicitly enabled for authenticated users."},{"lang":"es","value":"El complemento ShopLentor para WordPress es vulnerable a modificaciones no autorizadas de datos debido a una falta de verificación de capacidad en la función ajax_dismiss en todas las versiones hasta la 2.8.8 incluida. Esto hace posible que atacantes autenticados, con acceso de nivel de colaborador y superior, establezcan opciones arbitrarias de WordPress en \"true\". NOTA: Esta vulnerabilidad puede ser aprovechada por atacantes con acceso a nivel de suscriptor o cliente y superior si (1) el complemento WooCommerce está desactivado o (2) el acceso al panel de administración predeterminado de WordPress está explícitamente habilitado para usuarios autenticados."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:N\/I:L\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"HIGH","baseScore":7.1,"baseSeverity":"HIGH"},"exploitabilityScore":2.8,"impactScore":4.2}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/woolentor-addons\/trunk\/includes\/admin\/include\/class.notice.php#L52","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088881\/woolentor-addons\/trunk\/includes\/admin\/include\/class.notice.php","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/c6aaabe9-4f55-4c01-b350-573e6a944353?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4875","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T09:15:09.103","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The HT Mega – Absolute Addons For Elementor plugin for WordPress is vulnerable to unauthorized modification of data|loss of data due to a missing capability check on the 'ajax_dismiss' function in versions up to, and including, 2.5.2. This makes it possible for authenticated attackers, with subscriber-level permissions and above, to update options such as users_can_register, which can lead to unauthorized user registration."},{"lang":"es","value":" El complemento HT Mega – Absolute Addons For Elementor para WordPress es vulnerable a la modificación no autorizada de datos (pérdida de datos) debido a una falta de verificación de capacidad en la función 'ajax_dismiss' en versiones hasta la 2.5.2 incluida. Esto hace posible que atacantes autenticados, con permisos de nivel de suscriptor y superiores, actualicen opciones como users_can_register, lo que puede conducir al registro de usuarios no autorizados."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:N\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":4.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":1.4}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/ht-mega-for-elementor\/trunk\/admin\/include\/class.dynamic-notice.php#L52","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088899\/ht-mega-for-elementor\/trunk\/admin\/include\/class.dynamic-notice.php","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/bdd3868a-d741-42b4-bc7f-6fb5d33bb71b?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2023-3938","sourceIdentifier":"vulnerability@kaspersky.com","published":"2024-05-21T10:15:08.730","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Improper Neutralization of Special Elements used in an SQL Command ('SQL\n Injection') vulnerability in ZkTeco-based OEM devices allows an \nattacker \n to authenticate under any user from the device database.\n\nThis issue affects \n\n\nZkTeco-based OEM devices (ZkTeco ProFace X, Smartec ST-FR043, Smartec \nST-FR041ME and possibly others) with the ZAM170-NF-1.8.25-7354-Ver1.0.0 \nand possibly others."},{"lang":"es","value":" La neutralización incorrecta de elementos especiales utilizados en una vulnerabilidad de comando SQL (\"inyección SQL\") en dispositivos OEM basados en ZkTeco permite a un atacante autenticarse con cualquier usuario de la base de datos del dispositivo. Este problema afecta a los dispositivos OEM basados en ZkTeco (ZkTeco ProFace X, Smartec ST-FR043, Smartec ST-FR041ME y posiblemente otros) con ZAM170-NF-1.8.25-7354-Ver1.0.0 y posiblemente otros."}],"metrics":{"cvssMetricV31":[{"source":"vulnerability@kaspersky.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:P\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:N\/A:N","attackVector":"PHYSICAL","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":4.6,"baseSeverity":"MEDIUM"},"exploitabilityScore":0.9,"impactScore":3.6}]},"weaknesses":[{"source":"vulnerability@kaspersky.com","type":"Secondary","description":[{"lang":"en","value":"CWE-89"}]}],"references":[{"url":"https:\/\/github.com\/klsecservices\/Advisories\/blob\/master\/K-ZkTeco-2023-001.md","source":"vulnerability@kaspersky.com"}]}},{"cve":{"id":"CVE-2023-3939","sourceIdentifier":"vulnerability@kaspersky.com","published":"2024-05-21T10:15:09.683","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Improper Neutralization of Special Elements used in an OS Command ('OS \nCommand Injection') vulnerability in ZkTeco-based OEM devices allows OS \nCommand Injection. \nSince all the found command implementations are executed from the \nsuperuser, their impact is the maximum possible.\nThis issue affects \nZkTeco-based OEM devices (ZkTeco ProFace X, Smartec ST-FR043, Smartec \nST-FR041ME and possibly others) with the ZAM170-NF-1.8.25-7354-Ver1.0.0 \nand possibly other."},{"lang":"es","value":"La neutralización incorrecta de elementos especiales utilizados en una vulnerabilidad de comando del sistema operativo ('inyección de comando del sistema operativo') en dispositivos OEM basados en ZkTeco permite la inyección de comando del sistema operativo. Dado que todas las implementaciones de comandos encontradas se ejecutan desde el superusuario, su impacto es el máximo posible. Este problema afecta a los dispositivos OEM basados en ZkTeco (ZkTeco ProFace X, Smartec ST-FR043, Smartec ST-FR041ME y posiblemente otros) con ZAM170-NF-1.8.25-7354-Ver1.0.0 y posiblemente otros."}],"metrics":{"cvssMetricV31":[{"source":"vulnerability@kaspersky.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:C\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":10.0,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":6.0}]},"weaknesses":[{"source":"vulnerability@kaspersky.com","type":"Secondary","description":[{"lang":"en","value":"CWE-78"}]}],"references":[{"url":"https:\/\/github.com\/klsecservices\/Advisories\/blob\/master\/K-ZkTeco-2023-002.md","source":"vulnerability@kaspersky.com"}]}},{"cve":{"id":"CVE-2024-4435","sourceIdentifier":"6b35d637-e00f-4228-858c-b20ad6e1d07b","published":"2024-05-21T10:15:10.393","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"When storing unbounded types in a BTreeMap, a node is represented as a linked list of \"memory chunks\". It was discovered recently that when we deallocate a node, in some cases only the first memory chunk is deallocated, and the rest of the memory chunks remain (incorrectly) allocated, causing a memory leak. In the worst case, depending on how a canister uses the BTreeMap, an adversary could interact with the canister through its API and trigger interactions with the map that keep consuming memory due to the memory leak. This could potentially lead to using an excessive amount of memory, or even running out of memory.\n\nThis issue has been fixed in  #212 https:\/\/github.com\/dfinity\/stable-structures\/pull\/212  by changing the logic for deallocating nodes to ensure that all of a node's memory chunks are deallocated and users are asked to upgrade to version 0.6.4.. Tests have been added to prevent regressions of this nature moving forward. Note: Users of stable-structure < 0.6.0 are not affected.\n\nUsers who are not storing unbounded types in BTreeMap are not affected and do not need to upgrade. Otherwise, an upgrade to version 0.6.4 is necessary."},{"lang":"es","value":"Al almacenar tipos ilimitados en un BTreeMap, un nodo se representa como una lista vinculada de \"fragmentos de memoria\". Recientemente se descubrió que cuando desasignamos un nodo, en algunos casos solo se desasigna el primer fragmento de memoria y el resto de los fragmentos de memoria permanecen (incorrectamente) asignados, lo que provoca una pérdida de memoria. En el peor de los casos, dependiendo de cómo un recipiente utilice BTreeMap, un adversario podría interactuar con el recipiente a través de su API y desencadenar interacciones con el mapa que sigan consumiendo memoria debido a la pérdida de memoria. Esto podría llevar potencialmente al uso de una cantidad excesiva de memoria o incluso a quedarse sin memoria. Este problema se solucionó en el n.º 212 https:\/\/github.com\/dfinity\/stable-structures\/pull\/212 cambiando la lógica para desasignar nodos para garantizar que todos los fragmentos de memoria de un nodo se desasignen y se solicite a los usuarios que actualicen a versión 0.6.4.. Se han agregado pruebas para evitar que avancen regresiones de esta naturaleza. Nota: Los usuarios de estructura estable &lt;0.6.0 no se ven afectados. Los usuarios que no almacenan tipos ilimitados en BTreeMap no se ven afectados y no necesitan actualizar. De lo contrario, es necesaria una actualización a la versión 0.6.4."}],"metrics":{"cvssMetricV31":[{"source":"6b35d637-e00f-4228-858c-b20ad6e1d07b","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:N\/UI:N\/S:U\/C:N\/I:N\/A:H","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"NONE","availabilityImpact":"HIGH","baseScore":5.9,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.2,"impactScore":3.6}]},"weaknesses":[{"source":"6b35d637-e00f-4228-858c-b20ad6e1d07b","type":"Secondary","description":[{"lang":"en","value":"CWE-401"}]}],"references":[{"url":"https:\/\/docs.rs\/ic-stable-structures\/0.6.4\/ic_stable_structures\/","source":"6b35d637-e00f-4228-858c-b20ad6e1d07b"},{"url":"https:\/\/github.com\/dfinity\/stable-structures\/pull\/212","source":"6b35d637-e00f-4228-858c-b20ad6e1d07b"},{"url":"https:\/\/internetcomputer.org\/docs\/current\/developer-docs\/smart-contracts\/maintain\/storage#stable-memory","source":"6b35d637-e00f-4228-858c-b20ad6e1d07b"}]}},{"cve":{"id":"CVE-2024-4553","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T10:15:10.623","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The WP Shortcodes Plugin — Shortcodes Ultimate plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'su_members' shortcode in all versions up to, and including, 7.1.5 due to insufficient input sanitization and output escaping on user supplied 'color' attribute. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":"El complemento WP Shortcodes Plugin — Shortcodes Ultimate para WordPress es vulnerable a Cross Site Scripting Almacenado a través del código abreviado 'su_members' del complemento en todas las versiones hasta la 7.1.5 incluida debido a una sanitización de entrada insuficiente y a que la salida se escapa en el atributo 'color' proporcionado por el usuario. Esto hace posible que atacantes autenticados, con acceso de nivel de colaborador y superior, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/shortcodes-ultimate\/tags\/7.1.4\/includes\/shortcodes\/members.php#L83","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3084162\/#file524","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/d8db8ed5-ebeb-4102-928f-fe417e429ad2?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4695","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T10:15:10.820","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Move Addons for Elementor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via multiple widgets in all versions up to, and including, 1.3.1 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":" El complemento Move Addons for Elementor para WordPress es vulnerable a Cross Site Scripting Almacenado a través de múltiples widgets en todas las versiones hasta la 1.3.1 incluida debido a una sanitización de entrada insuficiente y a un escape de salida en los atributos proporcionados por el usuario. Esto hace posible que atacantes autenticados, con acceso de nivel de colaborador y superior, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/move-addons\/trunk\/includes\/widgets\/data-table\/widget.php#L836","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/move-addons\/trunk\/includes\/widgets\/event-calendar\/widget.php#L932","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/move-addons\/trunk\/includes\/widgets\/mailchimp\/widget.php#L728","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/move-addons\/trunk\/includes\/widgets\/shop-product-grid\/widget.php#L1203","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/move-addons\/trunk\/includes\/widgets\/team-member\/widget.php#L1464","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/move-addons\/trunk\/includes\/widgets\/user-login\/widget.php#L1146","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088859\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/72662a59-f41c-4df7-aa04-7243ff43c48d?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4700","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T10:15:11.023","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The WP Table Builder – WordPress Table Plugin plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the button element in all versions up to, and including, 1.4.14 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page. By default, this can only be exploited by administrators, but the ability to use and configure WP Table Builder can be extended to contributors."},{"lang":"es","value":"El complemento WP Table Builder – WordPress Table Plugin para WordPress es vulnerable a Cross Site Scripting Almacenado a través del elemento de botón en todas las versiones hasta la 1.4.14 incluida debido a una sanitización de entrada y un escape de salida insuficientes. Esto hace posible que atacantes autenticados inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada. De forma predeterminada, esto solo puede ser aprovechado por los administradores, pero la capacidad de usar y configurar WP Table Builder se puede extender a los contribuyentes."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/wp-table-builder\/trunk\/inc\/admin\/element-classes\/elements\/button-element.php#L343","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088612\/","source":"security@wordfence.com"},{"url":"https:\/\/wordpress.org\/plugins\/wp-table-builder\/#developers","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/20cd08ac-826f-40dd-804a-546b0c334b66?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4988","sourceIdentifier":"907edf6c-bf03-423e-ab1a-8da27e1aa1ea","published":"2024-05-21T10:15:11.240","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The mobile application (com.transsion.videocallenhancer) interface has improper permission control, which can lead to the risk of private file leakage."},{"lang":"es","value":" La interfaz de la aplicación móvil (com.transsion.videocallenhancer) tiene un control de permisos inadecuado, lo que puede generar riesgo de filtración de archivos privados."}],"metrics":{},"references":[{"url":"https:\/\/security.tecno.com\/SRC\/blogdetail\/250?lang=en_US","source":"907edf6c-bf03-423e-ab1a-8da27e1aa1ea"},{"url":"https:\/\/security.tecno.com\/SRC\/securityUpdates","source":"907edf6c-bf03-423e-ab1a-8da27e1aa1ea"}]}},{"cve":{"id":"CVE-2023-3940","sourceIdentifier":"vulnerability@kaspersky.com","published":"2024-05-21T11:15:08.780","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Relative Path Traversal vulnerability in ZkTeco-based OEM devices allows an attacker \nto access any file on the system.\n\n\nThis issue affects \nZkTeco-based OEM devices (ZkTeco ProFace X, Smartec ST-FR043, Smartec \nST-FR041ME and possibly others) with the ZAM170-NF-1.8.25-7354-Ver1.0.0 \nand possibly others."},{"lang":"es","value":" La vulnerabilidad de path traversal relativo en dispositivos OEM basados en ZkTeco permite a un atacante acceder a cualquier archivo del sistema. Este problema afecta a los dispositivos OEM basados en ZkTeco (ZkTeco ProFace X, Smartec ST-FR043, Smartec ST-FR041ME y posiblemente otros) con ZAM170-NF-1.8.25-7354-Ver1.0.0 y posiblemente otros."}],"metrics":{"cvssMetricV31":[{"source":"vulnerability@kaspersky.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":3.6}]},"weaknesses":[{"source":"vulnerability@kaspersky.com","type":"Secondary","description":[{"lang":"en","value":"CWE-23"}]}],"references":[{"url":"https:\/\/github.com\/klsecservices\/Advisories\/blob\/master\/K-ZkTeco-2023-003.md","source":"vulnerability@kaspersky.com"}]}},{"cve":{"id":"CVE-2023-3941","sourceIdentifier":"vulnerability@kaspersky.com","published":"2024-05-21T11:15:09.000","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Relative Path Traversal vulnerability in ZkTeco-based OEM devices allows an attacker \n\nto write any file on the system with root privileges.\n\n\nThis issue affects \nZkTeco-based OEM devices (ZkTeco ProFace X, Smartec ST-FR043, Smartec \nST-FR041ME and possibly others) with the ZAM170-NF-1.8.25-7354-Ver1.0.0 \nand possibly others."},{"lang":"es","value":"La vulnerabilidad de path traversal relativo en dispositivos OEM basados en ZkTeco permite a un atacante escribir cualquier archivo en el sistema con privilegios de root. Este problema afecta a los dispositivos OEM basados en ZkTeco (ZkTeco ProFace X, Smartec ST-FR043, Smartec ST-FR041ME y posiblemente otros) con ZAM170-NF-1.8.25-7354-Ver1.0.0 y posiblemente otros."}],"metrics":{"cvssMetricV31":[{"source":"vulnerability@kaspersky.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:C\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":10.0,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":6.0}]},"weaknesses":[{"source":"vulnerability@kaspersky.com","type":"Secondary","description":[{"lang":"en","value":"CWE-23"}]}],"references":[{"url":"https:\/\/github.com\/klsecservices\/Advisories\/blob\/master\/K-ZkTeco-2023-003.md","source":"vulnerability@kaspersky.com"}]}},{"cve":{"id":"CVE-2024-4361","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T11:15:09.210","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Page Builder by SiteOrigin plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'siteorigin_widget' shortcode in all versions up to, and including, 2.29.15 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":" El complemento Page Builder de SiteOrigin para WordPress es vulnerable a Cross Site Scripting Almacenado a través del código corto 'siteorigin_widget' del complemento en todas las versiones hasta la 2.29.15 incluida debido a una sanitización de entrada insuficiente y a un escape de salida en los atributos proporcionados por el usuario. Esto hace posible que atacantes autenticados, con acceso de nivel de colaborador y superior, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/siteorigin-panels\/trunk\/inc\/widget-shortcode.php#L40","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3086025\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/a97f72f6-86f7-45dc-908a-292ba735071d?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4619","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T11:15:09.397","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The Elementor Website Builder – More than Just a Page Builder plugin for WordPress is vulnerable to DOM-Based Stored Cross-Site Scripting via the ‘hover_animation’ parameter in versions up to, and including, 3.21.4 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with contributor-level permissions and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":"El complemento Elementor Website Builder – More than Just a Page Builder para WordPress es vulnerable a Cross Site Scripting Almacenado basado en DOM a través del parámetro 'hover_animation' en versiones hasta la 3.21.4 incluida debido a una limpieza de entrada insuficiente y un escape de salida . Esto hace posible que atacantes autenticados, con permisos de nivel de colaborador y superiores, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/elementor\/trunk\/includes\/widgets\/image-box.php#L696","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3089420","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/c7e1028e-e04b-46c4-b574-889d9fc1069d?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4876","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T11:15:09.587","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The HT Mega – Absolute Addons For Elementor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘popover_header_text’ parameter in versions up to, and including, 2.5.2 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with contributor-level permissions and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":"El complemento HT Mega – Absolute Addons For Elementor para WordPress es vulnerable a Cross Site Scripting Almacenado a través del parámetro 'popover_header_text' en versiones hasta la 2.5.2 incluida debido a una sanitización de entrada y un escape de salida insuficientes. Esto hace posible que atacantes autenticados, con permisos de nivel de colaborador y superiores, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/ht-mega-for-elementor\/tags\/2.5.0\/includes\/widgets\/htmega_popover.php#L891","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088899\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/39e104fa-591a-41e8-af7e-f8b32a199170?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-3268","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T12:15:08.397","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The YouTube Video Gallery by YouTube Showcase – Video Gallery Plugin for WordPress plugin for WordPress is vulnerable to unauthorized modification of data due to a missing capability check on the emd_form_builder_lite_submit_form function in all versions up to, and including, 3.3.6. This makes it possible for unauthenticated attackers to create arbitrary posts or pages."},{"lang":"es","value":"The YouTube Video Gallery by YouTube Showcase – Video Gallery complemento para WordPress es vulnerable a modificaciones no autorizadas de datos debido a una falta de verificación de capacidad en la función emd_form_builder_lite_submit_form en todas las versiones hasta la 3.3.6 incluida. Esto hace posible que atacantes no autenticados creen publicaciones o páginas arbitrarias."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":1.4}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088363\/youtube-showcase","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/0e9d5382-d37d-4a40-8f22-e32b8ee98859?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4420","sourceIdentifier":"cve-coordination@google.com","published":"2024-05-21T12:15:08.627","lastModified":"2024-05-21T12:37:59.687","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"There exists a Denial of service vulnerability in Tink-cc in versions prior to 2.1.3.   *  An adversary can crash binaries using the crypto::tink::JsonKeysetReader in tink-cc by providing an input that is not an encoded JSON object, but still a valid encoded JSON element, for example a number or an array. This will crash as Tink just assumes any valid JSON input will contain an object.\n\n\n  *  An adversary can crash binaries using the crypto::tink::JsonKeysetReader in tink-cc by providing an input containing many nested JSON objects. This may result in a stack overflow.\n\n\nWe recommend upgrading to version 2.1.3 or above"},{"lang":"es","value":" Existe una vulnerabilidad de denegación de servicio en Tink-cc en versiones anteriores a la 2.1.3. * Un adversario puede bloquear archivos binarios usando crypto::tink::JsonKeysetReader en tink-cc al proporcionar una entrada que no es un objeto JSON codificado, pero que sigue siendo un elemento JSON codificado válido, por ejemplo, un número o una matriz. Esto fallará ya que Tink simplemente asume que cualquier entrada JSON válida contendrá un objeto. * Un adversario puede bloquear archivos binarios usando crypto::tink::JsonKeysetReader en tink-cc al proporcionar una entrada que contiene muchos objetos JSON anidados. Esto puede provocar un desbordamiento de la pila. Recomendamos actualizar a la versión 2.1.3 o superior."}],"metrics":{},"weaknesses":[{"source":"cve-coordination@google.com","type":"Secondary","description":[{"lang":"en","value":"CWE-116"}]}],"references":[{"url":"https:\/\/github.com\/tink-crypto\/tink-cc\/issues\/4","source":"cve-coordination@google.com"}]}},{"cve":{"id":"CVE-2023-3942","sourceIdentifier":"vulnerability@kaspersky.com","published":"2024-05-21T13:15:08.580","lastModified":"2024-05-21T16:54:35.880","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An 'SQL Injection' vulnerability, due to improper neutralization of special elements used in SQL commands, exists in ZKTeco-based OEM devices. This vulnerability allows an attacker to, in some cases, impersonate another user or perform unauthorized actions. In other instances, it enables the attacker to access user data and system parameters from the database.\nThis issue affects \nZkTeco-based OEM devices (ZkTeco ProFace X, Smartec ST-FR043, Smartec ST-FR041ME and possibly others)\n\n with firmware \nZAM170-NF-1.8.25-7354-Ver1.0.0 and possibly other, Standalone service v. 2.1.6-20200907 and possibly others."}],"metrics":{"cvssMetricV31":[{"source":"vulnerability@kaspersky.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":3.6}]},"weaknesses":[{"source":"vulnerability@kaspersky.com","type":"Secondary","description":[{"lang":"en","value":"CWE-89"}]}],"references":[{"url":"https:\/\/github.com\/klsecservices\/Advisories\/blob\/master\/K-ZkTeco-2023-005.md","source":"vulnerability@kaspersky.com"}]}},{"cve":{"id":"CVE-2024-35180","sourceIdentifier":"security-advisories@github.com","published":"2024-05-21T13:15:08.813","lastModified":"2024-05-21T16:54:35.880","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"OMERO.web provides a web based client and plugin infrastructure. There is currently no escaping or validation of the `callback` parameter that can be passed to various OMERO.web endpoints that have JSONP enabled. This vulnerability has been patched in version 5.26.0.\n"}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.1,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":2.7}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-830"}]}],"references":[{"url":"https:\/\/github.com\/ome\/omero-web\/commit\/d41207cbb82afc56ea79e84db532608aa24ab4aa","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/ome\/omero-web\/security\/advisories\/GHSA-vr85-5pwx-c6gq","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-35361","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T13:15:09.057","lastModified":"2024-05-21T16:54:35.880","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"MTab Bookmark v1.9.5 has an SQL injection vulnerability in \/LinkStore\/getIcon. An attacker can execute arbitrary SQL statements through this vulnerability without requiring any user rights."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/Hebing123\/cve\/issues\/37","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2023-3943","sourceIdentifier":"vulnerability@kaspersky.com","published":"2024-05-21T14:15:11.557","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Stack-based Buffer Overflow vulnerability in ZkTeco-based OEM devices allows, in some cases, the execution of arbitrary code. Due to the lack of protection mechanisms such as stack canaries and PIE, it is possible to successfully execute code even under restrictive conditions.\n\nThis issue affects \nZkTeco-based OEM devices (ZkTeco ProFace X, Smartec ST-FR043, Smartec ST-FR041ME and possibly others)\n\n with firmware \nZAM170-NF-1.8.25-7354-Ver1.0.0 and possibly others."},{"lang":"es","value":" La vulnerabilidad de desbordamiento del búfer basado en pila en dispositivos OEM basados en ZkTeco permite, en algunos casos, la ejecución de código arbitrario. Debido a la falta de mecanismos de protección como stack canaries y PIE, es posible ejecutar código con éxito incluso en condiciones restrictivas. Este problema afecta a dispositivos OEM basados en ZkTeco (ZkTeco ProFace X, Smartec ST-FR043, Smartec ST-FR041ME y posiblemente otros) con firmware ZAM170-NF-1.8.25-7354-Ver1.0.0 y posiblemente otros."}],"metrics":{"cvssMetricV31":[{"source":"vulnerability@kaspersky.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:C\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":10.0,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":6.0}]},"weaknesses":[{"source":"vulnerability@kaspersky.com","type":"Secondary","description":[{"lang":"en","value":"CWE-121"}]}],"references":[{"url":"https:\/\/github.com\/klsecservices\/Advisories\/blob\/master\/K-ZkTeco-2023-006.md","source":"vulnerability@kaspersky.com"}]}},{"cve":{"id":"CVE-2024-34071","sourceIdentifier":"security-advisories@github.com","published":"2024-05-21T14:15:11.783","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Umbraco is an ASP.NET CMS used by more than 730.000 websites. Umbraco has an endpoint that is vulnerable to open redirects. The endpoint is protected so it requires the user to be signed into backoffice before the vulnerable is exposed. This vulnerability has been patched in version(s) 8.18.14, 10.8.6, 12.3.10 and 13.3.1."},{"lang":"es","value":"Umbraco es un CMS ASP.NET utilizado por más de 730.000 sitios web. Umbraco tiene un endpoint que es vulnerable a redireccionamientos abiertos. El endpoint está protegido, por lo que requiere que el usuario inicie sesión en el backoffice antes de que la vulnerabilidad quede expuesta. Esta vulnerabilidad ha sido parcheada en las versiones 8.18.14, 10.8.6, 12.3.10 y 13.3.1."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.1,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":2.7}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-601"}]}],"references":[{"url":"https:\/\/github.com\/umbraco\/Umbraco-CMS\/commit\/5f24de308584b9771240a6db1a34630a5114c450","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/umbraco\/Umbraco-CMS\/commit\/c17d4e1a600098ec524e4126f4395255476bc33f","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/umbraco\/Umbraco-CMS\/commit\/c8f71af646171074c13e5c34f74312def4512031","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/umbraco\/Umbraco-CMS\/commit\/d8df405db4ea884bb4b96f088d10d9a2070cf024","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/umbraco\/Umbraco-CMS\/security\/advisories\/GHSA-j74q-mv2c-rxmp","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-35218","sourceIdentifier":"security-advisories@github.com","published":"2024-05-21T14:15:12.003","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Umbraco CMS is an ASP.NET CMS used by more than 730.000 websites. Stored Cross-site scripting (XSS) enable attackers that have access to backoffice to bring malicious content into a website or application. This vulnerability has been patched in version(s) 8.18.13, 10.8.4, 12.3.7, 13.1.1 by implementing IHtmlSanitizer.\n\n\n\n\n"},{"lang":"es","value":" Umbraco CMS es un CMS ASP.NET utilizado por más de 730.000 sitios web. El Cross Site Scripting (XSS) Almacenado permite a los atacantes que tienen acceso al backoffice introducir contenido malicioso en un sitio web o aplicación. Esta vulnerabilidad se ha solucionado en las versiones 8.18.13, 10.8.4, 12.3.7, 13.1.1 mediante la implementación de IHtmlSanitizer."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:H\/UI:R\/S:U\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"HIGH","userInteraction":"REQUIRED","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":4.2,"baseSeverity":"MEDIUM"},"exploitabilityScore":0.5,"impactScore":3.6}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-79"}]}],"references":[{"url":"https:\/\/github.com\/umbraco\/Umbraco-CMS\/commit\/1b712fe6ec52aa4e71b3acf63e393c8e6ab85385","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/umbraco\/Umbraco-CMS\/commit\/a2684069b1e9976444f60b4b37a80be05b87f6b6","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/umbraco\/Umbraco-CMS\/commit\/cbf9f9bcd199d7ca0412be3071d275556f10b7ba","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/umbraco\/Umbraco-CMS\/commit\/d090176272d07500dac0daee7c598aa8bb321050","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/umbraco\/Umbraco-CMS\/security\/advisories\/GHSA-gvpc-3pj6-4m9w","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-35384","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T14:15:12.217","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in Cesanta mjs 2.20.0 allows a remote attacker to cause a denial of service via the mjs_array_length function in the mjs.c file."},{"lang":"es","value":" Un problema en Cesanta mjs 2.20.0 permite a un atacante remoto provocar una denegación de servicio a través de la función mjs_array_length en el archivo mjs.c."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/cesanta\/mjs\/issues\/287","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-35385","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T14:15:12.307","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in Cesanta mjs 2.20.0 allows a remote attacker to cause a denial of service via the mjs_mk_ffi_sig function in the mjs.c file."},{"lang":"es","value":" Un problema en Cesanta mjs 2.20.0 permite a un atacante remoto provocar una denegación de servicio a través de la función mjs_mk_ffi_sig en el archivo mjs.c."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/cesanta\/mjs\/issues\/288","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-35386","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T14:15:12.400","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue in Cesanta mjs 2.20.0 allows a remote attacker to cause a denial of service via the mjs_do_gc function in the mjs.c file."},{"lang":"es","value":" Un problema en Cesanta mjs 2.20.0 permite que un atacante remoto provoque una denegación de servicio a través de la función mjs_do_gc en el archivo mjs.c."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/cesanta\/mjs\/issues\/286","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-4452","sourceIdentifier":"security@wordfence.com","published":"2024-05-21T14:15:12.563","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"The ElementsKit Pro plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘url’ parameter in versions up to, and including, 3.6.1 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with contributor-level permissions and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."},{"lang":"es","value":" El complemento ElementsKit Pro para WordPress es vulnerable a Cross Site Scripting Almacenado a través del parámetro 'url' en versiones hasta la 3.6.1 incluida debido a una sanitización de entrada y un escape de salida insuficientes. Esto hace posible que atacantes autenticados, con permisos de nivel de colaborador y superiores, inyecten scripts web arbitrarios en páginas que se ejecutarán cada vez que un usuario acceda a una página inyectada."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/wpmet.com\/plugin\/elementskit\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/488ac848-786e-4100-a387-5a40e8fc4175?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2020-36788","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:11.187","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/nouveau: avoid a use-after-free when BO init fails\n\nnouveau_bo_init() is backed by ttm_bo_init() and ferries its return code\nback to the caller. On failures, ttm_bo_init() invokes the provided\ndestructor which should de-initialize and free the memory.\n\nThus, when nouveau_bo_init() returns an error the gem object has already\nbeen released and the memory freed by nouveau_bo_del_ttm()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/548f2ff8ea5e0ce767ae3418d1ec5308990be87d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bcf34aa5082ee2343574bc3f4d1c126030913e54","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f86e19d918a85492ad1a01fcdc0ad5ecbdac6f96","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47220","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:11.290","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3: core: fix kernel panic when do reboot\n\nWhen do system reboot, it calls dwc3_shutdown and the whole debugfs\nfor dwc3 has removed first, when the gadget tries to do deinit, and\nremove debugfs for its endpoints, it meets NULL pointer dereference\nissue when call debugfs_lookup. Fix it by removing the whole dwc3\ndebugfs later than dwc3_drd_exit.\n\n[ 2924.958838] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000002\n....\n[ 2925.030994] pstate: 60000005 (nZCv daif -PAN -UAO -TCO BTYPE=--)\n[ 2925.037005] pc : inode_permission+0x2c\/0x198\n[ 2925.041281] lr : lookup_one_len_common+0xb0\/0xf8\n[ 2925.045903] sp : ffff80001276ba70\n[ 2925.049218] x29: ffff80001276ba70 x28: ffff0000c01f0000 x27: 0000000000000000\n[ 2925.056364] x26: ffff800011791e70 x25: 0000000000000008 x24: dead000000000100\n[ 2925.063510] x23: dead000000000122 x22: 0000000000000000 x21: 0000000000000001\n[ 2925.070652] x20: ffff8000122c6188 x19: 0000000000000000 x18: 0000000000000000\n[ 2925.077797] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000004\n[ 2925.084943] x14: ffffffffffffffff x13: 0000000000000000 x12: 0000000000000030\n[ 2925.092087] x11: 0101010101010101 x10: 7f7f7f7f7f7f7f7f x9 : ffff8000102b2420\n[ 2925.099232] x8 : 7f7f7f7f7f7f7f7f x7 : feff73746e2f6f64 x6 : 0000000000008080\n[ 2925.106378] x5 : 61c8864680b583eb x4 : 209e6ec2d263dbb7 x3 : 000074756f307065\n[ 2925.113523] x2 : 0000000000000001 x1 : 0000000000000000 x0 : ffff8000122c6188\n[ 2925.120671] Call trace:\n[ 2925.123119]  inode_permission+0x2c\/0x198\n[ 2925.127042]  lookup_one_len_common+0xb0\/0xf8\n[ 2925.131315]  lookup_one_len_unlocked+0x34\/0xb0\n[ 2925.135764]  lookup_positive_unlocked+0x14\/0x50\n[ 2925.140296]  debugfs_lookup+0x68\/0xa0\n[ 2925.143964]  dwc3_gadget_free_endpoints+0x84\/0xb0\n[ 2925.148675]  dwc3_gadget_exit+0x28\/0x78\n[ 2925.152518]  dwc3_drd_exit+0x100\/0x1f8\n[ 2925.156267]  dwc3_remove+0x11c\/0x120\n[ 2925.159851]  dwc3_shutdown+0x14\/0x20\n[ 2925.163432]  platform_shutdown+0x28\/0x38\n[ 2925.167360]  device_shutdown+0x15c\/0x378\n[ 2925.171291]  kernel_restart_prepare+0x3c\/0x48\n[ 2925.175650]  kernel_restart+0x1c\/0x68\n[ 2925.179316]  __do_sys_reboot+0x218\/0x240\n[ 2925.183247]  __arm64_sys_reboot+0x28\/0x30\n[ 2925.187262]  invoke_syscall+0x48\/0x100\n[ 2925.191017]  el0_svc_common.constprop.0+0x48\/0xc8\n[ 2925.195726]  do_el0_svc+0x28\/0x88\n[ 2925.199045]  el0_svc+0x20\/0x30\n[ 2925.202104]  el0_sync_handler+0xa8\/0xb0\n[ 2925.205942]  el0_sync+0x148\/0x180\n[ 2925.209270] Code: a9025bf5 2a0203f5 121f0056 370802b5 (79400660)\n[ 2925.215372] ---[ end trace 124254d8e485a58b ]---\n[ 2925.220012] Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b\n[ 2925.227676] Kernel Offset: disabled\n[ 2925.231164] CPU features: 0x00001001,20000846\n[ 2925.235521] Memory Limit: none\n[ 2925.238580] ---[ end Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b ]---\n\n(cherry picked from commit 2a042767814bd0edf2619f06fecd374e266ea068)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/174c27583b3807ac96228c442735b02622d8d1c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4bf584a03eec674975ee9fe36c8583d9d470dab1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/58b5e02c6ca0e2b7c87cd8023ff786ef3c0eef74","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7f9745ab342bcce5efd5d4d2297d0a3dd9db0eac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fa8c413e6b74ae5d12daf911c73238c5bdacd8e6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fd7c4bd582494934be15d41aebe0dbe23790605f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ff4c63f3e8cb7af2ce51cc56b031e08fd23c758b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47221","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:11.380","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmm\/slub: actually fix freelist pointer vs redzoning\n\nIt turns out that SLUB redzoning (\"slub_debug=Z\") checks from\ns->object_size rather than from s->inuse (which is normally bumped to\nmake room for the freelist pointer), so a cache created with an object\nsize less than 24 would have the freelist pointer written beyond\ns->object_size, causing the redzone to be corrupted by the freelist\npointer.  This was very visible with \"slub_debug=ZF\":\n\n  BUG test (Tainted: G    B            ): Right Redzone overwritten\n  -----------------------------------------------------------------------------\n\n  INFO: 0xffff957ead1c05de-0xffff957ead1c05df @offset=1502. First byte 0x1a instead of 0xbb\n  INFO: Slab 0xffffef3950b47000 objects=170 used=170 fp=0x0000000000000000 flags=0x8000000000000200\n  INFO: Object 0xffff957ead1c05d8 @offset=1496 fp=0xffff957ead1c0620\n\n  Redzone  (____ptrval____): bb bb bb bb bb bb bb bb               ........\n  Object   (____ptrval____): 00 00 00 00 00 f6 f4 a5               ........\n  Redzone  (____ptrval____): 40 1d e8 1a aa                        @....\n  Padding  (____ptrval____): 00 00 00 00 00 00 00 00               ........\n\nAdjust the offset to stay within s->object_size.\n\n(Note that no caches of in this size range are known to exist in the\nkernel currently.)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/ce6e8bee7a3883e8008b30f5887dbb426aac6a35","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e41a49fadbc80b60b48d3c095d9e2ee7ef7c9a8e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f6ed2357541612a13a5841b3af4dc32ed984a25f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47222","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:11.453","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: fix vlan tunnel dst refcnt when egressing\n\nThe egress tunnel code uses dst_clone() and directly sets the result\nwhich is wrong because the entry might have 0 refcnt or be already deleted,\ncausing number of problems. It also triggers the WARN_ON() in dst_hold()[1]\nwhen a refcnt couldn't be taken. Fix it by using dst_hold_safe() and\nchecking if a reference was actually taken before setting the dst.\n\n[1] dmesg WARN_ON log and following refcnt errors\n WARNING: CPU: 5 PID: 38 at include\/net\/dst.h:230 br_handle_egress_vlan_tunnel+0x10b\/0x134 [bridge]\n Modules linked in: 8021q garp mrp bridge stp llc bonding ipv6 virtio_net\n CPU: 5 PID: 38 Comm: ksoftirqd\/5 Kdump: loaded Tainted: G        W         5.13.0-rc3+ #360\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-1.fc33 04\/01\/2014\n RIP: 0010:br_handle_egress_vlan_tunnel+0x10b\/0x134 [bridge]\n Code: e8 85 bc 01 e1 45 84 f6 74 90 45 31 f6 85 db 48 c7 c7 a0 02 19 a0 41 0f 94 c6 31 c9 31 d2 44 89 f6 e8 64 bc 01 e1 85 db 75 02 <0f> 0b 31 c9 31 d2 44 89 f6 48 c7 c7 70 02 19 a0 e8 4b bc 01 e1 49\n RSP: 0018:ffff8881003d39e8 EFLAGS: 00010246\n RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffffffffa01902a0\n RBP: ffff8881040c6700 R08: 0000000000000000 R09: 0000000000000001\n R10: 2ce93d0054fe0d00 R11: 54fe0d00000e0000 R12: ffff888109515000\n R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000401\n FS:  0000000000000000(0000) GS:ffff88822bf40000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007f42ba70f030 CR3: 0000000109926000 CR4: 00000000000006e0\n Call Trace:\n  br_handle_vlan+0xbc\/0xca [bridge]\n  __br_forward+0x23\/0x164 [bridge]\n  deliver_clone+0x41\/0x48 [bridge]\n  br_handle_frame_finish+0x36f\/0x3aa [bridge]\n  ? skb_dst+0x2e\/0x38 [bridge]\n  ? br_handle_ingress_vlan_tunnel+0x3e\/0x1c8 [bridge]\n  ? br_handle_frame_finish+0x3aa\/0x3aa [bridge]\n  br_handle_frame+0x2c3\/0x377 [bridge]\n  ? __skb_pull+0x33\/0x51\n  ? vlan_do_receive+0x4f\/0x36a\n  ? br_handle_frame_finish+0x3aa\/0x3aa [bridge]\n  __netif_receive_skb_core+0x539\/0x7c6\n  ? __list_del_entry_valid+0x16e\/0x1c2\n  __netif_receive_skb_list_core+0x6d\/0xd6\n  netif_receive_skb_list_internal+0x1d9\/0x1fa\n  gro_normal_list+0x22\/0x3e\n  dev_gro_receive+0x55b\/0x600\n  ? detach_buf_split+0x58\/0x140\n  napi_gro_receive+0x94\/0x12e\n  virtnet_poll+0x15d\/0x315 [virtio_net]\n  __napi_poll+0x2c\/0x1c9\n  net_rx_action+0xe6\/0x1fb\n  __do_softirq+0x115\/0x2d8\n  run_ksoftirqd+0x18\/0x20\n  smpboot_thread_fn+0x183\/0x19c\n  ? smpboot_unregister_percpu_thread+0x66\/0x66\n  kthread+0x10a\/0x10f\n  ? kthread_mod_delayed_work+0xb6\/0xb6\n  ret_from_fork+0x22\/0x30\n ---[ end trace 49f61b07f775fd2b ]---\n dst_release: dst:00000000c02d677a refcnt:-1\n dst_release underflow"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/25053a8404ba17ca48f5553d487afc1882e9f56c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/42020f7f37a90d24b9551f5f7eba3f7c7c102968","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/79855be6445b6592bddb7bd7167083ec8cdbd73f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/84fc1c944e45ab317e2e70a0e7f76fa2a5e43b6e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cfc579f9d89af4ada58c69b03bcaa4887840f3b3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fc7fdd8c5c2ad2fe3e297698be9d4dbe4a4e0579","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47223","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:11.530","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: fix vlan tunnel dst null pointer dereference\n\nThis patch fixes a tunnel_dst null pointer dereference due to lockless\naccess in the tunnel egress path. When deleting a vlan tunnel the\ntunnel_dst pointer is set to NULL without waiting a grace period (i.e.\nwhile it's still usable) and packets egressing are dereferencing it\nwithout checking. Use READ\/WRITE_ONCE to annotate the lockless use of\ntunnel_id, use RCU for accessing tunnel_dst and make sure it is read\nonly once and checked in the egress path. The dst is already properly RCU\nprotected so we don't need to do anything fancy than to make sure\ntunnel_id and tunnel_dst are read only once and checked in the egress path."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/24a6e55f17aa123bc1fc54b7d3c410b41bc16530","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/58e2071742e38f29f051b709a5cca014ba51166f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a2241e62f6b4a774d8a92048fdf59c45f6c2fe5c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/abb02e05cb1c0a30dd873a29f33bc092067dc35d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad7feefe7164892db424c45687472db803d87f79","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fe0448a3fad365a747283a00a1d1ad5e8d6675b7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47224","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:11.687","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ll_temac: Make sure to free skb when it is completely used\n\nWith the skb pointer piggy-backed on the TX BD, we have a simple and\nefficient way to free the skb buffer when the frame has been transmitted.\nBut in order to avoid freeing the skb while there are still fragments from\nthe skb in use, we need to piggy-back on the TX BD of the skb, not the\nfirst.\n\nWithout this, we are doing use-after-free on the DMA side, when the first\nBD of a multi TX BD packet is seen as completed in xmit_done, and the\nremaining BDs are still being processed."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/019ab7d044d0ebf97e1236bb8935b7809be92358","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6aa32217a9a446275440ee8724b1ecaf1838df47","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6d120ab4dc39a543c6b63361e1d0541c382900a3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e8afe05bd359ebe12a61dbdc94c06c00ea3e8d4b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47225","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:11.760","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: fix deadlock in AP\/VLAN handling\n\nSyzbot reports that when you have AP_VLAN interfaces that are up\nand close the AP interface they belong to, we get a deadlock. No\nsurprise - since we dev_close() them with the wiphy mutex held,\nwhich goes back into the netdev notifier in cfg80211 and tries to\nacquire the wiphy mutex there.\n\nTo fix this, we need to do two things:\n 1) prevent changing iftype while AP_VLANs are up, we can't\n    easily fix this case since cfg80211 already calls us with\n    the wiphy mutex held, but change_interface() is relatively\n    rare in drivers anyway, so changing iftype isn't used much\n    (and userspace has to fall back to down\/change\/up anyway)\n 2) pull the dev_close() loop over VLANs out of the wiphy mutex\n    section in the normal stop case"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/8043903fcb72f545c52e3ec74d6fd82ef79ce7c5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d5befb224edbe53056c2c18999d630dafb4a08b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47226","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:11.823","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nx86\/fpu: Invalidate FPU state after a failed XRSTOR from a user buffer\n\nBoth Intel and AMD consider it to be architecturally valid for XRSTOR to\nfail with #PF but nonetheless change the register state.  The actual\nconditions under which this might occur are unclear [1], but it seems\nplausible that this might be triggered if one sibling thread unmaps a page\nand invalidates the shared TLB while another sibling thread is executing\nXRSTOR on the page in question.\n\n__fpu__restore_sig() can execute XRSTOR while the hardware registers\nare preserved on behalf of a different victim task (using the\nfpu_fpregs_owner_ctx mechanism), and, in theory, XRSTOR could fail but\nmodify the registers.\n\nIf this happens, then there is a window in which __fpu__restore_sig()\ncould schedule out and the victim task could schedule back in without\nreloading its own FPU registers. This would result in part of the FPU\nstate that __fpu__restore_sig() was attempting to load leaking into the\nvictim task's user-visible state.\n\nInvalidate preserved FPU registers on XRSTOR failure to prevent this\nsituation from corrupting any state.\n\n[1] Frequent readers of the errata lists might imagine \"complex\n    microarchitectural conditions\"."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/002665dcba4bbec8c82f0aeb4bd3f44334ed2c14","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7748e021b9fb7739e3cb88449296539de0b6817","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d8778e393afa421f1f117471144f8ce6deb6953a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47227","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:11.900","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nx86\/fpu: Prevent state corruption in __fpu__restore_sig()\n\nThe non-compacted slowpath uses __copy_from_user() and copies the entire\nuser buffer into the kernel buffer, verbatim.  This means that the kernel\nbuffer may now contain entirely invalid state on which XRSTOR will #GP.\nvalidate_user_xstate_header() can detect some of that corruption, but that\nleaves the onus on callers to clear the buffer.\n\nPrior to XSAVES support, it was possible just to reinitialize the buffer,\ncompletely, but with supervisor states that is not longer possible as the\nbuffer clearing code split got it backwards. Fixing that is possible but\nnot corrupting the state in the first place is more robust.\n\nAvoid corruption of the kernel XSAVE buffer by using copy_user_to_xstate()\nwhich validates the XSAVE header contents before copying the actual states\nto the kernel. copy_user_to_xstate() was previously only called for\ncompacted-format kernel buffers, but it works for both compacted and\nnon-compacted forms.\n\nUsing it for the non-compacted form is slower because of multiple\n__copy_from_user() operations, but that cost is less important than robust\ncode in an already slow path.\n\n[ Changelog polished by Dave Hansen ]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/076f732b16a5bf842686e1b43ab6021a2d98233e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/484cea4f362e1eeb5c869abbfb5f90eae6421b38","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ec25ea1f3f05d6f8ee51d1277efea986eafd4f2a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47228","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:12.250","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nx86\/ioremap: Map EFI-reserved memory as encrypted for SEV\n\nSome drivers require memory that is marked as EFI boot services\ndata. In order for this memory to not be re-used by the kernel\nafter ExitBootServices(), efi_mem_reserve() is used to preserve it\nby inserting a new EFI memory descriptor and marking it with the\nEFI_MEMORY_RUNTIME attribute.\n\nUnder SEV, memory marked with the EFI_MEMORY_RUNTIME attribute needs to\nbe mapped encrypted by Linux, otherwise the kernel might crash at boot\nlike below:\n\n  EFI Variables Facility v0.08 2004-May-17\n  general protection fault, probably for non-canonical address 0x3597688770a868b2: 0000 [#1] SMP NOPTI\n  CPU: 13 PID: 1 Comm: swapper\/0 Not tainted 5.12.4-2-default #1 openSUSE Tumbleweed\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02\/06\/2015\n  RIP: 0010:efi_mokvar_entry_next\n  [...]\n  Call Trace:\n   efi_mokvar_sysfs_init\n   ? efi_mokvar_table_init\n   do_one_initcall\n   ? __kmalloc\n   kernel_init_freeable\n   ? rest_init\n   kernel_init\n   ret_from_fork\n\nExpand the __ioremap_check_other() function to additionally check for\nthis other type of boot data reserved at runtime and indicate that it\nshould be mapped encrypted for an SEV guest.\n\n [ bp: Massage commit message. ]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/208bb686e7fa7fff16e8fa78ff0db34aa9acdbd7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8d651ee9c71bb12fc0c8eb2786b66cbe5aa3e43b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7a05aba39f733ec337c5b952e112dd2dc4fc404","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47229","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:12.323","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: aardvark: Fix kernel panic during PIO transfer\n\nTrying to start a new PIO transfer by writing value 0 in PIO_START register\nwhen previous transfer has not yet completed (which is indicated by value 1\nin PIO_START) causes an External Abort on CPU, which results in kernel\npanic:\n\n    SError Interrupt on CPU0, code 0xbf000002 -- SError\n    Kernel panic - not syncing: Asynchronous SError Interrupt\n\nTo prevent kernel panic, it is required to reject a new PIO transfer when\nprevious one has not finished yet.\n\nIf previous PIO transfer is not finished yet, the kernel may issue a new\nPIO request only if the previous PIO transfer timed out.\n\nIn the past the root cause of this issue was incorrectly identified (as it\noften happens during link retraining or after link down event) and special\nhack was implemented in Trusted Firmware to catch all SError events in EL3,\nto ignore errors with code 0xbf000002 and not forwarding any other errors\nto kernel and instead throw panic from EL3 Trusted Firmware handler.\n\nLinks to discussion and patches about this issue:\nhttps:\/\/git.trustedfirmware.org\/TF-A\/trusted-firmware-a.git\/commit\/?id=3c7dcdac5c50\nhttps:\/\/lore.kernel.org\/linux-pci\/20190316161243.29517-1-repk@triplefau.lt\/\nhttps:\/\/lore.kernel.org\/linux-pci\/971be151d24312cc533989a64bd454b4@www.loen.fr\/\nhttps:\/\/review.trustedfirmware.org\/c\/TF-A\/trusted-firmware-a\/+\/1541\n\nBut the real cause was the fact that during link retraining or after link\ndown event the PIO transfer may take longer time, up to the 1.44s until it\ntimes out. This increased probability that a new PIO transfer would be\nissued by kernel while previous one has not finished yet.\n\nAfter applying this change into the kernel, it is possible to revert the\nmentioned TF-A hack and SError events do not have to be caught in TF-A EL3."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1a1dbc4473974867fe8c5f195c17b341c8e82867","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3d213a4ddf49a860be6e795482c17f87e0c82b2a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/400e6b1860c8be61388d0b77814c53260f96e17a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4c90f90a91d75c3c73dd633827c90e8746d9f54d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b00a9aaa4be20ad6e3311fb78a485eae0899e89a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f18139966d072dab8e4398c95ce955a9742e04f7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47230","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:12.400","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Immediately reset the MMU context when the SMM flag is cleared\n\nImmediately reset the MMU context when the vCPU's SMM flag is cleared so\nthat the SMM flag in the MMU role is always synchronized with the vCPU's\nflag.  If RSM fails (which isn't correctly emulated), KVM will bail\nwithout calling post_leave_smm() and leave the MMU in a bad state.\n\nThe bad MMU role can lead to a NULL pointer dereference when grabbing a\nshadow page's rmap for a page fault as the initial lookups for the gfn\nwill happen with the vCPU's SMM flag (=0), whereas the rmap lookup will\nuse the shadow page's SMM flag, which comes from the MMU (=1).  SMM has\nan entirely different set of memslots, and so the initial lookup can find\na memslot (SMM=0) and then explode on the rmap memslot lookup (SMM=1).\n\n  general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN\n  KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n  CPU: 1 PID: 8410 Comm: syz-executor382 Not tainted 5.13.0-rc5-syzkaller #0\n  Hardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01\/2011\n  RIP: 0010:__gfn_to_rmap arch\/x86\/kvm\/mmu\/mmu.c:935 [inline]\n  RIP: 0010:gfn_to_rmap+0x2b0\/0x4d0 arch\/x86\/kvm\/mmu\/mmu.c:947\n  Code: <42> 80 3c 20 00 74 08 4c 89 ff e8 f1 79 a9 00 4c 89 fb 4d 8b 37 44\n  RSP: 0018:ffffc90000ffef98 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: ffff888015b9f414 RCX: ffff888019669c40\n  RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000001\n  RBP: 0000000000000001 R08: ffffffff811d9cdb R09: ffffed10065a6002\n  R10: ffffed10065a6002 R11: 0000000000000000 R12: dffffc0000000000\n  R13: 0000000000000003 R14: 0000000000000001 R15: 0000000000000000\n  FS:  000000000124b300(0000) GS:ffff8880b9b00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000000000000 CR3: 0000000028e31000 CR4: 00000000001526e0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   rmap_add arch\/x86\/kvm\/mmu\/mmu.c:965 [inline]\n   mmu_set_spte+0x862\/0xe60 arch\/x86\/kvm\/mmu\/mmu.c:2604\n   __direct_map arch\/x86\/kvm\/mmu\/mmu.c:2862 [inline]\n   direct_page_fault+0x1f74\/0x2b70 arch\/x86\/kvm\/mmu\/mmu.c:3769\n   kvm_mmu_do_page_fault arch\/x86\/kvm\/mmu.h:124 [inline]\n   kvm_mmu_page_fault+0x199\/0x1440 arch\/x86\/kvm\/mmu\/mmu.c:5065\n   vmx_handle_exit+0x26\/0x160 arch\/x86\/kvm\/vmx\/vmx.c:6122\n   vcpu_enter_guest+0x3bdd\/0x9630 arch\/x86\/kvm\/x86.c:9428\n   vcpu_run+0x416\/0xc20 arch\/x86\/kvm\/x86.c:9494\n   kvm_arch_vcpu_ioctl_run+0x4e8\/0xa40 arch\/x86\/kvm\/x86.c:9722\n   kvm_vcpu_ioctl+0x70f\/0xbb0 arch\/x86\/kvm\/..\/..\/..\/virt\/kvm\/kvm_main.c:3460\n   vfs_ioctl fs\/ioctl.c:51 [inline]\n   __do_sys_ioctl fs\/ioctl.c:1069 [inline]\n   __se_sys_ioctl+0xfb\/0x170 fs\/ioctl.c:1055\n   do_syscall_64+0x3f\/0xb0 arch\/x86\/entry\/common.c:47\n   entry_SYSCALL_64_after_hwframe+0x44\/0xae\n  RIP: 0033:0x440ce9"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/669a8866e468fd020d34eb00e08cb41d3774b71b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/78fcb2c91adfec8ce3a2ba6b4d0dda89f2f4a7c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cbb425f62df9df7abee4b3f068f7ed6ffc3561e2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df9a40cfb3be2cbeb1c17bb67c59251ba16630f3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47231","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:12.477","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncan: mcba_usb: fix memory leak in mcba_usb\n\nSyzbot reported memory leak in SocketCAN driver for Microchip CAN BUS\nAnalyzer Tool. The problem was in unfreed usb_coherent.\n\nIn mcba_usb_start() 20 coherent buffers are allocated and there is\nnothing, that frees them:\n\n1) In callback function the urb is resubmitted and that's all\n2) In disconnect function urbs are simply killed, but URB_FREE_BUFFER\n   is not set (see mcba_usb_start) and this flag cannot be used with\n   coherent buffers.\n\nFail log:\n| [ 1354.053291][ T8413] mcba_usb 1-1:0.0 can0: device disconnected\n| [ 1367.059384][ T8420] kmemleak: 20 new suspected memory leaks (see \/sys\/kernel\/debug\/kmem)\n\nSo, all allocated buffers should be freed with usb_free_coherent()\nexplicitly\n\nNOTE:\nThe same pattern for allocating and freeing coherent buffers\nis used in drivers\/net\/can\/usb\/kvaser_usb\/kvaser_usb_core.c"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6bd3d80d1f019cefa7011056c54b323f1d8b8e83","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6f87c0e21ad20dd3d22108e33db1c552dfa352a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/89df95ce32be204eef2e7d4b2f6fb552fb191a68","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/91c02557174be7f72e46ed7311e3bea1939840b0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a115198caaab6d663bef75823a3c5f0802306d60","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0760a4ef85697bc756d06eae17ae27f3f055401","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47232","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:12.557","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncan: j1939: fix Use-after-Free, hold skb ref while in use\n\nThis patch fixes a Use-after-Free found by the syzbot.\n\nThe problem is that a skb is taken from the per-session skb queue,\nwithout incrementing the ref count. This leads to a Use-after-Free if\nthe skb is taken concurrently from the session queue due to a CTS."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1071065eeb33d32b7d98c2ce7591881ae7381705","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2030043e616cab40f510299f09b636285e0a3678","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/22cba878abf646cd3a02ee7c8c2cef7afe66a256","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/509ab6bfdd0c76daebbad0f0af07da712116de22","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47233","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:12.630","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nregulator: rt4801: Fix NULL pointer dereference if priv->enable_gpios is NULL\n\ndevm_gpiod_get_array_optional may return NULL if no GPIO was assigned."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/ba8a26a7ce8617f9f3d6230de34b2302df086b41","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cb2381cbecb81a8893b2d1e1af29bc2e5531df27","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dc68f0c9e4a001e02376fe87f4bdcacadb27e8a1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47234","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:12.710","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nphy: phy-mtk-tphy: Fix some resource leaks in mtk_phy_init()\n\nUse clk_disable_unprepare() in the error path of mtk_phy_init() to fix\nsome resource leaks."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6472955af5e88b5489b6d78316082ad56ea3e489","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9a17907946232d01aa2ec109da5f93b8d31dd425","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aaac9a1bd370338ce372669eb9a6059d16b929aa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47235","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:12.777","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ethernet: fix potential use-after-free in ec_bhf_remove\n\nstatic void ec_bhf_remove(struct pci_dev *dev)\n{\n...\n\tstruct ec_bhf_priv *priv = netdev_priv(net_dev);\n\n\tunregister_netdev(net_dev);\n\tfree_netdev(net_dev);\n\n\tpci_iounmap(dev, priv->dma_io);\n\tpci_iounmap(dev, priv->io);\n...\n}\n\npriv is netdev private data, but it is used\nafter free_netdev(). It can cause use-after-free when accessing priv\npointer. So, fix it by moving free_netdev() after pci_iounmap()\ncalls."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0260916843cc74f3906acf8b6f256693e01530a2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/19f88ca68ccf8771276a606765239b167654f84a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1cafc540b7bf1b6a5a77dc000205fe337ef6eba6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/95deeb29d831e2fae608439e243e7a520611e7ea","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9cca0c2d70149160407bda9a9446ce0c29b6e6c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b1ad283755095a4b9d1431aeb357d7df1a33d3bb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d11d79e52ba080ee567cb7d7eb42a5ade60a8130","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/db2bc3cfd2bc01621014d4f17cdfc74611f339c8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47236","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:12.857","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: cdc_eem: fix tx fixup skb leak\n\nwhen usbnet transmit a skb, eem fixup it in eem_tx_fixup(),\nif skb_copy_expand() failed, it return NULL,\nusbnet_start_xmit() will have no chance to free original skb.\n\nfix it by free orginal skb in eem_tx_fixup() first,\nthen check skb clone status, if failed, return NULL to usbnet."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/05b2b9f7d24b5663d9b47427fe1555bdafd3ea02","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/14184ec5c958b589ba934da7363a2877879204df","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1bcacd6088d61c0ac6a990d87975600a81f3247e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/81de2ed06df8b5451e050fe6a318af3263dbff3f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4f7a9fc9d094c0c4a66f2ad7c37b1dbe9e78f88","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c3b26fdf1b32f91c7a3bc743384b4a298ab53ad7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f12554b0ff639e74612cc01b3b4a049e098d2d65","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f4e6a7f19c82f39b1803e91c54718f0d7143767d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47237","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:12.930","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hamradio: fix memory leak in mkiss_close\n\nMy local syzbot instance hit memory leak in\nmkiss_open()[1]. The problem was in missing\nfree_netdev() in mkiss_close().\n\nIn mkiss_open() netdevice is allocated and then\nregistered, but in mkiss_close() netdevice was\nonly unregistered, but not freed.\n\nFail log:\n\nBUG: memory leak\nunreferenced object 0xffff8880281ba000 (size 4096):\n  comm \"syz-executor.1\", pid 11443, jiffies 4295046091 (age 17.660s)\n  hex dump (first 32 bytes):\n    61 78 30 00 00 00 00 00 00 00 00 00 00 00 00 00  ax0.............\n    00 27 fa 2a 80 88 ff ff 00 00 00 00 00 00 00 00  .'.*............\n  backtrace:\n    [<ffffffff81a27201>] kvmalloc_node+0x61\/0xf0\n    [<ffffffff8706e7e8>] alloc_netdev_mqs+0x98\/0xe80\n    [<ffffffff84e64192>] mkiss_open+0xb2\/0x6f0 [1]\n    [<ffffffff842355db>] tty_ldisc_open+0x9b\/0x110\n    [<ffffffff84236488>] tty_set_ldisc+0x2e8\/0x670\n    [<ffffffff8421f7f3>] tty_ioctl+0xda3\/0x1440\n    [<ffffffff81c9f273>] __x64_sys_ioctl+0x193\/0x200\n    [<ffffffff8911263a>] do_syscall_64+0x3a\/0xb0\n    [<ffffffff89200068>] entry_SYSCALL_64_after_hwframe+0x44\/0xae\n\nBUG: memory leak\nunreferenced object 0xffff8880141a9a00 (size 96):\n  comm \"syz-executor.1\", pid 11443, jiffies 4295046091 (age 17.660s)\n  hex dump (first 32 bytes):\n    e8 a2 1b 28 80 88 ff ff e8 a2 1b 28 80 88 ff ff  ...(.......(....\n    98 92 9c aa b0 40 02 00 00 00 00 00 00 00 00 00  .....@..........\n  backtrace:\n    [<ffffffff8709f68b>] __hw_addr_create_ex+0x5b\/0x310\n    [<ffffffff8709fb38>] __hw_addr_add_ex+0x1f8\/0x2b0\n    [<ffffffff870a0c7b>] dev_addr_init+0x10b\/0x1f0\n    [<ffffffff8706e88b>] alloc_netdev_mqs+0x13b\/0xe80\n    [<ffffffff84e64192>] mkiss_open+0xb2\/0x6f0 [1]\n    [<ffffffff842355db>] tty_ldisc_open+0x9b\/0x110\n    [<ffffffff84236488>] tty_set_ldisc+0x2e8\/0x670\n    [<ffffffff8421f7f3>] tty_ioctl+0xda3\/0x1440\n    [<ffffffff81c9f273>] __x64_sys_ioctl+0x193\/0x200\n    [<ffffffff8911263a>] do_syscall_64+0x3a\/0xb0\n    [<ffffffff89200068>] entry_SYSCALL_64_after_hwframe+0x44\/0xae\n\nBUG: memory leak\nunreferenced object 0xffff8880219bfc00 (size 512):\n  comm \"syz-executor.1\", pid 11443, jiffies 4295046091 (age 17.660s)\n  hex dump (first 32 bytes):\n    00 a0 1b 28 80 88 ff ff 80 8f b1 8d ff ff ff ff  ...(............\n    80 8f b1 8d ff ff ff ff 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [<ffffffff81a27201>] kvmalloc_node+0x61\/0xf0\n    [<ffffffff8706eec7>] alloc_netdev_mqs+0x777\/0xe80\n    [<ffffffff84e64192>] mkiss_open+0xb2\/0x6f0 [1]\n    [<ffffffff842355db>] tty_ldisc_open+0x9b\/0x110\n    [<ffffffff84236488>] tty_set_ldisc+0x2e8\/0x670\n    [<ffffffff8421f7f3>] tty_ioctl+0xda3\/0x1440\n    [<ffffffff81c9f273>] __x64_sys_ioctl+0x193\/0x200\n    [<ffffffff8911263a>] do_syscall_64+0x3a\/0xb0\n    [<ffffffff89200068>] entry_SYSCALL_64_after_hwframe+0x44\/0xae\n\nBUG: memory leak\nunreferenced object 0xffff888029b2b200 (size 256):\n  comm \"syz-executor.1\", pid 11443, jiffies 4295046091 (age 17.660s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [<ffffffff81a27201>] kvmalloc_node+0x61\/0xf0\n    [<ffffffff8706f062>] alloc_netdev_mqs+0x912\/0xe80\n    [<ffffffff84e64192>] mkiss_open+0xb2\/0x6f0 [1]\n    [<ffffffff842355db>] tty_ldisc_open+0x9b\/0x110\n    [<ffffffff84236488>] tty_set_ldisc+0x2e8\/0x670\n    [<ffffffff8421f7f3>] tty_ioctl+0xda3\/0x1440\n    [<ffffffff81c9f273>] __x64_sys_ioctl+0x193\/0x200\n    [<ffffffff8911263a>] do_syscall_64+0x3a\/0xb0\n    [<ffffffff89200068>] entry_SYSCALL_64_after_hwframe+0x44\/0xae"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/290b0b6432e2599021db0b8d6046f756d931c29f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3942d0f9ace1a95a74930b5b4fc0e5005c62b37b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/765a8a04f828db7222b36a42b1031f576bfe95c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7edcc682301492380fbdd604b4516af5ae667a13","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a49cbb762ef20655f5c91abdc13658b0af5e159d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c16c4716a1b5ba4f83c7e00da457cba06761f119","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c634ba0b4159838ff45a60d3a0ace3b4118077a5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f4de2b43d13b7cf3ced9310e371b90c836dbd7cd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47238","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.017","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ipv4: fix memory leak in ip_mc_add1_src\n\nBUG: memory leak\nunreferenced object 0xffff888101bc4c00 (size 32):\n  comm \"syz-executor527\", pid 360, jiffies 4294807421 (age 19.329s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n    01 00 00 00 00 00 00 00 ac 14 14 bb 00 00 02 00 ................\n  backtrace:\n    [<00000000f17c5244>] kmalloc include\/linux\/slab.h:558 [inline]\n    [<00000000f17c5244>] kzalloc include\/linux\/slab.h:688 [inline]\n    [<00000000f17c5244>] ip_mc_add1_src net\/ipv4\/igmp.c:1971 [inline]\n    [<00000000f17c5244>] ip_mc_add_src+0x95f\/0xdb0 net\/ipv4\/igmp.c:2095\n    [<000000001cb99709>] ip_mc_source+0x84c\/0xea0 net\/ipv4\/igmp.c:2416\n    [<0000000052cf19ed>] do_ip_setsockopt net\/ipv4\/ip_sockglue.c:1294 [inline]\n    [<0000000052cf19ed>] ip_setsockopt+0x114b\/0x30c0 net\/ipv4\/ip_sockglue.c:1423\n    [<00000000477edfbc>] raw_setsockopt+0x13d\/0x170 net\/ipv4\/raw.c:857\n    [<00000000e75ca9bb>] __sys_setsockopt+0x158\/0x270 net\/socket.c:2117\n    [<00000000bdb993a8>] __do_sys_setsockopt net\/socket.c:2128 [inline]\n    [<00000000bdb993a8>] __se_sys_setsockopt net\/socket.c:2125 [inline]\n    [<00000000bdb993a8>] __x64_sys_setsockopt+0xba\/0x150 net\/socket.c:2125\n    [<000000006a1ffdbd>] do_syscall_64+0x40\/0x80 arch\/x86\/entry\/common.c:47\n    [<00000000b11467c4>] entry_SYSCALL_64_after_hwframe+0x44\/0xae\n\nIn commit 24803f38a5c0 (\"igmp: do not remove igmp souce list info when set\nlink down\"), the ip_mc_clear_src() in ip_mc_destroy_dev() was removed,\nbecause it was also called in igmpv3_clear_delrec().\n\nRough callgraph:\n\ninetdev_destroy\n-> ip_mc_destroy_dev\n     -> igmpv3_clear_delrec\n        -> ip_mc_clear_src\n-> RCU_INIT_POINTER(dev->ip_ptr, NULL)\n\nHowever, ip_mc_clear_src() called in igmpv3_clear_delrec() doesn't\nrelease in_dev->mc_list->sources. And RCU_INIT_POINTER() assigns the\nNULL to dev->ip_ptr. As a result, in_dev cannot be obtained through\ninetdev_by_index() and then in_dev->mc_list->sources cannot be released\nby ip_mc_del1_src() in the sock_close. Rough call sequence goes like:\n\nsock_close\n-> __sock_release\n   -> inet_release\n      -> ip_mc_drop_socket\n         -> inetdev_by_index\n         -> ip_mc_leave_src\n            -> ip_mc_del_src\n               -> ip_mc_del1_src\n\nSo we still need to call ip_mc_clear_src() in ip_mc_destroy_dev() to free\nin_dev->mc_list->sources."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0dc13e75507faa17ac9f7562b4ef7bf8fcd78422","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1e28018b5c83d5073f74a6fb72eabe8370b2f501","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3dd2aeac2e9624cff9fa634710837e4f2e352758","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6cff57eea3347f79f1867cc53e1093b6614138d8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/77de6ee73f54a9a89c0afa0bf4c53b239aa9953a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ac31cc837cafb57a271babad8ccffbf733caa076","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d8e2973029b8b2ce477b564824431f3385c77083","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47239","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.100","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: usb: fix possible use-after-free in smsc75xx_bind\n\nThe commit 46a8b29c6306 (\"net: usb: fix memory leak in smsc75xx_bind\")\nfails to clean up the work scheduled in smsc75xx_reset->\nsmsc75xx_set_multicast, which leads to use-after-free if the work is\nscheduled to start after the deallocation. In addition, this patch\nalso removes a dangling pointer - dev->data[0].\n\nThis patch calls cancel_work_sync to cancel the scheduled work and set\nthe dangling pointer to NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/14616c372a7be01a2fb8c56c9d8debd232b9e43d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2fc8300c9cfa5167fcb5b1a2a07db6f53e82f59b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4252bf6c2b245f47011098113d405ffad6ad5d5b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/56b786d86694e079d8aad9b314e015cd4ac02a3d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/570a52cf3e01d19f7fd1a251dfc52b0cd86c13cb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/64160d1741a3de5204d1a822e058e0b4cc526504","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7cc8b2e05fcea6edd022d26e82091d781af8fd9b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c4e3be2e7742863e454ce31faf8fd0109c00050b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47240","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.177","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: qrtr: fix OOB Read in qrtr_endpoint_post\n\nSyzbot reported slab-out-of-bounds Read in\nqrtr_endpoint_post. The problem was in wrong\n_size_ type:\n\n\tif (len != ALIGN(size, 4) + hdrlen)\n\t\tgoto err;\n\nIf size from qrtr_hdr is 4294967293 (0xfffffffd), the result of\nALIGN(size, 4) will be 0. In case of len == hdrlen and size == 4294967293\nin header this check won't fail and\n\n\tskb_put_data(skb, data + hdrlen, size);\n\nwill read out of bound from data, which is hdrlen allocated block."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/19892ab9c9d838e2e5a7744d36e4bb8b7c3292fe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/26b8d10703a9be45d6097946b2b4011f7dd2c56f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/960b08dd36de1e341e3eb43d1c547513e338f4f8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad9d24c9429e2159d1e279dc3a83191ccb4daf1d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f8111c0d7ed42ede41a3d0d393b104de0730a8a6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47241","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.250","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nethtool: strset: fix message length calculation\n\nOuter nest for ETHTOOL_A_STRSET_STRINGSETS is not accounted for.\nThis may result in ETHTOOL_MSG_STRSET_GET producing a warning like:\n\n    calculated message payload length (684) not sufficient\n    WARNING: CPU: 0 PID: 30967 at net\/ethtool\/netlink.c:369 ethnl_default_doit+0x87a\/0xa20\n\nand a splat.\n\nAs usually with such warnings three conditions must be met for the warning\nto trigger:\n - there must be no skb size rounding up (e.g. reply_size of 684);\n - string set must be per-device (so that the header gets populated);\n - the device name must be at least 12 characters long.\n\nall in all with current user space it looks like reading priv flags\nis the only place this could potentially happen. Or with syzbot :)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/cfc7f0e70d649e6d2233fba0d9390b525677d971","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e175aef902697826d344ce3a12189329848fe898","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fb3a948143688e14e2cfd2a2812877923d0e5e92","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47242","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.327","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: fix soft lookup in subflow_error_report()\n\nMaxim reported a soft lookup in subflow_error_report():\n\n watchdog: BUG: soft lockup - CPU#0 stuck for 22s! [swapper\/0:0]\n RIP: 0010:native_queued_spin_lock_slowpath\n RSP: 0018:ffffa859c0003bc0 EFLAGS: 00000202\n RAX: 0000000000000101 RBX: 0000000000000001 RCX: 0000000000000000\n RDX: ffff9195c2772d88 RSI: 0000000000000000 RDI: ffff9195c2772d88\n RBP: ffff9195c2772d00 R08: 00000000000067b0 R09: c6e31da9eb1e44f4\n R10: ffff9195ef379700 R11: ffff9195edb50710 R12: ffff9195c2772d88\n R13: ffff9195f500e3d0 R14: ffff9195ef379700 R15: ffff9195ef379700\n FS:  0000000000000000(0000) GS:ffff91961f400000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000000c000407000 CR3: 0000000002988000 CR4: 00000000000006f0\n Call Trace:\n  <IRQ>\n _raw_spin_lock_bh\n subflow_error_report\n mptcp_subflow_data_available\n __mptcp_move_skbs_from_subflow\n mptcp_data_ready\n tcp_data_queue\n tcp_rcv_established\n tcp_v4_do_rcv\n tcp_v4_rcv\n ip_protocol_deliver_rcu\n ip_local_deliver_finish\n __netif_receive_skb_one_core\n netif_receive_skb\n rtl8139_poll 8139too\n __napi_poll\n net_rx_action\n __do_softirq\n __irq_exit_rcu\n common_interrupt\n  <\/IRQ>\n\nThe calling function - mptcp_subflow_data_available() - can be invoked\nfrom different contexts:\n- plain ssk socket lock\n- ssk socket lock + mptcp_data_lock\n- ssk socket lock + mptcp_data_lock + msk socket lock.\n\nSince subflow_error_report() tries to acquire the mptcp_data_lock, the\nlatter two call chains will cause soft lookup.\n\nThis change addresses the issue moving the error reporting call to\nouter functions, where the held locks list is known and the we can\nacquire only the needed one."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/27ef25c72373222aaa5fe7b5cd890ae9cfb89a8d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/499ada5073361c631f2a3c4a8aed44d53b6f82ec","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47243","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.403","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nsch_cake: Fix out of bounds when parsing TCP options and header\n\nThe TCP option parser in cake qdisc (cake_get_tcpopt and\ncake_tcph_may_drop) could read one byte out of bounds. When the length\nis 1, the execution flow gets into the loop, reads one byte of the\nopcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads\none more byte, which exceeds the length of 1.\n\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack\nout of bounds when parsing TCP options.\").\n\nv2 changes:\n\nAdded doff validation in cake_get_tcphdr to avoid parsing garbage as TCP\nheader. Although it wasn't strictly an out-of-bounds access (memory was\nallocated), garbage values could be read where CAKE expected the TCP\nheader if doff was smaller than 5."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3371392c60e2685af30bd4547badd880f5df2b3f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3b491dd593d582ceeb27aa617600712a6bd14246","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4cefa061fc63f4d2dff5ab4083f43857cd7a2335","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/595897ef118d6fe66690c4fc5b572028c9da95b7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ba91c49dedbde758ba0b72f57ac90b06ddf8e548","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47244","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.477","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: Fix out of bounds when parsing TCP options\n\nThe TCP option parser in mptcp (mptcp_get_options) could read one byte\nout of bounds. When the length is 1, the execution flow gets into the\nloop, reads one byte of the opcode, and if the opcode is neither\nTCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the\nlength of 1.\n\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack\nout of bounds when parsing TCP options.\")."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/07718be265680dcf496347d475ce1a5442f55ad7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/73eeba71dc9932970befa009e68272a3d5ec4a58","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/76e02b8905d0691e89e104a882f3bba7dd0f6037","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47245","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.550","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: synproxy: Fix out of bounds when parsing TCP options\n\nThe TCP option parser in synproxy (synproxy_parse_options) could read\none byte out of bounds. When the length is 1, the execution flow gets\ninto the loop, reads one byte of the opcode, and if the opcode is\nneither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds\nthe length of 1.\n\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack\nout of bounds when parsing TCP options.\").\n\nv2 changes:\n\nAdded an early return when length < 0 to avoid calling\nskb_header_pointer with negative length."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/576c1526b4d83c44ad7b673cb841f36cbc6cb6c4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5fc177ab759418c9537433e63301096e733fb915","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/674b5f0c6a4fc5d3abce877048290cea6091fcb1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6defc77d48eff74075b80ad5925061b2fc010d98","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7d9a9a1a88a3da574e019b4de756bc73337b3b0b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9cdf299ba4e153b5e56187648420de22c6216f02","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e1eb98cfeafdd85537e7e3cefe93ca9bfbcc3ea8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f648089337cb8ed40b2bb96e244f72b9d97dc96b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47246","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.623","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/mlx5e: Fix page reclaim for dead peer hairpin\n\nWhen adding a hairpin flow, a firmware-side send queue is created for\nthe peer net device, which claims some host memory pages for its\ninternal ring buffer. If the peer net device is removed\/unbound before\nthe hairpin flow is deleted, then the send queue is not destroyed which\nleads to a stack trace on pci device remove:\n\n[ 748.005230] mlx5_core 0000:08:00.2: wait_func:1094:(pid 12985): MANAGE_PAGES(0x108) timeout. Will cause a leak of a command resource\n[ 748.005231] mlx5_core 0000:08:00.2: reclaim_pages:514:(pid 12985): failed reclaiming pages: err -110\n[ 748.001835] mlx5_core 0000:08:00.2: mlx5_reclaim_root_pages:653:(pid 12985): failed reclaiming pages (-110) for func id 0x0\n[ 748.002171] ------------[ cut here ]------------\n[ 748.001177] FW pages counter is 4 after reclaiming all pages\n[ 748.001186] WARNING: CPU: 1 PID: 12985 at drivers\/net\/ethernet\/mellanox\/mlx5\/core\/pagealloc.c:685 mlx5_reclaim_startup_pages+0x34b\/0x460 [mlx5_core]                      [  +0.002771] Modules linked in: cls_flower mlx5_ib mlx5_core ptp pps_core act_mirred sch_ingress openvswitch nsh xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi rdma_cm ib_umad ib_ipoib iw_cm ib_cm ib_uverbs ib_core overlay fuse [last unloaded: pps_core]\n[ 748.007225] CPU: 1 PID: 12985 Comm: tee Not tainted 5.12.0+ #1\n[ 748.001376] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04\/01\/2014\n[ 748.002315] RIP: 0010:mlx5_reclaim_startup_pages+0x34b\/0x460 [mlx5_core]\n[ 748.001679] Code: 28 00 00 00 0f 85 22 01 00 00 48 81 c4 b0 00 00 00 31 c0 5b 5d 41 5c 41 5d 41 5e 41 5f c3 48 c7 c7 40 cc 19 a1 e8 9f 71 0e e2 <0f> 0b e9 30 ff ff ff 48 c7 c7 a0 cc 19 a1 e8 8c 71 0e e2 0f 0b e9\n[ 748.003781] RSP: 0018:ffff88815220faf8 EFLAGS: 00010286\n[ 748.001149] RAX: 0000000000000000 RBX: ffff8881b4900280 RCX: 0000000000000000\n[ 748.001445] RDX: 0000000000000027 RSI: 0000000000000004 RDI: ffffed102a441f51\n[ 748.001614] RBP: 00000000000032b9 R08: 0000000000000001 R09: ffffed1054a15ee8\n[ 748.001446] R10: ffff8882a50af73b R11: ffffed1054a15ee7 R12: fffffbfff07c1e30\n[ 748.001447] R13: dffffc0000000000 R14: ffff8881b492cba8 R15: 0000000000000000\n[ 748.001429] FS:  00007f58bd08b580(0000) GS:ffff8882a5080000(0000) knlGS:0000000000000000\n[ 748.001695] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 748.001309] CR2: 000055a026351740 CR3: 00000001d3b48006 CR4: 0000000000370ea0\n[ 748.001506] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 748.001483] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[ 748.001654] Call Trace:\n[ 748.000576]  ? mlx5_satisfy_startup_pages+0x290\/0x290 [mlx5_core]\n[ 748.001416]  ? mlx5_cmd_teardown_hca+0xa2\/0xd0 [mlx5_core]\n[ 748.001354]  ? mlx5_cmd_init_hca+0x280\/0x280 [mlx5_core]\n[ 748.001203]  mlx5_function_teardown+0x30\/0x60 [mlx5_core]\n[ 748.001275]  mlx5_uninit_one+0xa7\/0xc0 [mlx5_core]\n[ 748.001200]  remove_one+0x5f\/0xc0 [mlx5_core]\n[ 748.001075]  pci_device_remove+0x9f\/0x1d0\n[ 748.000833]  device_release_driver_internal+0x1e0\/0x490\n[ 748.001207]  unbind_store+0x19f\/0x200\n[ 748.000942]  ? sysfs_file_ops+0x170\/0x170\n[ 748.001000]  kernfs_fop_write_iter+0x2bc\/0x450\n[ 748.000970]  new_sync_write+0x373\/0x610\n[ 748.001124]  ? new_sync_read+0x600\/0x600\n[ 748.001057]  ? lock_acquire+0x4d6\/0x700\n[ 748.000908]  ? lockdep_hardirqs_on_prepare+0x400\/0x400\n[ 748.001126]  ? fd_install+0x1c9\/0x4d0\n[ 748.000951]  vfs_write+0x4d0\/0x800\n[ 748.000804]  ksys_write+0xf9\/0x1d0\n[ 748.000868]  ? __x64_sys_read+0xb0\/0xb0\n[ 748.000811]  ? filp_open+0x50\/0x50\n[ 748.000919]  ? syscall_enter_from_user_mode+0x1d\/0x50\n[ 748.001223]  do_syscall_64+0x3f\/0x80\n[ 748.000892]  entry_SYSCALL_64_after_hwframe+0x44\/0xae\n[ 748.00\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4b16118665e94c90a3e84a5190486fd0e4eedd74","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a3e5fd9314dfc4314a9567cde96e1aef83a7458a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b374c1304f6d3d4752ad1412427b7bf02bb1fd61","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/be7f3f401d224e1efe8112b2fa8b837eeb8c5e52","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47247","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.703","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/mlx5e: Fix use-after-free of encap entry in neigh update handler\n\nFunction mlx5e_rep_neigh_update() wasn't updated to accommodate rtnl lock\nremoval from TC filter update path and properly handle concurrent encap\nentry insertion\/deletion which can lead to following use-after-free:\n\n [23827.464923] ==================================================================\n [23827.469446] BUG: KASAN: use-after-free in mlx5e_encap_take+0x72\/0x140 [mlx5_core]\n [23827.470971] Read of size 4 at addr ffff8881d132228c by task kworker\/u20:6\/21635\n [23827.472251]\n [23827.472615] CPU: 9 PID: 21635 Comm: kworker\/u20:6 Not tainted 5.13.0-rc3+ #5\n [23827.473788] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04\/01\/2014\n [23827.475639] Workqueue: mlx5e mlx5e_rep_neigh_update [mlx5_core]\n [23827.476731] Call Trace:\n [23827.477260]  dump_stack+0xbb\/0x107\n [23827.477906]  print_address_description.constprop.0+0x18\/0x140\n [23827.478896]  ? mlx5e_encap_take+0x72\/0x140 [mlx5_core]\n [23827.479879]  ? mlx5e_encap_take+0x72\/0x140 [mlx5_core]\n [23827.480905]  kasan_report.cold+0x7c\/0xd8\n [23827.481701]  ? mlx5e_encap_take+0x72\/0x140 [mlx5_core]\n [23827.482744]  kasan_check_range+0x145\/0x1a0\n [23827.493112]  mlx5e_encap_take+0x72\/0x140 [mlx5_core]\n [23827.494054]  ? mlx5e_tc_tun_encap_info_equal_generic+0x140\/0x140 [mlx5_core]\n [23827.495296]  mlx5e_rep_neigh_update+0x41e\/0x5e0 [mlx5_core]\n [23827.496338]  ? mlx5e_rep_neigh_entry_release+0xb80\/0xb80 [mlx5_core]\n [23827.497486]  ? read_word_at_a_time+0xe\/0x20\n [23827.498250]  ? strscpy+0xa0\/0x2a0\n [23827.498889]  process_one_work+0x8ac\/0x14e0\n [23827.499638]  ? lockdep_hardirqs_on_prepare+0x400\/0x400\n [23827.500537]  ? pwq_dec_nr_in_flight+0x2c0\/0x2c0\n [23827.501359]  ? rwlock_bug.part.0+0x90\/0x90\n [23827.502116]  worker_thread+0x53b\/0x1220\n [23827.502831]  ? process_one_work+0x14e0\/0x14e0\n [23827.503627]  kthread+0x328\/0x3f0\n [23827.504254]  ? _raw_spin_unlock_irq+0x24\/0x40\n [23827.505065]  ? __kthread_bind_mask+0x90\/0x90\n [23827.505912]  ret_from_fork+0x1f\/0x30\n [23827.506621]\n [23827.506987] Allocated by task 28248:\n [23827.507694]  kasan_save_stack+0x1b\/0x40\n [23827.508476]  __kasan_kmalloc+0x7c\/0x90\n [23827.509197]  mlx5e_attach_encap+0xde1\/0x1d40 [mlx5_core]\n [23827.510194]  mlx5e_tc_add_fdb_flow+0x397\/0xc40 [mlx5_core]\n [23827.511218]  __mlx5e_add_fdb_flow+0x519\/0xb30 [mlx5_core]\n [23827.512234]  mlx5e_configure_flower+0x191c\/0x4870 [mlx5_core]\n [23827.513298]  tc_setup_cb_add+0x1d5\/0x420\n [23827.514023]  fl_hw_replace_filter+0x382\/0x6a0 [cls_flower]\n [23827.514975]  fl_change+0x2ceb\/0x4a51 [cls_flower]\n [23827.515821]  tc_new_tfilter+0x89a\/0x2070\n [23827.516548]  rtnetlink_rcv_msg+0x644\/0x8c0\n [23827.517300]  netlink_rcv_skb+0x11d\/0x340\n [23827.518021]  netlink_unicast+0x42b\/0x700\n [23827.518742]  netlink_sendmsg+0x743\/0xc20\n [23827.519467]  sock_sendmsg+0xb2\/0xe0\n [23827.520131]  ____sys_sendmsg+0x590\/0x770\n [23827.520851]  ___sys_sendmsg+0xd8\/0x160\n [23827.521552]  __sys_sendmsg+0xb7\/0x140\n [23827.522238]  do_syscall_64+0x3a\/0x70\n [23827.522907]  entry_SYSCALL_64_after_hwframe+0x44\/0xae\n [23827.523797]\n [23827.524163] Freed by task 25948:\n [23827.524780]  kasan_save_stack+0x1b\/0x40\n [23827.525488]  kasan_set_track+0x1c\/0x30\n [23827.526187]  kasan_set_free_info+0x20\/0x30\n [23827.526968]  __kasan_slab_free+0xed\/0x130\n [23827.527709]  slab_free_freelist_hook+0xcf\/0x1d0\n [23827.528528]  kmem_cache_free_bulk+0x33a\/0x6e0\n [23827.529317]  kfree_rcu_work+0x55f\/0xb70\n [23827.530024]  process_one_work+0x8ac\/0x14e0\n [23827.530770]  worker_thread+0x53b\/0x1220\n [23827.531480]  kthread+0x328\/0x3f0\n [23827.532114]  ret_from_fork+0x1f\/0x30\n [23827.532785]\n [23827.533147] Last potentially related work creation:\n [23827.534007]  kasan_save_stack+0x1b\/0x40\n [23827.534710]  kasan_record_aux_stack+0xab\/0xc0\n [23827.535492]  kvfree_call_rcu+0x31\/0x7b0\n [23827.536206]  mlx5e_tc_del\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/b6447b72aca571632e71bb73a797118d5ce46a93","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fb1a3132ee1ac968316e45d21a48703a6db0b6c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47248","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.780","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nudp: fix race between close() and udp_abort()\n\nKaustubh reported and diagnosed a panic in udp_lib_lookup().\nThe root cause is udp_abort() racing with close(). Both\nracing functions acquire the socket lock, but udp{v6}_destroy_sock()\nrelease it before performing destructive actions.\n\nWe can't easily extend the socket lock scope to avoid the race,\ninstead use the SOCK_DEAD flag to prevent udp_abort from doing\nany action when the critical race happens.\n\nDiagnosed-and-tested-by: Kaustubh Pandey <kapandey@codeaurora.org>"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2f73448041bd0682d4b552cfd314ace66107f1ad","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5a88477c1c85e4baa51e91f2d40f2166235daa56","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/65310b0aff86980a011c7c7bfa487a333d4ca241","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8729ec8a2238152a4afc212a331a6cd2c61aeeac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a0882f68f54f7a8b6308261acee9bd4faab5a69e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a8b897c7bcd47f4147d066e22cc01d1026d7640e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e3c36c773aed0fef8b1d3d555b43393ec564400f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47249","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.857","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: rds: fix memory leak in rds_recvmsg\n\nSyzbot reported memory leak in rds. The problem\nwas in unputted refcount in case of error.\n\nint rds_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\tint msg_flags)\n{\n...\n\n\tif (!rds_next_incoming(rs, &inc)) {\n\t\t...\n\t}\n\nAfter this \"if\" inc refcount incremented and\n\n\tif (rds_cmsg_recv(inc, msg, rs)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n...\nout:\n\treturn ret;\n}\n\nin case of rds_cmsg_recv() fail the refcount won't be\ndecremented. And it's easy to see from ftrace log, that\nrds_inc_addref() don't have rds_inc_put() pair in\nrds_recvmsg() after rds_cmsg_recv()\n\n 1)               |  rds_recvmsg() {\n 1)   3.721 us    |    rds_inc_addref();\n 1)   3.853 us    |    rds_message_inc_copy_to_user();\n 1) + 10.395 us   |    rds_cmsg_recv();\n 1) + 34.260 us   |  }"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/06b7cb0194bd1ede0dd27f3a946e7c0279fba44a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1f79bc8ae81c05eb112a53f981cb2c244ee50d02","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2038cd15eacdf7512755c27686822e0052eb9042","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/423c6939758fb3b9cf5abbd1e7792068a5c4ae8c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/49bfcbfd989a8f1f23e705759a6bb099de2cff9f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5946fbf48355f5a8caeff72580c7658da5966b86","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8c3ec88b03e9e4ca117dcdc4204fd3edcd02084f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b25b60d076164edb3025e85aabd2cf50a5215b91","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47250","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:13.930","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ipv4: fix memory leak in netlbl_cipsov4_add_std\n\nReported by syzkaller:\nBUG: memory leak\nunreferenced object 0xffff888105df7000 (size 64):\ncomm \"syz-executor842\", pid 360, jiffies 4294824824 (age 22.546s)\nhex dump (first 32 bytes):\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\nbacktrace:\n[<00000000e67ed558>] kmalloc include\/linux\/slab.h:590 [inline]\n[<00000000e67ed558>] kzalloc include\/linux\/slab.h:720 [inline]\n[<00000000e67ed558>] netlbl_cipsov4_add_std net\/netlabel\/netlabel_cipso_v4.c:145 [inline]\n[<00000000e67ed558>] netlbl_cipsov4_add+0x390\/0x2340 net\/netlabel\/netlabel_cipso_v4.c:416\n[<0000000006040154>] genl_family_rcv_msg_doit.isra.0+0x20e\/0x320 net\/netlink\/genetlink.c:739\n[<00000000204d7a1c>] genl_family_rcv_msg net\/netlink\/genetlink.c:783 [inline]\n[<00000000204d7a1c>] genl_rcv_msg+0x2bf\/0x4f0 net\/netlink\/genetlink.c:800\n[<00000000c0d6a995>] netlink_rcv_skb+0x134\/0x3d0 net\/netlink\/af_netlink.c:2504\n[<00000000d78b9d2c>] genl_rcv+0x24\/0x40 net\/netlink\/genetlink.c:811\n[<000000009733081b>] netlink_unicast_kernel net\/netlink\/af_netlink.c:1314 [inline]\n[<000000009733081b>] netlink_unicast+0x4a0\/0x6a0 net\/netlink\/af_netlink.c:1340\n[<00000000d5fd43b8>] netlink_sendmsg+0x789\/0xc70 net\/netlink\/af_netlink.c:1929\n[<000000000a2d1e40>] sock_sendmsg_nosec net\/socket.c:654 [inline]\n[<000000000a2d1e40>] sock_sendmsg+0x139\/0x170 net\/socket.c:674\n[<00000000321d1969>] ____sys_sendmsg+0x658\/0x7d0 net\/socket.c:2350\n[<00000000964e16bc>] ___sys_sendmsg+0xf8\/0x170 net\/socket.c:2404\n[<000000001615e288>] __sys_sendmsg+0xd3\/0x190 net\/socket.c:2433\n[<000000004ee8b6a5>] do_syscall_64+0x37\/0x90 arch\/x86\/entry\/common.c:47\n[<00000000171c7cee>] entry_SYSCALL_64_after_hwframe+0x44\/0xae\n\nThe memory of doi_def->map.std pointing is allocated in\nnetlbl_cipsov4_add_std, but no place has freed it. It should be\nfreed in cipso_v4_doi_free which frees the cipso DOI resource."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/086e92b1d68c6338535f715aad173f8cf4bfbc8c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0ffb460be3abac86f884a8c548bb02724ec370f4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/212166510582631994be4f4b3fe15e10a03c1dd4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/398a24447eb60f060c8994221cb5ae6caf355fa1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5340858147e3dc60913fb3dd0cbb758ec4a26e66","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6dcea66d3bb519b426282588f38e884e07893c1f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d612c3f3fae221e7ea736d196581c2217304bbbc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/deeeb65c6ee404f2d1fb80b38b2730645c0f4663","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47251","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.007","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: fix skb length check in ieee80211_scan_rx()\n\nReplace hard-coded compile-time constants for header length check\nwith dynamic determination based on the frame type. Otherwise, we\nhit a validation WARN_ON in cfg80211 later.\n\n[style fixes, reword commit message]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5a1cd67a801cf5ef989c4783e07b86a25b143126","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d1b949c70206178b12027f66edc088d40375b5cb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e298aa358f0ca658406d524b6639fe389cb6e11e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47252","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.083","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbatman-adv: Avoid WARN_ON timing related checks\n\nThe soft\/batadv interface for a queued OGM can be changed during the time\nthe OGM was queued for transmission and when the OGM is actually\ntransmitted by the worker.\n\nBut WARN_ON must be used to denote kernel bugs and not to print simple\nwarnings. A warning can simply be printed using pr_warn."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/282baa8104af44e04c4af3e7f933b44267c7f86f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2eb4e0b3631832a4291c8bf4c9db873f60b128c8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/45011f2973f6b52cf50db397bb27bf805f5f0e7f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6031daaaf6d5c359c99dfffa102e332df234ff09","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/77a99aad5bc3ea105806ebae6be3cbadc2fc615e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9f460ae31c4435fd022c443a6029352217a16ac1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e7fbd8184fa9e85f0d648c499841cb7ff6dec9f4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e8e9d2968a9d08bf5c683afca182f1537edebf8d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47253","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.160","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/display: Fix potential memory leak in DMUB hw_init\n\n[Why]\nOn resume we perform DMUB hw_init which allocates memory:\ndm_resume->dm_dmub_hw_init->dc_dmub_srv_create->kzalloc\nThat results in memory leak in suspend\/resume scenarios.\n\n[How]\nAllocate memory for the DC wrapper to DMUB only if it was not\nallocated before.\nNo need to reallocate it on suspend\/resume."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/9e8c2af010463197315fa54a6c17e74988b5259c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aa000f828e60ac15d6340f606ec4a673966f5b0b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c5699e2d863f58221044efdc3fa712dd32d55cde","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47254","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.233","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: Fix use-after-free in gfs2_glock_shrink_scan\n\nThe GLF_LRU flag is checked under lru_lock in gfs2_glock_remove_from_lru() to\nremove the glock from the lru list in __gfs2_glock_put().\n\nOn the shrink scan path, the same flag is cleared under lru_lock but because\nof cond_resched_lock(&lru_lock) in gfs2_dispose_glock_lru(), progress on the\nput side can be made without deleting the glock from the lru list.\n\nKeep GLF_LRU across the race window opened by cond_resched_lock(&lru_lock) to\nensure correct behavior on both sides - clear GLF_LRU after list_del under\nlru_lock."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0364742decb0f02bc183404868b82896f7992595","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/094bf5670e762afa243d2c41a5c4ab71c7447bf4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1ab19c5de4c537ec0d9b21020395a5b5a6c059b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/38ce329534500bf4ae71f81df6a37a406cf187b4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/86fd5b27db743a0ce0cc245e3a34813b2aa6ec1d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/92869945cc5b78ee8a1ef90336fe070893e3458a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a61156314b66456ab6a291ed5deba1ebd002ab3c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e87ef30fe73e7e10d2c85bdcc778dcec24dca553","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47255","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.303","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nkvm: LAPIC: Restore guard to prevent illegal APIC register access\n\nPer the SDM, \"any access that touches bytes 4 through 15 of an APIC\nregister may cause undefined behavior and must not be executed.\"\nWorse, such an access in kvm_lapic_reg_read can result in a leak of\nkernel stack contents. Prior to commit 01402cf81051 (\"kvm: LAPIC:\nwrite down valid APIC registers\"), such an access was explicitly\ndisallowed. Restore the guard that was removed in that commit."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/018685461a5b9a9a70e664ac77aef0d7415a3fd5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/218bf772bddd221489c38dde6ef8e917131161f6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a2aff09807fbe4018c269d3773a629949058b210","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bf99ea52970caeb4583bdba1192c1f9b53b12c84","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47256","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.380","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmm\/memory-failure: make sure wait for page writeback in memory_failure\n\nOur syzkaller trigger the \"BUG_ON(!list_empty(&inode->i_wb_list))\" in\nclear_inode:\n\n  kernel BUG at fs\/inode.c:519!\n  Internal error: Oops - BUG: 0 [#1] SMP\n  Modules linked in:\n  Process syz-executor.0 (pid: 249, stack limit = 0x00000000a12409d7)\n  CPU: 1 PID: 249 Comm: syz-executor.0 Not tainted 4.19.95\n  Hardware name: linux,dummy-virt (DT)\n  pstate: 80000005 (Nzcv daif -PAN -UAO)\n  pc : clear_inode+0x280\/0x2a8\n  lr : clear_inode+0x280\/0x2a8\n  Call trace:\n    clear_inode+0x280\/0x2a8\n    ext4_clear_inode+0x38\/0xe8\n    ext4_free_inode+0x130\/0xc68\n    ext4_evict_inode+0xb20\/0xcb8\n    evict+0x1a8\/0x3c0\n    iput+0x344\/0x460\n    do_unlinkat+0x260\/0x410\n    __arm64_sys_unlinkat+0x6c\/0xc0\n    el0_svc_common+0xdc\/0x3b0\n    el0_svc_handler+0xf8\/0x160\n    el0_svc+0x10\/0x218\n  Kernel panic - not syncing: Fatal exception\n\nA crash dump of this problem show that someone called __munlock_pagevec\nto clear page LRU without lock_page: do_mmap -> mmap_region -> do_munmap\n-> munlock_vma_pages_range -> __munlock_pagevec.\n\nAs a result memory_failure will call identify_page_state without\nwait_on_page_writeback.  And after truncate_error_page clear the mapping\nof this page.  end_page_writeback won't call sb_clear_inode_writeback to\nclear inode->i_wb_list.  That will trigger BUG_ON in clear_inode!\n\nFix it by checking PageWriteback too to help determine should we skip\nwait_on_page_writeback."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/28788dc5c70597395b6b451dae4549bbaa8e2c56","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/566345aaabac853aa866f53a219c4b02a6beb527","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6d210d547adc2218ef8b5bcf23518c5f2f1fd872","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9e379da727a7a031be9b877cde7b9c34a0fb8306","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d05267fd27a5c4f54e06daefa3035995d765ca0c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e8675d291ac007e1c636870db880f837a9ea112a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47257","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.460","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ieee802154: fix null deref in parse dev addr\n\nFix a logic error that could result in a null deref if the user sets\nthe mode incorrectly for the given addr type."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1f95741981c899c4724647291fec5faa3c777185","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5f728ec65485625e30f46e5b4917ff023ad29ea0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9fdd04918a452980631ecc499317881c1d120b70","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c6998ccfefa652bac3f9b236821e392af43efa1e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c7836de2cadd88bc2f20f2c5a3d4ef4c73aef627","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0f47648b87b6d5f204cb7f3cbce6d36dab85a67","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fdd51e34f45311ab6e48d2147cbc2904731b9993","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47258","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.537","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: core: Fix error handling of scsi_host_alloc()\n\nAfter device is initialized via device_initialize(), or its name is set via\ndev_set_name(), the device has to be freed via put_device().  Otherwise\ndevice name will be leaked because it is allocated dynamically in\ndev_set_name().\n\nFix the leak by replacing kfree() with put_device(). Since\nscsi_host_dev_release() properly handles IDA and kthread removal, remove\nspecial-casing these from the error handling as well."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2dc85045ae65b9302a1d2e2ddd7ce4c030153a6a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/45d83db4728127944b237c0c8248987df9d478e7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/66a834d092930cf41d809c0e989b13cd6f9ca006","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/79296e292d67fa7b5fb8d8c27343683e823872c8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7a696ce1d5d16a33a6cd6400bbcc0339b2460e11","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8958181c1663e24a13434448e7d6b96b5d04900a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/db08ce595dd64ea9859f7d088b51cbfc8e685c66","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47259","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.610","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix use-after-free in nfs4_init_client()\n\nKASAN reports a use-after-free when attempting to mount two different\nexports through two different NICs that belong to the same server.\n\nOlga was able to hit this with kernels starting somewhere between 5.7\nand 5.10, but I traced the patch that introduced the clear_bit() call to\n4.13. So something must have changed in the refcounting of the clp\npointer to make this call to nfs_put_client() the very last one."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3e3c7ebbfac152d08be75c92802a64a1f6471a15","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/42c10b0db064e45f5c5ae7019bbf2168ffab766c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/476bdb04c501fc64bf3b8464ffddefc8dbe01577","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/72651c6579a25317a90536181d311c663d0329ab","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c3b6cf64dfe4ef96e7341508d50d6998da7062c7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c7eab9e2d7b4e983ce280276fb920af649955897","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47260","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.690","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix a potential NULL dereference in nfs_get_client()\n\nNone of the callers are expecting NULL returns from nfs_get_client() so\nthis code will lead to an Oops.  It's better to return an error\npointer.  I expect that this is dead code so hopefully no one is\naffected."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0057ecef9f324007c0ba5fcca4ddd131178ce78b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/09226e8303beeec10f2ff844d2e46d1371dc58e0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/279ad78a00f8b9c5ff24171a59297187a3bd44b7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4b380a7d84ef2ce3f4f5bec5d8706ed937ac6502","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/58ddf61f10b8f9b7b1341644bfee2f1c6508d4e1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/634f17ff1d59905eb3b4bbbc00805961d08beaee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a979e601000982a3ca693171a6d4dffc47f8ad00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fab8bfdfb4aac9e4e8363666333adfdf21e89106","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47261","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.770","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nIB\/mlx5: Fix initializing CQ fragments buffer\n\nThe function init_cq_frag_buf() can be called to initialize the current CQ\nfragments buffer cq->buf, or the temporary cq->resize_buf that is filled\nduring CQ resize operation.\n\nHowever, the offending commit started to use function get_cqe() for\ngetting the CQEs, the issue with this change is that get_cqe() always\nreturns CQEs from cq->buf, which leads us to initialize the wrong buffer,\nand in case of enlarging the CQ we try to access elements beyond the size\nof the current cq->buf and eventually hit a kernel panic.\n\n [exception RIP: init_cq_frag_buf+103]\n  [ffff9f799ddcbcd8] mlx5_ib_resize_cq at ffffffffc0835d60 [mlx5_ib]\n  [ffff9f799ddcbdb0] ib_resize_cq at ffffffffc05270df [ib_core]\n  [ffff9f799ddcbdc0] llt_rdma_setup_qp at ffffffffc0a6a712 [llt]\n  [ffff9f799ddcbe10] llt_rdma_cc_event_action at ffffffffc0a6b411 [llt]\n  [ffff9f799ddcbe98] llt_rdma_client_conn_thread at ffffffffc0a6bb75 [llt]\n  [ffff9f799ddcbec8] kthread at ffffffffa66c5da1\n  [ffff9f799ddcbf50] ret_from_fork_nospec_begin at ffffffffa6d95ddd\n\nFix it by getting the needed CQE by calling mlx5_frag_buf_get_wqe() that\ntakes the correct source buffer as a parameter."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1ec2dcd680c71d0d36fa25638b327a468babd5c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2ba0aa2feebda680ecfc3c552e867cf4d1b05a3a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3e670c54eda238cb8a1ea93538a79ae89285c1c4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/91f7fdc4cc10542ca1045c06aad23365f0d067e0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e3ecd9c09fcc10cf6b2bc67e2990c397c40a8c26","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47262","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:14.930","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Ensure liveliness of nested VM-Enter fail tracepoint message\n\nUse the __string() machinery provided by the tracing subystem to make a\ncopy of the string literals consumed by the \"nested VM-Enter failed\"\ntracepoint.  A complete copy is necessary to ensure that the tracepoint\ncan't outlive the data\/memory it consumes and deference stale memory.\n\nBecause the tracepoint itself is defined by kvm, if kvm-intel and\/or\nkvm-amd are built as modules, the memory holding the string literals\ndefined by the vendor modules will be freed when the module is unloaded,\nwhereas the tracepoint and its data in the ring buffer will live until\nkvm is unloaded (or \"indefinitely\" if kvm is built-in).\n\nThis bug has existed since the tracepoint was added, but was recently\nexposed by a new check in tracing to detect exactly this type of bug.\n\n  fmt: '%s%s\n  ' current_buffer: ' vmx_dirty_log_t-140127  [003] ....  kvm_nested_vmenter_failed: '\n  WARNING: CPU: 3 PID: 140134 at kernel\/trace\/trace.c:3759 trace_check_vprintf+0x3be\/0x3e0\n  CPU: 3 PID: 140134 Comm: less Not tainted 5.13.0-rc1-ce2e73ce600a-req #184\n  Hardware name: ASUS Q87M-E\/Q87M-E, BIOS 1102 03\/03\/2014\n  RIP: 0010:trace_check_vprintf+0x3be\/0x3e0\n  Code: <0f> 0b 44 8b 4c 24 1c e9 a9 fe ff ff c6 44 02 ff 00 49 8b 97 b0 20\n  RSP: 0018:ffffa895cc37bcb0 EFLAGS: 00010282\n  RAX: 0000000000000000 RBX: ffffa895cc37bd08 RCX: 0000000000000027\n  RDX: 0000000000000027 RSI: 00000000ffffdfff RDI: ffff9766cfad74f8\n  RBP: ffffffffc0a041d4 R08: ffff9766cfad74f0 R09: ffffa895cc37bad8\n  R10: 0000000000000001 R11: 0000000000000001 R12: ffffffffc0a041d4\n  R13: ffffffffc0f4dba8 R14: 0000000000000000 R15: ffff976409f2c000\n  FS:  00007f92fa200740(0000) GS:ffff9766cfac0000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000559bd11b0000 CR3: 000000019fbaa002 CR4: 00000000001726e0\n  Call Trace:\n   trace_event_printf+0x5e\/0x80\n   trace_raw_output_kvm_nested_vmenter_failed+0x3a\/0x60 [kvm]\n   print_trace_line+0x1dd\/0x4e0\n   s_show+0x45\/0x150\n   seq_read_iter+0x2d5\/0x4c0\n   seq_read+0x106\/0x150\n   vfs_read+0x98\/0x180\n   ksys_read+0x5f\/0xe0\n   do_syscall_64+0x40\/0xb0\n   entry_SYSCALL_64_after_hwframe+0x44\/0xae"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/796d3bd4ac9316e70c181189318cd2bd98af34bc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9fb088ce13bc3c59a51260207b487db3e556f275","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d046f724bbd725a24007b7e52b2d675249870888","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f31500b0d437a2464ca5972d8f5439e156b74960","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47263","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.007","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ngpio: wcd934x: Fix shift-out-of-bounds error\n\nbit-mask for pins 0 to 4 is BIT(0) to BIT(4) however we ended up with BIT(n - 1)\nwhich is not right, and this was caught by below usban check\n\nUBSAN: shift-out-of-bounds in drivers\/gpio\/gpio-wcd934x.c:34:14"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/dbec64b11c65d74f31427e2b9d5746fbf17bf840","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dd55331d493b7ea75c5db1f24d6822946fde2862","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e0b518a2eb44d8a74c19e50f79a8ed393e96d634","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47264","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.070","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: core: Fix Null-point-dereference in fmt_single_name()\n\nCheck the return value of devm_kstrdup() in case of\nNull-point-dereference."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/047fd16015a79180771650aa6ce71f68b2c23368","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0e2c9aeb00289f279b8181fbd4c20765127d8943","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/41daf6ba594d55f201c50280ebcd430590441da1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47265","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.147","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA: Verify port when creating flow rule\n\nValidate port value provided by the user and with that remove no longer\nneeded validation by the driver.  The missing check in the mlx5_ib driver\ncould cause to the below oops.\n\nCall trace:\n  _create_flow_rule+0x2d4\/0xf28 [mlx5_ib]\n  mlx5_ib_create_flow+0x2d0\/0x5b0 [mlx5_ib]\n  ib_uverbs_ex_create_flow+0x4cc\/0x624 [ib_uverbs]\n  ib_uverbs_handler_UVERBS_METHOD_INVOKE_WRITE+0xd4\/0x150 [ib_uverbs]\n  ib_uverbs_cmd_verbs.isra.7+0xb28\/0xc50 [ib_uverbs]\n  ib_uverbs_ioctl+0x158\/0x1d0 [ib_uverbs]\n  do_vfs_ioctl+0xd0\/0xaf0\n  ksys_ioctl+0x84\/0xb4\n  __arm64_sys_ioctl+0x28\/0xc4\n  el0_svc_common.constprop.3+0xa4\/0x254\n  el0_svc_handler+0x84\/0xa0\n  el0_svc+0x10\/0x26c\n Code: b9401260 f9615681 51000400 8b001c20 (f9403c1a)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2adcb4c5a52a2623cd2b43efa7041e74d19f3a5e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8dc1b0e0ca204596c50bcd159ee069ae0f998176","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47266","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.213","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA\/ipoib: Fix warning caused by destroying non-initial netns\n\nAfter the commit 5ce2dced8e95 (\"RDMA\/ipoib: Set rtnl_link_ops for ipoib\ninterfaces\"), if the IPoIB device is moved to non-initial netns,\ndestroying that netns lets the device vanish instead of moving it back to\nthe initial netns, This is happening because default_device_exit() skips\nthe interfaces due to having rtnl_link_ops set.\n\nSteps to reporoduce:\n  ip netns add foo\n  ip link set mlx5_ib0 netns foo\n  ip netns delete foo\n\nWARNING: CPU: 1 PID: 704 at net\/core\/dev.c:11435 netdev_exit+0x3f\/0x50\nModules linked in: xt_CHECKSUM xt_MASQUERADE xt_conntrack ipt_REJECT\nnf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack\nnf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink tun d\n fuse\nCPU: 1 PID: 704 Comm: kworker\/u64:3 Tainted: G S      W  5.13.0-rc1+ #1\nHardware name: Dell Inc. PowerEdge R630\/02C2CP, BIOS 2.1.5 04\/11\/2016\nWorkqueue: netns cleanup_net\nRIP: 0010:netdev_exit+0x3f\/0x50\nCode: 48 8b bb 30 01 00 00 e8 ef 81 b1 ff 48 81 fb c0 3a 54 a1 74 13 48\n8b 83 90 00 00 00 48 81 c3 90 00 00 00 48 39 d8 75 02 5b c3 <0f> 0b 5b\nc3 66 66 2e 0f 1f 84 00 00 00 00 00 66 90 0f 1f 44 00\nRSP: 0018:ffffb297079d7e08 EFLAGS: 00010206\nRAX: ffff8eb542c00040 RBX: ffff8eb541333150 RCX: 000000008010000d\nRDX: 000000008010000e RSI: 000000008010000d RDI: ffff8eb440042c00\nRBP: ffffb297079d7e48 R08: 0000000000000001 R09: ffffffff9fdeac00\nR10: ffff8eb5003be000 R11: 0000000000000001 R12: ffffffffa1545620\nR13: ffffffffa1545628 R14: 0000000000000000 R15: ffffffffa1543b20\nFS:  0000000000000000(0000) GS:ffff8ed37fa00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00005601b5f4c2e8 CR3: 0000001fc8c10002 CR4: 00000000003706e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n ops_exit_list.isra.9+0x36\/0x70\n cleanup_net+0x234\/0x390\n process_one_work+0x1cb\/0x360\n ? process_one_work+0x360\/0x360\n worker_thread+0x30\/0x370\n ? process_one_work+0x360\/0x360\n kthread+0x116\/0x130\n ? kthread_park+0x80\/0x80\n ret_from_fork+0x22\/0x30\n\nTo avoid the above warning and later on the kernel panic that could happen\non shutdown due to a NULL pointer dereference, make sure to set the\nnetns_refund flag that was introduced by commit 3a5ca857079e (\"can: dev:\nMove device back to init netns on owning netns delete\") to properly\nrestore the IPoIB interfaces to the initial netns."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0a672f7d89db2da17ae02733ccc08458be72a6f8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/64f1fb6acc2ab95982fc4334f351d7576c26f313","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/67cf4e447b5e5e9e94996cb6812ae2828e0e0e27","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a3e74fb9247cd530dca246699d5eb5a691884d32","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47267","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.297","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: fix various gadget panics on 10gbps cabling\n\nusb_assign_descriptors() is called with 5 parameters,\nthe last 4 of which are the usb_descriptor_header for:\n  full-speed (USB1.1 - 12Mbps [including USB1.0 low-speed @ 1.5Mbps),\n  high-speed (USB2.0 - 480Mbps),\n  super-speed (USB3.0 - 5Gbps),\n  super-speed-plus (USB3.1 - 10Gbps).\n\nThe differences between full\/high\/super-speed descriptors are usually\nsubstantial (due to changes in the maximum usb block size from 64 to 512\nto 1024 bytes and other differences in the specs), while the difference\nbetween 5 and 10Gbps descriptors may be as little as nothing\n(in many cases the same tuning is simply good enough).\n\nHowever if a gadget driver calls usb_assign_descriptors() with\na NULL descriptor for super-speed-plus and is then used on a max 10gbps\nconfiguration, the kernel will crash with a null pointer dereference,\nwhen a 10gbps capable device port + cable + host port combination shows up.\n(This wouldn't happen if the gadget max-speed was set to 5gbps, but\nit of course defaults to the maximum, and there's no real reason to\nartificially limit it)\n\nThe fix is to simply use the 5gbps descriptor as the 10gbps descriptor,\nif a 10gbps descriptor wasn't provided.\n\nObviously this won't fix the problem if the 5gbps descriptor is also\nNULL, but such cases can't be so trivially solved (and any such gadgets\nare unlikely to be used with USB3 ports any way)."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/032e288097a553db5653af552dd8035cd2a0ba96","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/45f9a2fe737dc0a5df270787f2231aee8985cd59","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5ef23506695b01d5d56a13a092a97f2478069d75","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/70cd19cb5bd94bbb5bacfc9c1e4ee0071699a604","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b972eff874637402ddc4a7dd11fb22538a0b6d28","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca6bc277430d90375452b60b047763a090b7673e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fd24be23abf3e94260be0f00bb42c7e91d495f87","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47268","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.390","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: tcpm: cancel vdm and state machine hrtimer when unregister tcpm port\n\nA pending hrtimer may expire after the kthread_worker of tcpm port\nis destroyed, see below kernel dump when do module unload, fix it\nby cancel the 2 hrtimers.\n\n[  111.517018] Unable to handle kernel paging request at virtual address ffff8000118cb880\n[  111.518786] blk_update_request: I\/O error, dev sda, sector 60061185 op 0x0:(READ) flags 0x0 phys_seg 1 prio class 0\n[  111.526594] Mem abort info:\n[  111.526597]   ESR = 0x96000047\n[  111.526600]   EC = 0x25: DABT (current EL), IL = 32 bits\n[  111.526604]   SET = 0, FnV = 0\n[  111.526607]   EA = 0, S1PTW = 0\n[  111.526610] Data abort info:\n[  111.526612]   ISV = 0, ISS = 0x00000047\n[  111.526615]   CM = 0, WnR = 1\n[  111.526619] swapper pgtable: 4k pages, 48-bit VAs, pgdp=0000000041d75000\n[  111.526623] [ffff8000118cb880] pgd=10000001bffff003, p4d=10000001bffff003, pud=10000001bfffe003, pmd=10000001bfffa003, pte=0000000000000000\n[  111.526642] Internal error: Oops: 96000047 [#1] PREEMPT SMP\n[  111.526647] Modules linked in: dwc3_imx8mp dwc3 phy_fsl_imx8mq_usb [last unloaded: tcpci]\n[  111.526663] CPU: 0 PID: 0 Comm: swapper\/0 Not tainted 5.13.0-rc4-00927-gebbe9dbd802c-dirty #36\n[  111.526670] Hardware name: NXP i.MX8MPlus EVK board (DT)\n[  111.526674] pstate: 800000c5 (Nzcv daIF -PAN -UAO -TCO BTYPE=--)\n[  111.526681] pc : queued_spin_lock_slowpath+0x1a0\/0x390\n[  111.526695] lr : _raw_spin_lock_irqsave+0x88\/0xb4\n[  111.526703] sp : ffff800010003e20\n[  111.526706] x29: ffff800010003e20 x28: ffff00017f380180\n[  111.537156] buffer_io_error: 6 callbacks suppressed\n[  111.537162] Buffer I\/O error on dev sda1, logical block 60040704, async page read\n[  111.539932]  x27: ffff00017f3801c0\n[  111.539938] x26: ffff800010ba2490 x25: 0000000000000000 x24: 0000000000000001\n[  111.543025] blk_update_request: I\/O error, dev sda, sector 60061186 op 0x0:(READ) flags 0x0 phys_seg 7 prio class 0\n[  111.548304]\n[  111.548306] x23: 00000000000000c0 x22: ffff0000c2a9f184 x21: ffff00017f380180\n[  111.551374] Buffer I\/O error on dev sda1, logical block 60040705, async page read\n[  111.554499]\n[  111.554503] x20: ffff0000c5f14210 x19: 00000000000000c0 x18: 0000000000000000\n[  111.557391] Buffer I\/O error on dev sda1, logical block 60040706, async page read\n[  111.561218]\n[  111.561222] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\n[  111.564205] Buffer I\/O error on dev sda1, logical block 60040707, async page read\n[  111.570887] x14: 00000000000000f5 x13: 0000000000000001 x12: 0000000000000040\n[  111.570902] x11: ffff0000c05ac6d8\n[  111.583420] Buffer I\/O error on dev sda1, logical block 60040708, async page read\n[  111.588978]  x10: 0000000000000000 x9 : 0000000000040000\n[  111.588988] x8 : 0000000000000000\n[  111.597173] Buffer I\/O error on dev sda1, logical block 60040709, async page read\n[  111.605766]  x7 : ffff00017f384880 x6 : ffff8000118cb880\n[  111.605777] x5 : ffff00017f384880\n[  111.611094] Buffer I\/O error on dev sda1, logical block 60040710, async page read\n[  111.617086]  x4 : 0000000000000000 x3 : ffff0000c2a9f184\n[  111.617096] x2 : ffff8000118cb880\n[  111.622242] Buffer I\/O error on dev sda1, logical block 60040711, async page read\n[  111.626927]  x1 : ffff8000118cb880 x0 : ffff00017f384888\n[  111.626938] Call trace:\n[  111.626942]  queued_spin_lock_slowpath+0x1a0\/0x390\n[  111.795809]  kthread_queue_work+0x30\/0xc0\n[  111.799828]  state_machine_timer_handler+0x20\/0x30\n[  111.804624]  __hrtimer_run_queues+0x140\/0x1e0\n[  111.808990]  hrtimer_interrupt+0xec\/0x2c0\n[  111.813004]  arch_timer_handler_phys+0x38\/0x50\n[  111.817456]  handle_percpu_devid_irq+0x88\/0x150\n[  111.821991]  __handle_domain_irq+0x80\/0xe0\n[  111.826093]  gic_handle_irq+0xc0\/0x140\n[  111.829848]  el1_irq+0xbc\/0x154\n[  111.832991]  arch_cpu_idle+0x1c\/0x2c\n[  111.836572]  default_idle_call+0x24\/0x6c\n[  111.840497]  do_idle+0x238\/0x2ac\n[  1\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/18eaf0de50eadeeb395b83310b259b21ad8ed0a6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3a13ff7ef4349d70d1d18378d661117dd5af8efe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0a06696a8a4d99f649240b6f9b8a2e55452ecf5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47269","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.470","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3: ep0: fix NULL pointer exception\n\nThere is no validation of the index from dwc3_wIndex_to_dep() and we might\nbe referring a non-existing ep and trigger a NULL pointer exception. In\ncertain configurations we might use fewer eps and the index might wrongly\nindicate a larger ep index than existing.\n\nBy adding this validation from the patch we can actually report a wrong\nindex back to the caller.\n\nIn our usecase we are using a composite device on an older kernel, but\nupstream might use this fix also. Unfortunately, I cannot describe the\nhardware for others to reproduce the issue as it is a proprietary\nimplementation.\n\n[   82.958261] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000a4\n[   82.966891] Mem abort info:\n[   82.969663]   ESR = 0x96000006\n[   82.972703]   Exception class = DABT (current EL), IL = 32 bits\n[   82.978603]   SET = 0, FnV = 0\n[   82.981642]   EA = 0, S1PTW = 0\n[   82.984765] Data abort info:\n[   82.987631]   ISV = 0, ISS = 0x00000006\n[   82.991449]   CM = 0, WnR = 0\n[   82.994409] user pgtable: 4k pages, 39-bit VAs, pgdp = 00000000c6210ccc\n[   83.000999] [00000000000000a4] pgd=0000000053aa5003, pud=0000000053aa5003, pmd=0000000000000000\n[   83.009685] Internal error: Oops: 96000006 [#1] PREEMPT SMP\n[   83.026433] Process irq\/62-dwc3 (pid: 303, stack limit = 0x000000003985154c)\n[   83.033470] CPU: 0 PID: 303 Comm: irq\/62-dwc3 Not tainted 4.19.124 #1\n[   83.044836] pstate: 60000085 (nZCv daIf -PAN -UAO)\n[   83.049628] pc : dwc3_ep0_handle_feature+0x414\/0x43c\n[   83.054558] lr : dwc3_ep0_interrupt+0x3b4\/0xc94\n\n...\n\n[   83.141788] Call trace:\n[   83.144227]  dwc3_ep0_handle_feature+0x414\/0x43c\n[   83.148823]  dwc3_ep0_interrupt+0x3b4\/0xc94\n[   83.181546] ---[ end trace aac6b5267d84c32f ]---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/366369b89bedd59b1425386e8d4a18a466e420e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/470403639114895e2697c766fbe17be8d0e9b67a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/60156089f07e724e4dc8483702d5e1ede4522749","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/788755756dd4a6aba1de479fec20b0fa600e7f19","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/96b74a99d360235c24052f1d060e64ac53f43528","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/990dc90750772622d44ca2ea6652c521e6f67e16","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bd551e7c85939de2182010273450bfa78c3742fc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d00889080ab60051627dab1d85831cd9db750e2a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47270","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.540","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: fix various gadgets null ptr deref on 10gbps cabling.\n\nThis avoids a null pointer dereference in\nf_{ecm,eem,hid,loopback,printer,rndis,serial,sourcesink,subset,tcm}\nby simply reusing the 5gbps config for 10gbps."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/10770d2ac0094b053c8897d96d7b2737cd72f7c5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4b289a0f3033f465b4fd51ba995251a7867a2aa2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8cd5f45c1b769e3e9e0f4325dd08b6c3749dc7ee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90c4d05780d47e14a50e11a7f17373104cd47d25","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4903f7fdc484628d0b8022daf86e2439d3ab4db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/beb1e67a5ca8d69703c776db9000527f44c0c93c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f17aae7c4009160f0630a91842a281773976a5bc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47271","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.610","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: cdnsp: Fix deadlock issue in cdnsp_thread_irq_handler\n\nPatch fixes the following critical issue caused by deadlock which has been\ndetected during testing NCM class:\n\nsmp: csd: Detected non-responsive CSD lock (#1) on CPU#0\nsmp:     csd: CSD lock (#1) unresponsive.\n....\nRIP: 0010:native_queued_spin_lock_slowpath+0x61\/0x1d0\nRSP: 0018:ffffbc494011cde0 EFLAGS: 00000002\nRAX: 0000000000000101 RBX: ffff9ee8116b4a68 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff9ee8116b4658\nRBP: ffffbc494011cde0 R08: 0000000000000001 R09: 0000000000000000\nR10: ffff9ee8116b4670 R11: 0000000000000000 R12: ffff9ee8116b4658\nR13: ffff9ee8116b4670 R14: 0000000000000246 R15: ffff9ee8116b4658\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f7bcc41a830 CR3: 000000007a612003 CR4: 00000000001706e0\nCall Trace:\n <IRQ>\n do_raw_spin_lock+0xc0\/0xd0\n _raw_spin_lock_irqsave+0x95\/0xa0\n cdnsp_gadget_ep_queue.cold+0x88\/0x107 [cdnsp_udc_pci]\n usb_ep_queue+0x35\/0x110\n eth_start_xmit+0x220\/0x3d0 [u_ether]\n ncm_tx_timeout+0x34\/0x40 [usb_f_ncm]\n ? ncm_free_inst+0x50\/0x50 [usb_f_ncm]\n __hrtimer_run_queues+0xac\/0x440\n hrtimer_run_softirq+0x8c\/0xb0\n __do_softirq+0xcf\/0x428\n asm_call_irq_on_stack+0x12\/0x20\n <\/IRQ>\n do_softirq_own_stack+0x61\/0x70\n irq_exit_rcu+0xc1\/0xd0\n sysvec_apic_timer_interrupt+0x52\/0xb0\n asm_sysvec_apic_timer_interrupt+0x12\/0x20\nRIP: 0010:do_raw_spin_trylock+0x18\/0x40\nRSP: 0018:ffffbc494138bda8 EFLAGS: 00000246\nRAX: 0000000000000000 RBX: ffff9ee8116b4658 RCX: 0000000000000000\nRDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff9ee8116b4658\nRBP: ffffbc494138bda8 R08: 0000000000000001 R09: 0000000000000000\nR10: ffff9ee8116b4670 R11: 0000000000000000 R12: ffff9ee8116b4658\nR13: ffff9ee8116b4670 R14: ffff9ee7b5c73d80 R15: ffff9ee8116b4000\n _raw_spin_lock+0x3d\/0x70\n ? cdnsp_thread_irq_handler.cold+0x32\/0x112c [cdnsp_udc_pci]\n cdnsp_thread_irq_handler.cold+0x32\/0x112c [cdnsp_udc_pci]\n ? cdnsp_remove_request+0x1f0\/0x1f0 [cdnsp_udc_pci]\n ? cdnsp_thread_irq_handler+0x5\/0xa0 [cdnsp_udc_pci]\n ? irq_thread+0xa0\/0x1c0\n irq_thread_fn+0x28\/0x60\n irq_thread+0x105\/0x1c0\n ? __kthread_parkme+0x42\/0x90\n ? irq_forced_thread_fn+0x90\/0x90\n ? wake_threads_waitq+0x30\/0x30\n ? irq_thread_check_affinity+0xe0\/0xe0\n kthread+0x12a\/0x160\n ? kthread_park+0x90\/0x90\n ret_from_fork+0x22\/0x30\n\nThe root cause of issue is spin_lock\/spin_unlock instruction instead\nspin_lock_irqsave\/spin_lock_irqrestore in cdnsp_thread_irq_handler\nfunction."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/a9aecef198faae3240921b707bc09b602e966fce","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ae746b6f4ce619cf4032fd798a232b010907a397","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47272","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.687","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3: gadget: Bail from dwc3_gadget_exit() if dwc->gadget is NULL\n\nThere exists a possible scenario in which dwc3_gadget_init() can fail:\nduring during host -> peripheral mode switch in dwc3_set_mode(), and\na pending gadget driver fails to bind.  Then, if the DRD undergoes\nanother mode switch from peripheral->host the resulting\ndwc3_gadget_exit() will attempt to reference an invalid and dangling\ndwc->gadget pointer as well as call dma_free_coherent() on unmapped\nDMA pointers.\n\nThe exact scenario can be reproduced as follows:\n - Start DWC3 in peripheral mode\n - Configure ConfigFS gadget with FunctionFS instance (or use g_ffs)\n - Run FunctionFS userspace application (open EPs, write descriptors, etc)\n - Bind gadget driver to DWC3's UDC\n - Switch DWC3 to host mode\n   => dwc3_gadget_exit() is called. usb_del_gadget() will put the\n\tConfigFS driver instance on the gadget_driver_pending_list\n - Stop FunctionFS application (closes the ep files)\n - Switch DWC3 to peripheral mode\n   => dwc3_gadget_init() fails as usb_add_gadget() calls\n\tcheck_pending_gadget_drivers() and attempts to rebind the UDC\n\tto the ConfigFS gadget but fails with -19 (-ENODEV) because the\n\tFFS instance is not in FFS_ACTIVE state (userspace has not\n\tre-opened and written the descriptors yet, i.e. desc_ready!=0).\n - Switch DWC3 back to host mode\n   => dwc3_gadget_exit() is called again, but this time dwc->gadget\n\tis invalid.\n\nAlthough it can be argued that userspace should take responsibility\nfor ensuring that the FunctionFS application be ready prior to\nallowing the composite driver bind to the UDC, failure to do so\nshould not result in a panic from the kernel driver.\n\nFix this by setting dwc->gadget to NULL in the failure path of\ndwc3_gadget_init() and add a check to dwc3_gadget_exit() to bail out\nunless the gadget pointer is valid."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/03715ea2e3dbbc56947137ce3b4ac18a726b2f87","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4aad390363d2b9b3e92428dd34d27bb7ea8f1ee8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/851dee5a5da56564a70290713aee665403bb0b24","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47273","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.760","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3-meson-g12a: fix usb2 PHY glue init when phy0 is disabled\n\nWhen only PHY1 is used (for example on Odroid-HC4), the regmap init code\nuses the usb2 ports when doesn't initialize the PHY1 regmap entry.\n\nThis fixes:\nUnable to handle kernel NULL pointer dereference at virtual address 0000000000000020\n...\npc : regmap_update_bits_base+0x40\/0xa0\nlr : dwc3_meson_g12a_usb2_init_phy+0x4c\/0xf8\n...\nCall trace:\nregmap_update_bits_base+0x40\/0xa0\ndwc3_meson_g12a_usb2_init_phy+0x4c\/0xf8\ndwc3_meson_g12a_usb2_init+0x7c\/0xc8\ndwc3_meson_g12a_usb_init+0x28\/0x48\ndwc3_meson_g12a_probe+0x298\/0x540\nplatform_probe+0x70\/0xe0\nreally_probe+0xf0\/0x4d8\ndriver_probe_device+0xfc\/0x168\n..."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4d2aa178d2ad2fb156711113790dde13e9aa2376","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/750a0d75564293be3ed50f13ef7f38ab75106421","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d8dd3754e707104a34f8ec595034d503ea8871a2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47274","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.830","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Correct the length check which causes memory corruption\n\nWe've suffered from severe kernel crashes due to memory corruption on\nour production environment, like,\n\nCall Trace:\n[1640542.554277] general protection fault: 0000 [#1] SMP PTI\n[1640542.554856] CPU: 17 PID: 26996 Comm: python Kdump: loaded Tainted:G\n[1640542.556629] RIP: 0010:kmem_cache_alloc+0x90\/0x190\n[1640542.559074] RSP: 0018:ffffb16faa597df8 EFLAGS: 00010286\n[1640542.559587] RAX: 0000000000000000 RBX: 0000000000400200 RCX:\n0000000006e931bf\n[1640542.560323] RDX: 0000000006e931be RSI: 0000000000400200 RDI:\nffff9a45ff004300\n[1640542.560996] RBP: 0000000000400200 R08: 0000000000023420 R09:\n0000000000000000\n[1640542.561670] R10: 0000000000000000 R11: 0000000000000000 R12:\nffffffff9a20608d\n[1640542.562366] R13: ffff9a45ff004300 R14: ffff9a45ff004300 R15:\n696c662f65636976\n[1640542.563128] FS:  00007f45d7c6f740(0000) GS:ffff9a45ff840000(0000)\nknlGS:0000000000000000\n[1640542.563937] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[1640542.564557] CR2: 00007f45d71311a0 CR3: 000000189d63e004 CR4:\n00000000003606e0\n[1640542.565279] DR0: 0000000000000000 DR1: 0000000000000000 DR2:\n0000000000000000\n[1640542.566069] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:\n0000000000000400\n[1640542.566742] Call Trace:\n[1640542.567009]  anon_vma_clone+0x5d\/0x170\n[1640542.567417]  __split_vma+0x91\/0x1a0\n[1640542.567777]  do_munmap+0x2c6\/0x320\n[1640542.568128]  vm_munmap+0x54\/0x70\n[1640542.569990]  __x64_sys_munmap+0x22\/0x30\n[1640542.572005]  do_syscall_64+0x5b\/0x1b0\n[1640542.573724]  entry_SYSCALL_64_after_hwframe+0x44\/0xa9\n[1640542.575642] RIP: 0033:0x7f45d6e61e27\n\nJames Wang has reproduced it stably on the latest 4.19 LTS.\nAfter some debugging, we finally proved that it's due to ftrace\nbuffer out-of-bound access using a debug tool as follows:\n[   86.775200] BUG: Out-of-bounds write at addr 0xffff88aefe8b7000\n[   86.780806]  no_context+0xdf\/0x3c0\n[   86.784327]  __do_page_fault+0x252\/0x470\n[   86.788367]  do_page_fault+0x32\/0x140\n[   86.792145]  page_fault+0x1e\/0x30\n[   86.795576]  strncpy_from_unsafe+0x66\/0xb0\n[   86.799789]  fetch_memory_string+0x25\/0x40\n[   86.804002]  fetch_deref_string+0x51\/0x60\n[   86.808134]  kprobe_trace_func+0x32d\/0x3a0\n[   86.812347]  kprobe_dispatcher+0x45\/0x50\n[   86.816385]  kprobe_ftrace_handler+0x90\/0xf0\n[   86.820779]  ftrace_ops_assist_func+0xa1\/0x140\n[   86.825340]  0xffffffffc00750bf\n[   86.828603]  do_sys_open+0x5\/0x1f0\n[   86.832124]  do_syscall_64+0x5b\/0x1b0\n[   86.835900]  entry_SYSCALL_64_after_hwframe+0x44\/0xa9\n\ncommit b220c049d519 (\"tracing: Check length before giving out\nthe filter buffer\") adds length check to protect trace data\noverflow introduced in 0fc1b09ff1ff, seems that this fix can't prevent\noverflow entirely, the length check should also take the sizeof\nentry->array[0] into account, since this array[0] is filled the\nlength of trace data and occupy addtional space and risk overflow."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2d598902799886d67947406f26ee8e5fd2ca097f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/31ceae385556c37e4d286cb6378696448f566883","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3e08a9f9760f4a70d633c328a76408e62d6f80a3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/43c32c22254b9328d7abb1c2b0f689dc67838e60","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b16a249eca2230c2cd66fa1d4b94743bd9b6ef92","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d63f00ec908b3be635ead5d6029cc94246e1f38d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/edcce01e0e50840a9aa6a70baed21477bdd2c9f9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47275","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.903","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbcache: avoid oversized read request in cache missing code path\n\nIn the cache missing code path of cached device, if a proper location\nfrom the internal B+ tree is matched for a cache miss range, function\ncached_dev_cache_miss() will be called in cache_lookup_fn() in the\nfollowing code block,\n[code block 1]\n  526         unsigned int sectors = KEY_INODE(k) == s->iop.inode\n  527                 ? min_t(uint64_t, INT_MAX,\n  528                         KEY_START(k) - bio->bi_iter.bi_sector)\n  529                 : INT_MAX;\n  530         int ret = s->d->cache_miss(b, s, bio, sectors);\n\nHere s->d->cache_miss() is the call backfunction pointer initialized as\ncached_dev_cache_miss(), the last parameter 'sectors' is an important\nhint to calculate the size of read request to backing device of the\nmissing cache data.\n\nCurrent calculation in above code block may generate oversized value of\n'sectors', which consequently may trigger 2 different potential kernel\npanics by BUG() or BUG_ON() as listed below,\n\n1) BUG_ON() inside bch_btree_insert_key(),\n[code block 2]\n   886         BUG_ON(b->ops->is_extents && !KEY_SIZE(k));\n2) BUG() inside biovec_slab(),\n[code block 3]\n   51         default:\n   52                 BUG();\n   53                 return NULL;\n\nAll the above panics are original from cached_dev_cache_miss() by the\noversized parameter 'sectors'.\n\nInside cached_dev_cache_miss(), parameter 'sectors' is used to calculate\nthe size of data read from backing device for the cache missing. This\nsize is stored in s->insert_bio_sectors by the following lines of code,\n[code block 4]\n  909    s->insert_bio_sectors = min(sectors, bio_sectors(bio) + reada);\n\nThen the actual key inserting to the internal B+ tree is generated and\nstored in s->iop.replace_key by the following lines of code,\n[code block 5]\n  911   s->iop.replace_key = KEY(s->iop.inode,\n  912                    bio->bi_iter.bi_sector + s->insert_bio_sectors,\n  913                    s->insert_bio_sectors);\nThe oversized parameter 'sectors' may trigger panic 1) by BUG_ON() from\nthe above code block.\n\nAnd the bio sending to backing device for the missing data is allocated\nwith hint from s->insert_bio_sectors by the following lines of code,\n[code block 6]\n  926    cache_bio = bio_alloc_bioset(GFP_NOWAIT,\n  927                 DIV_ROUND_UP(s->insert_bio_sectors, PAGE_SECTORS),\n  928                 &dc->disk.bio_split);\nThe oversized parameter 'sectors' may trigger panic 2) by BUG() from the\nagove code block.\n\nNow let me explain how the panics happen with the oversized 'sectors'.\nIn code block 5, replace_key is generated by macro KEY(). From the\ndefinition of macro KEY(),\n[code block 7]\n  71 #define KEY(inode, offset, size)                                  \\\n  72 ((struct bkey) {                                                  \\\n  73      .high = (1ULL << 63) | ((__u64) (size) << 20) | (inode),     \\\n  74      .low = (offset)                                              \\\n  75 })\n\nHere 'size' is 16bits width embedded in 64bits member 'high' of struct\nbkey. But in code block 1, if \"KEY_START(k) - bio->bi_iter.bi_sector\" is\nvery probably to be larger than (1<<16) - 1, which makes the bkey size\ncalculation in code block 5 is overflowed. In one bug report the value\nof parameter 'sectors' is 131072 (= 1 << 17), the overflowed 'sectors'\nresults the overflowed s->insert_bio_sectors in code block 4, then makes\nsize field of s->iop.replace_key to be 0 in code block 5. Then the 0-\nsized s->iop.replace_key is inserted into the internal B+ tree as cache\nmissing check key (a special key to detect and avoid a racing between\nnormal write request and cache missing read request) as,\n[code block 8]\n  915   ret = bch_btree_insert_check_key(b, &s->op, &s->iop.replace_key);\n\nThen the 0-sized s->iop.replace_key as 3rd parameter triggers the bkey\nsize check BUG_ON() in code block 2, and causes the kernel panic 1).\n\nAnother ke\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/41fe8d088e96472f63164e213de44ec77be69478","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/555002a840ab88468e252b0eedf0b05e2ce7099c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47276","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:15.983","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nftrace: Do not blindly read the ip address in ftrace_bug()\n\nIt was reported that a bug on arm64 caused a bad ip address to be used for\nupdating into a nop in ftrace_init(), but the error path (rightfully)\nreturned -EINVAL and not -EFAULT, as the bug caused more than one error to\noccur. But because -EINVAL was returned, the ftrace_bug() tried to report\nwhat was at the location of the ip address, and read it directly. This\ncaused the machine to panic, as the ip was not pointing to a valid memory\naddress.\n\nInstead, read the ip address with copy_from_kernel_nofault() to safely\naccess the memory, and if it faults, report that the address faulted,\notherwise report what was in that location."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0bc62e398bbd9e600959e610def5109957437b28","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3e4ddeb68751fb4fb657199aed9cfd5d02796875","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4aedc2bc2b32c93555f47c95610efb89cc1ec09b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6c14133d2d3f768e0a35128faac8aa6ed4815051","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7e4e824b109f1d41ccf223fbb0565d877d6223a2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/862dcc14f2803c556bdd73b43c27b023fafce2fb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/97524384762c1fb9b3ded931498dd2047bd0de81","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/acf671ba79c1feccc3ec7cfdcffead4efcec49e7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47277","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.053","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nkvm: avoid speculation-based attacks from out-of-range memslot accesses\n\nKVM's mechanism for accessing guest memory translates a guest physical\naddress (gpa) to a host virtual address using the right-shifted gpa\n(also known as gfn) and a struct kvm_memory_slot.  The translation is\nperformed in __gfn_to_hva_memslot using the following formula:\n\n      hva = slot->userspace_addr + (gfn - slot->base_gfn) * PAGE_SIZE\n\nIt is expected that gfn falls within the boundaries of the guest's\nphysical memory.  However, a guest can access invalid physical addresses\nin such a way that the gfn is invalid.\n\n__gfn_to_hva_memslot is called from kvm_vcpu_gfn_to_hva_prot, which first\nretrieves a memslot through __gfn_to_memslot.  While __gfn_to_memslot\ndoes check that the gfn falls within the boundaries of the guest's\nphysical memory or not, a CPU can speculate the result of the check and\ncontinue execution speculatively using an illegal gfn. The speculation\ncan result in calculating an out-of-bounds hva.  If the resulting host\nvirtual address is used to load another guest physical address, this\nis effectively a Spectre gadget consisting of two consecutive reads,\nthe second of which is data dependent on the first.\n\nRight now it's not clear if there are any cases in which this is\nexploitable.  One interesting case was reported by the original author\nof this patch, and involves visiting guest page tables on x86.  Right\nnow these are not vulnerable because the hva read goes through get_user(),\nwhich contains an LFENCE speculation barrier.  However, there are\npatches in progress for x86 uaccess.h to mask kernel addresses instead of\nusing LFENCE; once these land, a guest could use speculation to read\nfrom the VMM's ring 3 address space.  Other architectures such as ARM\nalready use the address masking method, and would be susceptible to\nthis same kind of data-dependent access gadgets.  Therefore, this patch\nproactively protects from these attacks by masking out-of-bounds gfns\nin __gfn_to_hva_memslot, which blocks speculation of invalid hvas.\n\nSean Christopherson noted that this patch does not cover\nkvm_read_guest_offset_cached.  This however is limited to a few bytes\npast the end of the cache, and therefore it is unlikely to be useful in\nthe context of building a chain of data dependent accesses."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/22b87fb17a28d37331bb9c1110737627b17f6781","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3098b86390a6b9ea52657689f08410baf130ceff","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/361ce3b917aff93123e9e966d8608655c967f438","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/740621309b25bbf619b8a0ba5fd50a8e58989441","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7af299b97734c7e7f465b42a2139ce4d77246975","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bff1fbf0cf0712686f1df59a83fba6e31d2746a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/da27a83fd6cc7780fea190e1f5c19e87019da65c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ed0e2a893092c7fcb4ff7ba74e5efce53a6f5940","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47278","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.143","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbus: mhi: pci_generic: Fix possible use-after-free in mhi_pci_remove()\n\nThis driver's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0b67808ade8893a1b3608ddd74fac7854786c919","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c597d5c59c7a6417dba06590f59b922e01188e8d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47279","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.210","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: misc: brcmstb-usb-pinmap: check return value after calling platform_get_resource()\n\nIt will cause null-ptr-deref if platform_get_resource() returns NULL,\nwe need check the return value."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2147684be1ebdaf845783139b9bc4eba3fecd9e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fbf649cd6d64d40c03c5397ecd6b1ae922ba7afc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47280","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.277","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: Fix use-after-free read in drm_getunique()\n\nThere is a time-of-check-to-time-of-use error in drm_getunique() due\nto retrieving file_priv->master prior to locking the device's master\nmutex.\n\nAn example can be seen in the crash report of the use-after-free error\nfound by Syzbot:\nhttps:\/\/syzkaller.appspot.com\/bug?id=148d2f1dfac64af52ffd27b661981a540724f803\n\nIn the report, the master pointer was used after being freed. This is\nbecause another process had acquired the device's master mutex in\ndrm_setmaster_ioctl(), then overwrote fpriv->master in\ndrm_new_set_master(). The old value of fpriv->master was subsequently\nfreed before the mutex was unlocked.\n\nTo fix this, we lock the device's master mutex before retrieving the\npointer from from fpriv->master. This patch passes the Syzbot\nreproducer test."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/17dab9326ff263c62dab1dbac4492e2938a049e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/491d52e0078860b33b6c14f0a7ac74ca1b603bd6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7d233ba700ceb593905ea82b42dadb4ec8ef85e9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b246b4c70c1250e7814f409b243000f9c0bf79a3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b436acd1cf7fac0ba987abd22955d98025c80c2b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f773f8cccac13c7e7bbd9182e7996c727742488e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47281","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.353","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: seq: Fix race of snd_seq_timer_open()\n\nThe timer instance per queue is exclusive, and snd_seq_timer_open()\nshould have managed the concurrent accesses.  It looks as if it's\nchecking the already existing timer instance at the beginning, but\nit's not right, because there is no protection, hence any later\nconcurrent call of snd_seq_timer_open() may override the timer\ninstance easily.  This may result in UAF, as the leftover timer\ninstance can keep running while the queue itself gets closed, as\nspotted by syzkaller recently.\n\nFor avoiding the race, add a proper check at the assignment of\ntmr->timeri again, and return -EBUSY if it's been already registered."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/536a7646c00a0f14fee49e5e313109e5da2f6031","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/83e197a8414c0ba545e7e3916ce05f836f349273","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bd7d88b0874f82f7b29d1a53e574cedaf23166ba","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47282","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.430","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nspi: bcm2835: Fix out-of-bounds access with more than 4 slaves\n\nCommit 571e31fa60b3 (\"spi: bcm2835: Cache CS register value for\n->prepare_message()\") limited the number of slaves to 3 at compile-time.\nThe limitation was necessitated by a statically-sized array prepare_cs[]\nin the driver private data which contains a per-slave register value.\n\nThe commit sought to enforce the limitation at run-time by setting the\ncontroller's num_chipselect to 3:  Slaves with a higher chipselect are\nrejected by spi_add_device().\n\nHowever the commit neglected that num_chipselect only limits the number\nof *native* chipselects.  If GPIO chipselects are specified in the\ndevice tree for more than 3 slaves, num_chipselect is silently raised by\nof_spi_get_gpio_numbers() and the result are out-of-bounds accesses to\nthe statically-sized array prepare_cs[].\n\nAs a bandaid fix which is backportable to stable, raise the number of\nallowed slaves to 24 (which \"ought to be enough for anybody\"), enforce\nthe limitation on slave ->setup and revert num_chipselect to 3 (which is\nthe number of native chipselects supported by the controller).\nAn upcoming for-next commit will allow an arbitrary number of slaves."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/01415ff85a24308059e06ca3e97fd7bf75648690","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/13817d466eb8713a1ffd254f537402f091d48444","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/82a8ffba54d31e97582051cb56ba1f988018681e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b5502580cf958b094f3b69dfe4eece90eae01fbc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47283","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.503","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet:sfc: fix non-freed irq in legacy irq mode\n\nSFC driver can be configured via modparam to work using MSI-X, MSI or\nlegacy IRQ interrupts. In the last one, the interrupt was not properly\nreleased on module remove.\n\nIt was not freed because the flag irqs_hooked was not set during\ninitialization in the case of using legacy IRQ.\n\nExample of (trimmed) trace during module remove without this fix:\n\nremove_proc_entry: removing non-empty directory 'irq\/125', leaking at least '0000:3b:00.1'\nWARNING: CPU: 39 PID: 3658 at fs\/proc\/generic.c:715 remove_proc_entry+0x15c\/0x170\n...trimmed...\nCall Trace:\n unregister_irq_proc+0xe3\/0x100\n free_desc+0x29\/0x70\n irq_free_descs+0x47\/0x70\n mp_unmap_irq+0x58\/0x60\n acpi_unregister_gsi_ioapic+0x2a\/0x40\n acpi_pci_irq_disable+0x78\/0xb0\n pci_disable_device+0xd1\/0x100\n efx_pci_remove+0xa1\/0x1e0 [sfc]\n pci_device_remove+0x38\/0xa0\n __device_release_driver+0x177\/0x230\n driver_detach+0xcb\/0x110\n bus_remove_driver+0x58\/0xd0\n pci_unregister_driver+0x2a\/0xb0\n efx_exit_module+0x24\/0xf40 [sfc]\n __do_sys_delete_module.constprop.0+0x171\/0x280\n ? exit_to_user_mode_prepare+0x83\/0x1d0\n do_syscall_64+0x3d\/0x80\n entry_SYSCALL_64_after_hwframe+0x44\/0xae\nRIP: 0033:0x7f9f9385800b\n...trimmed..."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/81c4d1d83f88e15b26f4522a35cba6ffd8c5dfdd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8d717c9135a3340ae62d1699484850bfb4112b0c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f03eeb6e0a0a0b8d617ee0a4bce729e47130036","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47284","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.577","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nisdn: mISDN: netjet: Fix crash in nj_probe:\n\n'nj_setup' in netjet.c might fail with -EIO and in this case\n'card->irq' is initialized and is bigger than zero. A subsequent call to\n'nj_release' will free the irq that has not been requested.\n\nFix this bug by deleting the previous assignment to 'card->irq' and just\nkeep the assignment before 'request_irq'.\n\nThe KASAN's log reveals it:\n\n[    3.354615 ] WARNING: CPU: 0 PID: 1 at kernel\/irq\/manage.c:1826\nfree_irq+0x100\/0x480\n[    3.355112 ] Modules linked in:\n[    3.355310 ] CPU: 0 PID: 1 Comm: swapper\/0 Not tainted\n5.13.0-rc1-00144-g25a1298726e #13\n[    3.355816 ] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\nrel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04\/01\/2014\n[    3.356552 ] RIP: 0010:free_irq+0x100\/0x480\n[    3.356820 ] Code: 6e 08 74 6f 4d 89 f4 e8 5e ac 09 00 4d 8b 74 24 18\n4d 85 f6 75 e3 e8 4f ac 09 00 8b 75 c8 48 c7 c7 78 c1 2e 85 e8 e0 cf f5\nff <0f> 0b 48 8b 75 c0 4c 89 ff e8 72 33 0b 03 48 8b 43 40 4c 8b a0 80\n[    3.358012 ] RSP: 0000:ffffc90000017b48 EFLAGS: 00010082\n[    3.358357 ] RAX: 0000000000000000 RBX: ffff888104dc8000 RCX:\n0000000000000000\n[    3.358814 ] RDX: ffff8881003c8000 RSI: ffffffff8124a9e6 RDI:\n00000000ffffffff\n[    3.359272 ] RBP: ffffc90000017b88 R08: 0000000000000000 R09:\n0000000000000000\n[    3.359732 ] R10: ffffc900000179f0 R11: 0000000000001d04 R12:\n0000000000000000\n[    3.360195 ] R13: ffff888107dc6000 R14: ffff888107dc6928 R15:\nffff888104dc80a8\n[    3.360652 ] FS:  0000000000000000(0000) GS:ffff88817bc00000(0000)\nknlGS:0000000000000000\n[    3.361170 ] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[    3.361538 ] CR2: 0000000000000000 CR3: 000000000582e000 CR4:\n00000000000006f0\n[    3.362003 ] DR0: 0000000000000000 DR1: 0000000000000000 DR2:\n0000000000000000\n[    3.362175 ] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:\n0000000000000400\n[    3.362175 ] Call Trace:\n[    3.362175 ]  nj_release+0x51\/0x1e0\n[    3.362175 ]  nj_probe+0x450\/0x950\n[    3.362175 ]  ? pci_device_remove+0x110\/0x110\n[    3.362175 ]  local_pci_probe+0x45\/0xa0\n[    3.362175 ]  pci_device_probe+0x12b\/0x1d0\n[    3.362175 ]  really_probe+0x2a9\/0x610\n[    3.362175 ]  driver_probe_device+0x90\/0x1d0\n[    3.362175 ]  ? mutex_lock_nested+0x1b\/0x20\n[    3.362175 ]  device_driver_attach+0x68\/0x70\n[    3.362175 ]  __driver_attach+0x124\/0x1b0\n[    3.362175 ]  ? device_driver_attach+0x70\/0x70\n[    3.362175 ]  bus_for_each_dev+0xbb\/0x110\n[    3.362175 ]  ? rdinit_setup+0x45\/0x45\n[    3.362175 ]  driver_attach+0x27\/0x30\n[    3.362175 ]  bus_add_driver+0x1eb\/0x2a0\n[    3.362175 ]  driver_register+0xa9\/0x180\n[    3.362175 ]  __pci_register_driver+0x82\/0x90\n[    3.362175 ]  ? w6692_init+0x38\/0x38\n[    3.362175 ]  nj_init+0x36\/0x38\n[    3.362175 ]  do_one_initcall+0x7f\/0x3d0\n[    3.362175 ]  ? rdinit_setup+0x45\/0x45\n[    3.362175 ]  ? rcu_read_lock_sched_held+0x4f\/0x80\n[    3.362175 ]  kernel_init_freeable+0x2aa\/0x301\n[    3.362175 ]  ? rest_init+0x2c0\/0x2c0\n[    3.362175 ]  kernel_init+0x18\/0x190\n[    3.362175 ]  ? rest_init+0x2c0\/0x2c0\n[    3.362175 ]  ? rest_init+0x2c0\/0x2c0\n[    3.362175 ]  ret_from_fork+0x1f\/0x30\n[    3.362175 ] Kernel panic - not syncing: panic_on_warn set ...\n[    3.362175 ] CPU: 0 PID: 1 Comm: swapper\/0 Not tainted\n5.13.0-rc1-00144-g25a1298726e #13\n[    3.362175 ] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\nrel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04\/01\/2014\n[    3.362175 ] Call Trace:\n[    3.362175 ]  dump_stack+0xba\/0xf5\n[    3.362175 ]  ? free_irq+0x100\/0x480\n[    3.362175 ]  panic+0x15a\/0x3f2\n[    3.362175 ]  ? __warn+0xf2\/0x150\n[    3.362175 ]  ? free_irq+0x100\/0x480\n[    3.362175 ]  __warn+0x108\/0x150\n[    3.362175 ]  ? free_irq+0x100\/0x480\n[    3.362175 ]  report_bug+0x119\/0x1c0\n[    3.362175 ]  handle_bug+0x3b\/0x80\n[    3.362175 ]  exc_invalid_op+0x18\/0x70\n[    3.362175 ]  asm_exc_invalid_op+0x12\/0x20\n[    3.362175 ] RIP: 0010:free_irq+0x100\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/143fc7220961220eecc04669e5909af8847bf8c8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4c1fcb6ec964b44edbf84235134582a5ffae1521","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6249193e03709ea625e10706ecaf17fea0427d3d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/958cb1078ca60d214826fd90a0961a447fade59a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9d7d4649dc1c53acf76df260fd519db698ed20d7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9f6f852550d0e1b7735651228116ae9d300f69b3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a0a37e4454ca1c0b424edc2c9c2487c2c46a1be6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bf78e25bd3f487208e042c67c8a31706c2dba265","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47285","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.653","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/nfc\/rawsock.c: fix a permission check bug\n\nThe function rawsock_create() calls a privileged function sk_alloc(), which requires a ns-aware check to check net->user_ns, i.e., ns_capable(). However, the original code checks the init_user_ns using capable(). So we replace the capable() with ns_capable()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1e5cab50208c8fb7351b798cb1d569debfeb994a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/38cb2e23188af29c43966acee9dbb18b62e26cfe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8ab78863e9eff11910e1ac8bcf478060c29b379e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90d0a3c76965d7a10fc87c07be3e9714e2130d5c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c08e0be44759d0b5affc5888be4aa5e536873335","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d6a21a3fb03300fbaa9fc3ed99f8b0962ce28362","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ec72482564ff99c6832d33610d9f8ab7ecc81b6d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f3ed12af6bbbaf79eddb0ae14656b8ecacea74f0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47286","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.723","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbus: mhi: core: Validate channel ID when processing command completions\n\nMHI reads the channel ID from the event ring element sent by the\ndevice which can be any value between 0 and 255. In order to\nprevent any out of bound accesses, add a check against the maximum\nnumber of channels supported by the controller and those channels\nnot configured yet so as to skip processing of that event ring\nelement."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3efec3b4b16fc7af25676a94230a8ab2a3bb867c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/546362a9ef2ef40b57c6605f14e88ced507f8dd0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aed4f5b51aba41e2afd7cfda20a0571a6a67dfe9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47287","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.797","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndriver core: auxiliary bus: Fix memory leak when driver_register() fail\n\nIf driver_register() returns with error we need to free the memory\nallocated for auxdrv->driver.name before returning from\n__auxiliary_driver_register()"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4afa0c22eed33cfe0c590742387f0d16f32412f3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ce5b3de58fc21303722df46551f7eb9a91afb409","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47288","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.867","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: ngene: Fix out-of-bounds bug in ngene_command_config_free_buf()\n\nFix an 11-year old bug in ngene_command_config_free_buf() while\naddressing the following warnings caught with -Warray-bounds:\n\narch\/alpha\/include\/asm\/string.h:22:16: warning: '__builtin_memcpy' offset [12, 16] from the object at 'com' is out of the bounds of referenced subobject 'config' with type 'unsigned char' at offset 10 [-Warray-bounds]\narch\/x86\/include\/asm\/string_32.h:182:25: warning: '__builtin_memcpy' offset [12, 16] from the object at 'com' is out of the bounds of referenced subobject 'config' with type 'unsigned char' at offset 10 [-Warray-bounds]\n\nThe problem is that the original code is trying to copy 6 bytes of\ndata into a one-byte size member _config_ of the wrong structue\nFW_CONFIGURE_BUFFERS, in a single call to memcpy(). This causes a\nlegitimate compiler warning because memcpy() overruns the length\nof &com.cmd.ConfigureBuffers.config. It seems that the right\nstructure is FW_CONFIGURE_FREE_BUFFERS, instead, because it contains\n6 more members apart from the header _hdr_. Also, the name of\nthe function ngene_command_config_free_buf() suggests that the actual\nintention is to ConfigureFreeBuffers, instead of ConfigureBuffers\n(which takes place in the function ngene_command_config_buf(), above).\n\nFix this by enclosing those 6 members of struct FW_CONFIGURE_FREE_BUFFERS\ninto new struct config, and use &com.cmd.ConfigureFreeBuffers.config as\nthe destination address, instead of &com.cmd.ConfigureBuffers.config,\nwhen calling memcpy().\n\nThis also helps with the ongoing efforts to globally enable\n-Warray-bounds and get us closer to being able to tighten the\nFORTIFY_SOURCE routines on memcpy()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4487b968e5eacd02c493303dc2b61150bb7fe4b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8d4abca95ecc82fc8c41912fa0085281f19cc29f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b9a178f189bb6d75293573e181928735f5e3e070","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c6ddeb63dd543b5474b0217c4e47538b7ffd7686","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e617fa62f6cf859a7b042cdd6c73af905ff8fca3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e818f2ff648581a6c553ae2bebc5dcef9a8bb90c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e991457afdcb5f4dbc5bc9d79eaf775be33e7092","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ec731c6ef564ee6fc101fc5d73e3a3a953d09a00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47289","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:16.950","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: fix NULL pointer dereference\n\nCommit 71f642833284 (\"ACPI: utils: Fix reference counting in\nfor_each_acpi_dev_match()\") started doing \"acpi_dev_put()\" on a pointer\nthat was possibly NULL.  That fails miserably, because that helper\ninline function is not set up to handle that case.\n\nJust make acpi_dev_put() silently accept a NULL pointer, rather than\ncalling down to put_device() with an invalid offset off that NULL\npointer."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/38f54217b423c0101d03a00feec6fb8ec608b12e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cae3fa3d8165761f3000f523b11cfa1cd35206bc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ccf23a0888077a25a0793a746c3941db2a7562e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fc68f42aa737dc15e7665a4101d4168aadb8e4c4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47290","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.027","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: Fix NULL dereference on XCOPY completion\n\nCPU affinity control added with commit 39ae3edda325 (\"scsi: target: core:\nMake completion affinity configurable\") makes target_complete_cmd() queue\nwork on a CPU based on se_tpg->se_tpg_wwn->cmd_compl_affinity state.\n\nLIO's EXTENDED COPY worker is a special case in that read\/write cmds are\ndispatched using the global xcopy_pt_tpg, which carries a NULL se_tpg_wwn\npointer following initialization in target_xcopy_setup_pt().\n\nThe NULL xcopy_pt_tpg->se_tpg_wwn pointer is dereferenced on completion of\nany EXTENDED COPY initiated read\/write cmds. E.g using the libiscsi\nSCSI.ExtendedCopy.Simple test:\n\n  BUG: kernel NULL pointer dereference, address: 00000000000001a8\n  RIP: 0010:target_complete_cmd+0x9d\/0x130 [target_core_mod]\n  Call Trace:\n   fd_execute_rw+0x148\/0x42a [target_core_file]\n   ? __dynamic_pr_debug+0xa7\/0xe0\n   ? target_check_reservation+0x5b\/0x940 [target_core_mod]\n   __target_execute_cmd+0x1e\/0x90 [target_core_mod]\n   transport_generic_new_cmd+0x17c\/0x330 [target_core_mod]\n   target_xcopy_issue_pt_cmd+0x9\/0x60 [target_core_mod]\n   target_xcopy_read_source.isra.7+0x10b\/0x1b0 [target_core_mod]\n   ? target_check_fua+0x40\/0x40 [target_core_mod]\n   ? transport_complete_task_attr+0x130\/0x130 [target_core_mod]\n   target_xcopy_do_work+0x61f\/0xc00 [target_core_mod]\n\nThis fix makes target_complete_cmd() queue work on se_cmd->cpuid if\nse_tpg_wwn is NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/a47fa41381a09e5997afd762664db4f5f6657e03","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e7732c5a19a15a62b0b23fd683a639b0483e1f40","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47291","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.100","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: fix another slab-out-of-bounds in fib6_nh_flush_exceptions\n\nWhile running the self-tests on a KASAN enabled kernel, I observed a\nslab-out-of-bounds splat very similar to the one reported in\ncommit 821bbf79fe46 (\"ipv6: Fix KASAN: slab-out-of-bounds Read in\n fib6_nh_flush_exceptions\").\n\nWe additionally need to take care of fib6_metrics initialization\nfailure when the caller provides an nh.\n\nThe fix is similar, explicitly free the route instead of calling\nfib6_info_release on a half-initialized object."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/115784bcccf135c3a3548098153413d76f16aae0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/830251361425c5be044db4d826aaf304ea3d14c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8fb4792f091e608a0a1d353dfdf07ef55a719db5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ce8fafb68051fba52546f8bbe8621f7641683680","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47292","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.173","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring: fix memleak in io_init_wq_offload()\n\nI got memory leak report when doing fuzz test:\n\nBUG: memory leak\nunreferenced object 0xffff888107310a80 (size 96):\ncomm \"syz-executor.6\", pid 4610, jiffies 4295140240 (age 20.135s)\nhex dump (first 32 bytes):\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00 .....N..........\nbacktrace:\n[<000000001974933b>] kmalloc include\/linux\/slab.h:591 [inline]\n[<000000001974933b>] kzalloc include\/linux\/slab.h:721 [inline]\n[<000000001974933b>] io_init_wq_offload fs\/io_uring.c:7920 [inline]\n[<000000001974933b>] io_uring_alloc_task_context+0x466\/0x640 fs\/io_uring.c:7955\n[<0000000039d0800d>] __io_uring_add_tctx_node+0x256\/0x360 fs\/io_uring.c:9016\n[<000000008482e78c>] io_uring_add_tctx_node fs\/io_uring.c:9052 [inline]\n[<000000008482e78c>] __do_sys_io_uring_enter fs\/io_uring.c:9354 [inline]\n[<000000008482e78c>] __se_sys_io_uring_enter fs\/io_uring.c:9301 [inline]\n[<000000008482e78c>] __x64_sys_io_uring_enter+0xabc\/0xc20 fs\/io_uring.c:9301\n[<00000000b875f18f>] do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n[<00000000b875f18f>] do_syscall_64+0x3b\/0x90 arch\/x86\/entry\/common.c:80\n[<000000006b0a8484>] entry_SYSCALL_64_after_hwframe+0x44\/0xae\n\nCPU0                          CPU1\nio_uring_enter                io_uring_enter\nio_uring_add_tctx_node        io_uring_add_tctx_node\n__io_uring_add_tctx_node      __io_uring_add_tctx_node\nio_uring_alloc_task_context   io_uring_alloc_task_context\nio_init_wq_offload            io_init_wq_offload\nhash = kzalloc                hash = kzalloc\nctx->hash_map = hash          ctx->hash_map = hash <- one of the hash is leaked\n\nWhen calling io_uring_enter() in parallel, the 'hash_map' will be leaked,\nadd uring_lock to protect 'hash_map'."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/362a9e65289284f36403058eea2462d0330c1f24","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/502731a03f27cba1513fbbff77e508185ffce5bb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47293","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.243","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/sched: act_skbmod: Skip non-Ethernet packets\n\nCurrently tcf_skbmod_act() assumes that packets use Ethernet as their L2\nprotocol, which is not always the case.  As an example, for CAN devices:\n\n\t$ ip link add dev vcan0 type vcan\n\t$ ip link set up vcan0\n\t$ tc qdisc add dev vcan0 root handle 1: htb\n\t$ tc filter add dev vcan0 parent 1: protocol ip prio 10 \\\n\t\tmatchall action skbmod swap mac\n\nDoing the above silently corrupts all the packets.  Do not perform skbmod\nactions for non-Ethernet packets."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/071729150be9e1d1b851b70efb6d91ee9269d57b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/34f1e1f657fae2891b485a3b2b95fe4d2aef9f0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/727d6a8b7ef3d25080fad228b2c4a1d4da5999c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a88414fb1117f2fe65fb88e45ba694e1d09d5024","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e4fdca366806f6bab374d1a95e626a10a3854b0c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47294","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.323","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetrom: Decrease sock refcount when sock timers expire\n\nCommit 63346650c1a9 (\"netrom: switch to sock timer API\") switched to use\nsock timer API. It replaces mod_timer() by sk_reset_timer(), and\ndel_timer() by sk_stop_timer().\n\nFunction sk_reset_timer() will increase the refcount of sock if it is\ncalled on an inactive timer, hence, in case the timer expires, we need to\ndecrease the refcount ourselves in the handler, otherwise, the sock\nrefcount will be unbalanced and the sock will never be freed."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/25df44e90ff5959b5c24ad361b648504a7e39ef3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/48866fd5c361ea417ed24b43fc2a7dc2f5b060ef","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/517a16b1a88bdb6b530f48d5d153478b2552d9a8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6811744bd0efb9e472cb15d066cdb460beb8cb8a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/853262355518cd1247515b74e83fabf038aa6c29","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9619cc7d97c3aa8ed3cfd2b8678b74fb6d6c7950","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a01634bf91f2b6c42583770eb6815fb6d1e251cf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bc1660206c3723c37ed4d622ad81781f1e987250","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47295","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.400","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: fix memory leak in tcindex_partial_destroy_work\n\nSyzbot reported memory leak in tcindex_set_parms(). The problem was in\nnon-freed perfect hash in tcindex_partial_destroy_work().\n\nIn tcindex_set_parms() new tcindex_data is allocated and some fields from\nold one are copied to new one, but not the perfect hash. Since\ntcindex_partial_destroy_work() is the destroy function for old\ntcindex_data, we need to free perfect hash to avoid memory leak."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/8d7924ce85bae64e7a67c366c7c50840f49f3a62","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8e9662fde6d63c78eb1350f6167f64c9d71a865b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cac71d27745f92ee13f0ecc668ffe151a4a9c9b1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f5051bcece50140abd1a11a2d36dc3ec5484fc32","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47296","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.477","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: PPC: Fix kvm_arch_vcpu_ioctl vcpu_load leak\n\nvcpu_put is not called if the user copy fails. This can result in preempt\nnotifier corruption and crashes, among other issues."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/9bafc34dc4ad0cef18727c557f21ed3c3304df50","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a4a488915feaad38345cc01b80d52e8200ff5209","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bc4188a2f56e821ea057aca6bf444e138d06c252","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e14ef1095387f764d95614d3ec9e4d07c82a3533","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f38527f1890543cdfca8dfd06f75f9887cce6151","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47297","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.553","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fix uninit-value in caif_seqpkt_sendmsg\n\nWhen nr_segs equal to zero in iovec_from_user, the object\nmsg->msg_iter.iov is uninit stack memory in caif_seqpkt_sendmsg\nwhich is defined in ___sys_sendmsg. So we cann't just judge\nmsg->msg_iter.iov->base directlly. We can use nr_segs to judge\nmsg in caif_seqpkt_sendmsg whether has data buffers.\n\n=====================================================\nBUG: KMSAN: uninit-value in caif_seqpkt_sendmsg+0x693\/0xf60 net\/caif\/caif_socket.c:542\nCall Trace:\n __dump_stack lib\/dump_stack.c:77 [inline]\n dump_stack+0x1c9\/0x220 lib\/dump_stack.c:118\n kmsan_report+0xf7\/0x1e0 mm\/kmsan\/kmsan_report.c:118\n __msan_warning+0x58\/0xa0 mm\/kmsan\/kmsan_instr.c:215\n caif_seqpkt_sendmsg+0x693\/0xf60 net\/caif\/caif_socket.c:542\n sock_sendmsg_nosec net\/socket.c:652 [inline]\n sock_sendmsg net\/socket.c:672 [inline]\n ____sys_sendmsg+0x12b6\/0x1350 net\/socket.c:2343\n ___sys_sendmsg net\/socket.c:2397 [inline]\n __sys_sendmmsg+0x808\/0xc90 net\/socket.c:2480\n __compat_sys_sendmmsg net\/compat.c:656 [inline]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1582a02fecffcee306663035a295e28e1c4aaaff","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/452c3ed7bf63721b07bc2238ed1261bb26027e85","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5c6d8e2f7187b8e45a18c27acb7a3885f03ee3db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9413c0abb57f70a953b1116318d6aa478013c35d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/991e634360f2622a683b48dfe44fe6d9cb765a09","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d4c7797ab1517515f0d08b3bc1c6b48883889c54","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d9d646acad2c3590e189bb5d5c86ab8bd8a2dfc3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ffe31dd70b70a40cd6b21b78c1713a23e021843a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47298","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.657","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, sockmap: Fix potential memory leak on unlikely error case\n\nIf skb_linearize is needed and fails we could leak a msg on the error\nhandling. To fix ensure we kfree the msg block before returning error.\nFound during code review."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6c508a1c6c62793dc6e6872cad4b200097bab7c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/715f378f42909c401ec043f5150c4fdf57fb8889","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7e6b27a69167f97c56b5437871d29e9722c3e470","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47299","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.743","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nxdp, net: Fix use-after-free in bpf_xdp_link_release\n\nThe problem occurs between dev_get_by_index() and dev_xdp_attach_link().\nAt this point, dev_xdp_uninstall() is called. Then xdp link will not be\ndetached automatically when dev is released. But link->dev already\npoints to dev, when xdp link is released, dev will still be accessed,\nbut dev has been released.\n\ndev_get_by_index()        |\nlink->dev = dev           |\n                          |      rtnl_lock()\n                          |      unregister_netdevice_many()\n                          |          dev_xdp_uninstall()\n                          |      rtnl_unlock()\nrtnl_lock();              |\ndev_xdp_attach_link()     |\nrtnl_unlock();            |\n                          |      netdev_run_todo() \/\/ dev released\nbpf_xdp_link_release()    |\n    \/* access dev.        |\n       use-after-free *\/  |\n\n[   45.966867] BUG: KASAN: use-after-free in bpf_xdp_link_release+0x3b8\/0x3d0\n[   45.967619] Read of size 8 at addr ffff00000f9980c8 by task a.out\/732\n[   45.968297]\n[   45.968502] CPU: 1 PID: 732 Comm: a.out Not tainted 5.13.0+ #22\n[   45.969222] Hardware name: linux,dummy-virt (DT)\n[   45.969795] Call trace:\n[   45.970106]  dump_backtrace+0x0\/0x4c8\n[   45.970564]  show_stack+0x30\/0x40\n[   45.970981]  dump_stack_lvl+0x120\/0x18c\n[   45.971470]  print_address_description.constprop.0+0x74\/0x30c\n[   45.972182]  kasan_report+0x1e8\/0x200\n[   45.972659]  __asan_report_load8_noabort+0x2c\/0x50\n[   45.973273]  bpf_xdp_link_release+0x3b8\/0x3d0\n[   45.973834]  bpf_link_free+0xd0\/0x188\n[   45.974315]  bpf_link_put+0x1d0\/0x218\n[   45.974790]  bpf_link_release+0x3c\/0x58\n[   45.975291]  __fput+0x20c\/0x7e8\n[   45.975706]  ____fput+0x24\/0x30\n[   45.976117]  task_work_run+0x104\/0x258\n[   45.976609]  do_notify_resume+0x894\/0xaf8\n[   45.977121]  work_pending+0xc\/0x328\n[   45.977575]\n[   45.977775] The buggy address belongs to the page:\n[   45.978369] page:fffffc00003e6600 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x4f998\n[   45.979522] flags: 0x7fffe0000000000(node=0|zone=0|lastcpupid=0x3ffff)\n[   45.980349] raw: 07fffe0000000000 fffffc00003e6708 ffff0000dac3c010 0000000000000000\n[   45.981309] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000\n[   45.982259] page dumped because: kasan: bad access detected\n[   45.982948]\n[   45.983153] Memory state around the buggy address:\n[   45.983753]  ffff00000f997f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   45.984645]  ffff00000f998000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[   45.985533] >ffff00000f998080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[   45.986419]                                               ^\n[   45.987112]  ffff00000f998100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[   45.988006]  ffff00000f998180: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n[   45.988895] ==================================================================\n[   45.989773] Disabling lock debugging due to kernel taint\n[   45.990552] Kernel panic - not syncing: panic_on_warn set ...\n[   45.991166] CPU: 1 PID: 732 Comm: a.out Tainted: G    B             5.13.0+ #22\n[   45.991929] Hardware name: linux,dummy-virt (DT)\n[   45.992448] Call trace:\n[   45.992753]  dump_backtrace+0x0\/0x4c8\n[   45.993208]  show_stack+0x30\/0x40\n[   45.993627]  dump_stack_lvl+0x120\/0x18c\n[   45.994113]  dump_stack+0x1c\/0x34\n[   45.994530]  panic+0x3a4\/0x7d8\n[   45.994930]  end_report+0x194\/0x198\n[   45.995380]  kasan_report+0x134\/0x200\n[   45.995850]  __asan_report_load8_noabort+0x2c\/0x50\n[   45.996453]  bpf_xdp_link_release+0x3b8\/0x3d0\n[   45.997007]  bpf_link_free+0xd0\/0x188\n[   45.997474]  bpf_link_put+0x1d0\/0x218\n[   45.997942]  bpf_link_release+0x3c\/0x58\n[   45.998429]  __fput+0x20c\/0x7e8\n[   45.998833]  ____fput+0x24\/0x30\n[   45.999247]  task_work_run+0x104\/0x258\n[   45.999731]  do_notify_resume+0x894\/0xaf8\n[   46.000236]  work_pending\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5acc7d3e8d342858405fbbc671221f676b547ce7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7537dc73e69ad9c0b67ad24ad3ebee954ed0af6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca9ba1de8f09976b45ccc8e655c51c6201992139","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47300","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.820","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix tail_call_reachable rejection for interpreter when jit failed\n\nDuring testing of f263a81451c1 (\"bpf: Track subprog poke descriptors correctly\nand fix use-after-free\") under various failure conditions, for example, when\njit_subprogs() fails and tries to clean up the program to be run under the\ninterpreter, we ran into the following freeze:\n\n  [...]\n  #127\/8 tailcall_bpf2bpf_3:FAIL\n  [...]\n  [   92.041251] BUG: KASAN: slab-out-of-bounds in ___bpf_prog_run+0x1b9d\/0x2e20\n  [   92.042408] Read of size 8 at addr ffff88800da67f68 by task test_progs\/682\n  [   92.043707]\n  [   92.044030] CPU: 1 PID: 682 Comm: test_progs Tainted: G   O   5.13.0-53301-ge6c08cb33a30-dirty #87\n  [   92.045542] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1 04\/01\/2014\n  [   92.046785] Call Trace:\n  [   92.047171]  ? __bpf_prog_run_args64+0xc0\/0xc0\n  [   92.047773]  ? __bpf_prog_run_args32+0x8b\/0xb0\n  [   92.048389]  ? __bpf_prog_run_args64+0xc0\/0xc0\n  [   92.049019]  ? ktime_get+0x117\/0x130\n  [...] \/\/ few hundred [similar] lines more\n  [   92.659025]  ? ktime_get+0x117\/0x130\n  [   92.659845]  ? __bpf_prog_run_args64+0xc0\/0xc0\n  [   92.660738]  ? __bpf_prog_run_args32+0x8b\/0xb0\n  [   92.661528]  ? __bpf_prog_run_args64+0xc0\/0xc0\n  [   92.662378]  ? print_usage_bug+0x50\/0x50\n  [   92.663221]  ? print_usage_bug+0x50\/0x50\n  [   92.664077]  ? bpf_ksym_find+0x9c\/0xe0\n  [   92.664887]  ? ktime_get+0x117\/0x130\n  [   92.665624]  ? kernel_text_address+0xf5\/0x100\n  [   92.666529]  ? __kernel_text_address+0xe\/0x30\n  [   92.667725]  ? unwind_get_return_address+0x2f\/0x50\n  [   92.668854]  ? ___bpf_prog_run+0x15d4\/0x2e20\n  [   92.670185]  ? ktime_get+0x117\/0x130\n  [   92.671130]  ? __bpf_prog_run_args64+0xc0\/0xc0\n  [   92.672020]  ? __bpf_prog_run_args32+0x8b\/0xb0\n  [   92.672860]  ? __bpf_prog_run_args64+0xc0\/0xc0\n  [   92.675159]  ? ktime_get+0x117\/0x130\n  [   92.677074]  ? lock_is_held_type+0xd5\/0x130\n  [   92.678662]  ? ___bpf_prog_run+0x15d4\/0x2e20\n  [   92.680046]  ? ktime_get+0x117\/0x130\n  [   92.681285]  ? __bpf_prog_run32+0x6b\/0x90\n  [   92.682601]  ? __bpf_prog_run64+0x90\/0x90\n  [   92.683636]  ? lock_downgrade+0x370\/0x370\n  [   92.684647]  ? mark_held_locks+0x44\/0x90\n  [   92.685652]  ? ktime_get+0x117\/0x130\n  [   92.686752]  ? lockdep_hardirqs_on+0x79\/0x100\n  [   92.688004]  ? ktime_get+0x117\/0x130\n  [   92.688573]  ? __cant_migrate+0x2b\/0x80\n  [   92.689192]  ? bpf_test_run+0x2f4\/0x510\n  [   92.689869]  ? bpf_test_timer_continue+0x1c0\/0x1c0\n  [   92.690856]  ? rcu_read_lock_bh_held+0x90\/0x90\n  [   92.691506]  ? __kasan_slab_alloc+0x61\/0x80\n  [   92.692128]  ? eth_type_trans+0x128\/0x240\n  [   92.692737]  ? __build_skb+0x46\/0x50\n  [   92.693252]  ? bpf_prog_test_run_skb+0x65e\/0xc50\n  [   92.693954]  ? bpf_prog_test_run_raw_tp+0x2d0\/0x2d0\n  [   92.694639]  ? __fget_light+0xa1\/0x100\n  [   92.695162]  ? bpf_prog_inc+0x23\/0x30\n  [   92.695685]  ? __sys_bpf+0xb40\/0x2c80\n  [   92.696324]  ? bpf_link_get_from_fd+0x90\/0x90\n  [   92.697150]  ? mark_held_locks+0x24\/0x90\n  [   92.698007]  ? lockdep_hardirqs_on_prepare+0x124\/0x220\n  [   92.699045]  ? finish_task_switch+0xe6\/0x370\n  [   92.700072]  ? lockdep_hardirqs_on+0x79\/0x100\n  [   92.701233]  ? finish_task_switch+0x11d\/0x370\n  [   92.702264]  ? __switch_to+0x2c0\/0x740\n  [   92.703148]  ? mark_held_locks+0x24\/0x90\n  [   92.704155]  ? __x64_sys_bpf+0x45\/0x50\n  [   92.705146]  ? do_syscall_64+0x35\/0x80\n  [   92.706953]  ? entry_SYSCALL_64_after_hwframe+0x44\/0xae\n  [...]\n\nTurns out that the program rejection from e411901c0b77 (\"bpf: allow for tailcalls\nin BPF subprograms for x64 JIT\") is buggy since env->prog->aux->tail_call_reachable\nis never true. Commit ebf7d1f508a7 (\"bpf, x64: rework pro\/epilogue and tailcall\nhandling in JIT\") added a tracker into check_max_stack_depth() which propagates\nthe tail_call_reachable condition throughout the subprograms. This info is then\nassigned to the subprogram's \n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/39f1735c8107ef43a53c4daf82f330d880488d8f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5dd0a6b8582ffbfa88351949d50eccd5b6694ade","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cbb086074dab631ac43f8645cbac1d7b148e05c4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47301","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.890","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nigb: Fix use-after-free error during reset\n\nCleans the next descriptor to watch (next_to_watch) when cleaning the\nTX ring.\n\nFailure to do so can cause invalid memory accesses. If igb_poll() runs\nwhile the controller is reset this can lead to the driver try to free\na skb that was already freed.\n\n(The crash is harder to reproduce with the igb driver, but the same\npotential problem exists as the code is identical to igc)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7b292608db23ccbbfbfa50cdb155d01725d7a52e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/88e0720133d42d34851c8721cf5f289a50a8710f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8e24c12f2ff6d32fd9f057382f08e748ec97194c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d3ccb18ed5ac3283c7b31ecc685b499e580d5492","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d7367f781e5a9ca5df9082b15b272b55e76931f8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f153664d8e70c11d0371341613651e1130e20240","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47302","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:17.960","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nigc: Fix use-after-free error during reset\n\nCleans the next descriptor to watch (next_to_watch) when cleaning the\nTX ring.\n\nFailure to do so can cause invalid memory accesses. If igc_poll() runs\nwhile the controller is being reset this can lead to the driver try to\nfree a skb that was already freed.\n\nLog message:\n\n [  101.525242] refcount_t: underflow; use-after-free.\n [  101.525251] WARNING: CPU: 1 PID: 646 at lib\/refcount.c:28 refcount_warn_saturate+0xab\/0xf0\n [  101.525259] Modules linked in: sch_etf(E) sch_mqprio(E) rfkill(E) intel_rapl_msr(E) intel_rapl_common(E)\n x86_pkg_temp_thermal(E) intel_powerclamp(E) coretemp(E) binfmt_misc(E) kvm_intel(E) kvm(E) irqbypass(E) crc32_pclmul(E)\n ghash_clmulni_intel(E) aesni_intel(E) mei_wdt(E) libaes(E) crypto_simd(E) cryptd(E) glue_helper(E) snd_hda_codec_hdmi(E)\n rapl(E) intel_cstate(E) snd_hda_intel(E) snd_intel_dspcfg(E) sg(E) soundwire_intel(E) intel_uncore(E) at24(E)\n soundwire_generic_allocation(E) iTCO_wdt(E) soundwire_cadence(E) intel_pmc_bxt(E) serio_raw(E) snd_hda_codec(E)\n iTCO_vendor_support(E) watchdog(E) snd_hda_core(E) snd_hwdep(E) snd_soc_core(E) snd_compress(E) snd_pcsp(E)\n soundwire_bus(E) snd_pcm(E) evdev(E) snd_timer(E) mei_me(E) snd(E) soundcore(E) mei(E) configfs(E) ip_tables(E) x_tables(E)\n autofs4(E) ext4(E) crc32c_generic(E) crc16(E) mbcache(E) jbd2(E) sd_mod(E) t10_pi(E) crc_t10dif(E) crct10dif_generic(E)\n i915(E) ahci(E) libahci(E) ehci_pci(E) igb(E) xhci_pci(E) ehci_hcd(E)\n [  101.525303]  drm_kms_helper(E) dca(E) xhci_hcd(E) libata(E) crct10dif_pclmul(E) cec(E) crct10dif_common(E) tsn(E) igc(E)\n e1000e(E) ptp(E) i2c_i801(E) crc32c_intel(E) psmouse(E) i2c_algo_bit(E) i2c_smbus(E) scsi_mod(E) lpc_ich(E) pps_core(E)\n usbcore(E) drm(E) button(E) video(E)\n [  101.525318] CPU: 1 PID: 646 Comm: irq\/37-enp7s0-T Tainted: G            E     5.10.30-rt37-tsn1-rt-ipipe #ipipe\n [  101.525320] Hardware name: SIEMENS AG SIMATIC IPC427D\/A5E31233588, BIOS V17.02.09 03\/31\/2017\n [  101.525322] RIP: 0010:refcount_warn_saturate+0xab\/0xf0\n [  101.525325] Code: 05 31 48 44 01 01 e8 f0 c6 42 00 0f 0b c3 80 3d 1f 48 44 01 00 75 90 48 c7 c7 78 a8 f3 a6 c6 05 0f 48\n 44 01 01 e8 d1 c6 42 00 <0f> 0b c3 80 3d fe 47 44 01 00 0f 85 6d ff ff ff 48 c7 c7 d0 a8 f3\n [  101.525327] RSP: 0018:ffffbdedc0917cb8 EFLAGS: 00010286\n [  101.525329] RAX: 0000000000000000 RBX: ffff98fd6becbf40 RCX: 0000000000000001\n [  101.525330] RDX: 0000000000000001 RSI: ffffffffa6f2700c RDI: 00000000ffffffff\n [  101.525332] RBP: ffff98fd6becc14c R08: ffffffffa7463d00 R09: ffffbdedc0917c50\n [  101.525333] R10: ffffffffa74c3578 R11: 0000000000000034 R12: 00000000ffffff00\n [  101.525335] R13: ffff98fd6b0b1000 R14: 0000000000000039 R15: ffff98fd6be35c40\n [  101.525337] FS:  0000000000000000(0000) GS:ffff98fd6e240000(0000) knlGS:0000000000000000\n [  101.525339] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n [  101.525341] CR2: 00007f34135a3a70 CR3: 0000000150210003 CR4: 00000000001706e0\n [  101.525343] Call Trace:\n [  101.525346]  sock_wfree+0x9c\/0xa0\n [  101.525353]  unix_destruct_scm+0x7b\/0xa0\n [  101.525358]  skb_release_head_state+0x40\/0x90\n [  101.525362]  skb_release_all+0xe\/0x30\n [  101.525364]  napi_consume_skb+0x57\/0x160\n [  101.525367]  igc_poll+0xb7\/0xc80 [igc]\n [  101.525376]  ? sched_clock+0x5\/0x10\n [  101.525381]  ? sched_clock_cpu+0xe\/0x100\n [  101.525385]  net_rx_action+0x14c\/0x410\n [  101.525388]  __do_softirq+0xe9\/0x2f4\n [  101.525391]  __local_bh_enable_ip+0xe3\/0x110\n [  101.525395]  ? irq_finalize_oneshot.part.47+0xe0\/0xe0\n [  101.525398]  irq_forced_thread_fn+0x6a\/0x80\n [  101.525401]  irq_thread+0xe8\/0x180\n [  101.525403]  ? wake_threads_waitq+0x30\/0x30\n [  101.525406]  ? irq_thread_check_affinity+0xd0\/0xd0\n [  101.525408]  kthread+0x183\/0x1a0\n [  101.525412]  ? kthread_park+0x80\/0x80\n [  101.525415]  ret_from_fork+0x22\/0x30"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/56ea7ed103b46970e171eb1c95916f393d64eeff","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a9508e0edfe369ac95d0825bcdca976436ce780f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e15f629036bac005fc758b4ad17896cf2312add4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ea5e36b7367ea0a36ef73a163768f16d2977bd83","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47303","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.037","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Track subprog poke descriptors correctly and fix use-after-free\n\nSubprograms are calling map_poke_track(), but on program release there is no\nhook to call map_poke_untrack(). However, on program release, the aux memory\n(and poke descriptor table) is freed even though we still have a reference to\nit in the element list of the map aux data. When we run map_poke_run(), we then\nend up accessing free'd memory, triggering KASAN in prog_array_map_poke_run():\n\n  [...]\n  [  402.824689] BUG: KASAN: use-after-free in prog_array_map_poke_run+0xc2\/0x34e\n  [  402.824698] Read of size 4 at addr ffff8881905a7940 by task hubble-fgs\/4337\n  [  402.824705] CPU: 1 PID: 4337 Comm: hubble-fgs Tainted: G          I       5.12.0+ #399\n  [  402.824715] Call Trace:\n  [  402.824719]  dump_stack+0x93\/0xc2\n  [  402.824727]  print_address_description.constprop.0+0x1a\/0x140\n  [  402.824736]  ? prog_array_map_poke_run+0xc2\/0x34e\n  [  402.824740]  ? prog_array_map_poke_run+0xc2\/0x34e\n  [  402.824744]  kasan_report.cold+0x7c\/0xd8\n  [  402.824752]  ? prog_array_map_poke_run+0xc2\/0x34e\n  [  402.824757]  prog_array_map_poke_run+0xc2\/0x34e\n  [  402.824765]  bpf_fd_array_map_update_elem+0x124\/0x1a0\n  [...]\n\nThe elements concerned are walked as follows:\n\n    for (i = 0; i < elem->aux->size_poke_tab; i++) {\n           poke = &elem->aux->poke_tab[i];\n    [...]\n\nThe access to size_poke_tab is a 4 byte read, verified by checking offsets\nin the KASAN dump:\n\n  [  402.825004] The buggy address belongs to the object at ffff8881905a7800\n                 which belongs to the cache kmalloc-1k of size 1024\n  [  402.825008] The buggy address is located 320 bytes inside of\n                 1024-byte region [ffff8881905a7800, ffff8881905a7c00)\n\nThe pahole output of bpf_prog_aux:\n\n  struct bpf_prog_aux {\n    [...]\n    \/* --- cacheline 5 boundary (320 bytes) --- *\/\n    u32                        size_poke_tab;        \/*   320     4 *\/\n    [...]\n\nIn general, subprograms do not necessarily manage their own data structures.\nFor example, BTF func_info and linfo are just pointers to the main program\nstructure. This allows reference counting and cleanup to be done on the latter\nwhich simplifies their management a bit. The aux->poke_tab struct, however,\ndid not follow this logic. The initial proposed fix for this use-after-free\nbug further embedded poke data tracking into the subprogram with proper\nreference counting. However, Daniel and Alexei questioned why we were treating\nthese objects special; I agree, its unnecessary. The fix here removes the per\nsubprogram poke table allocation and map tracking and instead simply points\nthe aux->poke_tab pointer at the main programs poke table. This way, map\ntracking is simplified to the main program and we do not need to manage them\nper subprogram.\n\nThis also means, bpf_prog_free_deferred(), which unwinds the program reference\ncounting and kfrees objects, needs to ensure that we don't try to double free\nthe poke_tab when free'ing the subprog structures. This is easily solved by\nNULL'ing the poke_tab pointer. The second detail is to ensure that per\nsubprogram JIT logic only does fixups on poke_tab[] entries it owns. To do\nthis, we add a pointer in the poke structure to point at the subprogram value\nso JITs can easily check while walking the poke_tab structure if the current\nentry belongs to the current program. The aux pointer is stable and therefore\nsuitable for such comparison. On the jit_subprogs() error path, we omit\ncleaning up the poke->aux field because these are only ever referenced from\nthe JIT side, but on error we will never make it to the JIT, so its fine to\nleave them dangling. Removing these pointers would complicate the error path\nfor no reason. However, we do need to untrack all poke descriptors from the\nmain program as otherwise they could race with the freeing of JIT memory from\nthe subprograms. Lastly, a748c6975dea3 (\"bpf: propagate poke des\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/599148d40366bd5d1d504a3a8fcd65e21107e500","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a9f36bf3613c65cb587c70fac655c775d911409b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f263a81451c12da5a342d90572e317e611846f2c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47304","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.110","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: fix tcp_init_transfer() to not reset icsk_ca_initialized\n\nThis commit fixes a bug (found by syzkaller) that could cause spurious\ndouble-initializations for congestion control modules, which could cause\nmemory leaks or other problems for congestion control modules (like CDG)\nthat allocate memory in their init functions.\n\nThe buggy scenario constructed by syzkaller was something like:\n\n(1) create a TCP socket\n(2) initiate a TFO connect via sendto()\n(3) while socket is in TCP_SYN_SENT, call setsockopt(TCP_CONGESTION),\n    which calls:\n       tcp_set_congestion_control() ->\n         tcp_reinit_congestion_control() ->\n           tcp_init_congestion_control()\n(4) receive ACK, connection is established, call tcp_init_transfer(),\n    set icsk_ca_initialized=0 (without first calling cc->release()),\n    call tcp_init_congestion_control() again.\n\nNote that in this sequence tcp_init_congestion_control() is called\ntwice without a cc->release() call in between. Thus, for CC modules\nthat allocate memory in their init() function, e.g, CDG, a memory leak\nmay occur. The syzkaller tool managed to find a reproducer that\ntriggered such a leak in CDG.\n\nThe bug was introduced when that commit 8919a9b31eb4 (\"tcp: Only init\ncongestion control if not initialized already\")\nintroduced icsk_ca_initialized and set icsk_ca_initialized to 0 in\ntcp_init_transfer(), missing the possibility for a sequence like the\none above, where a process could call setsockopt(TCP_CONGESTION) in\nstate TCP_SYN_SENT (i.e. after the connect() or TFO open sendmsg()),\nwhich would call tcp_init_congestion_control(). It did not intend to\nreset any initialization that the user had already explicitly made;\nit just missed the possibility of that particular sequence (which\nsyzkaller managed to find)."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/ad4ba3404931745a5977ad12db4f0c34080e52f7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/be5d1b61a2ad28c7e57fe8bfa277373e8ecffcdc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fe77b85828ca9ddc42977b79de9e40d18545b4fe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47305","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.177","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndma-buf\/sync_file: Don't leak fences on merge failure\n\nEach add_fence() call does a dma_fence_get() on the relevant fence.  In\nthe error path, we weren't calling dma_fence_put() so all those fences\ngot leaked.  Also, in the krealloc_array failure case, we weren't\nfreeing the fences array.  Instead, ensure that i and fences are always\nzero-initialized and dma_fence_put() all the fences and kfree(fences) on\nevery error path."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0d514185ae792d3a1903c8e1a83899aa996705ce","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/19edcd97727aae9362444a859a24d99a8730cb27","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/19f51c2529339280d2c8c6427cd3e21ddf1ac3f8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/41f45e91c92c8480242ea448d54e28c753b13902","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e0355a0ad31a1d677b2a4514206de4902bd550e8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ffe000217c5068c5da07ccb1c0f8cce7ad767435","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47306","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.250","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fddi: fix UAF in fza_probe\n\nfp is netdev private data and it cannot be\nused after free_netdev() call. Using fp after free_netdev()\ncan cause UAF bug. Fix it by moving free_netdev() after error message.\n\nTURBOchannel adapter\")"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/04b06716838bfc26742dbed3ae1d3697fe5317ee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bdfbb51f7a437ae8ea91317a5c133ec13adf3c47","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/deb7178eb940e2c5caca1b1db084a69b2e59b4c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f33605908a9b6063525e9f68e62d739948c5fccf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47307","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.320","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: prevent NULL deref in cifs_compose_mount_options()\n\nThe optional @ref parameter might contain an NULL node_name, so\nprevent dereferencing it in cifs_compose_mount_options().\n\nAddresses-Coverity: 1476408 (\"Explicit null dereferenced\")"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/03313d1c3a2f086bb60920607ab79ac8f8578306","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ae3d181f4e912f51af7776ea165f199b16fc165d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e58c162789becede894d3e94c0ce6695a2ef5796","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f7d1fa65e74263d11f90ddd33b4d4cd905a93759","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47308","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.383","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: libfc: Fix array index out of bound exception\n\nFix array index out of bound exception in fc_rport_prli_resp()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0fe70c15f9435bb3c50954778245d62ee38b0e03","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/44651522941c623e20882b3b443f23f77de1ea8b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4921b1618045ffab71b1050bf0014df3313a2289","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8511293e643a18b248510ae5734e4f360754348c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a4a54c54af2516caa9c145015844543cfc84316a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b27c4577557045f1ab3cdfeabfc7f3cd24aca1fe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47309","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.453","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: validate lwtstate->data before returning from skb_tunnel_info()\n\nskb_tunnel_info() returns pointer of lwtstate->data as ip_tunnel_info\ntype without validation. lwtstate->data can have various types such as\nmpls_iptunnel_encap, etc and these are not compatible.\nSo skb_tunnel_info() should validate before returning that pointer.\n\nSplat looks like:\nBUG: KASAN: slab-out-of-bounds in vxlan_get_route+0x418\/0x4b0 [vxlan]\nRead of size 2 at addr ffff888106ec2698 by task ping\/811\n\nCPU: 1 PID: 811 Comm: ping Not tainted 5.13.0+ #1195\nCall Trace:\n dump_stack_lvl+0x56\/0x7b\n print_address_description.constprop.8.cold.13+0x13\/0x2ee\n ? vxlan_get_route+0x418\/0x4b0 [vxlan]\n ? vxlan_get_route+0x418\/0x4b0 [vxlan]\n kasan_report.cold.14+0x83\/0xdf\n ? vxlan_get_route+0x418\/0x4b0 [vxlan]\n vxlan_get_route+0x418\/0x4b0 [vxlan]\n [ ... ]\n vxlan_xmit_one+0x148b\/0x32b0 [vxlan]\n [ ... ]\n vxlan_xmit+0x25c5\/0x4780 [vxlan]\n [ ... ]\n dev_hard_start_xmit+0x1ae\/0x6e0\n __dev_queue_xmit+0x1f39\/0x31a0\n [ ... ]\n neigh_xmit+0x2f9\/0x940\n mpls_xmit+0x911\/0x1600 [mpls_iptunnel]\n lwtunnel_xmit+0x18f\/0x450\n ip_finish_output2+0x867\/0x2040\n [ ... ]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2179d96ec702cc33ead02a9ce40ece599b8538c5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/67a9c94317402b826fc3db32afc8f39336803d97","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/83bdcfbd968bcc91a0632b7b625e4a9b0cba5e0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8aa13a86964cdec4fd969ef677c6614ff068641a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8bb1589c89e61e3b182dd546f1021928ebb5c2a6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a915379594f1e045421635c6316d8f3ffa018c58","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b61d327cd3cc5ea591f3bf751dd11e034f388bb5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e7f3c9df40515a6c6b46f36c4c94cf48a043f887","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47310","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.520","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ti: fix UAF in tlan_remove_one\n\npriv is netdev private data and it cannot be\nused after free_netdev() call. Using priv after free_netdev()\ncan cause UAF bug. Fix it by moving free_netdev() at the end of the\nfunction."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0336f8ffece62f882ab3012820965a786a983f70","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0538b0ab7d2c396e385694228c7cdcd2d2c514e9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/93efab0ef2a607fff9166d447c4035f98b5db342","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a0a817b2d308fac090a05cbbe80988e073ac5193","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a18a8d9cfbb112ad72e625372849adc3986fd6bf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7e5563f2a7862a9e4796abb9908b092f677e3c1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c263ae8c7e4c482387de5e6c89e213f8173fe8b6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f2a062fcfe1d6f1b0a86fa76ae21c277d65f4405","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47311","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.590","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: qcom\/emac: fix UAF in emac_remove\n\nadpt is netdev private data and it cannot be\nused after free_netdev() call. Using adpt after free_netdev()\ncan cause UAF bug. Fix it by moving free_netdev() at the end of the\nfunction."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/11e9d163d631198bb3eb41a677a61b499516c0f7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2b70ca92847c619d6264c7372ef74fcbfd1e048c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4d04a42b926e682140776e54188f4a44f1f01a81","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a225a6e07a57a1538d53637cb3d82bd3e477839","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad297cd2db8953e2202970e9504cab247b6c7cb4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b1e091331920f8fbfc747dcbd16263fcd71abb2d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b560521eca03d0a2db6093a5a632cbdd0a0cf833","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47312","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.660","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: Fix dereference of null pointer flow\n\nIn the case where chain->flags & NFT_CHAIN_HW_OFFLOAD is false then\nnft_flow_rule_create is not called and flow is NULL. The subsequent\nerror handling execution via label err_destroy_flow_rule will lead\nto a null pointer dereference on flow when calling nft_flow_rule_destroy.\nSince the error path to err_destroy_flow_rule has to cater for null\nand non-null flows, only call nft_flow_rule_destroy if flow is non-null\nto fix this issue.\n\nAddresses-Coverity: (\"Explicity null dereference\")"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4ca041f919f13783b0b03894783deee00dbca19a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/70a5a1950cca02c5cd161bb3846b4d983eed97d3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47313","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.727","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq: CPPC: Fix potential memleak in cppc_cpufreq_cpu_init\n\nIt's a classic example of memleak, we allocate something, we fail and\nnever free the resources.\n\nMake sure we free all resources on policy ->init() failures."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/b775383355755885b19d2acef977f1ca132e80a3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e1b2b2b61d30d7ce057ec17237c217d152ed97f2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fe2535a44904a77615a3af8e8fd7dafb98fb0e1b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47314","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.790","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmemory: fsl_ifc: fix leak of private memory on probe failure\n\nOn probe error the driver should free the memory allocated for private\nstructure.  Fix this by using resource-managed allocation."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3b45b8a7d549bd92ec94b5357c2c2c1a7ed107e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/443f6ca6fd186b4fa4e6f377b6e19a91feb1a0d5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/48ee69825f7480622ed447b0249123236d3b3ad0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7626ffbea708e5aba6912295c012d2b409a1769f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8018476756066e97ecb886c3dc024aeb7d5792ad","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8e0d09b1232d0538066c40ed4c13086faccbdff6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a6b45b4932f7b0c36b41fb56a35ad679ece939a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b5789e23773f4a852fbfe244b63f675e265d3a7f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ee1aa737ba0b75ab8af3444c4ae5bdba36aed6e6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47315","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.860","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmemory: fsl_ifc: fix leak of IO mapping on probe failure\n\nOn probe error the driver should unmap the IO memory.  Smatch reports:\n\n  drivers\/memory\/fsl_ifc.c:298 fsl_ifc_ctrl_probe() warn: 'fsl_ifc_ctrl_dev->gregs' not released on lines: 298."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/28f71fd81ebd3b386bf5c7c5539664156f7d72c1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3b132ab67fc7a358fff35e808fa65d4bea452521","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6b3b002de90738e3c85853a682ce7e0fa078d42b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/83af5816308b490b05fc8fa27fc1bdc769df200a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8d071d270afba468708faca5f7b6d9e656f75e27","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/94bc2fe46102d1e060fc749c0c19511e76c9995f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7a2bcb4a3731d68f938207f75ed3e1d41774510","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bd051b3e184fa56eeb6276ee913ba4d48069024b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0d04b95e8ed0223844a1d58497c686fe2e4a955","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d9213d4f372d30b5bc4d921795d6bed0c0e3eebf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47316","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:18.940","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: fix NULL dereference in nfs3svc_encode_getaclres\n\nIn error cases the dentry may be NULL.\n\nBefore 20798dfe249a, the encoder also checked dentry and\nd_really_is_positive(dentry), but that looks like overkill to me--zero\nstatus should be enough to guarantee a positive dentry.\n\nThis isn't the first time we've seen an error-case NULL dereference\nhidden in the initialization of a local variable in an xdr encoder.  But\nI went back through the other recent rewrites and didn't spot any\nsimilar bugs."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/650e6f383a6eb40f7c0a010982a74ab4b6893870","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ab1016d39cc052064e32f25ad18ef8767a0ee3b8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47317","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.007","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc\/bpf: Fix detecting BPF atomic instructions\n\nCommit 91c960b0056672 (\"bpf: Rename BPF_XADD and prepare to encode other\natomics in .imm\") converted BPF_XADD to BPF_ATOMIC and added a way to\ndistinguish instructions based on the immediate field. Existing JIT\nimplementations were updated to check for the immediate field and to\nreject programs utilizing anything more than BPF_ADD (such as BPF_FETCH)\nin the immediate field.\n\nHowever, the check added to powerpc64 JIT did not look at the correct\nBPF instruction. Due to this, such programs would be accepted and\nincorrectly JIT'ed resulting in soft lockups, as seen with the atomic\nbounds test. Fix this by looking at the correct immediate value."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0d435b6d94b05dcfd836d758a63145aa566618e2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/419ac821766cbdb9fd85872bb3f1a589df05c94c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7284dab07e4d51d453cc42851fae9ec4fac6ef2f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47318","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.080","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\narch_topology: Avoid use-after-free for scale_freq_data\n\nCurrently topology_scale_freq_tick() (which gets called from\nscheduler_tick()) may end up using a pointer to \"struct\nscale_freq_data\", which was previously cleared by\ntopology_clear_scale_freq_source(), as there is no protection in place\nhere. The users of topology_clear_scale_freq_source() though needs a\nguarantee that the previously cleared scale_freq_data isn't used\nanymore, so they can free the related resources.\n\nSince topology_scale_freq_tick() is called from scheduler tick, we don't\nwant to add locking in there. Use the RCU update mechanism instead\n(which is already used by the scheduler's utilization update path) to\nguarantee race free updates here.\n\nsynchronize_rcu() makes sure that all RCU critical sections that started\nbefore it is called, will finish before it returns. And so the callers\nof topology_clear_scale_freq_source() don't need to worry about their\ncallback getting called anymore."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/83150f5d05f065fb5c12c612f119015cabdcc124","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ccdf7e073170886bc370c613e269de610a794c4a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47319","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.147","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio-blk: Fix memory leak among suspend\/resume procedure\n\nThe vblk->vqs should be freed before we call init_vqs()\nin virtblk_restore()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/04c6e60b884cb5e94ff32af46867fb41d5848358","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/102d6bc6475ab09bab579c18704e6cf8d898e93c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/29a2f4a3214aa14d61cc9737c9f886dae9dbb710","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/381bde79d11e596002edfd914e6714291826967a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/600942d2fd49b90e44857d20c774b20d16f3130f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/863da837964c80c72e368a4f748c30d25daa1815","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b71ba22e7c6c6b279c66f53ee7818709774efa1f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca2b8ae93a6da9839dc7f9eb9199b18aa03c3dae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cd24da0db9f75ca11eaf6060f0ccb90e2f3be3b0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47320","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.220","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnfs: fix acl memory leak of posix_acl_create()\n\nWhen looking into another nfs xfstests report, I found acl and\ndefault_acl in nfs3_proc_create() and nfs3_proc_mknod() error\npaths are possibly leaked. Fix them in advance."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0704f617040c397ae73c1f88f3956787ec5d6529","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1fcb6fcd74a222d9ead54d405842fc763bb86262","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2e3960f276b4574a9bb0dfa31a7497302f6363b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4b515308ab875c7e8ada8e606fe0c64762da5ed4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/687cf32865b2d6960214bce523f2afac58dd3cd2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a2b308a54c5ec224fedc753617f99b29ffcd883","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c8fc86e9df6a6a03f5a8e15a3b7a5c75fd05aa38","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cef9d9acb7c80ed6bace894b6334557fd493863b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0b32dc1409f7e65e4fcc34e236462268e69a357","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47321","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.297","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwatchdog: Fix possible use-after-free by calling del_timer_sync()\n\nThis driver's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1a053c4d716898a53c2e31c574a70ea0c37044a3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4c05dac488a660fe2925c047ecb119e7afaaeb1e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/58606882ad8ec6c39e0f40344b922921ef94ab4d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/66ba9cf929b1c4fabf545bd4c18f6f64e23e46e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8bec568d7518b1504a602ed5376bb322e4dbb270","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca96b8ea5e74956071154bdb456778cc3027e79f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0212f095ab56672f6f36aabc605bda205e1e0bf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/db222f1477ad5692cd454709b714949807e5d111","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ecd620e0fb1ff7f78fdb593379b2e6938c99707a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47322","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.397","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nNFSv4: Fix an Oops in pnfs_mark_request_commit() when doing O_DIRECT\n\nFix an Oopsable condition in pnfs_mark_request_commit() when we're\nputting a set of writes on the commit list to reschedule them after a\nfailed pNFS attempt."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3731d44bba8e0116b052b1b374476c5f6dd9a456","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5c7ef8a3705542136a1e19b070e951f0730b2153","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7aec9f862411906f8c27071ba65a1e110ad7d2fd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7c96a2ee45be41d5a167e6332d202086752c36bb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47323","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.467","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwatchdog: sc520_wdt: Fix possible use-after-free in wdt_turnoff()\n\nThis module's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0015581a79bbf8e521f85dddb7d3e4a66b9f51d4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2aef07017fae21c3d8acea9656b10e3b9c0f1e04","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/522e75ed63f67e815d4ec0deace67df22d9ce78e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7c56c5508dc20a6b133bc669fc34327a6711c24c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90b7c141132244e8e49a34a4c1e445cce33e07f4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a173e3b62cf6dd3c4a0a10c8a82eedfcae81a566","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b3c41ea5bc34d8c7b19e230d80e0e555c6f5057d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4565a8a2d6bffb05bfbec11399d261ec16fe373","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f0feab82f6a0323f54d85e8b512a2be64f83648a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47324","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.543","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwatchdog: Fix possible use-after-free in wdt_startup()\n\nThis module's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0ac50a76cf3cd63db000648b3b19f3f98b8aaa76","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/146cc288fb80c662c9c35e7bc58325d1ac0a7875","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/63a3dc24bd053792f84cb4eef0168b1266202a02","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/862f2b5a7c38762ac9e369daefbf361a91aca685","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8adbbe6c86bb13e14f8a19e036ae5f4f5661fd90","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a397cb4576fc2fc802562418b3a50b8f67d60d31","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4ebf4a4692e84163a69444c70ad515de06e2259","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c08a6b31e4917034f0ed0cb457c3bb209576f542","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dc9403097be52d57a5c9c35efa9be79d166a78af","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47325","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.613","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\niommu\/arm-smmu: Fix arm_smmu_device refcount leak in address translation\n\nThe reference counting issue happens in several exception handling paths\nof arm_smmu_iova_to_phys_hard(). When those error scenarios occur, the\nfunction forgets to decrease the refcount of \"smmu\" increased by\narm_smmu_rpm_get(), causing a refcount leak.\n\nFix this issue by jumping to \"out\" label when those error scenarios\noccur."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0f0c5ea09139777d90729d408b807021f2ea6492","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/43d1aaa1965f9b58035196dac49b1e1e6c9c25eb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5f9741a9a91f25c89e04b408cd61e3ab050ce24b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7c8f176d6a3fa18aa0f8875da6f7c672ed2a8554","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b11220803ad14a2a880cc06d8e01fe2548cc85b0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47326","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.687","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nx86\/signal: Detect and prevent an alternate signal stack overflow\n\nThe kernel pushes context on to the userspace stack to prepare for the\nuser's signal handler. When the user has supplied an alternate signal\nstack, via sigaltstack(2), it is easy for the kernel to verify that the\nstack size is sufficient for the current hardware context.\n\nCheck if writing the hardware context to the alternate stack will exceed\nit's size. If yes, then instead of corrupting user-data and proceeding with\nthe original signal handler, an immediate SIGSEGV signal is delivered.\n\nRefactor the stack pointer check code from on_sig_stack() and use the new\nhelper.\n\nWhile the kernel allows new source code to discover and use a sufficient\nalternate signal stack size, this check is still necessary to protect\nbinaries with insufficient alternate signal stack size from data\ncorruption."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/00fcd8f33e9b9f57115c3b1cfc4cb96450c18796","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2beb4a53fc3f1081cedc1c1a198c7f56cc4fc60c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/74569cb9ed7bc60e395927f55d3dc3be143a0164","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/74d6fcea1d896800e60f1c675137efebd1a6c9a6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/afb04d0b5543a5bf8e157b9119fbfc52606f4c11","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47327","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.757","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\niommu\/arm-smmu: Fix arm_smmu_device refcount leak when arm_smmu_rpm_get fails\n\narm_smmu_rpm_get() invokes pm_runtime_get_sync(), which increases the\nrefcount of the \"smmu\" even though the return value is less than 0.\n\nThe reference counting issue happens in some error handling paths of\narm_smmu_rpm_get() in its caller functions. When arm_smmu_rpm_get()\nfails, the caller functions forget to decrease the refcount of \"smmu\"\nincreased by arm_smmu_rpm_get(), causing a refcount leak.\n\nFix this issue by calling pm_runtime_resume_and_get() instead of\npm_runtime_get_sync() in arm_smmu_rpm_get(), which can keep the refcount\nbalanced in case of failure."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1adf30f198c26539a62d761e45af72cde570413d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3761ae0d0e549f2acdaf11f49df4ed06d256b20f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c4007596fbdabc29f858dc2e1990858a146b60b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fbf4daa6f4105e01fbd3868006f65c163365c1e3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fe92c058199067ae90cf2a901ddf3c271893557a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47328","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.823","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: iscsi: Fix conn use after free during resets\n\nIf we haven't done a unbind target call we can race where\niscsi_conn_teardown wakes up the EH thread and then frees the conn while\nthose threads are still accessing the conn ehwait.\n\nWe can only do one TMF per session so this just moves the TMF fields from\nthe conn to the session. We can then rely on the\niscsi_session_teardown->iscsi_remove_session->__iscsi_unbind_session call\nto remove the target and it's devices, and know after that point there is\nno device or scsi-ml callout trying to access the session."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/89812e7957ab0746eab66ed6fc49d52bb4dca250","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bf20d85a88384574fabb3d53ad62a8af57e7ab11","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d04958a348e560938410e04a12fb99da9c7e6a00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ec29d0ac29be366450a7faffbcf8cba3a6a3b506","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f0a031f7c55ffd944fead1ddaf2aa94df9a158c1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fa9542b35ceb4202e8f8d65f440529a63524dca9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47329","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.910","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: megaraid_sas: Fix resource leak in case of probe failure\n\nThe driver doesn't clean up all the allocated resources properly when\nscsi_add_host(), megasas_start_aen() function fails during the PCI device\nprobe.\n\nClean up all those resources."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/04b6b9ea80906e3b41ff120b45db31768947cf72","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0680db6f41920b2c91c7df3cc9cd5968701a6f74","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0c6226601c3e191a44a57d8f9f814b7e5c308959","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b5438f48fdd8e1c3f130d32637511efd32038152","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e623f79691c5104317669ab36ec316a90c05062f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47330","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:19.977","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntty: serial: 8250: serial_cs: Fix a memory leak in error handling path\n\nIn the probe function, if the final 'serial_config()' fails, 'info' is\nleaking.\n\nAdd a resource handling path to free this memory."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/331f5923fce4f45b8170ccf06c529e8eb28f37bc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/34f4590f5ec9859ea9136249f528173d150bd584","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7a80f71601af015856a0aeb1e3c294037ac3dd32","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b2ef1f5de40342de44fc5355321595f91774dab5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b5a2799cd62ed30c81b22c23028d9ee374e2138c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c39cf4df19acf0133fa284a8cd83fad42cd13cc2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cddee5c287e26f6b2ba5c0ffdfc3a846f2f10461","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ee16bed959862a6de2913f71a04cb563d7237b67","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fad92b11047a748c996ebd6cfb164a63814eeb2e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47331","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.067","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: common: usb-conn-gpio: fix NULL pointer dereference of charger\n\nWhen power on system with OTG cable, IDDIG's interrupt arises before\nthe charger registration, it will cause a NULL pointer dereference,\nfix the issue by registering the power supply before requesting\nIDDIG\/VBUS irq."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1a133a0996d6b4c83509d570ed4edcba34c44f25","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/436906fd248e018403bcda61a9311d9af02912f1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/880287910b1892ed2cb38977893b947382a09d21","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8e8d910e9a3a7fba86140aff4924c30955ab228b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47332","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.133","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usx2y: Don't call free_pages_exact() with NULL address\n\nUnlike some other functions, we can't pass NULL pointer to\nfree_pages_exact().  Add a proper NULL check for avoiding possible\nOops."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7d7f30cf182e55023fa8fde4c084b2d37c6be69d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/82e5ee742fdd8874fe996181b87fafe1eb5f1196","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/88262229b778f4f7a896da828d966f94dcb35d19","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bee295f5e03510252d18b25cc1d26230256eb87a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cae0cf651adccee2c3f376e78f30fbd788d0829f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47333","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.200","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmisc: alcor_pci: fix null-ptr-deref when there is no PCI bridge\n\nThere is an issue with the ASPM(optional) capability checking function.\nA device might be attached to root complex directly, in this case,\nbus->self(bridge) will be NULL, thus priv->parent_pdev is NULL.\nSince alcor_pci_init_check_aspm(priv->parent_pdev) checks the PCI link's\nASPM capability and populate parent_cap_off, which will be used later by\nalcor_pci_aspm_ctrl() to dynamically turn on\/off device, what we can do\nhere is to avoid checking the capability if we are on the root complex.\nThis will make pdev_cap_off 0 and alcor_pci_aspm_ctrl() will simply\nreturn when bring called, effectively disable ASPM for the device.\n\n[    1.246492] BUG: kernel NULL pointer dereference, address: 00000000000000c0\n[    1.248731] RIP: 0010:pci_read_config_byte+0x5\/0x40\n[    1.253998] Call Trace:\n[    1.254131]  ? alcor_pci_find_cap_offset.isra.0+0x3a\/0x100 [alcor_pci]\n[    1.254476]  alcor_pci_probe+0x169\/0x2d5 [alcor_pci]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/09d154990ca82d14aed2b72796f6c8845e2e605d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3ce3e45cc333da707d4d6eb433574b990bcc26f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/58f69684ba03e5b0e0a3ae844a845280c0f06309","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/717cf5ae52322ddbdf3ac2c584b34c5970b0d174","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d2639ffdcad463b358b6bef8645ff81715daffcb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47334","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.273","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmisc\/libmasm\/module: Fix two use after free in ibmasm_init_one\n\nIn ibmasm_init_one, it calls ibmasm_init_remote_input_dev().\nInside ibmasm_init_remote_input_dev, mouse_dev and keybd_dev are\nallocated by input_allocate_device(), and assigned to\nsp->remote.mouse_dev and sp->remote.keybd_dev respectively.\n\nIn the err_free_devices error branch of ibmasm_init_one,\nmouse_dev and keybd_dev are freed by input_free_device(), and return\nerror. Then the execution runs into error_send_message error branch\nof ibmasm_init_one, where ibmasm_free_remote_input_dev(sp) is called\nto unregister the freed sp->remote.mouse_dev and sp->remote.keybd_dev.\n\nMy patch add a \"error_init_remote\" label to handle the error of\nibmasm_init_remote_input_dev(), to avoid the uaf bugs."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1512e7dc5eb08b7d92a12e2bfcd9cb8c4a1ec069","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/29ba8e2ba89ee2862a26d91204dd5fe77ceee25a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/38660031e80eaa6cc9370b031c180612f414b00d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/481a76d4749ee3a27f902ba213fdcbb4bb39720e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5b06ca113bf197aab2ab61288f42506e0049fbab","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7272b591c4cb9327c43443f67b8fbae7657dd9ae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7268e8a227d5a4f0bd1584f556246b0224ab274","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b9c87ce3bc6331f82811a8cf8e930423c22523a3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ef1067d2baa847d53c9988510d99fb494de4d12c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47335","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.350","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to avoid racing on fsync_entry_slab by multi filesystem instances\n\nAs syzbot reported, there is an use-after-free issue during f2fs recovery:\n\nUse-after-free write at 0xffff88823bc16040 (in kfence-#10):\n kmem_cache_destroy+0x1f\/0x120 mm\/slab_common.c:486\n f2fs_recover_fsync_data+0x75b0\/0x8380 fs\/f2fs\/recovery.c:869\n f2fs_fill_super+0x9393\/0xa420 fs\/f2fs\/super.c:3945\n mount_bdev+0x26c\/0x3a0 fs\/super.c:1367\n legacy_get_tree+0xea\/0x180 fs\/fs_context.c:592\n vfs_get_tree+0x86\/0x270 fs\/super.c:1497\n do_new_mount fs\/namespace.c:2905 [inline]\n path_mount+0x196f\/0x2be0 fs\/namespace.c:3235\n do_mount fs\/namespace.c:3248 [inline]\n __do_sys_mount fs\/namespace.c:3456 [inline]\n __se_sys_mount+0x2f9\/0x3b0 fs\/namespace.c:3433\n do_syscall_64+0x3f\/0xb0 arch\/x86\/entry\/common.c:47\n entry_SYSCALL_64_after_hwframe+0x44\/0xae\n\nThe root cause is multi f2fs filesystem instances can race on accessing\nglobal fsync_entry_slab pointer, result in use-after-free issue of slab\ncache, fixes to init\/destroy this slab cache only once during module\ninit\/destroy procedure to avoid this issue."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/79fa5d944c875711253a23b8155b36883c696409","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/86786603014e0a22d0d6af8e80ae4b8687927048","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cad83c968c2ebe97905f900326988ed37146c347","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e472b276a0d2180808009be38105e12754432e2a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47336","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.437","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nsmackfs: restrict bytes count in smk_set_cipso()\n\nOops, I failed to update subject line.\n\nFrom 07571157c91b98ce1a4aa70967531e64b78e8346 Mon Sep 17 00:00:00 2001\nDate: Mon, 12 Apr 2021 22:25:06 +0900\nSubject: [PATCH] smackfs: restrict bytes count in smk_set_cipso()\n\nCommit 7ef4c19d245f3dc2 (\"smackfs: restrict bytes count in smackfs write\nfunctions\") missed that count > SMK_CIPSOMAX check applies to only\nformat == SMK_FIXED24_FMT case."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/135122f174c357b7a3e58f40fa5792156c5e93e6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/258fd821f69378453c071b9dd767b298810fc766","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3780348c1a0e14ffefcaf1fc521f815bcaac94b0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/49ec114a6e62d8d320037ce71c1aaf9650b3cafd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5c2dca9a7a7ff6a2df34158903515e2e4fd3d2b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5f9880403e6b71d56924748ba331daf836243fca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f5c773a2871cf446e3f36b2834fb25bbb28512b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cbd87ba6a13891acf6180783f8234a8b7a3e3d4d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47337","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.527","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: core: Fix bad pointer dereference when ehandler kthread is invalid\n\nCommit 66a834d09293 (\"scsi: core: Fix error handling of scsi_host_alloc()\")\nchanged the allocation logic to call put_device() to perform host cleanup\nwith the assumption that IDA removal and stopping the kthread would\nproperly be performed in scsi_host_dev_release(). However, in the unlikely\ncase that the error handler thread fails to spawn, shost->ehandler is set\nto ERR_PTR(-ENOMEM).\n\nThe error handler cleanup code in scsi_host_dev_release() will call\nkthread_stop() if shost->ehandler != NULL which will always be the case\nwhether the kthread was successfully spawned or not. In the case that it\nfailed to spawn this has the nasty side effect of trying to dereference an\ninvalid pointer when kthread_stop() is called. The following splat provides\nan example of this behavior in the wild:\n\nscsi host11: error handler thread failed to spawn, error = -4\nKernel attempted to read user page (10c) - exploit attempt? (uid: 0)\nBUG: Kernel NULL pointer dereference on read at 0x0000010c\nFaulting instruction address: 0xc00000000818e9a8\nOops: Kernel access of bad area, sig: 11 [#1]\nLE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries\nModules linked in: ibmvscsi(+) scsi_transport_srp dm_multipath dm_mirror dm_region\n hash dm_log dm_mod fuse overlay squashfs loop\nCPU: 12 PID: 274 Comm: systemd-udevd Not tainted 5.13.0-rc7 #1\nNIP:  c00000000818e9a8 LR: c0000000089846e8 CTR: 0000000000007ee8\nREGS: c000000037d12ea0 TRAP: 0300   Not tainted  (5.13.0-rc7)\nMSR:  800000000280b033 &lt;SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE&gt;  CR: 28228228\nXER: 20040001\nCFAR: c0000000089846e4 DAR: 000000000000010c DSISR: 40000000 IRQMASK: 0\nGPR00: c0000000089846e8 c000000037d13140 c000000009cc1100 fffffffffffffffc\nGPR04: 0000000000000001 0000000000000000 0000000000000000 c000000037dc0000\nGPR08: 0000000000000000 c000000037dc0000 0000000000000001 00000000fffff7ff\nGPR12: 0000000000008000 c00000000a049000 c000000037d13d00 000000011134d5a0\nGPR16: 0000000000001740 c0080000190d0000 c0080000190d1740 c000000009129288\nGPR20: c000000037d13bc0 0000000000000001 c000000037d13bc0 c0080000190b7898\nGPR24: c0080000190b7708 0000000000000000 c000000033bb2c48 0000000000000000\nGPR28: c000000046b28280 0000000000000000 000000000000010c fffffffffffffffc\nNIP [c00000000818e9a8] kthread_stop+0x38\/0x230\nLR [c0000000089846e8] scsi_host_dev_release+0x98\/0x160\nCall Trace:\n[c000000033bb2c48] 0xc000000033bb2c48 (unreliable)\n[c0000000089846e8] scsi_host_dev_release+0x98\/0x160\n[c00000000891e960] device_release+0x60\/0x100\n[c0000000087e55c4] kobject_release+0x84\/0x210\n[c00000000891ec78] put_device+0x28\/0x40\n[c000000008984ea4] scsi_host_alloc+0x314\/0x430\n[c0080000190b38bc] ibmvscsi_probe+0x54\/0xad0 [ibmvscsi]\n[c000000008110104] vio_bus_probe+0xa4\/0x4b0\n[c00000000892a860] really_probe+0x140\/0x680\n[c00000000892aefc] driver_probe_device+0x15c\/0x200\n[c00000000892b63c] device_driver_attach+0xcc\/0xe0\n[c00000000892b740] __driver_attach+0xf0\/0x200\n[c000000008926f28] bus_for_each_dev+0xa8\/0x130\n[c000000008929ce4] driver_attach+0x34\/0x50\n[c000000008928fc0] bus_add_driver+0x1b0\/0x300\n[c00000000892c798] driver_register+0x98\/0x1a0\n[c00000000810eb60] __vio_register_driver+0x80\/0xe0\n[c0080000190b4a30] ibmvscsi_module_init+0x9c\/0xdc [ibmvscsi]\n[c0000000080121d0] do_one_initcall+0x60\/0x2d0\n[c000000008261abc] do_init_module+0x7c\/0x320\n[c000000008265700] load_module+0x2350\/0x25b0\n[c000000008265cb4] __do_sys_finit_module+0xd4\/0x160\n[c000000008031110] system_call_exception+0x150\/0x2d0\n[c00000000800d35c] system_call_common+0xec\/0x278\n\nFix this be nulling shost->ehandler when the kthread fails to spawn."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/887bfae2732b5b02a86a859fd239d34f7ff93c05","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8e4212ecf0713dd57d0e3209a66201da582149b1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/93aa71ad7379900e61c8adff6a710a4c18c7c99b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c1671d2d2ef8a84837eea1b4d99ca0c6a66fb691","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d2f0b960d07e52bb664471b4de0ed8b08c636b3a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e1bd3fac2baa3d5c04375980c1d5263a3335af92","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ea518b70ed5e4598c8d706f37fc16f7b06e440bd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f3d0a109240c9bed5c60d819014786be3a2fe515","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47338","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.610","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nfbmem: Do not delete the mode that is still in use\n\nThe execution of fb_delete_videomode() is not based on the result of the\nprevious fbcon_mode_deleted(). As a result, the mode is directly deleted,\nregardless of whether it is still in use, which may cause UAF.\n\n==================================================================\nBUG: KASAN: use-after-free in fb_mode_is_equal+0x36e\/0x5e0 \\\ndrivers\/video\/fbdev\/core\/modedb.c:924\nRead of size 4 at addr ffff88807e0ddb1c by task syz-executor.0\/18962\n\nCPU: 2 PID: 18962 Comm: syz-executor.0 Not tainted 5.10.45-rc1+ #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ...\nCall Trace:\n __dump_stack lib\/dump_stack.c:77 [inline]\n dump_stack+0x137\/0x1be lib\/dump_stack.c:118\n print_address_description+0x6c\/0x640 mm\/kasan\/report.c:385\n __kasan_report mm\/kasan\/report.c:545 [inline]\n kasan_report+0x13d\/0x1e0 mm\/kasan\/report.c:562\n fb_mode_is_equal+0x36e\/0x5e0 drivers\/video\/fbdev\/core\/modedb.c:924\n fbcon_mode_deleted+0x16a\/0x220 drivers\/video\/fbdev\/core\/fbcon.c:2746\n fb_set_var+0x1e1\/0xdb0 drivers\/video\/fbdev\/core\/fbmem.c:975\n do_fb_ioctl+0x4d9\/0x6e0 drivers\/video\/fbdev\/core\/fbmem.c:1108\n vfs_ioctl fs\/ioctl.c:48 [inline]\n __do_sys_ioctl fs\/ioctl.c:753 [inline]\n __se_sys_ioctl+0xfb\/0x170 fs\/ioctl.c:739\n do_syscall_64+0x2d\/0x70 arch\/x86\/entry\/common.c:46\n entry_SYSCALL_64_after_hwframe+0x44\/0xa9\n\nFreed by task 18960:\n kasan_save_stack mm\/kasan\/common.c:48 [inline]\n kasan_set_track+0x3d\/0x70 mm\/kasan\/common.c:56\n kasan_set_free_info+0x17\/0x30 mm\/kasan\/generic.c:355\n __kasan_slab_free+0x108\/0x140 mm\/kasan\/common.c:422\n slab_free_hook mm\/slub.c:1541 [inline]\n slab_free_freelist_hook+0xd6\/0x1a0 mm\/slub.c:1574\n slab_free mm\/slub.c:3139 [inline]\n kfree+0xca\/0x3d0 mm\/slub.c:4121\n fb_delete_videomode+0x56a\/0x820 drivers\/video\/fbdev\/core\/modedb.c:1104\n fb_set_var+0x1f3\/0xdb0 drivers\/video\/fbdev\/core\/fbmem.c:978\n do_fb_ioctl+0x4d9\/0x6e0 drivers\/video\/fbdev\/core\/fbmem.c:1108\n vfs_ioctl fs\/ioctl.c:48 [inline]\n __do_sys_ioctl fs\/ioctl.c:753 [inline]\n __se_sys_ioctl+0xfb\/0x170 fs\/ioctl.c:739\n do_syscall_64+0x2d\/0x70 arch\/x86\/entry\/common.c:46\n entry_SYSCALL_64_after_hwframe+0x44\/0xa9"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/087bff9acd2ec6db3f61aceb3224bde90fe0f7f8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0af778269a522c988ef0b4188556aba97fb420cc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/359311b85ebec7c07c3a08ae2f3def946cad33fa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d6e76469157d8f240e5dec6f8411aa8d306b1126","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f193509afc7ff37a46862610c93b896044d5b693","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47339","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.693","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: v4l2-core: explicitly clear ioctl input data\n\nAs seen from a recent syzbot bug report, mistakes in the compat ioctl\nimplementation can lead to uninitialized kernel stack data getting used\nas input for driver ioctl handlers.\n\nThe reported bug is now fixed, but it's possible that other related\nbugs are still present or get added in the future. As the drivers need\nto check user input already, the possible impact is fairly low, but it\nmight still cause an information leak.\n\nTo be on the safe side, always clear the entire ioctl buffer before\ncalling the conversion handler functions that are meant to initialize\nthem."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7b53cca764f9b291b7907fcd39d9e66ad728ee0b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bfb48b54db25c3b4ef4bef5e0691464ebc4aa335","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dc02c0b2bd6096f2f3ce63e1fc317aeda05f74d8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47340","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.770","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix GPF in diFree\n\nAvoid passing inode with\nJFS_SBI(inode->i_sb)->ipimap == NULL to\ndiFree()[1]. GFP will appear:\n\n\tstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\nJFS_IP() will return invalid pointer when ipimap == NULL\n\nCall Trace:\n diFree+0x13d\/0x2dc0 fs\/jfs\/jfs_imap.c:853 [1]\n jfs_evict_inode+0x2c9\/0x370 fs\/jfs\/inode.c:154\n evict+0x2ed\/0x750 fs\/inode.c:578\n iput_final fs\/inode.c:1654 [inline]\n iput.part.0+0x3fe\/0x820 fs\/inode.c:1680\n iput+0x58\/0x70 fs\/inode.c:1670"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3bb27e27240289b47d3466f647a55c567adbdc3a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/42f102ea1943ecb10a0756bf75424de5d1d5beed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/49def1b0644892e3b113673c13d650c3060b43bc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/745c9a59422c63f661f4374ed5181740db4130a1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7bde24bde490f3139eee147efc6d60d6040fe975","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8018936950360f1c503bb385e158cfc5e4945d18","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9d574f985fe33efd6911f4d752de6f485a1ea732","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a21e5cb1a64c904f1f0ef7b2d386fc7d2b1d2ce2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aff8d95b69051d0cf4acc3d91f22299fdbb9dfb3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47341","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.850","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: mmio: Fix use-after-free Read in kvm_vm_ioctl_unregister_coalesced_mmio\n\nBUG: KASAN: use-after-free in kvm_vm_ioctl_unregister_coalesced_mmio+0x7c\/0x1ec arch\/arm64\/kvm\/..\/..\/..\/virt\/kvm\/coalesced_mmio.c:183\nRead of size 8 at addr ffff0000c03a2500 by task syz-executor083\/4269\n\nCPU: 5 PID: 4269 Comm: syz-executor083 Not tainted 5.10.0 #7\nHardware name: linux,dummy-virt (DT)\nCall trace:\n dump_backtrace+0x0\/0x2d0 arch\/arm64\/kernel\/stacktrace.c:132\n show_stack+0x28\/0x34 arch\/arm64\/kernel\/stacktrace.c:196\n __dump_stack lib\/dump_stack.c:77 [inline]\n dump_stack+0x110\/0x164 lib\/dump_stack.c:118\n print_address_description+0x78\/0x5c8 mm\/kasan\/report.c:385\n __kasan_report mm\/kasan\/report.c:545 [inline]\n kasan_report+0x148\/0x1e4 mm\/kasan\/report.c:562\n check_memory_region_inline mm\/kasan\/generic.c:183 [inline]\n __asan_load8+0xb4\/0xbc mm\/kasan\/generic.c:252\n kvm_vm_ioctl_unregister_coalesced_mmio+0x7c\/0x1ec arch\/arm64\/kvm\/..\/..\/..\/virt\/kvm\/coalesced_mmio.c:183\n kvm_vm_ioctl+0xe30\/0x14c4 arch\/arm64\/kvm\/..\/..\/..\/virt\/kvm\/kvm_main.c:3755\n vfs_ioctl fs\/ioctl.c:48 [inline]\n __do_sys_ioctl fs\/ioctl.c:753 [inline]\n __se_sys_ioctl fs\/ioctl.c:739 [inline]\n __arm64_sys_ioctl+0xf88\/0x131c fs\/ioctl.c:739\n __invoke_syscall arch\/arm64\/kernel\/syscall.c:36 [inline]\n invoke_syscall arch\/arm64\/kernel\/syscall.c:48 [inline]\n el0_svc_common arch\/arm64\/kernel\/syscall.c:158 [inline]\n do_el0_svc+0x120\/0x290 arch\/arm64\/kernel\/syscall.c:220\n el0_svc+0x1c\/0x28 arch\/arm64\/kernel\/entry-common.c:367\n el0_sync_handler+0x98\/0x170 arch\/arm64\/kernel\/entry-common.c:383\n el0_sync+0x140\/0x180 arch\/arm64\/kernel\/entry.S:670\n\nAllocated by task 4269:\n stack_trace_save+0x80\/0xb8 kernel\/stacktrace.c:121\n kasan_save_stack mm\/kasan\/common.c:48 [inline]\n kasan_set_track mm\/kasan\/common.c:56 [inline]\n __kasan_kmalloc+0xdc\/0x120 mm\/kasan\/common.c:461\n kasan_kmalloc+0xc\/0x14 mm\/kasan\/common.c:475\n kmem_cache_alloc_trace include\/linux\/slab.h:450 [inline]\n kmalloc include\/linux\/slab.h:552 [inline]\n kzalloc include\/linux\/slab.h:664 [inline]\n kvm_vm_ioctl_register_coalesced_mmio+0x78\/0x1cc arch\/arm64\/kvm\/..\/..\/..\/virt\/kvm\/coalesced_mmio.c:146\n kvm_vm_ioctl+0x7e8\/0x14c4 arch\/arm64\/kvm\/..\/..\/..\/virt\/kvm\/kvm_main.c:3746\n vfs_ioctl fs\/ioctl.c:48 [inline]\n __do_sys_ioctl fs\/ioctl.c:753 [inline]\n __se_sys_ioctl fs\/ioctl.c:739 [inline]\n __arm64_sys_ioctl+0xf88\/0x131c fs\/ioctl.c:739\n __invoke_syscall arch\/arm64\/kernel\/syscall.c:36 [inline]\n invoke_syscall arch\/arm64\/kernel\/syscall.c:48 [inline]\n el0_svc_common arch\/arm64\/kernel\/syscall.c:158 [inline]\n do_el0_svc+0x120\/0x290 arch\/arm64\/kernel\/syscall.c:220\n el0_svc+0x1c\/0x28 arch\/arm64\/kernel\/entry-common.c:367\n el0_sync_handler+0x98\/0x170 arch\/arm64\/kernel\/entry-common.c:383\n el0_sync+0x140\/0x180 arch\/arm64\/kernel\/entry.S:670\n\nFreed by task 4269:\n stack_trace_save+0x80\/0xb8 kernel\/stacktrace.c:121\n kasan_save_stack mm\/kasan\/common.c:48 [inline]\n kasan_set_track+0x38\/0x6c mm\/kasan\/common.c:56\n kasan_set_free_info+0x20\/0x40 mm\/kasan\/generic.c:355\n __kasan_slab_free+0x124\/0x150 mm\/kasan\/common.c:422\n kasan_slab_free+0x10\/0x1c mm\/kasan\/common.c:431\n slab_free_hook mm\/slub.c:1544 [inline]\n slab_free_freelist_hook mm\/slub.c:1577 [inline]\n slab_free mm\/slub.c:3142 [inline]\n kfree+0x104\/0x38c mm\/slub.c:4124\n coalesced_mmio_destructor+0x94\/0xa4 arch\/arm64\/kvm\/..\/..\/..\/virt\/kvm\/coalesced_mmio.c:102\n kvm_iodevice_destructor include\/kvm\/iodev.h:61 [inline]\n kvm_io_bus_unregister_dev+0x248\/0x280 arch\/arm64\/kvm\/..\/..\/..\/virt\/kvm\/kvm_main.c:4374\n kvm_vm_ioctl_unregister_coalesced_mmio+0x158\/0x1ec arch\/arm64\/kvm\/..\/..\/..\/virt\/kvm\/coalesced_mmio.c:186\n kvm_vm_ioctl+0xe30\/0x14c4 arch\/arm64\/kvm\/..\/..\/..\/virt\/kvm\/kvm_main.c:3755\n vfs_ioctl fs\/ioctl.c:48 [inline]\n __do_sys_ioctl fs\/ioctl.c:753 [inline]\n __se_sys_ioctl fs\/ioctl.c:739 [inline]\n __arm64_sys_ioctl+0xf88\/0x131c fs\/ioctl.c:739\n __invoke_syscall arch\/arm64\/kernel\/syscall.c:36 [inline]\n invoke_syscall arch\/arm64\/kernel\/sys\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/069d44a24c0ff8f85adf49233aae7a8ca16f5c7e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/23fa2e46a5556f787ce2ea1a315d3ab93cced204","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/679837dc0abaa2c6e2a7bcd86483e05eee1d5066","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8d7c539316d652d217e5e82b89ee204c812a7061","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f2ff9d03432fcb160e9f7d4be26174d89de2779a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47342","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.923","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix possible UAF when remounting r\/o a mmp-protected file system\n\nAfter commit 618f003199c6 (\"ext4: fix memory leak in\next4_fill_super\"), after the file system is remounted read-only, there\nis a race where the kmmpd thread can exit, causing sbi->s_mmp_tsk to\npoint at freed memory, which the call to ext4_stop_mmpd() can trip\nover.\n\nFix this by only allowing kmmpd() to exit when it is stopped via\next4_stop_mmpd().\n\nBug-Report-Link: <20210629143603.2166962-1-yebin10@huawei.com>"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/61bb4a1c417e5b95d9edb4f887f131de32e419cb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7ed572cdf11081f8f9e07abd4bea56a3f2c4edbd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b663890d854403e566169f7e90aed5cd6ff64f6b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47343","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:20.993","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndm btree remove: assign new_root only when removal succeeds\n\nremove_raw() in dm_btree_remove() may fail due to IO read error\n(e.g. read the content of origin block fails during shadowing),\nand the value of shadow_spine::root is uninitialized, but\nthe uninitialized value is still assign to new_root in the\nend of dm_btree_remove().\n\nFor dm-thin, the value of pmd->details_root or pmd->root will become\nan uninitialized value, so if trying to read details_info tree again\nout-of-bound memory may occur as showed below:\n\n  general protection fault, probably for non-canonical address 0x3fdcb14c8d7520\n  CPU: 4 PID: 515 Comm: dmsetup Not tainted 5.13.0-rc6\n  Hardware name: QEMU Standard PC\n  RIP: 0010:metadata_ll_load_ie+0x14\/0x30\n  Call Trace:\n   sm_metadata_count_is_more_than_one+0xb9\/0xe0\n   dm_tm_shadow_block+0x52\/0x1c0\n   shadow_step+0x59\/0xf0\n   remove_raw+0xb2\/0x170\n   dm_btree_remove+0xf4\/0x1c0\n   dm_pool_delete_thin_device+0xc3\/0x140\n   pool_message+0x218\/0x2b0\n   target_message+0x251\/0x290\n   ctl_ioctl+0x1c4\/0x4d0\n   dm_ctl_ioctl+0xe\/0x20\n   __x64_sys_ioctl+0x7b\/0xb0\n   do_syscall_64+0x40\/0xb0\n   entry_SYSCALL_64_after_hwframe+0x44\/0xae\n\nFixing it by only assign new_root when removal succeeds"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4c84b3e0728ffe10d89c633694c35a02b5c477dc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/73f27adaa73e3057a9ec464e33c4f54d34ea5de3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/89bf942314b78d454db92427201421b5dec132d9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8fbae4a1bdb5b889490cdee929e68540151536e5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/964d57d1962d7e68f0f578f05d9ae4a104d74851","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad365e9351ac2b450e7e79932ff6abf59342d91a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b6e58b5466b2959f83034bead2e2e1395cca8aeb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ba47e65a5de3e0e8270301a409fc63d3129fdb9e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c154775619186781aaf8a99333ac07437a1768d5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47344","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.067","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: zr364xx: fix memory leak in zr364xx_start_readpipe\n\nsyzbot reported memory leak in zr364xx driver.\nThe problem was in non-freed urb in case of\nusb_submit_urb() fail.\n\nbacktrace:\n  [<ffffffff82baedf6>] kmalloc include\/linux\/slab.h:561 [inline]\n  [<ffffffff82baedf6>] usb_alloc_urb+0x66\/0xe0 drivers\/usb\/core\/urb.c:74\n  [<ffffffff82f7cce8>] zr364xx_start_readpipe+0x78\/0x130 drivers\/media\/usb\/zr364xx\/zr364xx.c:1022\n  [<ffffffff84251dfc>] zr364xx_board_init drivers\/media\/usb\/zr364xx\/zr364xx.c:1383 [inline]\n  [<ffffffff84251dfc>] zr364xx_probe+0x6a3\/0x851 drivers\/media\/usb\/zr364xx\/zr364xx.c:1516\n  [<ffffffff82bb6507>] usb_probe_interface+0x177\/0x370 drivers\/usb\/core\/driver.c:396\n  [<ffffffff826018a9>] really_probe+0x159\/0x500 drivers\/base\/dd.c:576"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/021c294dff030f3ba38eb81e400ba123db32ecbc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0a045eac8d0427b64577a24d74bb8347c905ac65","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0edd6759167295ea9969e89283b81017b4c688aa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5f3f81f1c96b501d180021c23c25e9f48eaab235","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0633051a6cb24186ff04ce1af99c7de18c1987e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bbc80a972a3c5d7eba3f6c9c07af8fea42f5c513","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c57b2bd3247925e253729dce283d6bf6abc9339d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c57bfd8000d7677bf435873b440eec0c47f73a08","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d69b39d89f362cfeeb54a68690768d0d257b2c8f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47345","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.143","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA\/cma: Fix rdma_resolve_route() memory leak\n\nFix a memory leak when \"mda_resolve_route() is called more than once on\nthe same \"rdma_cm_id\".\n\nThis is possible if cma_query_handler() triggers the\nRDMA_CM_EVENT_ROUTE_ERROR flow which puts the state machine back and\nallows rdma_resolve_route() to be called again."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/032c68b4f5be128a2167f35b558b7cec88fe4972","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/07583ba2e2d8947c3d365d97608cb436510885ac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3d08b5917984f737f32d5bee9737b9075c3895c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/40b613db3a95bc27998e4097d74c2f7e5d083a0b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4893c938f2a140a74be91779e45e4a7fa111198f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/74f160ead74bfe5f2b38afb4fcf86189f9ff40c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e2da8ce2a9543f3ca5c93369bd1fe6eeb572101a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e4e062da082a199357ba4911145f331d40139ad8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f4f553d67236145fa5fd203ed7b35b9377e19939","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47346","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.217","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncoresight: tmc-etf: Fix global-out-of-bounds in tmc_update_etf_buffer()\n\ncommit 6f755e85c332 (\"coresight: Add helper for inserting synchronization\npackets\") removed trailing '\\0' from barrier_pkt array and updated the\ncall sites like etb_update_buffer() to have proper checks for barrier_pkt\nsize before read but missed updating tmc_update_etf_buffer() which still\nreads barrier_pkt past the array size resulting in KASAN out-of-bounds\nbug. Fix this by adding a check for barrier_pkt size before accessing\nlike it is done in etb_update_buffer().\n\n BUG: KASAN: global-out-of-bounds in tmc_update_etf_buffer+0x4b8\/0x698\n Read of size 4 at addr ffffffd05b7d1030 by task perf\/2629\n\n Call trace:\n  dump_backtrace+0x0\/0x27c\n  show_stack+0x20\/0x2c\n  dump_stack+0x11c\/0x188\n  print_address_description+0x3c\/0x4a4\n  __kasan_report+0x140\/0x164\n  kasan_report+0x10\/0x18\n  __asan_report_load4_noabort+0x1c\/0x24\n  tmc_update_etf_buffer+0x4b8\/0x698\n  etm_event_stop+0x248\/0x2d8\n  etm_event_del+0x20\/0x2c\n  event_sched_out+0x214\/0x6f0\n  group_sched_out+0xd0\/0x270\n  ctx_sched_out+0x2ec\/0x518\n  __perf_event_task_sched_out+0x4fc\/0xe6c\n  __schedule+0x1094\/0x16a0\n  preempt_schedule_irq+0x88\/0x170\n  arm64_preempt_schedule_irq+0xf0\/0x18c\n  el1_irq+0xe8\/0x180\n  perf_event_exec+0x4d8\/0x56c\n  setup_new_exec+0x204\/0x400\n  load_elf_binary+0x72c\/0x18c0\n  search_binary_handler+0x13c\/0x420\n  load_script+0x500\/0x6c4\n  search_binary_handler+0x13c\/0x420\n  exec_binprm+0x118\/0x654\n  __do_execve_file+0x77c\/0xba4\n  __arm64_compat_sys_execve+0x98\/0xac\n  el0_svc_common+0x1f8\/0x5e0\n  el0_svc_compat_handler+0x84\/0xb0\n  el0_svc_compat+0x10\/0x50\n\n The buggy address belongs to the variable:\n  barrier_pkt+0x10\/0x40\n\n Memory state around the buggy address:\n  ffffffd05b7d0f00: fa fa fa fa 04 fa fa fa fa fa fa fa 00 00 00 00\n  ffffffd05b7d0f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n >ffffffd05b7d1000: 00 00 00 00 00 00 fa fa fa fa fa fa 00 00 00 03\n                                      ^\n  ffffffd05b7d1080: fa fa fa fa 00 02 fa fa fa fa fa fa 03 fa fa fa\n  ffffffd05b7d1100: fa fa fa fa 00 00 00 00 05 fa fa fa fa fa fa fa\n =================================================================="}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0115687be7b13993066aef602253a53d55f5b11f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/04bd77ef4f4d9fc6102023b85f4590fc2130aac5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/35c1c4bd2d59ad734129d4e232af9d1098023918","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5fae8a946ac2df879caf3f79a193d4766d00239b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/733d4d95c0101d5f277b8e4910411d016e49a9dc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ef0a06acc6b16388640ad367eedfa2a17f1945db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47347","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.287","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwl1251: Fix possible buffer overflow in wl1251_cmd_scan\n\nFunction wl1251_cmd_scan calls memcpy without checking the length.\nHarden by checking the length is within the maximum allowed size."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0f6c0488368c9ac1aa685821916fadba32f5d1ef","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/115103f6e3f1c26c473766c16439c7c8b235529a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/302e2ee34c5f7c5d805b7f835d9a6f2b43474e2a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/40af3960a15339e8bbd3be50c3bc7b35e1a0b6ea","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/57ad99ae3c6738ba87bad259bb57c641ca68ebf6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c5e4a10d7bd5d4f419d8b9705dff60cf69b302a1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d10a87a3535cce2b890897914f5d0d83df669c63","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d3d8b9c9c7843dce31e284927d4c9904fd5a510a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d71dddeb5380613f9ef199f3e7368fd78fb1a46e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47348","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.350","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/display: Avoid HDCP over-read and corruption\n\nInstead of reading the desired 5 bytes of the actual target field,\nthe code was reading 8. This could result in a corrupted value if the\ntrailing 3 bytes were non-zero, so instead use an appropriately sized\nand zero-initialized bounce buffer, and read only 5 bytes before casting\nto u64."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/06888d571b513cbfc0b41949948def6cb81021b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3b2b93a485fb7a970bc8b5daef16f4cf579d172f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/44c7c901cb368a9f2493748f213b247b5872639f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c5b518f4b98dbb2bc31b6a55e6aaa1e0e2948f2e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47349","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.417","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmwifiex: bring down link before deleting interface\n\nWe can deadlock when rmmod'ing the driver or going through firmware\nreset, because the cfg80211_unregister_wdev() has to bring down the link\nfor us, ... which then grab the same wiphy lock.\n\nnl80211_del_interface() already handles a very similar case, with a nice\ndescription:\n\n        \/*\n         * We hold RTNL, so this is safe, without RTNL opencount cannot\n         * reach 0, and thus the rdev cannot be deleted.\n         *\n         * We need to do it for the dev_close(), since that will call\n         * the netdev notifiers, and we need to acquire the mutex there\n         * but don't know if we get there from here or from some other\n         * place (e.g. \"ip link set ... down\").\n         *\/\n        mutex_unlock(&rdev->wiphy.mtx);\n...\n\nDo similarly for mwifiex teardown, by ensuring we bring the link down\nfirst.\n\nSample deadlock trace:\n\n[  247.103516] INFO: task rmmod:2119 blocked for more than 123 seconds.\n[  247.110630]       Not tainted 5.12.4 #5\n[  247.115796] \"echo 0 > \/proc\/sys\/kernel\/hung_task_timeout_secs\" disables this message.\n[  247.124557] task:rmmod           state:D stack:    0 pid: 2119 ppid:  2114 flags:0x00400208\n[  247.133905] Call trace:\n[  247.136644]  __switch_to+0x130\/0x170\n[  247.140643]  __schedule+0x714\/0xa0c\n[  247.144548]  schedule_preempt_disabled+0x88\/0xf4\n[  247.149714]  __mutex_lock_common+0x43c\/0x750\n[  247.154496]  mutex_lock_nested+0x5c\/0x68\n[  247.158884]  cfg80211_netdev_notifier_call+0x280\/0x4e0 [cfg80211]\n[  247.165769]  raw_notifier_call_chain+0x4c\/0x78\n[  247.170742]  call_netdevice_notifiers_info+0x68\/0xa4\n[  247.176305]  __dev_close_many+0x7c\/0x138\n[  247.180693]  dev_close_many+0x7c\/0x10c\n[  247.184893]  unregister_netdevice_many+0xfc\/0x654\n[  247.190158]  unregister_netdevice_queue+0xb4\/0xe0\n[  247.195424]  _cfg80211_unregister_wdev+0xa4\/0x204 [cfg80211]\n[  247.201816]  cfg80211_unregister_wdev+0x20\/0x2c [cfg80211]\n[  247.208016]  mwifiex_del_virtual_intf+0xc8\/0x188 [mwifiex]\n[  247.214174]  mwifiex_uninit_sw+0x158\/0x1b0 [mwifiex]\n[  247.219747]  mwifiex_remove_card+0x38\/0xa0 [mwifiex]\n[  247.225316]  mwifiex_pcie_remove+0xd0\/0xe0 [mwifiex_pcie]\n[  247.231451]  pci_device_remove+0x50\/0xe0\n[  247.235849]  device_release_driver_internal+0x110\/0x1b0\n[  247.241701]  driver_detach+0x5c\/0x9c\n[  247.245704]  bus_remove_driver+0x84\/0xb8\n[  247.250095]  driver_unregister+0x3c\/0x60\n[  247.254486]  pci_unregister_driver+0x2c\/0x90\n[  247.259267]  cleanup_module+0x18\/0xcdc [mwifiex_pcie]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1f9482aa8d412b4ba06ce6ab8e333fb8ca29a06e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/35af69c7c0490fdccfc159c6a87e4d1dc070838a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a3041d39d3c14da97fa3476835aba043ba810cf0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47350","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.483","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc\/mm: Fix lockup on kernel exec fault\n\nThe powerpc kernel is not prepared to handle exec faults from kernel.\nEspecially, the function is_exec_fault() will return 'false' when an\nexec fault is taken by kernel, because the check is based on reading\ncurrent->thread.regs->trap which contains the trap from user.\n\nFor instance, when provoking a LKDTM EXEC_USERSPACE test,\ncurrent->thread.regs->trap is set to SYSCALL trap (0xc00), and\nthe fault taken by the kernel is not seen as an exec fault by\nset_access_flags_filter().\n\nCommit d7df2443cd5f (\"powerpc\/mm: Fix spurious segfaults on radix\nwith autonuma\") made it clear and handled it properly. But later on\ncommit d3ca587404b3 (\"powerpc\/mm: Fix reporting of kernel execute\nfaults\") removed that handling, introducing test based on error_code.\nAnd here is the problem, because on the 603 all upper bits of SRR1\nget cleared when the TLB instruction miss handler bails out to ISI.\n\nUntil commit cbd7e6ca0210 (\"powerpc\/fault: Avoid heavy\nsearch_exception_tables() verification\"), an exec fault from kernel\nat a userspace address was indirectly caught by the lack of entry for\nthat address in the exception tables. But after that commit the\nkernel mainly relies on KUAP or on core mm handling to catch wrong\nuser accesses. Here the access is not wrong, so mm handles it.\nIt is a minor fault because PAGE_EXEC is not set,\nset_access_flags_filter() should set PAGE_EXEC and voila.\nBut as is_exec_fault() returns false as explained in the beginning,\nset_access_flags_filter() bails out without setting PAGE_EXEC flag,\nwhich leads to a forever minor exec fault.\n\nAs the kernel is not prepared to handle such exec faults, the thing to\ndo is to fire in bad_kernel_fault() for any exec fault taken by the\nkernel, as it was prior to commit d3ca587404b3."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/500f81cec9f1bfa5210aa9dd5ba9a06e22f62a35","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a96ec5ebf96ad8e2ba7b1b34103a0be5140fc70","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a82471a14aad90f79d1608d2bcbb019f0ffb53f0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cd5d5e602f502895e47e18cd46804d6d7014e65c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d2e52d4664097a6c1f591d869ec594bd7a0d4925","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47351","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.553","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nubifs: Fix races between xattr_{set|get} and listxattr operations\n\nUBIFS may occur some problems with concurrent xattr_{set|get} and\nlistxattr operations, such as assertion failure, memory corruption,\nstale xattr value[1].\n\nFix it by importing a new rw-lock in @ubifs_inode to serilize write\noperations on xattr, concurrent read operations are still effective,\njust like ext4.\n\n[1] https:\/\/lore.kernel.org\/linux-mtd\/20200630130438.141649-1-houtao1@huawei.com"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/38dde03eb239605f428f3f1e4baa73d4933a4cc6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7adc05b73d91a5e3d4ca7714fa53ad9b70c53d08","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9558612cb829f2c022b788f55d6b8437d5234a82","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c0756f75c22149d20fcb7d8409827cee905eb386","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f4e3634a3b642225a530c292fdb1e8a4007507f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47352","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.620","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio-net: Add validation for used length\n\nThis adds validation for used length (might come\nfrom an untrusted device) to avoid data corruption\nor loss."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3133e01514c3c498f2b01ff210ee6134b70c663c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad993a95c508417acdeb15244109e009e50d8758","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ba710baa1cc1b17a0483f7befe03e696efd17292","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c92298d228f61589dd21657af2bea95fc866b813","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47353","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.693","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nudf: Fix NULL pointer dereference in udf_symlink function\n\nIn function udf_symlink, epos.bh is assigned with the value returned\nby udf_tgetblk. The function udf_tgetblk is defined in udf\/misc.c\nand returns the value of sb_getblk function that could be NULL.\nThen, epos.bh is used without any check, causing a possible\nNULL pointer dereference when sb_getblk fails.\n\nThis fix adds a check to validate the value of epos.bh."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/21bf1414580c36ffc8d8de043beb3508cf812238","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2f3d9ddd32a28803baa547e6274983b67d5e287c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3638705ecd5ad2785e996f820121c0ad15ce64b5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/371566f63cbd0bb6fbb25b8fe9d5798268d35af9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5150877e4d99f85057a458daac7cd7c01005d5c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/80d505aee6398cf8beb72475c7edcf1733c1c68b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aebed6b19e51a34003d998da5ebb1dfdd2cb1d02","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/baea588a42d675e35daeaddd10fbc9700550bc4d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fa236c2b2d4436d9f19ee4e5d5924e90ffd7bb43","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47354","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.767","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/sched: Avoid data corruptions\n\nWait for all dependencies of a job  to complete before\nkilling it to avoid data corruptions."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0687411e2a8858262de2fc4a1d576016fd77292e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0b10ab80695d61422337ede6ff496552d8ace99d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/50d7e03ad487cc45fc85164a299b945a41756ac0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a8e23e3c1ff9ec598ab1b3a941ace6045027781f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c32d0f0e164ffab2a56c7cf8e612584b4b740e2e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47355","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.840","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\natm: nicstar: Fix possible use-after-free in nicstar_cleanup()\n\nThis module's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2f958b6f6ba0854b39be748d21dfe71e0fe6580f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/34e7434ba4e97f4b85c1423a59b2922ba7dff2ea","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4e2a0848ea2cab0716d46f85a8ccd5fa9a493e51","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5b991df8881088448cb223e769e37cab8dd40706","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/99779c9d9ffc7775da6f7fd8a7c93ac61657bed5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7a7b2848312cc4c3a42b6e42a8ab2e441857aba","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7f7c42e31157d1f0871d6a8e1a0b73a6b4ea785","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bdf5334250c69fabf555b7322c75249ea7d5f148","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c471569632654e57c83512e0fc1ba0dbb4544ad6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47356","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:21.920","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmISDN: fix possible use-after-free in HFC_cleanup()\n\nThis module's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/009fc857c5f6fda81f2f7dd851b2d54193a8e733","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3ecd228c636ee17c14662729737fa07242a93cb0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/49331c07ef0f8fdfa42b30ba6a83a657b29d7fbe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/54ff3202928952a100c477248e65ac6db01258a7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5f2818185da0fe82a932f0856633038b66faf124","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/61370ff07e0acc657559a8fac02551dfeb9d3020","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7867ddc5f3de7f289aee63233afc0df4b62834c5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7ee9ae1e0cf55a037c4a99af2acc5d78cb7802d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ed7c3739d0a07e2ec3ccbffe7e93cea01c438cda","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47357","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.000","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\natm: iphase: fix possible use-after-free in ia_module_exit()\n\nThis module's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1c72e6ab66b9598cac741ed397438a52065a8f1f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/89ce0b0747f319eb70f85bc820dcc43cebbd5417","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9e161687855175334ca93c6c3ccb221731194479","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a832ee2f2145f57443b2d565f8cb5490e8339f42","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b58d246a058ae88484758cd4ab27b3180fd5ecf8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bcdd2be48edd8c6867fb44112cb8d18086beae29","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c9172498d4d62c9b64e5fb37c1ee0343e65fe51b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d1fb12412874c94ad037e11d0ecdd1140a439297","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e759ff76ebbbfcdcf83b6634c54dc47828573d8b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47358","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.073","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nstaging: greybus: uart: fix tty use after free\n\nUser space can hold a tty open indefinitely and tty drivers must not\nrelease the underlying structures until the last user is gone.\n\nSwitch to using the tty-port reference counter to manage the life time\nof the greybus tty state to avoid use after free after a disconnect."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4dc56951a8d9d61d364d346c61a5f1d70b4f5e14","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/64062fcaca8872f063ec9da011e7bf30470be33f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/92b67aaafb7c449db9f0c3dcabc0ff967cb3a42d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/92dc0b1f46e12cfabd28d709bb34f7a39431b44f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9872ff6fdce8b229f01993b611b5d1719cb70ff1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a5cfd51f6348e8fd7531461366946039c29c7e69","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b9e697e60ce9890e9258a73eb061288e7d68e5e6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47359","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.143","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix soft lockup during fsstress\n\nBelow traces are observed during fsstress and system got hung.\n[  130.698396] watchdog: BUG: soft lockup - CPU#6 stuck for 26s!"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/71826b068884050d5fdd37fda857ba1539c513d3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9f6c7aff21f81ae8856da1f63847d1362d523409","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47360","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.210","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbinder: make sure fd closes complete\n\nDuring BC_FREE_BUFFER processing, the BINDER_TYPE_FDA object\ncleanup may close 1 or more fds. The close operations are\ncompleted using the task work mechanism -- which means the thread\nneeds to return to userspace or the file object may never be\ndereferenced -- which can lead to hung processes.\n\nForce the binder thread back to userspace if an fd is closed during\nBC_FREE_BUFFER handling."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5fdb55c1ac9585eb23bb2541d5819224429e103d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aa2c274c279ff365a06a4cba263f04965895166e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b95483d8d94b41fa31a84c1d86710b7907a37621","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d5b0473707fa53b03a5db0256ce62b2874bddbc7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47361","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.283","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmcb: fix error handling in mcb_alloc_bus()\n\nThere are two bugs:\n1) If ida_simple_get() fails then this code calls put_device(carrier)\n   but we haven't yet called get_device(carrier) and probably that\n   leads to a use after free.\n2) After device_initialize() then we need to use put_device() to\n   release the bus.  This will free the internal resources tied to the\n   device and call mcb_free_bus() which will free the rest."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/115b07d9f47e3996430b8f2007edd9768e1f807f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/25a1433216489de4abc889910f744e952cb6dbae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/66f74ba9be9daf9c47fface6af3677f602774f6b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7751f609eadf36b1f53712bae430019c53a16eb0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a558261fa57a6deefb0925ab1829f698b194aea","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/91e4ad05bf18322b5921d1a6c9b603f6eb1694f0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9fc198f415dee070a1de957bb5bf5921d8df3499","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47362","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.357","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/pm: Update intermediate power state for SI\n\nUpdate the current state as boot state during dpm initialization.\nDuring the subsequent initialization, set_power_state gets called to\ntransition to the final power state. set_power_state refers to values\nfrom the current state and without current state populated, it could\nresult in NULL pointer dereference.\n\nFor ex: on platforms where PCI speed change is supported through ACPI\nATCS method, the link speed of current state needs to be queried before\ndeciding on changing to final power state's link speed. The logic to query\nATCS-support was broken on certain platforms. The issue became visible\nwhen broken ATCS-support logic got fixed with commit\nf9b7f3703ff9 (\"drm\/amdgpu\/acpi: make ATPX\/ATCS structures global (v2)\").\n\nBug: https:\/\/gitlab.freedesktop.org\/drm\/amd\/-\/issues\/1698"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/06a18e64256f7aecb5a27df02faa3568fcd3c105","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/68d4fbe6220cd1f3d07cab0a4901e62f8c12cc68","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ab39d3cef526ba09c4c6923b4cd7e6ec1c5d4faa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47363","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.430","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnexthop: Fix division by zero while replacing a resilient group\n\nThe resilient nexthop group torture tests in fib_nexthop.sh exposed a\npossible division by zero while replacing a resilient group [1]. The\ndivision by zero occurs when the data path sees a resilient nexthop\ngroup with zero buckets.\n\nThe tests replace a resilient nexthop group in a loop while traffic is\nforwarded through it. The tests do not specify the number of buckets\nwhile performing the replacement, resulting in the kernel allocating a\nstub resilient table (i.e, 'struct nh_res_table') with zero buckets.\n\nThis table should never be visible to the data path, but the old nexthop\ngroup (i.e., 'oldg') might still be used by the data path when the stub\ntable is assigned to it.\n\nFix this by only assigning the stub table to the old nexthop group after\nmaking sure the group is no longer used by the data path.\n\nTested with fib_nexthops.sh:\n\nTests passed: 222\nTests failed:   0\n\n[1]\n divide error: 0000 [#1] PREEMPT SMP KASAN\n CPU: 0 PID: 1850 Comm: ping Not tainted 5.14.0-custom-10271-ga86eb53057fe #1107\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-4.fc34 04\/01\/2014\n RIP: 0010:nexthop_select_path+0x2d2\/0x1a80\n[...]\n Call Trace:\n  fib_select_multipath+0x79b\/0x1530\n  fib_select_path+0x8fb\/0x1c10\n  ip_route_output_key_hash_rcu+0x1198\/0x2da0\n  ip_route_output_key_hash+0x190\/0x340\n  ip_route_output_flow+0x21\/0x120\n  raw_sendmsg+0x91d\/0x2e10\n  inet_sendmsg+0x9e\/0xe0\n  __sys_sendto+0x23d\/0x360\n  __x64_sys_sendto+0xe1\/0x1b0\n  do_syscall_64+0x35\/0x80\n  entry_SYSCALL_64_after_hwframe+0x44\/0xae"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/563f23b002534176f49524b5ca0e1d94d8906c40","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e9d32ec26e7f01d1af13bdc687f586362546aa25","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47364","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.497","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncomedi: Fix memory leak in compat_insnlist()\n\n`compat_insnlist()` handles the 32-bit version of the `COMEDI_INSNLIST`\nioctl (whenwhen `CONFIG_COMPAT` is enabled).  It allocates memory to\ntemporarily hold an array of `struct comedi_insn` converted from the\n32-bit version in user space.  This memory is only being freed if there\nis a fault while filling the array, otherwise it is leaked.\n\nAdd a call to `kfree()` to fix the leak."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/8d6a21e4cd6a319b0662cbe4ad6199e276ac776a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bb509a6ffed2c8b0950f637ab5779aa818ed1596","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f217b6c1e28ed0b353634ce4d92a155b80bd1671","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47365","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.563","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nafs: Fix page leak\n\nThere's a loop in afs_extend_writeback() that adds extra pages to a write\nwe want to make to improve the efficiency of the writeback by making it\nlarger.  This loop stops, however, if we hit a page we can't write back\nfrom immediately, but it doesn't get rid of the page ref we speculatively\nacquired.\n\nThis was caused by the removal of the cleanup loop when the code switched\nfrom using find_get_pages_contig() to xarray scanning as the latter only\ngets a single page at a time, not a batch.\n\nFix this by putting the page on a ref on an early break from the loop.\nUnfortunately, we can't just add that page to the pagevec we're employing\nas we'll go through that and add those pages to the RPC call.\n\nThis was found by the generic\/074 test.  It leaks ~4GiB of RAM each time it\nis run - which can be observed with \"top\"."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/581b2027af0018944ba301d68e7af45c6d1128b5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d130b5fdd42254d92948d06347940276140c927e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47366","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.633","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nafs: Fix corruption in reads at fpos 2G-4G from an OpenAFS server\n\nAFS-3 has two data fetch RPC variants, FS.FetchData and FS.FetchData64, and\nLinux's afs client switches between them when talking to a non-YFS server\nif the read size, the file position or the sum of the two have the upper 32\nbits set of the 64-bit value.\n\nThis is a problem, however, since the file position and length fields of\nFS.FetchData are *signed* 32-bit values.\n\nFix this by capturing the capability bits obtained from the fileserver when\nit's sent an FS.GetCapabilities RPC, rather than just discarding them, and\nthen picking out the VICED_CAPABILITY_64BITFILES flag.  This can then be\nused to decide whether to use FS.FetchData or FS.FetchData64 - and also\nFS.StoreData or FS.StoreData64 - rather than using upper_32_bits() to\nswitch on the parameter values.\n\nThis capabilities flag could also be used to limit the maximum size of the\nfile, but all servers must be checked for that.\n\nNote that the issue does not exist with FS.StoreData - that uses *unsigned*\n32-bit values.  It's also not a problem with Auristor servers as its\nYFS.FetchData64 op uses unsigned 64-bit values.\n\nThis can be tested by cloning a git repo through an OpenAFS client to an\nOpenAFS server and then doing \"git status\" on it from a Linux afs\nclient[1].  Provided the clone has a pack file that's in the 2G-4G range,\nthe git status will show errors like:\n\n\terror: packfile .git\/objects\/pack\/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack does not match index\n\terror: packfile .git\/objects\/pack\/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack does not match index\n\nThis can be observed in the server's FileLog with something like the\nfollowing appearing:\n\nSun Aug 29 19:31:39 2021 SRXAFS_FetchData, Fid = 2303380852.491776.3263114, Host 192.168.11.201:7001, Id 1001\nSun Aug 29 19:31:39 2021 CheckRights: len=0, for host=192.168.11.201:7001\nSun Aug 29 19:31:39 2021 FetchData_RXStyle: Pos 18446744071815340032, Len 3154\nSun Aug 29 19:31:39 2021 FetchData_RXStyle: file size 2400758866\n...\nSun Aug 29 19:31:40 2021 SRXAFS_FetchData returns 5\n\nNote the file position of 18446744071815340032.  This is the requested file\nposition sign-extended."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/b537a3c21775075395af475dcc6ef212fcf29db8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e66fc460d6dcf85cf12288e133a081205aebcd97","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47367","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.700","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio-net: fix pages leaking when building skb in big mode\n\nWe try to use build_skb() if we had sufficient tailroom. But we forget\nto release the unused pages chained via private in big mode which will\nleak pages. Fixing this by release the pages after building the skb in\nbig mode."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/afd92d82c9d715fb97565408755acad81573591a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f020bb63b5d2e5576acadd10e158fe3b04af67ba","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47368","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.773","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nenetc: Fix illegal access when reading affinity_hint\n\nirq_set_affinity_hit() stores a reference to the cpumask_t\nparameter in the irq descriptor, and that reference can be\naccessed later from irq_affinity_hint_proc_show(). Since\nthe cpu_mask parameter passed to irq_set_affinity_hit() has\nonly temporary storage (it's on the stack memory), later\naccesses to it are illegal. Thus reads from the corresponding\nprocfs affinity_hint file can result in paging request oops.\n\nThe issue is fixed by the get_cpu_mask() helper, which provides\na permanent storage for the cpumask_t parameter."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4c4c3052911b577920353a7646e4883d5da40c28","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6c3f1b741c6c2914ea120e3a5790d3e900152f7b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6f329d9da2a5ae032fcde800a99b118124ed5270","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7237a494decfa17d0b9d0076e6cee3235719de90","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47369","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.853","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ns390\/qeth: fix NULL deref in qeth_clear_working_pool_list()\n\nWhen qeth_set_online() calls qeth_clear_working_pool_list() to roll\nback after an error exit from qeth_hardsetup_card(), we are at risk of\naccessing card->qdio.in_q before it was allocated by\nqeth_alloc_qdio_queues() via qeth_mpc_initialize().\n\nqeth_clear_working_pool_list() then dereferences NULL, and by writing to\nqueue->bufs[i].pool_entry scribbles all over the CPU's lowcore.\nResulting in a crash when those lowcore areas are used next (eg. on\nthe next machine-check interrupt).\n\nSuch a scenario would typically happen when the device is first set\nonline and its queues aren't allocated yet. An early IO error or certain\nmisconfigs (eg. mismatched transport mode, bad portno) then cause us to\nerror out from qeth_hardsetup_card() with card->qdio.in_q still being\nNULL.\n\nFix it by checking the pointer for NULL before accessing it.\n\nNote that we also have (rare) paths inside qeth_mpc_initialize() where\na configuration change can cause us to free the existing queues,\nexpecting that subsequent code will allocate them again. If we then\nerror out before that re-allocation happens, the same bug occurs.\n\nRoot-caused-by: Heiko Carstens <hca@linux.ibm.com>"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/248f064af222a1f97ee02c84a98013dfbccad386","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9b00fb12cdc9d8d1c3ffe82a78e74738127803fc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/db94f89e1dadf693c15c2d60de0c34777cea5779","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47370","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:22.927","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: ensure tx skbs always have the MPTCP ext\n\nDue to signed\/unsigned comparison, the expression:\n\n\tinfo->size_goal - skb->len > 0\n\nevaluates to true when the size goal is smaller than the\nskb size. That results in lack of tx cache refill, so that\nthe skb allocated by the core TCP code lacks the required\nMPTCP skb extensions.\n\nDue to the above, syzbot is able to trigger the following WARN_ON():\n\nWARNING: CPU: 1 PID: 810 at net\/mptcp\/protocol.c:1366 mptcp_sendmsg_frag+0x1362\/0x1bc0 net\/mptcp\/protocol.c:1366\nModules linked in:\nCPU: 1 PID: 810 Comm: syz-executor.4 Not tainted 5.14.0-syzkaller #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01\/2011\nRIP: 0010:mptcp_sendmsg_frag+0x1362\/0x1bc0 net\/mptcp\/protocol.c:1366\nCode: ff 4c 8b 74 24 50 48 8b 5c 24 58 e9 0f fb ff ff e8 13 44 8b f8 4c 89 e7 45 31 ed e8 98 57 2e fe e9 81 f4 ff ff e8 fe 43 8b f8 <0f> 0b 41 bd ea ff ff ff e9 6f f4 ff ff 4c 89 e7 e8 b9 8e d2 f8 e9\nRSP: 0018:ffffc9000531f6a0 EFLAGS: 00010216\nRAX: 000000000000697f RBX: 0000000000000000 RCX: ffffc90012107000\nRDX: 0000000000040000 RSI: ffffffff88eac9e2 RDI: 0000000000000003\nRBP: ffff888078b15780 R08: 0000000000000000 R09: 0000000000000000\nR10: ffffffff88eac017 R11: 0000000000000000 R12: ffff88801de0a280\nR13: 0000000000006b58 R14: ffff888066278280 R15: ffff88803c2fe9c0\nFS:  00007fd9f866e700(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007faebcb2f718 CR3: 00000000267cb000 CR4: 00000000001506e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n __mptcp_push_pending+0x1fb\/0x6b0 net\/mptcp\/protocol.c:1547\n mptcp_release_cb+0xfe\/0x210 net\/mptcp\/protocol.c:3003\n release_sock+0xb4\/0x1b0 net\/core\/sock.c:3206\n sk_stream_wait_memory+0x604\/0xed0 net\/core\/stream.c:145\n mptcp_sendmsg+0xc39\/0x1bc0 net\/mptcp\/protocol.c:1749\n inet6_sendmsg+0x99\/0xe0 net\/ipv6\/af_inet6.c:643\n sock_sendmsg_nosec net\/socket.c:704 [inline]\n sock_sendmsg+0xcf\/0x120 net\/socket.c:724\n sock_write_iter+0x2a0\/0x3e0 net\/socket.c:1057\n call_write_iter include\/linux\/fs.h:2163 [inline]\n new_sync_write+0x40b\/0x640 fs\/read_write.c:507\n vfs_write+0x7cf\/0xae0 fs\/read_write.c:594\n ksys_write+0x1ee\/0x250 fs\/read_write.c:647\n do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n do_syscall_64+0x35\/0xb0 arch\/x86\/entry\/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44\/0xae\nRIP: 0033:0x4665f9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fd9f866e188 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\nRAX: ffffffffffffffda RBX: 000000000056c038 RCX: 00000000004665f9\nRDX: 00000000000e7b78 RSI: 0000000020000000 RDI: 0000000000000003\nRBP: 00000000004bfcc4 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 000000000056c038\nR13: 0000000000a9fb1f R14: 00007fd9f866e300 R15: 0000000000022000\n\nFix the issue rewriting the relevant expression to avoid\nsign-related problems - note: size_goal is always >= 0.\n\nAdditionally, ensure that the skb in the tx cache always carries\nthe relevant extension."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/977d293e23b48a1129830d7968605f61c4af71a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f8ff625a8082db8c2b58dcb5229b27928943b94b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47371","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.000","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnexthop: Fix memory leaks in nexthop notification chain listeners\n\nsyzkaller discovered memory leaks [1] that can be reduced to the\nfollowing commands:\n\n # ip nexthop add id 1 blackhole\n # devlink dev reload pci\/0000:06:00.0\n\nAs part of the reload flow, mlxsw will unregister its netdevs and then\nunregister from the nexthop notification chain. Before unregistering\nfrom the notification chain, mlxsw will receive delete notifications for\nnexthop objects using netdevs registered by mlxsw or their uppers. mlxsw\nwill not receive notifications for nexthops using netdevs that are not\ndismantled as part of the reload flow. For example, the blackhole\nnexthop above that internally uses the loopback netdev as its nexthop\ndevice.\n\nOne way to fix this problem is to have listeners flush their nexthop\ntables after unregistering from the notification chain. This is\nerror-prone as evident by this patch and also not symmetric with the\nregistration path where a listener receives a dump of all the existing\nnexthops.\n\nTherefore, fix this problem by replaying delete notifications for the\nlistener being unregistered. This is symmetric to the registration path\nand also consistent with the netdev notification chain.\n\nThe above means that unregister_nexthop_notifier(), like\nregister_nexthop_notifier(), will have to take RTNL in order to iterate\nover the existing nexthops and that any callers of the function cannot\nhold RTNL. This is true for mlxsw and netdevsim, but not for the VXLAN\ndriver. To avoid a deadlock, change the latter to unregister its nexthop\nlistener without holding RTNL, making it symmetric to the registration\npath.\n\n[1]\nunreferenced object 0xffff88806173d600 (size 512):\n  comm \"syz-executor.0\", pid 1290, jiffies 4295583142 (age 143.507s)\n  hex dump (first 32 bytes):\n    41 9d 1e 60 80 88 ff ff 08 d6 73 61 80 88 ff ff  A..`......sa....\n    08 d6 73 61 80 88 ff ff 01 00 00 00 00 00 00 00  ..sa............\n  backtrace:\n    [<ffffffff81a6b576>] kmemleak_alloc_recursive include\/linux\/kmemleak.h:43 [inline]\n    [<ffffffff81a6b576>] slab_post_alloc_hook+0x96\/0x490 mm\/slab.h:522\n    [<ffffffff81a716d3>] slab_alloc_node mm\/slub.c:3206 [inline]\n    [<ffffffff81a716d3>] slab_alloc mm\/slub.c:3214 [inline]\n    [<ffffffff81a716d3>] kmem_cache_alloc_trace+0x163\/0x370 mm\/slub.c:3231\n    [<ffffffff82e8681a>] kmalloc include\/linux\/slab.h:591 [inline]\n    [<ffffffff82e8681a>] kzalloc include\/linux\/slab.h:721 [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_group_create drivers\/net\/ethernet\/mellanox\/mlxsw\/spectrum_router.c:4918 [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_new drivers\/net\/ethernet\/mellanox\/mlxsw\/spectrum_router.c:5054 [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_event+0x59a\/0x2910 drivers\/net\/ethernet\/mellanox\/mlxsw\/spectrum_router.c:5239\n    [<ffffffff813ef67d>] notifier_call_chain+0xbd\/0x210 kernel\/notifier.c:83\n    [<ffffffff813f0662>] blocking_notifier_call_chain kernel\/notifier.c:318 [inline]\n    [<ffffffff813f0662>] blocking_notifier_call_chain+0x72\/0xa0 kernel\/notifier.c:306\n    [<ffffffff8384b9c6>] call_nexthop_notifiers+0x156\/0x310 net\/ipv4\/nexthop.c:244\n    [<ffffffff83852bd8>] insert_nexthop net\/ipv4\/nexthop.c:2336 [inline]\n    [<ffffffff83852bd8>] nexthop_add net\/ipv4\/nexthop.c:2644 [inline]\n    [<ffffffff83852bd8>] rtm_new_nexthop+0x14e8\/0x4d10 net\/ipv4\/nexthop.c:2913\n    [<ffffffff833e9a78>] rtnetlink_rcv_msg+0x448\/0xbf0 net\/core\/rtnetlink.c:5572\n    [<ffffffff83608703>] netlink_rcv_skb+0x173\/0x480 net\/netlink\/af_netlink.c:2504\n    [<ffffffff833de032>] rtnetlink_rcv+0x22\/0x30 net\/core\/rtnetlink.c:5590\n    [<ffffffff836069de>] netlink_unicast_kernel net\/netlink\/af_netlink.c:1314 [inline]\n    [<ffffffff836069de>] netlink_unicast+0x5ae\/0x7f0 net\/netlink\/af_netlink.c:1340\n    [<ffffffff83607501>] netlink_sendmsg+0x8e1\/0xe30 net\/netlink\/af_netlink.c:1929\n    [<ffffffff832fde84>] sock_sendmsg_nosec net\/socket.c:704 [inline\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3106a0847525befe3e22fc723909d1b21eb0d520","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/741760fa6252628a3d3afad439b72437d4b123d9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47372","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.087","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: macb: fix use after free on rmmod\n\nplat_dev->dev->platform_data is released by platform_device_unregister(),\nuse of pclk and hclk is a use-after-free. Since device unregister won't\nneed a clk device we adjust the function call sequence to fix this issue.\n\n[   31.261225] BUG: KASAN: use-after-free in macb_remove+0x77\/0xc6 [macb_pci]\n[   31.275563] Freed by task 306:\n[   30.276782]  platform_device_release+0x25\/0x80"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1da750d1e2140ef43d64d17f301ff6f41b45541e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/46670fb832ee80943715df618632ca13c2e96f2b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4ad6f2d23b0f6ac0d3e5f3102a4256d1c86c90f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7721221e87d25c9840d9ca6b986dbdc410d5ce2b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7d521cc726f30b8e679a6f36d04b18a8ab3c536","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d82d5303c4c539db86588ffb5dc5b26c3f1513e8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47373","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.157","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nirqchip\/gic-v3-its: Fix potential VPE leak on error\n\nIn its_vpe_irq_domain_alloc, when its_vpe_init() returns an error,\nthere is an off-by-one in the number of VPEs to be freed.\n\nFix it by simply passing the number of VPEs allocated, which is the\nindex of the loop iterating over the VPEs.\n\n[maz: fixed commit message]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/280bef512933b2dda01d681d8cbe499b98fc5bdd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/42d3711c23781045e7a5cd28536c774b9a66d20b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/568662e37f927e3dc3e475f3ff7cf4ab7719c5e7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5701e8bff314c155e7afdc467b1e0389d86853d0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7d39992d45acd6f2d6b2f62389c55b61fb3d486b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e0c1c2e5da19685a20557a50f10c6aa4fa26aa84","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47374","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.223","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndma-debug: prevent an error message from causing runtime problems\n\nFor some drivers, that use the DMA API. This error message can be reached\nseveral millions of times per second, causing spam to the kernel's printk\nbuffer and bringing the CPU usage up to 100% (so, it should be rate\nlimited). However, since there is at least one driver that is in the\nmainline and suffers from the error condition, it is more useful to\nerr_printk() here instead of just rate limiting the error message (in hopes\nthat it will make it easier for other drivers that suffer from this issue\nto be spotted)."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/510e1a724ab1bf38150be2c1acabb303f98d0047","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/de4afec2d2946c92c62a15ab341c70b287289e6a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47375","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.290","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nblktrace: Fix uaf in blk_trace access after removing by sysfs\n\nThere is an use-after-free problem triggered by following process:\n\n      P1(sda)\t\t\t\tP2(sdb)\n\t\t\techo 0 > \/sys\/block\/sdb\/trace\/enable\n\t\t\t  blk_trace_remove_queue\n\t\t\t    synchronize_rcu\n\t\t\t    blk_trace_free\n\t\t\t      relay_close\nrcu_read_lock\n__blk_add_trace\n  trace_note_tsk\n  (Iterate running_trace_list)\n\t\t\t        relay_close_buf\n\t\t\t\t  relay_destroy_buf\n\t\t\t\t    kfree(buf)\n    trace_note(sdb's bt)\n      relay_reserve\n        buf->offset <- nullptr deference (use-after-free) !!!\nrcu_read_unlock\n\n[  502.714379] BUG: kernel NULL pointer dereference, address:\n0000000000000010\n[  502.715260] #PF: supervisor read access in kernel mode\n[  502.715903] #PF: error_code(0x0000) - not-present page\n[  502.716546] PGD 103984067 P4D 103984067 PUD 17592b067 PMD 0\n[  502.717252] Oops: 0000 [#1] SMP\n[  502.720308] RIP: 0010:trace_note.isra.0+0x86\/0x360\n[  502.732872] Call Trace:\n[  502.733193]  __blk_add_trace.cold+0x137\/0x1a3\n[  502.733734]  blk_add_trace_rq+0x7b\/0xd0\n[  502.734207]  blk_add_trace_rq_issue+0x54\/0xa0\n[  502.734755]  blk_mq_start_request+0xde\/0x1b0\n[  502.735287]  scsi_queue_rq+0x528\/0x1140\n...\n[  502.742704]  sg_new_write.isra.0+0x16e\/0x3e0\n[  502.747501]  sg_ioctl+0x466\/0x1100\n\nReproduce method:\n  ioctl(\/dev\/sda, BLKTRACESETUP, blk_user_trace_setup[buf_size=127])\n  ioctl(\/dev\/sda, BLKTRACESTART)\n  ioctl(\/dev\/sdb, BLKTRACESETUP, blk_user_trace_setup[buf_size=127])\n  ioctl(\/dev\/sdb, BLKTRACESTART)\n\n  echo 0 > \/sys\/block\/sdb\/trace\/enable &\n  \/\/ Add delay(mdelay\/msleep) before kernel enters blk_trace_free()\n\n  ioctl$SG_IO(\/dev\/sda, SG_IO, ...)\n  \/\/ Enters trace_note_tsk() after blk_trace_free() returned\n  \/\/ Use mdelay in rcu region rather than msleep(which may schedule out)\n\nRemove blk_trace from running_list before calling blk_trace_free() by\nsysfs if blk_trace is at Blktrace_running state."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3815fe7371d2411ce164281cef40d9fc7b323dee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/488da313edf3abea7f7733efe011c96b23740ab5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5afedf670caf30a2b5a52da96eb7eac7dee6a9c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/677e362ba807f3aafe6f405c07e0b37244da5222","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a5f8e86192612d0183047448d8bbe7918b3f1a26","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d56171d9360c0170c5c5f8f7e2362a2e999eca40","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dacfd5e4d1142bfb3809aab3634a375f6f373269","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ebb8d26d93c3ec3c7576c52a8373a2309423c069","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47376","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.380","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Add oversize check before call kvcalloc()\n\nCommit 7661809d493b (\"mm: don't allow oversized kvmalloc() calls\") add the\noversize check. When the allocation is larger than what kmalloc() supports,\nthe following warning triggered:\n\nWARNING: CPU: 0 PID: 8408 at mm\/util.c:597 kvmalloc_node+0x108\/0x110 mm\/util.c:597\nModules linked in:\nCPU: 0 PID: 8408 Comm: syz-executor221 Not tainted 5.14.0-syzkaller #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01\/2011\nRIP: 0010:kvmalloc_node+0x108\/0x110 mm\/util.c:597\nCall Trace:\n kvmalloc include\/linux\/mm.h:806 [inline]\n kvmalloc_array include\/linux\/mm.h:824 [inline]\n kvcalloc include\/linux\/mm.h:829 [inline]\n check_btf_line kernel\/bpf\/verifier.c:9925 [inline]\n check_btf_info kernel\/bpf\/verifier.c:10049 [inline]\n bpf_check+0xd634\/0x150d0 kernel\/bpf\/verifier.c:13759\n bpf_prog_load kernel\/bpf\/syscall.c:2301 [inline]\n __sys_bpf+0x11181\/0x126e0 kernel\/bpf\/syscall.c:4587\n __do_sys_bpf kernel\/bpf\/syscall.c:4691 [inline]\n __se_sys_bpf kernel\/bpf\/syscall.c:4689 [inline]\n __x64_sys_bpf+0x78\/0x90 kernel\/bpf\/syscall.c:4689\n do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n do_syscall_64+0x3d\/0xb0 arch\/x86\/entry\/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44\/0xae"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0e6491b559704da720f6da09dd0a52c4df44c514","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6345a0bee80139ea00a341c4202ebfd1534b5eb0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/93937596e0652d50973f9dc944fea1694ac8cdfd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b5fe7cdfee5901ce5513c30e554d51536e003bde","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47377","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.453","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nxen\/balloon: use a kernel thread instead a workqueue\n\nToday the Xen ballooning is done via delayed work in a workqueue. This\nmight result in workqueue hangups being reported in case of large\namounts of memory are being ballooned in one go (here 16GB):\n\nBUG: workqueue lockup - pool cpus=6 node=0 flags=0x0 nice=0 stuck for 64s!\nShowing busy workqueues and worker pools:\nworkqueue events: flags=0x0\n  pwq 12: cpus=6 node=0 flags=0x0 nice=0 active=2\/256 refcnt=3\n    in-flight: 229:balloon_process\n    pending: cache_reap\nworkqueue events_freezable_power_: flags=0x84\n  pwq 12: cpus=6 node=0 flags=0x0 nice=0 active=1\/256 refcnt=2\n    pending: disk_events_workfn\nworkqueue mm_percpu_wq: flags=0x8\n  pwq 12: cpus=6 node=0 flags=0x0 nice=0 active=1\/256 refcnt=2\n    pending: vmstat_update\npool 12: cpus=6 node=0 flags=0x0 nice=0 hung=64s workers=3 idle: 2222 43\n\nThis can easily be avoided by using a dedicated kernel thread for doing\nthe ballooning work."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/29917bbb07c30be295dece245c7c21872e1a6fbb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/372d3e6ea1e115942fdfb4b25f7003d822d071be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6bba79c6a073741b672b0bf86a1f03c0fe47f973","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8480ed9c2bbd56fc86524998e5f2e3e22f5038f6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/922fd5b6bb13ad31ff36e86e2eba2f26d8135272","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c5d5a43dd2b649a0a290bfed00fb76d1aff89be6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47378","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.527","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-rdma: destroy cm id before destroy qp to avoid use after free\n\nWe should always destroy cm_id before destroy qp to avoid to get cma\nevent after qp was destroyed, which may lead to use after free.\nIn RDMA connection establishment error flow, don't destroy qp in cm\nevent handler.Just report cm_error to upper level, qp will be destroy\nin nvme_rdma_alloc_queue() after destroy cm id."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/9817d763dbe15327b9b3ff4404fa6f27f927e744","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d268a182c56e8361e19fb781137411643312b994","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ecf0dc5a904830c926a64feffd8e01141f89822f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47379","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.590","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nblk-cgroup: fix UAF by grabbing blkcg lock before destroying blkg pd\n\nKASAN reports a use-after-free report when doing fuzz test:\n\n[693354.104835] ==================================================================\n[693354.105094] BUG: KASAN: use-after-free in bfq_io_set_weight_legacy+0xd3\/0x160\n[693354.105336] Read of size 4 at addr ffff888be0a35664 by task sh\/1453338\n\n[693354.105607] CPU: 41 PID: 1453338 Comm: sh Kdump: loaded Not tainted 4.18.0-147\n[693354.105610] Hardware name: Huawei 2288H V5\/BC11SPSCB0, BIOS 0.81 07\/02\/2018\n[693354.105612] Call Trace:\n[693354.105621]  dump_stack+0xf1\/0x19b\n[693354.105626]  ? show_regs_print_info+0x5\/0x5\n[693354.105634]  ? printk+0x9c\/0xc3\n[693354.105638]  ? cpumask_weight+0x1f\/0x1f\n[693354.105648]  print_address_description+0x70\/0x360\n[693354.105654]  kasan_report+0x1b2\/0x330\n[693354.105659]  ? bfq_io_set_weight_legacy+0xd3\/0x160\n[693354.105665]  ? bfq_io_set_weight_legacy+0xd3\/0x160\n[693354.105670]  bfq_io_set_weight_legacy+0xd3\/0x160\n[693354.105675]  ? bfq_cpd_init+0x20\/0x20\n[693354.105683]  cgroup_file_write+0x3aa\/0x510\n[693354.105693]  ? ___slab_alloc+0x507\/0x540\n[693354.105698]  ? cgroup_file_poll+0x60\/0x60\n[693354.105702]  ? 0xffffffff89600000\n[693354.105708]  ? usercopy_abort+0x90\/0x90\n[693354.105716]  ? mutex_lock+0xef\/0x180\n[693354.105726]  kernfs_fop_write+0x1ab\/0x280\n[693354.105732]  ? cgroup_file_poll+0x60\/0x60\n[693354.105738]  vfs_write+0xe7\/0x230\n[693354.105744]  ksys_write+0xb0\/0x140\n[693354.105749]  ? __ia32_sys_read+0x50\/0x50\n[693354.105760]  do_syscall_64+0x112\/0x370\n[693354.105766]  ? syscall_return_slowpath+0x260\/0x260\n[693354.105772]  ? do_page_fault+0x9b\/0x270\n[693354.105779]  ? prepare_exit_to_usermode+0xf9\/0x1a0\n[693354.105784]  ? enter_from_user_mode+0x30\/0x30\n[693354.105793]  entry_SYSCALL_64_after_hwframe+0x65\/0xca\n\n[693354.105875] Allocated by task 1453337:\n[693354.106001]  kasan_kmalloc+0xa0\/0xd0\n[693354.106006]  kmem_cache_alloc_node_trace+0x108\/0x220\n[693354.106010]  bfq_pd_alloc+0x96\/0x120\n[693354.106015]  blkcg_activate_policy+0x1b7\/0x2b0\n[693354.106020]  bfq_create_group_hierarchy+0x1e\/0x80\n[693354.106026]  bfq_init_queue+0x678\/0x8c0\n[693354.106031]  blk_mq_init_sched+0x1f8\/0x460\n[693354.106037]  elevator_switch_mq+0xe1\/0x240\n[693354.106041]  elevator_switch+0x25\/0x40\n[693354.106045]  elv_iosched_store+0x1a1\/0x230\n[693354.106049]  queue_attr_store+0x78\/0xb0\n[693354.106053]  kernfs_fop_write+0x1ab\/0x280\n[693354.106056]  vfs_write+0xe7\/0x230\n[693354.106060]  ksys_write+0xb0\/0x140\n[693354.106064]  do_syscall_64+0x112\/0x370\n[693354.106069]  entry_SYSCALL_64_after_hwframe+0x65\/0xca\n\n[693354.106114] Freed by task 1453336:\n[693354.106225]  __kasan_slab_free+0x130\/0x180\n[693354.106229]  kfree+0x90\/0x1b0\n[693354.106233]  blkcg_deactivate_policy+0x12c\/0x220\n[693354.106238]  bfq_exit_queue+0xf5\/0x110\n[693354.106241]  blk_mq_exit_sched+0x104\/0x130\n[693354.106245]  __elevator_exit+0x45\/0x60\n[693354.106249]  elevator_switch_mq+0xd6\/0x240\n[693354.106253]  elevator_switch+0x25\/0x40\n[693354.106257]  elv_iosched_store+0x1a1\/0x230\n[693354.106261]  queue_attr_store+0x78\/0xb0\n[693354.106264]  kernfs_fop_write+0x1ab\/0x280\n[693354.106268]  vfs_write+0xe7\/0x230\n[693354.106271]  ksys_write+0xb0\/0x140\n[693354.106275]  do_syscall_64+0x112\/0x370\n[693354.106280]  entry_SYSCALL_64_after_hwframe+0x65\/0xca\n\n[693354.106329] The buggy address belongs to the object at ffff888be0a35580\n                 which belongs to the cache kmalloc-1k of size 1024\n[693354.106736] The buggy address is located 228 bytes inside of\n                 1024-byte region [ffff888be0a35580, ffff888be0a35980)\n[693354.107114] The buggy address belongs to the page:\n[693354.107273] page:ffffea002f828c00 count:1 mapcount:0 mapping:ffff888107c17080 index:0x0 compound_mapcount: 0\n[693354.107606] flags: 0x17ffffc0008100(slab|head)\n[693354.107760] raw: 0017ffffc0008100 ffffea002fcbc808 ffffea0030bd3a08 ffff888107c17080\n[693354.108020] r\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7c2c69e010431b0157c9454adcdd2305809bf9fb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/858560b27645e7e97aca37ee8f232cccd658fbd2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d12ddd843f1877de1f7dd2aeea4907cf9ff3ac08","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f58d305887ad7b24986d58e881f6806bb81b2bdf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47380","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.663","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nHID: amd_sfh: Fix potential NULL pointer dereference\n\ndevm_add_action_or_reset() can suddenly invoke amd_mp2_pci_remove() at\nregistration that will cause NULL pointer dereference since\ncorresponding data is not initialized yet. The patch moves\ninitialization of data before devm_add_action_or_reset().\n\nFound by Linux Driver Verification project (linuxtesting.org).\n\n[jkosina@suse.cz: rebase]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/283e4bee701dfcd409dd293f19a268bb2bc8ff38","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d46ef750ed58cbeeba2d9a55c99231c30a172764","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47381","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.733","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: SOF: Fix DSP oops stack dump output contents\n\nFix @buf arg given to hex_dump_to_buffer() and stack address used\nin dump error output."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/a6bb576ead074ca6fa3b53cb1c5d4037a23de81b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ac4dfccb96571ca03af7cac64b7a0b2952c97f3a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47382","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.803","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ns390\/qeth: fix deadlock during failing recovery\n\nCommit 0b9902c1fcc5 (\"s390\/qeth: fix deadlock during recovery\") removed\ntaking discipline_mutex inside qeth_do_reset(), fixing potential\ndeadlocks. An error path was missed though, that still takes\ndiscipline_mutex and thus has the original deadlock potential.\n\nIntermittent deadlocks were seen when a qeth channel path is configured\noffline, causing a race between qeth_do_reset and ccwgroup_remove.\nCall qeth_set_offline() directly in the qeth_do_reset() error case and\nthen a new variant of ccwgroup_set_offline(), without taking\ndiscipline_mutex."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0bfe741741327822d1482c7edef0184636d08b40","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d2b59bd4b06d84a4eadb520b0f71c62fe8ec0a62","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47383","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.873","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntty: Fix out-of-bound vmalloc access in imageblit\n\nThis issue happens when a userspace program does an ioctl\nFBIOPUT_VSCREENINFO passing the fb_var_screeninfo struct\ncontaining only the fields xres, yres, and bits_per_pixel\nwith values.\n\nIf this struct is the same as the previous ioctl, the\nvc_resize() detects it and doesn't call the resize_screen(),\nleaving the fb_var_screeninfo incomplete. And this leads to\nthe updatescrollmode() calculates a wrong value to\nfbcon_display->vrows, which makes the real_y() return a\nwrong value of y, and that value, eventually, causes\nthe imageblit to access an out-of-bound address value.\n\nTo solve this issue I made the resize_screen() be called\neven if the screen does not need any resizing, so it will\n\"fix and fill\" the fb_var_screeninfo independently."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/067c694d06040db6f0c65281bb358452ca6d85b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3b0c406124719b625b1aba431659f5cdc24a982c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/699d926585daa6ec44be556cdc1ab89e5d54557b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/70aed03b1d5a5df974f456cdc8eedb213c94bb8b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7e71fcedfda6f7de18f850a6b36e78d78b04476f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/883f7897a25e3ce14a7f274ca4c73f49ac84002a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a6a240f52e14356386030d8958ae8b1761d2325","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d570c48dd37dbe8fc6875d4461d01a9554ae2560","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47384","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:23.947","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (w83793) Fix NULL pointer dereference by removing unnecessary structure field\n\nIf driver read tmp value sufficient for\n(tmp & 0x08) && (!(tmp & 0x80)) && ((tmp & 0x7) == ((tmp >> 4) & 0x7))\nfrom device then Null pointer dereference occurs.\n(It is possible if tmp = 0b0xyz1xyz, where same literals mean same numbers)\nAlso lm75[] does not serve a purpose anymore after switching to\ndevm_i2c_new_dummy_device() in w83791d_detect_subclients().\n\nThe patch fixes possible NULL pointer dereference by removing lm75[].\n\nFound by Linux Driver Verification project (linuxtesting.org).\n\n[groeck: Dropped unnecessary continuation lines, fixed multi-line alignments]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6cb01fe630eaffc5a2c3f7364436caddba286623","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/746011193f44f97f8784edcf8327c587946745fc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7c4fd5de39f273626a2b0f3a446d2cc85cd47616","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dd4d747ef05addab887dc8ff0d6ab9860bbcd783","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47385","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.020","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (w83792d) Fix NULL pointer dereference by removing unnecessary structure field\n\nIf driver read val value sufficient for\n(val & 0x08) && (!(val & 0x80)) && ((val & 0x7) == ((val >> 4) & 0x7))\nfrom device then Null pointer dereference occurs.\n(It is possible if tmp = 0b0xyz1xyz, where same literals mean same numbers)\nAlso lm75[] does not serve a purpose anymore after switching to\ndevm_i2c_new_dummy_device() in w83791d_detect_subclients().\n\nThe patch fixes possible NULL pointer dereference by removing lm75[].\n\nFound by Linux Driver Verification project (linuxtesting.org).\n\n[groeck: Dropped unnecessary continuation lines, fixed multipline alignment]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0f36b88173f028e372668ae040ab1a496834d278","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1499bb2c3a87a2efea0065adab2bd66badee61c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/200ced5ba724d8bbf29dfac4ed1e17a39ccaccd1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/24af1fe376e22c42238a4a604d31e46c486876c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47386","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.117","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (w83791d) Fix NULL pointer dereference by removing unnecessary structure field\n\nIf driver read val value sufficient for\n(val & 0x08) && (!(val & 0x80)) && ((val & 0x7) == ((val >> 4) & 0x7))\nfrom device then Null pointer dereference occurs.\n(It is possible if tmp = 0b0xyz1xyz, where same literals mean same numbers)\nAlso lm75[] does not serve a purpose anymore after switching to\ndevm_i2c_new_dummy_device() in w83791d_detect_subclients().\n\nThe patch fixes possible NULL pointer dereference by removing lm75[].\n\nFound by Linux Driver Verification project (linuxtesting.org).\n\n[groeck: Dropped unnecessary continuation lines, fixed multi-line alignment]"},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: hwmon: (w83791d) Corrija la desreferencia del puntero NULL eliminando el campo de estructura innecesario. Si el controlador lee el valor val suficiente para (val &amp; 0x08) &amp;&amp; (!(val &amp; 0x80)) &amp;&amp; (( val &amp; 0x7) == ((val &gt;&gt; 4) &amp; 0x7)) desde el dispositivo, luego se produce la desreferencia del puntero null. (Es posible si tmp = 0b0xyz1xyz, donde los mismos literales significan los mismos números) Además, lm75[] ya no sirve para nada después de cambiar a devm_i2c_new_dummy_device() en w83791d_detect_subclients(). El parche corrige la posible desreferencia del puntero NULL eliminando lm75[]. Encontrado por el proyecto de verificación de controladores de Linux (linuxtesting.org). [groeck: Se eliminaron líneas de continuación innecesarias, se corrigió la alineación de varias líneas]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/16887ae4e3defd2c4e7913b6c539f33eaf4eac5c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/44d3c480e4e2a75bf6296a18b4356157991ccd80","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/516d9055039017a20a698103be2b556b4c976bb8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/943c15ac1b84d378da26bba41c83c67e16499ac4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47387","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.183","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq: schedutil: Use kobject release() method to free sugov_tunables\n\nThe struct sugov_tunables is protected by the kobject, so we can't free\nit directly. Otherwise we would get a call trace like this:\n  ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0\/0x30\n  WARNING: CPU: 3 PID: 720 at lib\/debugobjects.c:505 debug_print_object+0xb8\/0x100\n  Modules linked in:\n  CPU: 3 PID: 720 Comm: a.sh Tainted: G        W         5.14.0-rc1-next-20210715-yocto-standard+ #507\n  Hardware name: Marvell OcteonTX CN96XX board (DT)\n  pstate: 40400009 (nZcv daif +PAN -UAO -TCO BTYPE=--)\n  pc : debug_print_object+0xb8\/0x100\n  lr : debug_print_object+0xb8\/0x100\n  sp : ffff80001ecaf910\n  x29: ffff80001ecaf910 x28: ffff00011b10b8d0 x27: ffff800011043d80\n  x26: ffff00011a8f0000 x25: ffff800013cb3ff0 x24: 0000000000000000\n  x23: ffff80001142aa68 x22: ffff800011043d80 x21: ffff00010de46f20\n  x20: ffff800013c0c520 x19: ffff800011d8f5b0 x18: 0000000000000010\n  x17: 6e6968207473696c x16: 5f72656d6974203a x15: 6570797420746365\n  x14: 6a626f2029302065 x13: 303378302f307830 x12: 2b6e665f72656d69\n  x11: ffff8000124b1560 x10: ffff800012331520 x9 : ffff8000100ca6b0\n  x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 0000000000000001\n  x5 : ffff800011d8c000 x4 : ffff800011d8c740 x3 : 0000000000000000\n  x2 : ffff0001108301c0 x1 : ab3c90eedf9c0f00 x0 : 0000000000000000\n  Call trace:\n   debug_print_object+0xb8\/0x100\n   __debug_check_no_obj_freed+0x1c0\/0x230\n   debug_check_no_obj_freed+0x20\/0x88\n   slab_free_freelist_hook+0x154\/0x1c8\n   kfree+0x114\/0x5d0\n   sugov_exit+0xbc\/0xc0\n   cpufreq_exit_governor+0x44\/0x90\n   cpufreq_set_policy+0x268\/0x4a8\n   store_scaling_governor+0xe0\/0x128\n   store+0xc0\/0xf0\n   sysfs_kf_write+0x54\/0x80\n   kernfs_fop_write_iter+0x128\/0x1c0\n   new_sync_write+0xf0\/0x190\n   vfs_write+0x2d4\/0x478\n   ksys_write+0x74\/0x100\n   __arm64_sys_write+0x24\/0x30\n   invoke_syscall.constprop.0+0x54\/0xe0\n   do_el0_svc+0x64\/0x158\n   el0_svc+0x2c\/0xb0\n   el0t_64_sync_handler+0xb0\/0xb8\n   el0t_64_sync+0x198\/0x19c\n  irq event stamp: 5518\n  hardirqs last  enabled at (5517): [<ffff8000100cbd7c>] console_unlock+0x554\/0x6c8\n  hardirqs last disabled at (5518): [<ffff800010fc0638>] el1_dbg+0x28\/0xa0\n  softirqs last  enabled at (5504): [<ffff8000100106e0>] __do_softirq+0x4d0\/0x6c0\n  softirqs last disabled at (5483): [<ffff800010049548>] irq_exit+0x1b0\/0x1b8\n\nSo split the original sugov_tunables_free() into two functions,\nsugov_clear_global_tunables() is just used to clear the global_tunables\nand the new sugov_tunables_free() is used as kobj_type::release to\nrelease the sugov_tunables safely."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: cpufreq: schedutil: utilice el método kobject release() para liberar sugov_tunables. La estructura sugov_tunables está protegida por kobject, por lo que no podemos liberarla directamente. De lo contrario, obtendríamos un seguimiento de llamada como este: ODEBUG: activo libre (estado activo 0) tipo de objeto: timer_list sugerencia: delay_work_timer_fn+0x0\/0x30 ADVERTENCIA: CPU: 3 PID: 720 en lib\/debugobjects.c:505 debug_print_object+0xb8\/ 0x100 Módulos vinculados en: CPU: 3 PID: 720 Comm: a.sh Contaminado: GW 5.14.0-rc1-next-20210715-yocto-standard+ #507 Nombre del hardware: Placa Marvell OcteonTX CN96XX (DT) pstate: 40400009 (nZcv daif +PAN -UAO -TCO BTYPE=--) pc: debug_print_object+0xb8\/0x100 lr: debug_print_object+0xb8\/0x100 sp: ffff80001ecaf910 x29: ffff80001ecaf910 x28: ffff00011b10b8d0 x27: d80 x26: ffff00011a8f0000 x25: ffff800013cb3ff0 x24: 0000000000000000 x23: ffff80001142aa68 x22 : ffff800011043d80 x21: ffff00010de46f20 x20: ffff800013c0c520 x19: ffff800011d8f5b0 x18: 0000000000000010 x17: 6e6968207473696c x16: 656d6974203a x15: 6570797420746365 x14: 6a626f2029302065 x13: 303378302f307830 x12: 2b6e665f72656d69 x11: ffff8000124b1560 x10: 0012331520 x9: ffff8000100ca6b0 x8: 000000000017ffe8 x7: c0000000fffeffff x6: 0000000000000001 x5: ffff800011d8c000 x4: ffff800011d8c740 x3: 0000000000000000 x2: ffff0001108301c0 x1: ab3c90eedf9c0f00 x0: 0000000000000000 Rastreo de llamadas: xb8\/0x100 __debug_check_no_obj_freed+0x1c0\/0x230 debug_check_no_obj_freed+0x20\/0x88 slab_free_freelist_hook+0x154\/0x1c8 kfree+0x114\/0x5d0 sugov_exit+0xbc\/ 0xc0 cpufreq_exit_governor+0x44\/0x90 cpufreq_set_policy+0x268\/0x4a8 store_scaling_governor+0xe0\/0x128 store+0xc0\/0xf0 sysfs_kf_write+0x54\/0x80 kernfs_fop_write_iter+0x128\/0x1c0 nuevo _sync_write+0xf0\/0x190 vfs_write+0x2d4\/0x478 ksys_write+0x74\/0x100 __arm64_sys_write+0x24\/ 0x30 invoke_syscall.constprop.0+0x54\/0xe0 do_el0_svc+0x64\/0x158 el0_svc+0x2c\/0xb0 el0t_64_sync_handler+0xb0\/0xb8 el0t_64_sync+0x198\/0x19c sello de evento irq: 5518 hardirqs habilitado por última vez en ( 5517): [] consola_unlock+ 0x554\/0x6c8 hardirqs deshabilitado por última vez en (5518): [] el1_dbg+0x28\/0xa0 softirqs habilitado por última vez en (5504): [] __do_softirq+0x4d0\/0x6c0 softirqs deshabilitado por última vez en (5483): ff800010049548 &gt;] irq_exit+0x1b0\/0x1b8 Entonces divida el sugov_tunables_free() original en dos funciones, sugov_clear_global_tunables() solo se usa para borrar los global_tunables y el nuevo sugov_tunables_free() se usa como kobj_type::release para liberar los sugov_tunables de forma segura."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/30d57cf2c4116ca6d34ecd1cac94ad84f8bc446c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/463c46705f321201090b69c4ad5da0cd2ce614c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/67c98e023135ff81b8d52998a6fdb8ca0c518d82","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8d62aec52a8c5b1d25a2364b243fcc5098a2ede9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7d4fc84404d45d72f4490417e8cc3efa4af93f1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cb4a53ba37532c861a5f3f22803391018a41849a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e5c6b312ce3cc97e90ea159446e6bfa06645364d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47388","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.257","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: fix use-after-free in CCMP\/GCMP RX\n\nWhen PN checking is done in mac80211, for fragmentation we need\nto copy the PN to the RX struct so we can later use it to do a\ncomparison, since commit bf30ca922a0c (\"mac80211: check defrag\nPN against current frame\").\n\nUnfortunately, in that commit I used the 'hdr' variable without\nit being necessarily valid, so use-after-free could occur if it\nwas necessary to reallocate (parts of) the frame.\n\nFix this by reloading the variable after the code that results\nin the reallocations, if any.\n\nThis fixes https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=214401."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mac80211: corrige el use after free en CCMP\/GCMP RX. Cuando se realiza la verificación de PN en mac80211, para la fragmentación necesitamos copiar el PN a la estructura RX para poder usarlo más tarde. para hacer una comparación, desde la confirmación bf30ca922a0c (\"mac80211: verifique la desfragmentación PN con el marco actual\"). Desafortunadamente, en esa confirmación utilicé la variable 'hdr' sin que fuera necesariamente válida, por lo que podría ocurrir un use after free si fuera necesario reasignar (partes de) el marco. Solucione este problema recargando la variable después del código que da como resultado las reasignaciones, si corresponde. Esto corrige https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=214401."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/27d3eb5616ee2c0a3b30c3fa34813368ed1f3dc9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/31de381aef0ab1b342f62485118dc8a19363dc78","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3d5d629c99c468458022e9b381789de3595bf4dd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/447d001b875d0e7f211c4ba004916028da994258","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/50149e0866a82cef33e680ee68dc380a5bc75d32","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/57de2dcb18742dc2860861c9f496da7d42b67da0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/94513069eb549737bcfc3d988d6ed4da948a2de8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f556e1d6fb9f2923a9a36f3df638c7d79ba09dbb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47389","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.330","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: SVM: fix missing sev_decommission in sev_receive_start\n\nDECOMMISSION the current SEV context if binding an ASID fails after\nRECEIVE_START.  Per AMD's SEV API, RECEIVE_START generates a new guest\ncontext and thus needs to be paired with DECOMMISSION:\n\n     The RECEIVE_START command is the only command other than the LAUNCH_START\n     command that generates a new guest context and guest handle.\n\nThe missing DECOMMISSION can result in subsequent SEV launch failures,\nas the firmware leaks memory and might not able to allocate more SEV\nguest contexts in the future.\n\nNote, LAUNCH_START suffered the same bug, but was previously fixed by\ncommit 934002cd660b (\"KVM: SVM: Call SEV Guest Decommission if ASID\nbinding fails\")."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: SVM: corrige la falta de sev_decommission en sev_receive_start DESCOMMISSION el contexto SEV actual si falla la vinculación de un ASID después de RECEIVE_START. Según la API SEV de AMD, RECEIVE_START genera un nuevo contexto de invitado y, por lo tanto, debe combinarse con DECOMMISSION: el comando RECEIVE_START es el único comando, además del comando LAUNCH_START, que genera un nuevo contexto de invitado y un identificador de invitado. La DESCOMISIÓN faltante puede provocar fallas de inicio de SEV posteriores, ya que el firmware pierde memoria y es posible que no pueda asignar más contextos de invitados de SEV en el futuro. Tenga en cuenta que LAUNCH_START sufrió el mismo error, pero se solucionó previamente mediante la confirmación 934002cd660b (\"KVM: SVM: llame a SEV Guest Decommission si falla el enlace ASID\")."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/efd7866e114dcb44f86d151e843f8276b7efbc67","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f1815e0aa770f2127c5df31eb5c2f0e37b60fa77","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47390","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.397","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Fix stack-out-of-bounds memory access from ioapic_write_indirect()\n\nKASAN reports the following issue:\n\n BUG: KASAN: stack-out-of-bounds in kvm_make_vcpus_request_mask+0x174\/0x440 [kvm]\n Read of size 8 at addr ffffc9001364f638 by task qemu-kvm\/4798\n\n CPU: 0 PID: 4798 Comm: qemu-kvm Tainted: G               X --------- ---\n Hardware name: AMD Corporation DAYTONA_X\/DAYTONA_X, BIOS RYM0081C 07\/13\/2020\n Call Trace:\n  dump_stack+0xa5\/0xe6\n  print_address_description.constprop.0+0x18\/0x130\n  ? kvm_make_vcpus_request_mask+0x174\/0x440 [kvm]\n  __kasan_report.cold+0x7f\/0x114\n  ? kvm_make_vcpus_request_mask+0x174\/0x440 [kvm]\n  kasan_report+0x38\/0x50\n  kasan_check_range+0xf5\/0x1d0\n  kvm_make_vcpus_request_mask+0x174\/0x440 [kvm]\n  kvm_make_scan_ioapic_request_mask+0x84\/0xc0 [kvm]\n  ? kvm_arch_exit+0x110\/0x110 [kvm]\n  ? sched_clock+0x5\/0x10\n  ioapic_write_indirect+0x59f\/0x9e0 [kvm]\n  ? static_obj+0xc0\/0xc0\n  ? __lock_acquired+0x1d2\/0x8c0\n  ? kvm_ioapic_eoi_inject_work+0x120\/0x120 [kvm]\n\nThe problem appears to be that 'vcpu_bitmap' is allocated as a single long\non stack and it should really be KVM_MAX_VCPUS long. We also seem to clear\nthe lower 16 bits of it with bitmap_zero() for no particular reason (my\nguess would be that 'bitmap' and 'vcpu_bitmap' variables in\nkvm_bitmap_or_dest_vcpus() caused the confusion: while the later is indeed\n16-bit long, the later should accommodate all possible vCPUs)."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: KVM: x86: corrige el acceso a la memoria de pila fuera de los límites desde ioapic_write_indirect() KASAN informa el siguiente problema: BUG: KASAN: pila fuera de los límites en kvm_make_vcpus_request_mask+ 0x174\/0x440 [kvm] Lectura de tamaño 8 en la dirección ffffc9001364f638 por tarea qemu-kvm\/4798 CPU: 0 PID: 4798 Comm: qemu-kvm Contaminado: GX --------- --- Nombre de hardware: AMD Corporación DAYTONA_X\/DAYTONA_X, BIOS RYM0081C 13\/07\/2020 Seguimiento de llamadas: dump_stack+0xa5\/0xe6 print_address_description.constprop.0+0x18\/0x130 ? kvm_make_vcpus_request_mask+0x174\/0x440 [kvm] __kasan_report.cold+0x7f\/0x114 ? kvm_make_vcpus_request_mask+0x174\/0x440 [kvm] kasan_report+0x38\/0x50 kasan_check_range+0xf5\/0x1d0 kvm_make_vcpus_request_mask+0x174\/0x440 [kvm] 0 [kvm] ? kvm_arch_exit+0x110\/0x110 [kvm] ? sched_clock+0x5\/0x10 ioapic_write_indirect+0x59f\/0x9e0 [kvm] ? static_obj+0xc0\/0xc0? __lock_acquired+0x1d2\/0x8c0? kvm_ioapic_eoi_inject_work+0x120\/0x120 [kvm] El problema parece ser que 'vcpu_bitmap' está asignado como un único largo en la pila y en realidad debería ser KVM_MAX_VCPUS largo. También parece que borramos los 16 bits inferiores con bitmap_zero() sin ningún motivo en particular (supongo que las variables 'bitmap' y 'vcpu_bitmap' en kvm_bitmap_or_dest_vcpus() causaron la confusión: mientras que la última tiene 16 bits de longitud , este último debería acomodar todas las vCPU posibles)."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2f9b68f57c6278c322793a06063181deded0ad69","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/99a9e9b80f19fc63be005a33d76211dd23114792","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bebabb76ad9acca8858e0371e102fb60d708e25b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47391","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.480","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA\/cma: Ensure rdma_addr_cancel() happens before issuing more requests\n\nThe FSM can run in a circle allowing rdma_resolve_ip() to be called twice\non the same id_priv. While this cannot happen without going through the\nwork, it violates the invariant that the same address resolution\nbackground request cannot be active twice.\n\n       CPU 1                                  CPU 2\n\nrdma_resolve_addr():\n  RDMA_CM_IDLE -> RDMA_CM_ADDR_QUERY\n  rdma_resolve_ip(addr_handler)  #1\n\n\t\t\t process_one_req(): for #1\n                          addr_handler():\n                            RDMA_CM_ADDR_QUERY -> RDMA_CM_ADDR_BOUND\n                            mutex_unlock(&id_priv->handler_mutex);\n                            [.. handler still running ..]\n\nrdma_resolve_addr():\n  RDMA_CM_ADDR_BOUND -> RDMA_CM_ADDR_QUERY\n  rdma_resolve_ip(addr_handler)\n    !! two requests are now on the req_list\n\nrdma_destroy_id():\n destroy_id_handler_unlock():\n  _destroy_id():\n   cma_cancel_operation():\n    rdma_addr_cancel()\n\n                          \/\/ process_one_req() self removes it\n\t\t          spin_lock_bh(&lock);\n                           cancel_delayed_work(&req->work);\n\t                   if (!list_empty(&req->list)) == true\n\n      ! rdma_addr_cancel() returns after process_on_req #1 is done\n\n   kfree(id_priv)\n\n\t\t\t process_one_req(): for #2\n                          addr_handler():\n\t                    mutex_lock(&id_priv->handler_mutex);\n                            !! Use after free on id_priv\n\nrdma_addr_cancel() expects there to be one req on the list and only\ncancels the first one. The self-removal behavior of the work only happens\nafter the handler has returned. This yields a situations where the\nreq_list can have two reqs for the same \"handle\" but rdma_addr_cancel()\nonly cancels the first one.\n\nThe second req remains active beyond rdma_destroy_id() and will\nuse-after-free id_priv once it inevitably triggers.\n\nFix this by remembering if the id_priv has called rdma_resolve_ip() and\nalways cancel before calling it again. This ensures the req_list never\ngets more than one item in it and doesn't cost anything in the normal flow\nthat never uses this strange error path."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: RDMA\/cma: asegúrese de que rdma_addr_cancel() ocurra antes de emitir más solicitudes. El FSM puede ejecutarse en un círculo permitiendo llamar a rdma_resolve_ip() dos veces en el mismo id_priv. Si bien esto no puede suceder sin realizar el trabajo, viola la invariante de que la misma solicitud en segundo plano de resolución de dirección no puede estar activa dos veces. CPU 1 CPU 2 rdma_resolve_addr(): RDMA_CM_IDLE -&gt; RDMA_CM_ADDR_QUERY rdma_resolve_ip(addr_handler) #1 process_one_req(): para #1 addr_handler(): RDMA_CM_ADDR_QUERY -&gt; RDMA_CM_ADDR_BOUND mutex_unlock(&amp;id_priv-&gt;handler_mutex); [.. el controlador sigue ejecutándose...] rdma_resolve_addr(): RDMA_CM_ADDR_BOUND -&gt; RDMA_CM_ADDR_QUERY rdma_resolve_ip(addr_handler)!! ahora hay dos solicitudes en la lista de solicitudes rdma_destroy_id(): destroy_id_handler_unlock(): _destroy_id(): cma_cancel_operation(): rdma_addr_cancel() \/\/ Process_one_req() lo elimina automáticamente spin_lock_bh(&amp;lock); cancel_delayed_work(&amp;req-&gt;trabajo); if (!list_empty(&amp;req-&gt;list)) == verdadero! rdma_addr_cancel() regresa después de que se realiza el proceso_on_req #1 kfree(id_priv) Process_one_req(): para #2 addr_handler(): mutex_lock(&amp;id_priv-&gt;handler_mutex); !! El use after free en id_priv rdma_addr_cancel() espera que haya una solicitud en la lista y solo cancela la primera. El comportamiento de autoeliminación del trabajo sólo ocurre después de que el manipulador ha regresado. Esto genera situaciones en las que req_list puede tener dos solicitudes para el mismo \"identificador\" pero rdma_addr_cancel() solo cancela la primera. El segundo requisito permanece activo más allá de rdma_destroy_id() y usará id_priv después de liberarlo una vez que inevitablemente se active. Solucione este problema recordando si id_priv ha llamado a rdma_resolve_ip() y cancele siempre antes de volver a llamarlo. Esto garantiza que req_list nunca obtenga más de un elemento y no cueste nada en el flujo normal que nunca utiliza esta extraña ruta de error."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/03d884671572af8bcfbc9e63944c1021efce7589","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/305d568b72f17f674155a2a8275f865f207b3808","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9a085fa9b7d644a234465091e038c1911e1a4f2a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47392","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.553","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA\/cma: Fix listener leak in rdma_cma_listen_on_all() failure\n\nIf cma_listen_on_all() fails it leaves the per-device ID still on the\nlisten_list but the state is not set to RDMA_CM_ADDR_BOUND.\n\nWhen the cmid is eventually destroyed cma_cancel_listens() is not called\ndue to the wrong state, however the per-device IDs are still holding the\nrefcount preventing the ID from being destroyed, thus deadlocking:\n\n task:rping state:D stack:   0 pid:19605 ppid: 47036 flags:0x00000084\n Call Trace:\n  __schedule+0x29a\/0x780\n  ? free_unref_page_commit+0x9b\/0x110\n  schedule+0x3c\/0xa0\n  schedule_timeout+0x215\/0x2b0\n  ? __flush_work+0x19e\/0x1e0\n  wait_for_completion+0x8d\/0xf0\n  _destroy_id+0x144\/0x210 [rdma_cm]\n  ucma_close_id+0x2b\/0x40 [rdma_ucm]\n  __destroy_id+0x93\/0x2c0 [rdma_ucm]\n  ? __xa_erase+0x4a\/0xa0\n  ucma_destroy_id+0x9a\/0x120 [rdma_ucm]\n  ucma_write+0xb8\/0x130 [rdma_ucm]\n  vfs_write+0xb4\/0x250\n  ksys_write+0xb5\/0xd0\n  ? syscall_trace_enter.isra.19+0x123\/0x190\n  do_syscall_64+0x33\/0x40\n  entry_SYSCALL_64_after_hwframe+0x44\/0xa9\n\nEnsure that cma_listen_on_all() atomically unwinds its action under the\nlock during error."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: RDMA\/cma: corrige la fuga del oyente en el fallo de rdma_cma_listen_on_all(). Si cma_listen_on_all() falla, deja el ID por dispositivo todavía en la lista de escucha, pero el estado no está configurado en RDMA_CM_ADDR_BOUND. Cuando el cmid finalmente se destruye, no se llama a cma_cancel_listens() debido a un estado incorrecto; sin embargo, los ID por dispositivo aún mantienen el refcount evitando que el ID se destruya, lo que genera un punto muerto: tarea:rping estado:D pila: 0 pid: 19605 ppid: 47036 banderas: 0x00000084 Seguimiento de llamadas: __schedule+0x29a\/0x780? free_unref_page_commit+0x9b\/0x110 Schedule+0x3c\/0xa0 Schedule_timeout+0x215\/0x2b0? __flush_work+0x19e\/0x1e0 wait_for_completion+0x8d\/0xf0 _destroy_id+0x144\/0x210 [rdma_cm] ucma_close_id+0x2b\/0x40 [rdma_ucm] __destroy_id+0x93\/0x2c0 [rdma_ucm] ? __xa_erase+0x4a\/0xa0 ucma_destroy_id+0x9a\/0x120 [rdma_ucm] ucma_write+0xb8\/0x130 [rdma_ucm] vfs_write+0xb4\/0x250 ksys_write+0xb5\/0xd0 ? syscall_trace_enter.isra.19+0x123\/0x190 do_syscall_64+0x33\/0x40 Entry_SYSCALL_64_after_hwframe+0x44\/0xa9 Asegúrese de que cma_listen_on_all() desenrolle atómicamente su acción bajo el bloqueo durante el error."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3f4e68902d2e545033c80d7ad62fd9a439e573f4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca465e1f1f9b38fe916a36f7d80c5d25f2337c81","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e56a5146ef8cb51cd7c9e748267dce7564448a35","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47393","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.627","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (mlxreg-fan) Return non-zero value when fan current state is enforced from sysfs\n\nFan speed minimum can be enforced from sysfs. For example, setting\ncurrent fan speed to 20 is used to enforce fan speed to be at 100%\nspeed, 19 - to be not below 90% speed, etcetera. This feature provides\nability to limit fan speed according to some system wise\nconsiderations, like absence of some replaceable units or high system\nambient temperature.\n\nRequest for changing fan minimum speed is configuration request and can\nbe set only through 'sysfs' write procedure. In this situation value of\nargument 'state' is above nominal fan speed maximum.\n\nReturn non-zero code in this case to avoid\nthermal_cooling_device_stats_update() call, because in this case\nstatistics update violates thermal statistics table range.\nThe issues is observed in case kernel is configured with option\nCONFIG_THERMAL_STATISTICS.\n\nHere is the trace from KASAN:\n[  159.506659] BUG: KASAN: slab-out-of-bounds in thermal_cooling_device_stats_update+0x7d\/0xb0\n[  159.516016] Read of size 4 at addr ffff888116163840 by task hw-management.s\/7444\n[  159.545625] Call Trace:\n[  159.548366]  dump_stack+0x92\/0xc1\n[  159.552084]  ? thermal_cooling_device_stats_update+0x7d\/0xb0\n[  159.635869]  thermal_zone_device_update+0x345\/0x780\n[  159.688711]  thermal_zone_device_set_mode+0x7d\/0xc0\n[  159.694174]  mlxsw_thermal_modules_init+0x48f\/0x590 [mlxsw_core]\n[  159.700972]  ? mlxsw_thermal_set_cur_state+0x5a0\/0x5a0 [mlxsw_core]\n[  159.731827]  mlxsw_thermal_init+0x763\/0x880 [mlxsw_core]\n[  160.070233] RIP: 0033:0x7fd995909970\n[  160.074239] Code: 73 01 c3 48 8b 0d 28 d5 2b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 99 2d 2c 00 00 75 10 b8 01 00 00 00 0f 05 <48> 3d 01 f0 ff ..\n[  160.095242] RSP: 002b:00007fff54f5d938 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[  160.103722] RAX: ffffffffffffffda RBX: 0000000000000013 RCX: 00007fd995909970\n[  160.111710] RDX: 0000000000000013 RSI: 0000000001906008 RDI: 0000000000000001\n[  160.119699] RBP: 0000000001906008 R08: 00007fd995bc9760 R09: 00007fd996210700\n[  160.127687] R10: 0000000000000073 R11: 0000000000000246 R12: 0000000000000013\n[  160.135673] R13: 0000000000000001 R14: 00007fd995bc8600 R15: 0000000000000013\n[  160.143671]\n[  160.145338] Allocated by task 2924:\n[  160.149242]  kasan_save_stack+0x19\/0x40\n[  160.153541]  __kasan_kmalloc+0x7f\/0xa0\n[  160.157743]  __kmalloc+0x1a2\/0x2b0\n[  160.161552]  thermal_cooling_device_setup_sysfs+0xf9\/0x1a0\n[  160.167687]  __thermal_cooling_device_register+0x1b5\/0x500\n[  160.173833]  devm_thermal_of_cooling_device_register+0x60\/0xa0\n[  160.180356]  mlxreg_fan_probe+0x474\/0x5e0 [mlxreg_fan]\n[  160.248140]\n[  160.249807] The buggy address belongs to the object at ffff888116163400\n[  160.249807]  which belongs to the cache kmalloc-1k of size 1024\n[  160.263814] The buggy address is located 64 bytes to the right of\n[  160.263814]  1024-byte region [ffff888116163400, ffff888116163800)\n[  160.277536] The buggy address belongs to the page:\n[  160.282898] page:0000000012275840 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888116167000 pfn:0x116160\n[  160.294872] head:0000000012275840 order:3 compound_mapcount:0 compound_pincount:0\n[  160.303251] flags: 0x200000000010200(slab|head|node=0|zone=2)\n[  160.309694] raw: 0200000000010200 ffffea00046f7208 ffffea0004928208 ffff88810004dbc0\n[  160.318367] raw: ffff888116167000 00000000000a0006 00000001ffffffff 0000000000000000\n[  160.327033] page dumped because: kasan: bad access detected\n[  160.333270]\n[  160.334937] Memory state around the buggy address:\n[  160.356469] >ffff888116163800: fc .."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: hwmon: (mlxreg-fan) Devuelve un valor distinto de cero cuando el estado actual del ventilador se aplica desde sysfs. La velocidad mínima del ventilador se puede aplicar desde sysfs. Por ejemplo, configurar la velocidad actual del ventilador en 20 se utiliza para hacer que la velocidad del ventilador esté al 100 %, 19, para que no esté por debajo del 90 %, etcétera. Esta característica brinda la capacidad de limitar la velocidad del ventilador de acuerdo con algunas consideraciones del sistema, como la ausencia de algunas unidades reemplazables o la alta temperatura ambiente del sistema. La solicitud para cambiar la velocidad mínima del ventilador es una solicitud de configuración y solo se puede configurar mediante el procedimiento de escritura 'sysfs'. En esta situación, el valor del argumento \"estado\" está por encima de la velocidad máxima nominal del ventilador. En este caso, devuelva un código distinto de cero para evitar la llamada a Thermal_cooling_device_stats_update(), porque en este caso la actualización de estadísticas viola el rango de la tabla de estadísticas térmicas. Los problemas se observan en caso de que el kernel esté configurado con la opción CONFIG_THERMAL_STATISTICS. Aquí está el rastro de KASAN: [159.506659] ERROR: KASAN: slab fuera de los límites en Thermal_cooling_device_stats_update+0x7d\/0xb0 [159.516016] Lectura de tamaño 4 en la dirección ffff888116163840 mediante la tarea hw-management.s\/7444 [ 625] Llamada Seguimiento: [159.548366] dump_stack+0x92\/0xc1 [159.552084]? Thermal_cooling_device_stats_update+0x7d\/0xb0 [ 159.635869] Thermal_zone_device_update+0x345\/0x780 [ 159.688711] Thermal_zone_device_set_mode+0x7d\/0xc0 [ 159.694174] mlxsw_thermal_modules_init+0x48f \/0x590 [mlxsw_core] [159.700972]? mlxsw_thermal_set_cur_state+0x5a0\/0x5a0 [mlxsw_core] [ 159.731827] mlxsw_thermal_init+0x763\/0x880 [mlxsw_core] [ 160.070233] RIP: 0033:0x7fd995909970 [ 160.07423 9] Código: 73 01 c3 48 8b 0d 28 d5 2b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 99 2d 2c 00 00 75 10 b8 01 00 00 00 0f 05 &lt;48&gt; 3d 01 f0 ff .. [ 160.095242] RSP: 00007fff54f5d938 EFLAGS: 00000246 ORIG_RAX: 0000000000000001 [ 160.103722] RAX: ffffffffffffffda RBX: 0000000000000013 RCX: 00007fd995909970 [ 160.111710] RDX: 00000000000000013 RSI: 0000000001906008 RDI: 000000000000 0001 [ 160.119699] RBP: 0000000001906008 R08: 00007fd995bc9760 R09: 00007fd996210700 [ 160.127687] R10: 0000000000000073 R11: 000000246 R12: 00000000000000013 [ 160.135673] R13: 0000000000000001 R14: 00007fd995bc8600 R15: 0000000000000013 [ 160.143671] [ 160.145338] Asignado por tarea 2924: [ 160.149242] x40 [ 160.153541] __kasan_kmalloc+0x7f\/0xa0 [ 160.157743] __kmalloc+0x1a2\/0x2b0 [ 160.161552] Thermal_cooling_device_setup_sysfs+0xf9\/0x1a0 [ 160.167687] __thermal_cooling_device_register+0x1b5\/0x500 [ 160.173833] devm_thermal_of_cooling_device_register+0x60\/0xa0 [ 160.180356] mlxreg_fan_probe+0x474\/0x5e0 [mlxreg_fan] [ 160. 248140] [160.249807] La dirección con errores pertenece al objeto en ffff888116163400 [160.249807] que pertenece al caché kmalloc-1k de tamaño 1024 [ 160.263814] La dirección con errores se encuentra 64 bytes a la derecha de [ 160.263814] Región de 1024 bytes [ffff888116163400, ffff888116163800) [ 160.277536] La dirección con errores pertenece a la página: [ 160.2 82898] página:0000000012275840 refcount :1 mapcount:0 mapeo:0000000000000000 índice:0xffff888116167000 pfn:0x116160 [ 160.294872] head:0000000012275840 orden:3 compuesto_mapcount:0 compuesto_pincount:0 [ 160.303251] banderas: 00000010200(slab|cabeza|nodo=0|zona=2) [ 160.309694 ] sin formato: 0200000000010200 ffffea00046f7208 ffffea0004928208 ffff88810004dbc0 [ 160.318367] sin formato: ffff888116167000 00000000000a0006 00000001ffffffff 0000000000000000 [160.327033] página volcada porque: kasan: mal acceso detectado [160.333270] [160.334937] Estado de la memoria alrededor de la dirección con errores: [160.356469] &gt;ffff888116163800: fc .."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5c6e0bce647d9cb32a17d58ffa669b3421fcc6ca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/76bbb482d33bfcd7e9070ecf594c9ec73e01c930","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a6c42ae1530f94724d3c42cf91fe3d3c5e394f8a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aa85fb7bde558bb2e364e85976b14b259c8b6fe8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e6fab7af6ba1bc77c78713a83876f60ca7a4a064","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47394","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.710","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: unlink table before deleting it\n\nsyzbot reports following UAF:\nBUG: KASAN: use-after-free in memcmp+0x18f\/0x1c0 lib\/string.c:955\n nla_strcmp+0xf2\/0x130 lib\/nlattr.c:836\n nft_table_lookup.part.0+0x1a2\/0x460 net\/netfilter\/nf_tables_api.c:570\n nft_table_lookup net\/netfilter\/nf_tables_api.c:4064 [inline]\n nf_tables_getset+0x1b3\/0x860 net\/netfilter\/nf_tables_api.c:4064\n nfnetlink_rcv_msg+0x659\/0x13f0 net\/netfilter\/nfnetlink.c:285\n netlink_rcv_skb+0x153\/0x420 net\/netlink\/af_netlink.c:2504\n\nProblem is that all get operations are lockless, so the commit_mutex\nheld by nft_rcv_nl_event() isn't enough to stop a parallel GET request\nfrom doing read-accesses to the table object even after synchronize_rcu().\n\nTo avoid this, unlink the table first and store the table objects in\non-stack scratch space."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: netfilter: nf_tables: desvincular la tabla antes de eliminarla syzbot informa de lo sigueinte. UAF: BUG: KASAN: use-after-free en memcmp+0x18f\/0x1c0 lib\/string.c:955 nla_strcmp+ 0xf2\/0x130 lib\/nlattr.c:836 nft_table_lookup.part.0+0x1a2\/0x460 net\/netfilter\/nf_tables_api.c:570 nft_table_lookup net\/netfilter\/nf_tables_api.c:4064 [en línea] nf_tables_getset+0x1b3\/0x860 net \/filtro de red\/ nf_tables_api.c:4064 nfnetlink_rcv_msg+0x659\/0x13f0 net\/netfilter\/nfnetlink.c:285 netlink_rcv_skb+0x153\/0x420 net\/netlink\/af_netlink.c:2504 El problema es que todas las operaciones de obtención no tienen bloqueo, por lo que el commit_mutex mantenido por () no es suficiente para evitar que una solicitud GET paralela realice accesos de lectura al objeto de la tabla incluso después de sincronizar_rcu(). Para evitar esto, primero desvincule la tabla y almacene los objetos de la tabla en el espacio temporal de la pila."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/a499b03bf36b0c2e3b958a381d828678ab0ffc5e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f65c73d3aabb87d4353e0bc4a718b5ae8c43fd04","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47395","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.810","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: limit injected vht mcs\/nss in ieee80211_parse_tx_radiotap\n\nLimit max values for vht mcs and nss in ieee80211_parse_tx_radiotap\nroutine in order to fix the following warning reported by syzbot:\n\nWARNING: CPU: 0 PID: 10717 at include\/net\/mac80211.h:989 ieee80211_rate_set_vht include\/net\/mac80211.h:989 [inline]\nWARNING: CPU: 0 PID: 10717 at include\/net\/mac80211.h:989 ieee80211_parse_tx_radiotap+0x101e\/0x12d0 net\/mac80211\/tx.c:2244\nModules linked in:\nCPU: 0 PID: 10717 Comm: syz-executor.5 Not tainted 5.14.0-syzkaller #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01\/2011\nRIP: 0010:ieee80211_rate_set_vht include\/net\/mac80211.h:989 [inline]\nRIP: 0010:ieee80211_parse_tx_radiotap+0x101e\/0x12d0 net\/mac80211\/tx.c:2244\nRSP: 0018:ffffc9000186f3e8 EFLAGS: 00010216\nRAX: 0000000000000618 RBX: ffff88804ef76500 RCX: ffffc900143a5000\nRDX: 0000000000040000 RSI: ffffffff888f478e RDI: 0000000000000003\nRBP: 00000000ffffffff R08: 0000000000000000 R09: 0000000000000100\nR10: ffffffff888f46f9 R11: 0000000000000000 R12: 00000000fffffff8\nR13: ffff88804ef7653c R14: 0000000000000001 R15: 0000000000000004\nFS:  00007fbf5718f700(0000) GS:ffff8880b9c00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000001b2de23000 CR3: 000000006a671000 CR4: 00000000001506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nCall Trace:\n ieee80211_monitor_select_queue+0xa6\/0x250 net\/mac80211\/iface.c:740\n netdev_core_pick_tx+0x169\/0x2e0 net\/core\/dev.c:4089\n __dev_queue_xmit+0x6f9\/0x3710 net\/core\/dev.c:4165\n __bpf_tx_skb net\/core\/filter.c:2114 [inline]\n __bpf_redirect_no_mac net\/core\/filter.c:2139 [inline]\n __bpf_redirect+0x5ba\/0xd20 net\/core\/filter.c:2162\n ____bpf_clone_redirect net\/core\/filter.c:2429 [inline]\n bpf_clone_redirect+0x2ae\/0x420 net\/core\/filter.c:2401\n bpf_prog_eeb6f53a69e5c6a2+0x59\/0x234\n bpf_dispatcher_nop_func include\/linux\/bpf.h:717 [inline]\n __bpf_prog_run include\/linux\/filter.h:624 [inline]\n bpf_prog_run include\/linux\/filter.h:631 [inline]\n bpf_test_run+0x381\/0xa30 net\/bpf\/test_run.c:119\n bpf_prog_test_run_skb+0xb84\/0x1ee0 net\/bpf\/test_run.c:663\n bpf_prog_test_run kernel\/bpf\/syscall.c:3307 [inline]\n __sys_bpf+0x2137\/0x5df0 kernel\/bpf\/syscall.c:4605\n __do_sys_bpf kernel\/bpf\/syscall.c:4691 [inline]\n __se_sys_bpf kernel\/bpf\/syscall.c:4689 [inline]\n __x64_sys_bpf+0x75\/0xb0 kernel\/bpf\/syscall.c:4689\n do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n do_syscall_64+0x35\/0xb0 arch\/x86\/entry\/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44\/0xae\nRIP: 0033:0x4665f9"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mac80211: límite inyectado de vht mcs\/nss en ieee80211_parse_tx_radiotap. Limite los valores máximos para vht mcs y nss en la rutina ieee80211_parse_tx_radiotap para corregir la siguiente advertencia reportada por syzbot: ADVERTENCIA: CPU: 0 PID : 10717 en include\/net\/mac80211.h:989 ieee80211_rate_set_vht include\/net\/mac80211.h:989 [en línea] ADVERTENCIA: CPU: 0 PID: 10717 en include\/net\/mac80211.h:989 ieee80211_parse_tx_radiotap+0x101e\/0x12 d0 neto\/ mac80211\/tx.c:2244 Módulos vinculados en: CPU: 0 PID: 10717 Comm: syz-executor.5 Not tainted 5.14.0-syzkaller #0 Nombre del hardware: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01 \/2011 RIP: 0010:ieee80211_rate_set_vht include\/net\/mac80211.h:989 [en línea] RIP: 0010:ieee80211_parse_tx_radiotap+0x101e\/0x12d0 net\/mac80211\/tx.c:2244 RSP: 86f3e8 EFLAGS: 00010216 RAX: 0000000000000618 RBX: ffff88804ef76500 RCX: ffffc900143a5000 RDX: 0000000000040000 RSI: ffffffff888f478e RDI: 0000000000000003 RBP: 00000000ffffffff R08: 000 R09: 0000000000000100 R10: ffffffff888f46f9 R11: 0000000000000000 R12: 00000000ffffff8 R13: ffff88804ef7653c R14: 0000000000000001 R15: 0000000000000004 FS: 00007fbf5718f700(0000) GS:ffff8880b9c00000( 0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000001b2de23000 CR3: 000000006a671000 CR4: 000000000015 06f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000ffe0ff0 DR7: 0000000000000600 ieee80211_monitor_select_queue+0xa6 \/0x250 net\/mac80211\/iface.c:740 netdev_core_pick_tx+0x169\/0x2e0 net\/core\/dev.c:4089 __dev_queue_xmit+0x6f9\/0x3710 net\/core\/dev.c:4165 __bpf_tx_skb net\/core\/filter.c:2114 [ en línea] __bpf_redirect_no_mac net\/core\/filter.c:2139 [en línea] __bpf_redirect+0x5ba\/0xd20 net\/core\/filter.c:2162 ____bpf_clone_redirect net\/core\/filter.c:2429 [en línea] bpf_clone_redirect+0x2ae\/0x420 net\/core \/filter.c:2401 bpf_prog_eeb6f53a69e5c6a2+0x59\/0x234 bpf_dispatcher_nop_func include\/linux\/bpf.h:717 [en línea] __bpf_prog_run include\/linux\/filter.h:624 [en línea] bpf_prog_run include\/linux\/filter.h:631 [ en línea] bpf_test_run+0x381\/0xa30 net\/bpf\/test_run.c:119 bpf_prog_test_run_skb+0xb84\/0x1ee0 net\/bpf\/test_run.c:663 bpf_prog_test_run kernel\/bpf\/syscall.c:3307 [en línea] 5df0 núcleo\/bpf\/ syscall.c:4605 __do_sys_bpf kernel\/bpf\/syscall.c:4691 [en línea] __se_sys_bpf kernel\/bpf\/syscall.c:4689 [en línea] __x64_sys_bpf+0x75\/0xb0 kernel\/bpf\/syscall.c:4689 4 arco\/x86\/ entrada\/common.c:50 [en línea] do_syscall_64+0x35\/0xb0 arch\/x86\/entry\/common.c:80 entrada_SYSCALL_64_after_hwframe+0x44\/0xae RIP: 0033:0x4665f9"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1282bb00835ff79d2d9c023055d514df5b4de260","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/13cb6d826e0ac0d144b0d48191ff1a111d32f0c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/76538c7b4df314bb937e44c5cb1782f37d47443c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/997ee230e4f5285cd98445c102d9033c7ec4814b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ab85997465b972d39d9747fc16311fa5773374b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ce5f372f5f084ff51c285fc27b232f15a3d00f0b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e5bb852aa2ad963074f0ad73030dbc20a30853e3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47396","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:24.920","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211-hwsim: fix late beacon hrtimer handling\n\nThomas explained in https:\/\/lore.kernel.org\/r\/87mtoeb4hb.ffs@tglx\nthat our handling of the hrtimer here is wrong: If the timer fires\nlate (e.g. due to vCPU scheduling, as reported by Dmitry\/syzbot)\nthen it tries to actually rearm the timer at the next deadline,\nwhich might be in the past already:\n\n 1          2          3          N          N+1\n |          |          |   ...    |          |\n\n ^ intended to fire here (1)\n            ^ next deadline here (2)\n                                      ^ actually fired here\n\nThe next time it fires, it's later, but will still try to schedule\nfor the next deadline (now 3), etc. until it catches up with N,\nbut that might take a long time, causing stalls etc.\n\nNow, all of this is simulation, so we just have to fix it, but\nnote that the behaviour is wrong even per spec, since there's no\nvalue then in sending all those beacons unaligned - they should be\naligned to the TBTT (1, 2, 3, ... in the picture), and if we're a\nbit (or a lot) late, then just resume at that point.\n\nTherefore, change the code to use hrtimer_forward_now() which will\nensure that the next firing of the timer would be at N+1 (in the\npicture), i.e. the next interval point after the current time."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: mac80211-hwsim: corrige el manejo tardío del hrtimer de baliza. Thomas explicó en https:\/\/lore.kernel.org\/r\/87mtoeb4hb.ffs@tglx que nuestro manejo del hrtimer aquí es incorrecto : Si el temporizador se activa tarde (por ejemplo, debido a la programación de vCPU, según lo informado por Dmitry\/syzbot), entonces intenta rearmar el temporizador en la próxima fecha límite, que podría haber sido ya en el pasado: 1 2 3 N N+1 | | | ... | | ^ intención de disparar aquí (1) ^ próxima fecha límite aquí (2) ^ realmente disparado aquí La próxima vez que se active, será más tarde, pero aún así intentará programar la próxima fecha límite (ahora 3), etc. hasta que se ponga al día N, pero eso podría llevar mucho tiempo, causando bloqueos, etc. Ahora, todo esto es simulación, así que solo tenemos que arreglarlo, pero tenga en cuenta que el comportamiento es incorrecto incluso según la especificación, ya que no tiene ningún valor enviar todos esos balizas no alineadas: deben estar alineadas con el TBTT (1, 2, 3, ... en la imagen), y si llegamos un poco (o mucho) tarde, simplemente reanudemos en ese punto. Por lo tanto, cambie el código para usar hrtimer_forward_now(), lo que garantizará que el siguiente disparo del temporizador sea en N+1 (en la imagen), es decir, el siguiente punto del intervalo después de la hora actual."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2c204cf594df3b9468368dc9d0b24d482d93cda7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/313bbd1990b6ddfdaa7da098d0c56b098a833572","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9bee85de2c8155388c09a2e1530a243ec1c96f05","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ed2adf69e29848d1eb9df99633dde655421c92ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47397","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:25.017","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: break out if skb_header_pointer returns NULL in sctp_rcv_ootb\n\nWe should always check if skb_header_pointer's return is NULL before\nusing it, otherwise it may cause null-ptr-deref, as syzbot reported:\n\n  KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n  RIP: 0010:sctp_rcv_ootb net\/sctp\/input.c:705 [inline]\n  RIP: 0010:sctp_rcv+0x1d84\/0x3220 net\/sctp\/input.c:196\n  Call Trace:\n  <IRQ>\n   sctp6_rcv+0x38\/0x60 net\/sctp\/ipv6.c:1109\n   ip6_protocol_deliver_rcu+0x2e9\/0x1ca0 net\/ipv6\/ip6_input.c:422\n   ip6_input_finish+0x62\/0x170 net\/ipv6\/ip6_input.c:463\n   NF_HOOK include\/linux\/netfilter.h:307 [inline]\n   NF_HOOK include\/linux\/netfilter.h:301 [inline]\n   ip6_input+0x9c\/0xd0 net\/ipv6\/ip6_input.c:472\n   dst_input include\/net\/dst.h:460 [inline]\n   ip6_rcv_finish net\/ipv6\/ip6_input.c:76 [inline]\n   NF_HOOK include\/linux\/netfilter.h:307 [inline]\n   NF_HOOK include\/linux\/netfilter.h:301 [inline]\n   ipv6_rcv+0x28c\/0x3c0 net\/ipv6\/ip6_input.c:297"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: sctp: se rompe si skb_header_pointer devuelve NULL en sctp_rcv_ootb. Siempre debemos verificar si el retorno de skb_header_pointer es NULL antes de usarlo; de lo contrario, puede causar null-ptr-deref, como informó syzbot: KASAN : null-ptr-deref en el rango [0x0000000000000000-0x0000000000000007] RIP: 0010:sctp_rcv_ootb net\/sctp\/input.c:705 [en línea] RIP: 0010:sctp_rcv+0x1d84\/0x3220 net\/sctp\/input .c:196 Seguimiento de llamadas :  sctp6_rcv+0x38\/0x60 net\/sctp\/ipv6.c:1109 ip6_protocol_deliver_rcu+0x2e9\/0x1ca0 net\/ipv6\/ip6_input.c:422 ip6_input_finish+0x62\/0x170 net\/ipv6\/ip6_input.c:463 incluir\/linux \/netfilter.h:307 [en línea] NF_HOOK include\/linux\/netfilter.h:301 [en línea] ip6_input+0x9c\/0xd0 net\/ipv6\/ip6_input.c:472 dst_input include\/net\/dst.h:460 [en línea] ip6_rcv_finish net\/ipv6\/ip6_input.c:76 [en línea] NF_HOOK include\/linux\/netfilter.h:307 [en línea] NF_HOOK include\/linux\/netfilter.h:301 [en línea] ipv6_rcv+0x28c\/0x3c0 net\/ipv6\/ip6_input.c :297"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/77bc7dcf0fcc1519341a91788d7a2914fcfddf6d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8180611c238e11676612eb2a9828b1c7a3a4d77b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8c630a7b4f9dec63f08bd881ab77984a724a5124","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9c6591ae8e63f93c895ad5e2703c36c548aac997","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ec018021cf445abbe8e2f3e2a7f1dcc813cb8ea1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f7e745f8e94492a8ac0b0a26e25f2b19d342918f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47398","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:25.247","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA\/hfi1: Fix kernel pointer leak\n\nPointers should be printed with %p or %px rather than cast to 'unsigned\nlong long' and printed with %llx.  Change %llx to %p to print the secured\npointer."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: RDMA\/hfi1: corrige la fuga del puntero del kernel. Los punteros deben imprimirse con %p o %px en lugar de convertirlos a 'unsigned long long' e imprimirse con %llx. Cambie %llx a %p para imprimir el puntero seguro."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/714bfabe5f2901d96902e271d7217601fe4703e5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7d5cfafe8b4006a75b55c2f1fdfdb363f9a5cc98","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47399","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:25.360","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nixgbe: Fix NULL pointer dereference in ixgbe_xdp_setup\n\nThe ixgbe driver currently generates a NULL pointer dereference with\nsome machine (online cpus < 63). This is due to the fact that the\nmaximum value of num_xdp_queues is nr_cpu_ids. Code is in\n\"ixgbe_set_rss_queues\"\".\n\nHere's how the problem repeats itself:\nSome machine (online cpus < 63), And user set num_queues to 63 through\nethtool. Code is in the \"ixgbe_set_channels\",\n\tadapter->ring_feature[RING_F_FDIR].limit = count;\n\nIt becomes 63.\n\nWhen user use xdp, \"ixgbe_set_rss_queues\" will set queues num.\n\tadapter->num_rx_queues = rss_i;\n\tadapter->num_tx_queues = rss_i;\n\tadapter->num_xdp_queues = ixgbe_xdp_queues(adapter);\n\nAnd rss_i's value is from\n\tf = &adapter->ring_feature[RING_F_FDIR];\n\trss_i = f->indices = f->limit;\n\nSo \"num_rx_queues\" > \"num_xdp_queues\", when run to \"ixgbe_xdp_setup\",\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\tif (adapter->xdp_ring[i]->xsk_umem)\n\nIt leads to panic.\n\nCall trace:\n[exception RIP: ixgbe_xdp+368]\nRIP: ffffffffc02a76a0  RSP: ffff9fe16202f8d0  RFLAGS: 00010297\nRAX: 0000000000000000  RBX: 0000000000000020  RCX: 0000000000000000\nRDX: 0000000000000000  RSI: 000000000000001c  RDI: ffffffffa94ead90\nRBP: ffff92f8f24c0c18   R8: 0000000000000000   R9: 0000000000000000\nR10: ffff9fe16202f830  R11: 0000000000000000  R12: ffff92f8f24c0000\nR13: ffff9fe16202fc01  R14: 000000000000000a  R15: ffffffffc02a7530\nORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n 7 [ffff9fe16202f8f0] dev_xdp_install at ffffffffa89fbbcc\n 8 [ffff9fe16202f920] dev_change_xdp_fd at ffffffffa8a08808\n 9 [ffff9fe16202f960] do_setlink at ffffffffa8a20235\n10 [ffff9fe16202fa88] rtnl_setlink at ffffffffa8a20384\n11 [ffff9fe16202fc78] rtnetlink_rcv_msg at ffffffffa8a1a8dd\n12 [ffff9fe16202fcf0] netlink_rcv_skb at ffffffffa8a717eb\n13 [ffff9fe16202fd40] netlink_unicast at ffffffffa8a70f88\n14 [ffff9fe16202fd80] netlink_sendmsg at ffffffffa8a71319\n15 [ffff9fe16202fdf0] sock_sendmsg at ffffffffa89df290\n16 [ffff9fe16202fe08] __sys_sendto at ffffffffa89e19c8\n17 [ffff9fe16202ff30] __x64_sys_sendto at ffffffffa89e1a64\n18 [ffff9fe16202ff38] do_syscall_64 at ffffffffa84042b9\n19 [ffff9fe16202ff50] entry_SYSCALL_64_after_hwframe at ffffffffa8c0008c\n\nSo I fix ixgbe_max_channels so that it will not allow a setting of queues\nto be higher than the num_online_cpus(). And when run to ixgbe_xdp_setup,\ntake the smaller value of num_rx_queues and num_xdp_queues."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ixgbe: corrige la desreferencia del puntero NULL en ixgbe_xdp_setup. El controlador ixgbe actualmente genera una desreferencia del puntero NULL con alguna máquina (cpus en línea &lt;63). Esto se debe al hecho de que el valor máximo de num_xdp_queues es nr_cpu_ids. El código está en \"ixgbe_set_rss_queues\"\". Así es como el problema se repite: alguna máquina (cpus en línea &lt;63), y el usuario configuró num_queues en 63 a través de ethtool. El código está en \"ixgbe_set_channels\", adaptador-&gt;ring_feature[RING_F_FDIR].limit = count; se convierte en 63. Cuando el usuario usa xdp, \"ixgbe_set_rss_queues\" establecerá el número de colas adaptor-&gt;num_rx_queues = rss_i; = &amp;adapter-&gt;ring_feature[RING_F_FDIR]; rss_i = f-&gt;indices = f-&gt;limit; Entonces \"num_rx_queues\" &gt; \"num_xdp_queues\", cuando se ejecuta en \"ixgbe_xdp_setup\", para (i = 0; i &lt; adaptor-&gt;num_rx_queues; i++) if (adapter-&gt;xdp_ring[i]-&gt;xsk_umem) Genera pánico: [excepción RIP: ixgbe_xdp+368] RIP: ffffffffc02a76a0 RSP: ffff9fe16202f8d0 RFLAGS: 00010297 RAX: 0000000000000000 RBX: 0000000000000020 RCX: 0000000000000000 RDX : 0000000000000000 RSI: 000000000000001c RDI: ffffffffa94ead90 RBP: ffff92f8f24c0c18 R8: 0000000000000000 R9: 0000000000000000 R10: ffff9fe1620 2f830 R11: 0000000000000000 R12: ffff92f8f24c0000 R13: ffff9fe16202fc01 R14: 000000000000000a R15: ffffffffc02a7530 ORIG_RAX: ffffffffffffffff CS: : 0018 7 [ffff9fe16202f8f0] dev_xdp_install en fffffffa89fbbcc 8 [ffff9fe16202f920] dev_change_xdp_fd en fffffffa8a08808 9 [ffff9fe16202f960] do_setlink en fffffffa8a20235 10 [ffff9fe16202fa88] rtnl_setlink en fffffffa8a20384 11 [ffff9fe16202fc78] rtnetlink_rcv_msg en ffffffffa8a1a8dd 12 [ffff9fe16202fcf0] netlink_rcv_skb en ffffffffa8a717eb 13 [ffff9fe16202fd40] netlink_unicast en fffffffa8a70f88 14 [ffff9fe162 02fd80] netlink_sendmsg en fffffffa8a71319 15 [ffff9fe16202fdf0] sock_sendmsg en ffffffffa89df290 16 [ffff9fe16202fe08] __sys_sendto en ffffffffa89e19c8 17 [ffff9fe16202ff30] __x64_sys_sendto en ffffffffa89e1a64 8 [ffff9fe16202ff38] do_syscall_64 en ffffffffa84042b9 19 [ffff9fe16202ff50] Entry_SYSCALL_64_after_hwframe en ffffffffa8c0008c Entonces arreglo ixgbe_max_channels para que no permita una configuración de colas ser mayor que num_online_cpus(). Y cuando ejecute ixgbe_xdp_setup, tome el valor más pequeño de num_rx_queues y num_xdp_queues."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/20f6c4a31a525edd9ea6243712b868ba0e4e331e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2744341dd52e935344ca1b4bf189ba0d182a3e8e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/513e605d7a9ce136886cb42ebb2c40e9a6eb6333","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47400","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:25.457","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hns3: do not allow call hns3_nic_net_open repeatedly\n\nhns3_nic_net_open() is not allowed to called repeatly, but there\nis no checking for this. When doing device reset and setup tc\nconcurrently, there is a small oppotunity to call hns3_nic_net_open\nrepeatedly, and cause kernel bug by calling napi_enable twice.\n\nThe calltrace information is like below:\n[ 3078.222780] ------------[ cut here ]------------\n[ 3078.230255] kernel BUG at net\/core\/dev.c:6991!\n[ 3078.236224] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP\n[ 3078.243431] Modules linked in: hns3 hclgevf hclge hnae3 vfio_iommu_type1 vfio_pci vfio_virqfd vfio pv680_mii(O)\n[ 3078.258880] CPU: 0 PID: 295 Comm: kworker\/u8:5 Tainted: G           O      5.14.0-rc4+ #1\n[ 3078.269102] Hardware name:  , BIOS KpxxxFPGA 1P B600 V181 08\/12\/2021\n[ 3078.276801] Workqueue: hclge hclge_service_task [hclge]\n[ 3078.288774] pstate: 60400009 (nZCv daif +PAN -UAO -TCO BTYPE=--)\n[ 3078.296168] pc : napi_enable+0x80\/0x84\ntc qdisc sho[w  3d0e7v8 .e3t0h218 79] lr : hns3_nic_net_open+0x138\/0x510 [hns3]\n\n[ 3078.314771] sp : ffff8000108abb20\n[ 3078.319099] x29: ffff8000108abb20 x28: 0000000000000000 x27: ffff0820a8490300\n[ 3078.329121] x26: 0000000000000001 x25: ffff08209cfc6200 x24: 0000000000000000\n[ 3078.339044] x23: ffff0820a8490300 x22: ffff08209cd76000 x21: ffff0820abfe3880\n[ 3078.349018] x20: 0000000000000000 x19: ffff08209cd76900 x18: 0000000000000000\n[ 3078.358620] x17: 0000000000000000 x16: ffffc816e1727a50 x15: 0000ffff8f4ff930\n[ 3078.368895] x14: 0000000000000000 x13: 0000000000000000 x12: 0000259e9dbeb6b4\n[ 3078.377987] x11: 0096a8f7e764eb40 x10: 634615ad28d3eab5 x9 : ffffc816ad8885b8\n[ 3078.387091] x8 : ffff08209cfc6fb8 x7 : ffff0820ac0da058 x6 : ffff0820a8490344\n[ 3078.396356] x5 : 0000000000000140 x4 : 0000000000000003 x3 : ffff08209cd76938\n[ 3078.405365] x2 : 0000000000000000 x1 : 0000000000000010 x0 : ffff0820abfe38a0\n[ 3078.414657] Call trace:\n[ 3078.418517]  napi_enable+0x80\/0x84\n[ 3078.424626]  hns3_reset_notify_up_enet+0x78\/0xd0 [hns3]\n[ 3078.433469]  hns3_reset_notify+0x64\/0x80 [hns3]\n[ 3078.441430]  hclge_notify_client+0x68\/0xb0 [hclge]\n[ 3078.450511]  hclge_reset_rebuild+0x524\/0x884 [hclge]\n[ 3078.458879]  hclge_reset_service_task+0x3c4\/0x680 [hclge]\n[ 3078.467470]  hclge_service_task+0xb0\/0xb54 [hclge]\n[ 3078.475675]  process_one_work+0x1dc\/0x48c\n[ 3078.481888]  worker_thread+0x15c\/0x464\n[ 3078.487104]  kthread+0x160\/0x170\n[ 3078.492479]  ret_from_fork+0x10\/0x18\n[ 3078.498785] Code: c8027c81 35ffffa2 d50323bf d65f03c0 (d4210000)\n[ 3078.506889] ---[ end trace 8ebe0340a1b0fb44 ]---\n\nOnce hns3_nic_net_open() is excute success, the flag\nHNS3_NIC_STATE_DOWN will be cleared. So add checking for this\nflag, directly return when HNS3_NIC_STATE_DOWN is no set."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: hns3: no permitir llamadas repetidas a hns3_nic_net_open. No se permite llamar repetidamente a hns3_nic_net_open(), pero no se puede verificar esto. Al restablecer y configurar tc el dispositivo simultáneamente, existe una pequeña oportunidad de llamar a hns3_nic_net_open repetidamente y causar un error en el kernel al llamar a napi_enable dos veces. La información del seguimiento de llamadas es la siguiente: [3078.222780] ------------[ cortar aquí ]------------ [ 3078.230255] BUG del kernel en net\/core\/dev. c:6991! [3078.236224] Error interno: Ups - BUG: 0 [#1] SMP PREEMPLEADO [3078.243431] Módulos vinculados en: hns3 hclgevf hclge hnae3 vfio_iommu_type1 vfio_pci vfio_virqfd vfio pv680_mii(O) [ 3078.258880 CPU : 0 PID: 295 Comunicaciones: kworker\/u8 :5 Contaminado: GO 5.14.0-rc4+ #1 [ 3078.269102] Nombre de hardware: , BIOS KpxxxFPGA 1P B600 V181 12\/08\/2021 [ 3078.276801] Cola de trabajo: hclge hclge_service_task [hclge] [ 3078.288774] pstate: 0009 (nZCv daif +PAN -UAO -TCO BTYPE=--) [ 3078.296168] pc : napi_enable+0x80\/0x84 tc qdisc sho[w 3d0e7v8 .e3t0h218 79] lr : hns3_nic_net_open+0x138\/0x510 [hns3] [ 3078.314771] sp : 8000108abb20 [3078.319099] x29: ffff8000108abb20 x28: 0000000000000000 x27: ffff0820a8490300 [ 3078.329121] x26: 0000000000000001 x25: ffff08209cfc6200 x24: 00000000000 00000 [ 3078.339044] x23: ffff0820a8490300 x22: ffff08209cd76000 x21: ffff0820abfe3880 [ 3078.349018] x20: 0000000000000000 x19: 00 x18: 0000000000000000 [ 3078.358620] x17: 0000000000000000 x16 : ffffc816e1727a50 x15: 0000ffff8f4ff930 [ 3078.368895] x14: 0000000000000000 x13: 0000000000000000 x12: 0000259e9dbeb6b4 [ 3078.377987] x11: 0096a8f7e764eb40 x10: 634615ad28d3eab5 x9: ffffc816ad8885b8 [3078.387091] x8: ffff08209cfc6fb8 x7: ffff0820ac0da058 x6: ffff0820a8490344 [ 3 078.396356] x5: 0000000000000140 x4: 0000000000000003 x3: ffff08209cd76938 [3078.405365] x2: 0000000000000000 x1: 0000000000000010 x0: ffff0820abfe38a0 [3078.414657] Rastreo de llamadas: [3078.418517] +0x80\/0x84 [ 3078.424626] hns3_reset_notify_up_enet+0x78\/0xd0 [hns3] [ 3078.433469] hns3_reset_notify+0x64\/0x80 [hns3 ] [ 3078.441430] hclge_notify_client+0x68\/0xb0 [hclge] [ 3078.450511] hclge_reset_rebuild+0x524\/0x884 [hclge] [ 3078.458879] hclge_reset_service_task+0x3c4\/0x680 [hclge] 3078.467470] hclge_service_task+0xb0\/0xb54 [hclge] [ 3078.475675] proceso_one_work+ 0x1dc\/0x48c [ 3078.481888] work_thread+0x15c\/0x464 [ 3078.487104] kthread+0x160\/0x170 [ 3078.492479] ret_from_fork+0x10\/0x18 [ 3078.498785] Código: c81 35ffffa2 d50323bf d65f03c0 (d4210000) [ 3078.506889] ---[ final de seguimiento 8ebe0340a1b0fb44 ] --- Una vez que hns3_nic_net_open() se ejecute correctamente, se borrará el indicador HNS3_NIC_STATE_DOWN. Por lo tanto, agregue la verificación de este indicador y regrese directamente cuando HNS3_NIC_STATE_DOWN no esté configurado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3dac38bdce7932901b9f0b71c62331852c809e61","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5a31d4e73ada8022427b69b10fd1f01a6a8d4b3d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5b09e88e1bf7fe86540fab4b5f3eece8abead39e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f8ba689cb69523144d10606096ef686002dd7285","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47401","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:25.563","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nipack: ipoctal: fix stack information leak\n\nThe tty driver name is used also after registering the driver and must\nspecifically not be allocated on the stack to avoid leaking information\nto user space (or triggering an oops).\n\nDrivers should not try to encode topology information in the tty device\nname but this one snuck in through staging without anyone noticing and\nanother driver has since copied this malpractice.\n\nFixing the ABI is a separate issue, but this at least plugs the security\nhole."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ipack: ipoctal: corrige la fuga de información de la pila. El nombre del controlador tty también se usa después de registrar el controlador y específicamente no debe asignarse en la pila para evitar filtrar información al espacio del usuario (o activar un ups). Los controladores no deberían intentar codificar información de topología en el nombre del dispositivo tty, pero este se coló durante la preparación sin que nadie se diera cuenta y desde entonces otro controlador copió esta mala práctica. Arreglar la ABI es un tema aparte, pero esto al menos tapa el agujero de seguridad."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0a9c36a2e06a249acbed64e8e0b84637c2ad7575","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2725925982dc96a78069cd118ea3d66759bfdad7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5f6a309a699675680df15d9b6d389114515b4426","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/741ea2670e021350e54f491106bdaa22dc50e6a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/829f13d6079cf7a2465522f39acb43033e9b320d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8657158a3b68c85234e6da3d8eae33d6183588b7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a89936cce87d60766a75732a9e7e25c51164f47c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/acb96e782bad427ca4bb1bd94af660acd1462380","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47402","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:25.690","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: flower: protect fl_walk() with rcu\n\nPatch that refactored fl_walk() to use idr_for_each_entry_continue_ul()\nalso removed rcu protection of individual filters which causes following\nuse-after-free when filter is deleted concurrently. Fix fl_walk() to obtain\nrcu read lock while iterating and taking the filter reference and temporary\nrelease the lock while calling arg->fn() callback that can sleep.\n\nKASAN trace:\n\n[  352.773640] ==================================================================\n[  352.775041] BUG: KASAN: use-after-free in fl_walk+0x159\/0x240 [cls_flower]\n[  352.776304] Read of size 4 at addr ffff8881c8251480 by task tc\/2987\n\n[  352.777862] CPU: 3 PID: 2987 Comm: tc Not tainted 5.15.0-rc2+ #2\n[  352.778980] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04\/01\/2014\n[  352.781022] Call Trace:\n[  352.781573]  dump_stack_lvl+0x46\/0x5a\n[  352.782332]  print_address_description.constprop.0+0x1f\/0x140\n[  352.783400]  ? fl_walk+0x159\/0x240 [cls_flower]\n[  352.784292]  ? fl_walk+0x159\/0x240 [cls_flower]\n[  352.785138]  kasan_report.cold+0x83\/0xdf\n[  352.785851]  ? fl_walk+0x159\/0x240 [cls_flower]\n[  352.786587]  kasan_check_range+0x145\/0x1a0\n[  352.787337]  fl_walk+0x159\/0x240 [cls_flower]\n[  352.788163]  ? fl_put+0x10\/0x10 [cls_flower]\n[  352.789007]  ? __mutex_unlock_slowpath.constprop.0+0x220\/0x220\n[  352.790102]  tcf_chain_dump+0x231\/0x450\n[  352.790878]  ? tcf_chain_tp_delete_empty+0x170\/0x170\n[  352.791833]  ? __might_sleep+0x2e\/0xc0\n[  352.792594]  ? tfilter_notify+0x170\/0x170\n[  352.793400]  ? __mutex_unlock_slowpath.constprop.0+0x220\/0x220\n[  352.794477]  tc_dump_tfilter+0x385\/0x4b0\n[  352.795262]  ? tc_new_tfilter+0x1180\/0x1180\n[  352.796103]  ? __mod_node_page_state+0x1f\/0xc0\n[  352.796974]  ? __build_skb_around+0x10e\/0x130\n[  352.797826]  netlink_dump+0x2c0\/0x560\n[  352.798563]  ? netlink_getsockopt+0x430\/0x430\n[  352.799433]  ? __mutex_unlock_slowpath.constprop.0+0x220\/0x220\n[  352.800542]  __netlink_dump_start+0x356\/0x440\n[  352.801397]  rtnetlink_rcv_msg+0x3ff\/0x550\n[  352.802190]  ? tc_new_tfilter+0x1180\/0x1180\n[  352.802872]  ? rtnl_calcit.isra.0+0x1f0\/0x1f0\n[  352.803668]  ? tc_new_tfilter+0x1180\/0x1180\n[  352.804344]  ? _copy_from_iter_nocache+0x800\/0x800\n[  352.805202]  ? kasan_set_track+0x1c\/0x30\n[  352.805900]  netlink_rcv_skb+0xc6\/0x1f0\n[  352.806587]  ? rht_deferred_worker+0x6b0\/0x6b0\n[  352.807455]  ? rtnl_calcit.isra.0+0x1f0\/0x1f0\n[  352.808324]  ? netlink_ack+0x4d0\/0x4d0\n[  352.809086]  ? netlink_deliver_tap+0x62\/0x3d0\n[  352.809951]  netlink_unicast+0x353\/0x480\n[  352.810744]  ? netlink_attachskb+0x430\/0x430\n[  352.811586]  ? __alloc_skb+0xd7\/0x200\n[  352.812349]  netlink_sendmsg+0x396\/0x680\n[  352.813132]  ? netlink_unicast+0x480\/0x480\n[  352.813952]  ? __import_iovec+0x192\/0x210\n[  352.814759]  ? netlink_unicast+0x480\/0x480\n[  352.815580]  sock_sendmsg+0x6c\/0x80\n[  352.816299]  ____sys_sendmsg+0x3a5\/0x3c0\n[  352.817096]  ? kernel_sendmsg+0x30\/0x30\n[  352.817873]  ? __ia32_sys_recvmmsg+0x150\/0x150\n[  352.818753]  ___sys_sendmsg+0xd8\/0x140\n[  352.819518]  ? sendmsg_copy_msghdr+0x110\/0x110\n[  352.820402]  ? ___sys_recvmsg+0xf4\/0x1a0\n[  352.821110]  ? __copy_msghdr_from_user+0x260\/0x260\n[  352.821934]  ? _raw_spin_lock+0x81\/0xd0\n[  352.822680]  ? __handle_mm_fault+0xef3\/0x1b20\n[  352.823549]  ? rb_insert_color+0x2a\/0x270\n[  352.824373]  ? copy_page_range+0x16b0\/0x16b0\n[  352.825209]  ? perf_event_update_userpage+0x2d0\/0x2d0\n[  352.826190]  ? __fget_light+0xd9\/0xf0\n[  352.826941]  __sys_sendmsg+0xb3\/0x130\n[  352.827613]  ? __sys_sendmsg_sock+0x20\/0x20\n[  352.828377]  ? do_user_addr_fault+0x2c5\/0x8a0\n[  352.829184]  ? fpregs_assert_state_consistent+0x52\/0x60\n[  352.830001]  ? exit_to_user_mode_prepare+0x32\/0x160\n[  352.830845]  do_syscall_64+0x35\/0x80\n[  352.831445]  entry_SYSCALL_64_after_hwframe+0x44\/0xae\n[  352.832331] RIP: 0033:0x7f7bee973c17\n[ \n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: net: sched: flower: protege fl_walk() con rcu. El parche que refactorizó fl_walk() para usar idr_for_each_entry_continue_ul() también eliminó la protección de rcu de filtros individuales que provoca el siguiente use after free. cuando el filtro se elimina simultáneamente. Se corrige fl_walk() para obtener el bloqueo de lectura de rcu mientras se itera y se toma la referencia del filtro y se libera temporalmente el bloqueo mientras se llama a la devolución de llamada arg-&gt;fn() que puede dormir. Seguimiento de KASAN: [352.773640] ============================================= ========================== [352.775041] ERROR: KASAN: use-after-free en fl_walk+0x159\/0x240 [cls_flower] [352.776304] Lectura de tamaño 4 en addr ffff8881c8251480 por tarea tc\/2987 [ 352.777862] CPU: 3 PID: 2987 Comm: tc Not tainted 5.15.0-rc2+ #2 [ 352.778980] Nombre de hardware: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13 .0-0-gf21b5a4aeb02-prebuilt.qemu.org 01\/04\/2014 [352.781022] Seguimiento de llamadas: [352.781573] dump_stack_lvl+0x46\/0x5a [352.782332] print_address_description.constprop.0+0x1f\/0x140 [ 352.783400] ? fl_walk+0x159\/0x240 [cls_flower] [ 352.784292] ? fl_walk+0x159\/0x240 [cls_flower] [ 352.785138] kasan_report.cold+0x83\/0xdf [ 352.785851] ? fl_walk+0x159\/0x240 [cls_flower] [ 352.786587] kasan_check_range+0x145\/0x1a0 [ 352.787337] fl_walk+0x159\/0x240 [cls_flower] [ 352.788163] ? fl_put+0x10\/0x10 [cls_flower] [ 352.789007] ? __mutex_unlock_slowpath.constprop.0+0x220\/0x220 [352.790102] tcf_chain_dump+0x231\/0x450 [352.790878]? tcf_chain_tp_delete_empty+0x170\/0x170 [352.791833]? __might_sleep+0x2e\/0xc0 [ 352.792594] ? tfilter_notify+0x170\/0x170 [352.793400]? __mutex_unlock_slowpath.constprop.0+0x220\/0x220 [352.794477] tc_dump_tfilter+0x385\/0x4b0 [352.795262]? tc_new_tfilter+0x1180\/0x1180 [352.796103]? __mod_node_page_state+0x1f\/0xc0 [352.796974]? __build_skb_around+0x10e\/0x130 [ 352.797826] netlink_dump+0x2c0\/0x560 [ 352.798563] ? netlink_getsockopt+0x430\/0x430 [352.799433]? __mutex_unlock_slowpath.constprop.0+0x220\/0x220 [ 352.800542] __netlink_dump_start+0x356\/0x440 [ 352.801397] rtnetlink_rcv_msg+0x3ff\/0x550 [ 352.802190] ? tc_new_tfilter+0x1180\/0x1180 [352.802872]? rtnl_calcit.isra.0+0x1f0\/0x1f0 [ 352.803668] ? tc_new_tfilter+0x1180\/0x1180 [352.804344]? _copy_from_iter_nocache+0x800\/0x800 [352.805202]? kasan_set_track+0x1c\/0x30 [ 352.805900] netlink_rcv_skb+0xc6\/0x1f0 [ 352.806587] ? rht_deferred_worker+0x6b0\/0x6b0 [352.807455]? rtnl_calcit.isra.0+0x1f0\/0x1f0 [352.808324]? netlink_ack+0x4d0\/0x4d0 [352.809086]? netlink_deliver_tap+0x62\/0x3d0 [352.809951] netlink_unicast+0x353\/0x480 [352.810744]? netlink_attachskb+0x430\/0x430 [352.811586]? __alloc_skb+0xd7\/0x200 [ 352.812349] netlink_sendmsg+0x396\/0x680 [ 352.813132] ? netlink_unicast+0x480\/0x480 [352.813952]? __import_iovec+0x192\/0x210 [352.814759]? netlink_unicast+0x480\/0x480 [352.815580] sock_sendmsg+0x6c\/0x80 [352.816299] ____sys_sendmsg+0x3a5\/0x3c0 [352.817096] ? kernel_sendmsg+0x30\/0x30 [352.817873]? __ia32_sys_recvmmsg+0x150\/0x150 [ 352.818753] ___sys_sendmsg+0xd8\/0x140 [ 352.819518] ? sendmsg_copy_msghdr+0x110\/0x110 [352.820402]? ___sys_recvmsg+0xf4\/0x1a0 [352.821110]? __copy_msghdr_from_user+0x260\/0x260 [352.821934]? _raw_spin_lock+0x81\/0xd0 [352.822680]? __handle_mm_fault+0xef3\/0x1b20 [352.823549]? rb_insert_color+0x2a\/0x270 [352.824373]? copy_page_range+0x16b0\/0x16b0 [352.825209]? perf_event_update_userpage+0x2d0\/0x2d0 [352.826190]? __fget_light+0xd9\/0xf0 [ 352.826941] __sys_sendmsg+0xb3\/0x130 [ 352.827613] ? __sys_sendmsg_sock+0x20\/0x20 [352.828377]? do_user_addr_fault+0x2c5\/0x8a0 [352.829184]? fpregs_assert_state_consistent+0x52\/0x60 [352.830001]? exit_to_user_mode_prepare+0x32\/0x160 [ 352.830845] do_syscall_64+0x35\/0x80 [ 352.831445] Entry_SYSCALL_64_after_hwframe+0x44\/0xae [ 352.832331] RIP: 0033:0x7f7bee973c1 7 [ ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/694b0cee7f8546b69a80996a29cb3cf4149c0453","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0d520c19e7ea19ed38dc5797b12397b6ccf9f88","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d5ef190693a7d76c5c192d108e8dec48307b46ee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dab4677bdbffa5c8270e79e34e51c89efa0728a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47403","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:25.803","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nipack: ipoctal: fix module reference leak\n\nA reference to the carrier module was taken on every open but was only\nreleased once when the final reference to the tty struct was dropped.\n\nFix this by taking the module reference and initialising the tty driver\ndata when installing the tty."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ipack: ipoctal: reparar fuga de referencia del módulo. Se tomó una referencia al módulo portador en cada apertura, pero solo se publicó una vez cuando se eliminó la referencia final a la estructura tty. Solucione este problema tomando la referencia del módulo e inicializando los datos del controlador tty al instalar el tty."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/31398849b84ebae0d43a1cf379cb9895597f221a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3253c87e1e5bc0107aab773af2f135ebccf38666","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7cea848678470daadbfdaa6a112b823c290f900c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/811178f296b16af30264def74c8d2179a72d5562","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9c5b77a7ffc983b2429ce158b50497c5d3c86a69","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bb8a4fcb2136508224c596a7e665bdba1d7c3c27","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c0adb5a947dec6cff7050ec56d78ecd3916f9ce6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dde4c1429b97383689f755ce92b4ed1e84a9c92b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47404","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:25.920","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nHID: betop: fix slab-out-of-bounds Write in betop_probe\n\nSyzbot reported slab-out-of-bounds Write bug in hid-betopff driver.\nThe problem is the driver assumes the device must have an input report but\nsome malicious devices violate this assumption.\n\nSo this patch checks hid_device's input is non empty before it's been used."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: HID: betop: corrige escritura slab-out-of-bounds en betop_probe. Syzbot informó un error de escritura slab-out-of-bounds en el controlador hid-betopff. El problema es que el controlador supone que el dispositivo debe tener un informe de entrada, pero algunos dispositivos maliciosos violan esta suposición. Entonces, este parche verifica que la entrada de hid_device no esté vacía antes de usarse."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1c83c38dec83d57bc18d0c01d82c413d3b34ccb9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1e4ce418b1cb1a810256b5fb3fd33d22d1325993","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6fc4476dda58f6c00097c7ddec3b772513f57525","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/708107b80aa616976d1c5fa60ac0c1390749db5e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a4faa7153b87fbcfe4be15f4278676f79ca6e019","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bb8b72374db69afa25a5b65cf1c092860c6fe914","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dedfc35a2de2bae9fa3da8210a05bfd515f83fee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fe9bb925e7096509711660d39c0493a1546e9550","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47405","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.030","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nHID: usbhid: free raw_report buffers in usbhid_stop\n\nFree the unsent raw_report buffers when the device is removed.\n\nFixes a memory leak reported by syzbot at:\nhttps:\/\/syzkaller.appspot.com\/bug?id=7b4fa7cb1a7c2d3342a2a8a6c53371c8c418ab47"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2b704864c92dcec2b295f276fcfbfb81d9831f81","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/764ac04de056801dfe52a716da63f6e7018e7f3b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7ce4e49146612261265671b1d30d117139021030","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/965147067fa1bedff3ae1f07ce3f89f1a14d2df3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c3156fea4d8a0e643625dff69a0421e872d1fdae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/efc5c8d29256955cc90d8d570849b2d6121ed09f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f7744fa16b96da57187dc8e5634152d3b63d72de","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f7ac4d24e1610b92689946fa88177673f1e88a3f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47406","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.170","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\next4: add error checking to ext4_ext_replay_set_iblocks()\n\nIf the call to ext4_map_blocks() fails due to an corrupted file\nsystem, ext4_ext_replay_set_iblocks() can get stuck in an infinite\nloop.  This could be reproduced by running generic\/526 with a file\nsystem that has inline_data and fast_commit enabled.  The system will\nrepeatedly log to the console:\n\nEXT4-fs warning (device dm-3): ext4_block_to_path:105: block 1074800922 > max in inode 131076\n\nand the stack that it gets stuck in is:\n\n   ext4_block_to_path+0xe3\/0x130\n   ext4_ind_map_blocks+0x93\/0x690\n   ext4_map_blocks+0x100\/0x660\n   skip_hole+0x47\/0x70\n   ext4_ext_replay_set_iblocks+0x223\/0x440\n   ext4_fc_replay_inode+0x29e\/0x3b0\n   ext4_fc_replay+0x278\/0x550\n   do_one_pass+0x646\/0xc10\n   jbd2_journal_recover+0x14a\/0x270\n   jbd2_journal_load+0xc4\/0x150\n   ext4_load_journal+0x1f3\/0x490\n   ext4_fill_super+0x22d4\/0x2c00\n\nWith this patch, generic\/526 still fails, but system is no longer\nlocking up in a tight loop.  It's likely the root casue is that\nfast_commit replay is corrupting file systems with inline_data, and we\nprobably need to add better error handling in the fast commit replay\ncode path beyond what is done here, which essentially just breaks the\ninfinite loop without reporting the to the higher levels of the code."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ext4: agregue verificación de errores a ext4_ext_replay_set_iblocks(). Si la llamada a ext4_map_blocks() falla debido a un sistema de archivos dañado, ext4_ext_replay_set_iblocks() puede quedarse atascado en un bucle infinito. Esto podría reproducirse ejecutando generic\/526 con un sistema de archivos que tenga inline_data y fast_commit habilitados. El sistema iniciará sesión repetidamente en la consola: Advertencia EXT4-fs (dispositivo dm-3): ext4_block_to_path:105: bloque 1074800922 &gt; max en el inodo 131076 y la pila en la que se atasca es: ext4_block_to_path+0xe3\/0x130 ext4_ind_map_blocks+0x93\/ 0x690 ext4_map_blocks+0x100\/0x660 skip_hole+0x47\/0x70 ext4_ext_replay_set_iblocks+0x223\/0x440 ext4_fc_replay_inode+0x29e\/0x3b0 ext4_fc_replay+0x278\/0x550 do_one_pass+0x646\/ 0xc10 jbd2_journal_recover+0x14a\/0x270 jbd2_journal_load+0xc4\/0x150 ext4_load_journal+0x1f3\/0x490 ext4_fill_super+0x22d4\/ 0x2c00 Con este parche, generic\/526 todavía falla, pero el sistema ya no se bloquea en un bucle cerrado. Es probable que la causa raíz sea que la reproducción fast_commit esté corrompiendo los sistemas de archivos con inline_data, y probablemente necesitemos agregar un mejor manejo de errores en la ruta del código de reproducción de confirmación rápida más allá de lo que se hace aquí, lo que esencialmente simplemente rompe el bucle infinito sin informar al niveles superiores del código."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1fd95c05d8f742abfe906620780aee4dbe1a2db0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/27e10c5d31ff1d222c7f797f1ee96d422859ba67","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a63474dbf692dd09b50fed592bc41f6de5f102fc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47407","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.247","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Handle SRCU initialization failure during page track init\n\nCheck the return of init_srcu_struct(), which can fail due to OOM, when\ninitializing the page track mechanism.  Lack of checking leads to a NULL\npointer deref found by a modified syzkaller.\n\n[Move the call towards the beginning of kvm_arch_init_vm. - Paolo]"},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: x86: Manejar el error de inicialización de SRCU durante el inicio del seguimiento de la página. Verifique el retorno de init_srcu_struct(), que puede fallar debido a OOM, al inicializar el mecanismo de seguimiento de la página. La falta de verificación conduce a un puntero NULL deref encontrado por un syzkaller modificado. [Mueva la llamada hacia el principio de kvm_arch_init_vm. -Paolo]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4664318f73e496cd22c71b10888e75434a123e23","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/deb2949417677649e2413266d7ce8c2ff73952b4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb7511bf9182292ef1df1082d23039e856d1ddfb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47408","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.337","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: conntrack: serialize hash resizes and cleanups\n\nSyzbot was able to trigger the following warning [1]\n\nNo repro found by syzbot yet but I was able to trigger similar issue\nby having 2 scripts running in parallel, changing conntrack hash sizes,\nand:\n\nfor j in `seq 1 1000` ; do unshare -n \/bin\/true >\/dev\/null ; done\n\nIt would take more than 5 minutes for net_namespace structures\nto be cleaned up.\n\nThis is because nf_ct_iterate_cleanup() has to restart everytime\na resize happened.\n\nBy adding a mutex, we can serialize hash resizes and cleanups\nand also make get_next_corpse() faster by skipping over empty\nbuckets.\n\nEven without resizes in the picture, this patch considerably\nspeeds up network namespace dismantles.\n\n[1]\nINFO: task syz-executor.0:8312 can't die for more than 144 seconds.\ntask:syz-executor.0  state:R  running task     stack:25672 pid: 8312 ppid:  6573 flags:0x00004006\nCall Trace:\n context_switch kernel\/sched\/core.c:4955 [inline]\n __schedule+0x940\/0x26f0 kernel\/sched\/core.c:6236\n preempt_schedule_common+0x45\/0xc0 kernel\/sched\/core.c:6408\n preempt_schedule_thunk+0x16\/0x18 arch\/x86\/entry\/thunk_64.S:35\n __local_bh_enable_ip+0x109\/0x120 kernel\/softirq.c:390\n local_bh_enable include\/linux\/bottom_half.h:32 [inline]\n get_next_corpse net\/netfilter\/nf_conntrack_core.c:2252 [inline]\n nf_ct_iterate_cleanup+0x15a\/0x450 net\/netfilter\/nf_conntrack_core.c:2275\n nf_conntrack_cleanup_net_list+0x14c\/0x4f0 net\/netfilter\/nf_conntrack_core.c:2469\n ops_exit_list+0x10d\/0x160 net\/core\/net_namespace.c:171\n setup_net+0x639\/0xa30 net\/core\/net_namespace.c:349\n copy_net_ns+0x319\/0x760 net\/core\/net_namespace.c:470\n create_new_namespaces+0x3f6\/0xb20 kernel\/nsproxy.c:110\n unshare_nsproxy_namespaces+0xc1\/0x1f0 kernel\/nsproxy.c:226\n ksys_unshare+0x445\/0x920 kernel\/fork.c:3128\n __do_sys_unshare kernel\/fork.c:3202 [inline]\n __se_sys_unshare kernel\/fork.c:3200 [inline]\n __x64_sys_unshare+0x2d\/0x40 kernel\/fork.c:3200\n do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n do_syscall_64+0x35\/0xb0 arch\/x86\/entry\/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44\/0xae\nRIP: 0033:0x7f63da68e739\nRSP: 002b:00007f63d7c05188 EFLAGS: 00000246 ORIG_RAX: 0000000000000110\nRAX: ffffffffffffffda RBX: 00007f63da792f80 RCX: 00007f63da68e739\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000040000000\nRBP: 00007f63da6e8cc4 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007f63da792f80\nR13: 00007fff50b75d3f R14: 00007f63d7c05300 R15: 0000000000022000\n\nShowing all locks held in the system:\n1 lock held by khungtaskd\/27:\n #0: ffffffff8b980020 (rcu_read_lock){....}-{1:2}, at: debug_show_all_locks+0x53\/0x260 kernel\/locking\/lockdep.c:6446\n2 locks held by kworker\/u4:2\/153:\n #0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: arch_atomic64_set arch\/x86\/include\/asm\/atomic64_64.h:34 [inline]\n #0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: arch_atomic_long_set include\/linux\/atomic\/atomic-long.h:41 [inline]\n #0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: atomic_long_set include\/linux\/atomic\/atomic-instrumented.h:1198 [inline]\n #0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: set_work_data kernel\/workqueue.c:634 [inline]\n #0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: set_work_pool_and_clear_pending kernel\/workqueue.c:661 [inline]\n #0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: process_one_work+0x896\/0x1690 kernel\/workqueue.c:2268\n #1: ffffc9000140fdb0 ((kfence_timer).work){+.+.}-{0:0}, at: process_one_work+0x8ca\/0x1690 kernel\/workqueue.c:2272\n1 lock held by systemd-udevd\/2970:\n1 lock held by in:imklog\/6258:\n #0: ffff88807f970ff0 (&f->f_pos_lock){+.+.}-{3:3}, at: __fdget_pos+0xe9\/0x100 fs\/file.c:990\n3 locks held by kworker\/1:6\/8158:\n1 lock held by syz-executor.0\/8312:\n2 locks held by kworker\/u4:13\/9320:\n1 lock held by\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: netfilter: conntrack: serializar cambios de tamaño y limpiezas de hash. Syzbot pudo activar la siguiente advertencia [1] Syzbot aún no encontró ninguna reproducción, pero pude desencadenar un problema similar al tener 2 scripts ejecutándose en paralelo, cambiando los tamaños de hash de conntrack y: para j en `seq 1 1000`; dejar de compartir -n \/bin\/true &gt;\/dev\/null ; done Se necesitarían más de 5 minutos para limpiar las estructuras net_namespace. Esto se debe a que nf_ct_iterate_cleanup() tiene que reiniciarse cada vez que ocurre un cambio de tamaño. Al agregar un mutex, podemos serializar los cambios de tamaño y las limpiezas de hash y también hacer que get_next_corpse() sea más rápido omitiendo los depósitos vacíos. Incluso sin cambios de tamaño en la imagen, este parche acelera considerablemente el desmantelamiento del espacio de nombres de la red. [1] INFORMACIÓN: la tarea syz-executor.0:8312 no puede morir durante más de 144 segundos. tarea:syz-executor.0 estado:R ejecutando pila de tareas:25672 pid: 8312 ppid: 6573 banderas:0x00004006 Seguimiento de llamadas: context_switch kernel\/sched\/core.c:4955 [en línea] __schedule+0x940\/0x26f0 kernel\/sched\/core .c:6236 preempt_schedule_common+0x45\/0xc0 kernel\/sched\/core.c:6408 preempt_schedule_thunk+0x16\/0x18 arch\/x86\/entry\/thunk_64.S:35 __local_bh_enable_ip+0x109\/0x120 kernel\/softirq.c:390 local_bh_enable include\/ Linux \/bottom_half.h:32 [en línea] get_next_corpse net\/netfilter\/nf_conntrack_core.c:2252 [en línea] nf_ct_iterate_cleanup+0x15a\/0x450 net\/netfilter\/nf_conntrack_core.c:2275 nf_conntrack_cleanup_net_list+0x14c\/0x4f0 net\/netfilter\/ nf_conntrack_core.c:2469 ops_exit_list+0x10d\/0x160 net\/core\/net_namespace.c:171 setup_net+0x639\/0xa30 net\/core\/net_namespace.c:349 copy_net_ns+0x319\/0x760 net\/core\/net_namespace.c:470 create_new_namespaces+0x3f6\/0xb20 kernel\/nsproxy .c:110 unshare_nsproxy_namespaces+0xc1\/0x1f0 kernel\/nsproxy.c:226 ksys_unshare+0x445\/0x920 kernel\/fork.c:3128 __do_sys_unshare kernel\/fork.c:3202 [en línea] __se_sys_unshare kernel\/fork.c:3200 [en línea] __x64_sys_unshare+0x2d\/0x40 kernel\/fork.c:3200 do_syscall_x64 arch\/x86\/entry\/common.c:50 [en línea] do_syscall_64+0x35\/0xb0 arch\/x86\/entry\/common.c:80 Entry_SYSCALL_64_after_hwframe+0x44\/0xae : 0033:0x7f63da68e739 RSP: 002b:00007f63d7c05188 EFLAGS: 00000246 ORIG_RAX: 0000000000000110 RAX: ffffffffffffffda RBX: 00007f63da792f80 RCX: 63da68e739 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000040000000 RBP: 00007f63da6e8cc4 R08: 0000000000000000 R09: 000000 R10: 0000000000000000 R11: 0000000000000246 R12: 00007f63da792f80 R13: 00007fff50b75d3f R14: 00007f63d7c05300 R15: 0000000000022000 Mostrando todos los bloqueos retenidos en el sistema: 1 bloqueo retenido por khungtaskd\/27: #0: ffffffff8b980020 (rcu_read_lock){....}-{1:2}, : debug_show_all_locks+0x53 \/0x260 kernel\/locking\/lockdep.c:6446 2 bloqueos retenidos por kworker\/u4:2\/153: #0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, en: arch_atomic64_set arch \/x86\/include\/asm\/atomic64_64.h:34 [en línea] #0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, en: arch_atomic_long_set include\/linux\/atomic\/atomic-long .h:41 [en línea] #0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, en: atomic_long_set include\/linux\/atomic\/atomic-instrumented.h:1198 [en línea] # 0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, en: set_work_data kernel\/workqueue.c:634 [en línea] #0: ffff888010c69138 ((wq_completion)events_unbound){+.+. }-{0:0}, en: set_work_pool_and_clear_pending kernel\/workqueue.c:661 [en línea] #0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, en: Process_one_work+0x896\/ 0x1690 kernel\/workqueue.c:2268 #1: ffffc9000140fdb0 ((kfence_timer).work){+.+.}-{0:0}, en: Process_one_work+0x8ca\/0x1690 kernel\/workqueue.c:2272 1 bloqueo retenido por systemd-udevd\/2970: 1 bloqueo retenido por in:imklog\/6258: #0: ffff88807f970ff0 (&amp;f-&gt;f_pos_lock){+.+.}-{3:3}, en: __fdget_pos+0xe9\/0x100 ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7ea6f5848281182ce0cff6cafdcf3fbdeb8ca7e1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e2d192301a0df8160d1555b66ae8611e8050e424","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e9edc188fc76499b0b9bd60364084037f6d03773","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47409","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.433","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc2: check return value after calling platform_get_resource()\n\nIt will cause null-ptr-deref if platform_get_resource() returns NULL,\nwe need check the return value."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: usb: dwc2: verifique el valor de retorno después de llamar a platform_get_resource(). Causará null-ptr-deref si platform_get_resource() devuelve NULL, necesitamos verificar el valor de retorno."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2754fa3b73df7d0ae042f3ed6cfd9df9042f6262","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/337f00a0bc62d7cb7d10ec0b872c79009a1641df","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4b7f4a0eb92bf37bea4cd838c7f83ea42823ca8b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/856e6e8e0f9300befa87dde09edb578555c99a82","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8b9c1c33e51d0959f2aec573dfbac0ffd3f5c0b7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7182993dd8e09f96839ddc3ac54f9b37370d282","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47410","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.527","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdkfd: fix svm_migrate_fini warning\n\nDevice manager releases device-specific resources when a driver\ndisconnects from a device, devm_memunmap_pages and\ndevm_release_mem_region calls in svm_migrate_fini are redundant.\n\nIt causes below warning trace after patch \"drm\/amdgpu: Split\namdgpu_device_fini into early and late\", so remove function\nsvm_migrate_fini.\n\nBUG: https:\/\/gitlab.freedesktop.org\/drm\/amd\/-\/issues\/1718\n\nWARNING: CPU: 1 PID: 3646 at drivers\/base\/devres.c:795\ndevm_release_action+0x51\/0x60\nCall Trace:\n    ? memunmap_pages+0x360\/0x360\n    svm_migrate_fini+0x2d\/0x60 [amdgpu]\n    kgd2kfd_device_exit+0x23\/0xa0 [amdgpu]\n    amdgpu_amdkfd_device_fini_sw+0x1d\/0x30 [amdgpu]\n    amdgpu_device_fini_sw+0x45\/0x290 [amdgpu]\n    amdgpu_driver_release_kms+0x12\/0x30 [amdgpu]\n    drm_dev_release+0x20\/0x40 [drm]\n    release_nodes+0x196\/0x1e0\n    device_release_driver_internal+0x104\/0x1d0\n    driver_detach+0x47\/0x90\n    bus_remove_driver+0x7a\/0xd0\n    pci_unregister_driver+0x3d\/0x90\n    amdgpu_exit+0x11\/0x20 [amdgpu]"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amdkfd: corrige la advertencia de svm_migrate_fini. El administrador de dispositivos libera recursos específicos del dispositivo cuando un controlador se desconecta de un dispositivo, las llamadas a devm_memunmap_pages y devm_release_mem_region en svm_migrate_fini son redundantes. Provoca el siguiente seguimiento de advertencia después del parche \"drm\/amdgpu: dividir amdgpu_device_fini en temprano y tarde\", por lo tanto, elimine la función svm_migrate_fini. ERROR: https:\/\/gitlab.freedesktop.org\/drm\/amd\/-\/issues\/1718 ADVERTENCIA: CPU: 1 PID: 3646 en drivers\/base\/devres.c:795 devm_release_action+0x51\/0x60 Seguimiento de llamadas:? memunmap_pages+0x360\/0x360 svm_migrate_fini+0x2d\/0x60 [amdgpu] kgd2kfd_device_exit+0x23\/0xa0 [amdgpu] amdgpu_amdkfd_device_fini_sw+0x1d\/0x30 [amdgpu_device_fini_sw+0x45\/0 x290 [amdgpu] amdgpu_driver_release_kms+0x12\/0x30 [amdgpu] drm_dev_release+0x20\/0x40 [drm] release_nodes+0x196\/0x1e0 device_release_driver_internal+0x104\/0x1d0 driver_detach+0x47\/0x90 bus_remove_driver+0x7a\/0xd0 pci_unregister_driver+0x3d\/0x90 amdgpu_exit+0x11\/0x20 [amdgpu]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/197ae17722e989942b36e33e044787877f158574","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ac7d732b24f4061f8a732ada49b054ab38c63e15","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47411","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.617","lastModified":"2024-05-21T16:54:26.047","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring: allow conditional reschedule for intensive iterators\n\nIf we have a lot of threads and rings, the tctx list can get quite big.\nThis is especially true if we keep creating new threads and rings.\nLikewise for the provided buffers list. Be nice and insert a conditional\nreschedule point while iterating the nodes for deletion."},{"lang":"es","value":" En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: io_uring: permite reprogramación condicional para iteradores intensivos. Si tenemos muchos hilos y anillos, la lista tctx puede volverse bastante grande. Esto es especialmente cierto si seguimos creando nuevos hilos y anillos. Lo mismo ocurre con la lista de buffers proporcionada. Sea amable e inserte un punto de reprogramación condicional mientras itera los nodos para su eliminación."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/648f59a06b0e1fec7a4158cdee9acd362e493ce1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8bab4c09f24ec8d4a7a78ab343620f89d3a24804","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47412","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.700","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nblock: don't call rq_qos_ops->done_bio if the bio isn't tracked\n\nrq_qos framework is only applied on request based driver, so:\n\n1) rq_qos_done_bio() needn't to be called for bio based driver\n\n2) rq_qos_done_bio() needn't to be called for bio which isn't tracked,\nsuch as bios ended from error handling code.\n\nEspecially in bio_endio():\n\n1) request queue is referred via bio->bi_bdev->bd_disk->queue, which\nmay be gone since request queue refcount may not be held in above two\ncases\n\n2) q->rq_qos may be freed in blk_cleanup_queue() when calling into\n__rq_qos_done_bio()\n\nFix the potential kernel panic by not calling rq_qos_ops->done_bio if\nthe bio isn't tracked. This way is safe because both ioc_rqos_done_bio()\nand blkcg_iolatency_done_bio() are nop if the bio isn't tracked."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bloque: no llame a rq_qos_ops-&gt;done_bio si no se realiza un seguimiento de la biografía. El framework rq_qos solo se aplica en el controlador basado en solicitudes, por lo que: 1) rq_qos_done_bio() no necesita hacerlo ser llamado para un controlador basado en biografía 2) No es necesario llamar a rq_qos_done_bio() para una biografía que no está rastreada, como una biografía terminada por un código de manejo de errores. Especialmente en bio_endio(): 1) la cola de solicitudes se remite a través de bio-&gt;bi_bdev-&gt;bd_disk-&gt;queue, que puede desaparecer ya que el recuento de la cola de solicitudes no se puede mantener en los dos casos anteriores 2) q-&gt;rq_qos se puede liberar en blk_cleanup_queue() al llamar a __rq_qos_done_bio() Solucione el posible pánico del kernel al no llamar a rq_qos_ops-&gt;done_bio si no se realiza un seguimiento de la biografía. Esta forma es segura porque tanto ioc_rqos_done_bio() como blkcg_iolatency_done_bio() no funcionan si no se realiza un seguimiento de la biografía."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/004b8f8a691205a93d9e80d98b786b2b97424d6e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a647a524a46736786c95cdb553a070322ca096e3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47413","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.793","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: chipidea: ci_hdrc_imx: Also search for 'phys' phandle\n\nWhen passing 'phys' in the devicetree to describe the USB PHY phandle\n(which is the recommended way according to\nDocumentation\/devicetree\/bindings\/usb\/ci-hdrc-usb2.txt) the\nfollowing NULL pointer dereference is observed on i.MX7 and i.MX8MM:\n\n[    1.489344] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000098\n[    1.498170] Mem abort info:\n[    1.500966]   ESR = 0x96000044\n[    1.504030]   EC = 0x25: DABT (current EL), IL = 32 bits\n[    1.509356]   SET = 0, FnV = 0\n[    1.512416]   EA = 0, S1PTW = 0\n[    1.515569]   FSC = 0x04: level 0 translation fault\n[    1.520458] Data abort info:\n[    1.523349]   ISV = 0, ISS = 0x00000044\n[    1.527196]   CM = 0, WnR = 1\n[    1.530176] [0000000000000098] user address but active_mm is swapper\n[    1.536544] Internal error: Oops: 96000044 [#1] PREEMPT SMP\n[    1.542125] Modules linked in:\n[    1.545190] CPU: 3 PID: 7 Comm: kworker\/u8:0 Not tainted 5.14.0-dirty #3\n[    1.551901] Hardware name: Kontron i.MX8MM N801X S (DT)\n[    1.557133] Workqueue: events_unbound deferred_probe_work_func\n[    1.562984] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO BTYPE=--)\n[    1.568998] pc : imx7d_charger_detection+0x3f0\/0x510\n[    1.573973] lr : imx7d_charger_detection+0x22c\/0x510\n\nThis happens because the charger functions check for the phy presence\ninside the imx_usbmisc_data structure (data->usb_phy), but the chipidea\ncore populates the usb_phy passed via 'phys' inside 'struct ci_hdrc'\n(ci->usb_phy) instead.\n\nThis causes the NULL pointer dereference inside imx7d_charger_detection().\n\nFix it by also searching for 'phys' in case 'fsl,usbphy' is not found.\n\nTested on a imx7s-warp board."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: chipidea: ci_hdrc_imx: también busque 'phys' phandle. Al pasar 'phys' en el árbol de dispositivos para describir el phandle USB PHY (que es la forma recomendada según Documentation\/devicetree \/bindings\/usb\/ci-hdrc-usb2.txt) se observa la siguiente desreferencia del puntero NULL en i.MX7 e i.MX8MM: [1.489344] No se puede manejar la desreferencia del puntero NULL del kernel en la dirección virtual 00000000000000098 [1.498170] Información de cancelación de memoria: [ 1.500966] ESR = 0x96000044 [ 1.504030] EC = 0x25: DABT (EL actual), IL = 32 bits [ 1.509356] SET = 0, FnV = 0 [ 1.512416] EA = 0, S1PTW = 0 [ 1.515569] FSC = 0x04: error de traducción de nivel 0 [1.520458] Información de cancelación de datos: [1.523349] ISV = 0, ISS = 0x00000044 [1.527196] CM = 0, WnR = 1 [1.530176] [0000000000000098] dirección de usuario pero active_mm es intercambiador [1.536544 ] Error interno: Ups : 96000044 [#1] PREEMPT SMP [ 1.542125] Módulos vinculados en: [ 1.545190] CPU: 3 PID: 7 Comm: kworker\/u8:0 Not tainted 5.14.0-dirty #3 [ 1.551901] Nombre de hardware: Kontron i.MX8MM N801X S (DT) [1.557133] Cola de trabajo: events_unbound deferred_probe_work_func [1.562984] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO BTYPE=--) [1.568998] pc: imx7d_charger_detection+0x3f0\/0x510 [ 1. 573973] lr: imx7d_charger_detection+0x22c \/0x510 Esto sucede porque las funciones del cargador verifican la presencia de phy dentro de la estructura imx_usbmisc_data (data-&gt;usb_phy), pero el núcleo chipidea llena el usb_phy pasado a través de 'phys' dentro de 'struct ci_hdrc' (ci-&gt;usb_phy). Esto provoca la desreferencia del puntero NULL dentro de imx7d_charger_detection(). Solucione el problema buscando también 'phys' en caso de que no se encuentre 'fsl,usbphy'. Probado en una placa imx7s-warp."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/66dd03b10e1c0b2fae006c6e34c18ea8ee033e7b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8253a34bfae3278baca52fc1209b7c29270486ca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b3265b88e83b16c7be762fa5fb7e0632bce0002c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47414","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.887","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: Flush current cpu icache before other cpus\n\nOn SiFive Unmatched, I recently fell onto the following BUG when booting:\n\n[    0.000000] ftrace: allocating 36610 entries in 144 pages\n[    0.000000] Oops - illegal instruction [#1]\n[    0.000000] Modules linked in:\n[    0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 5.13.1+ #5\n[    0.000000] Hardware name: SiFive HiFive Unmatched A00 (DT)\n[    0.000000] epc : riscv_cpuid_to_hartid_mask+0x6\/0xae\n[    0.000000]  ra : __sbi_rfence_v02+0xc8\/0x10a\n[    0.000000] epc : ffffffff80007240 ra : ffffffff80009964 sp : ffffffff81803e10\n[    0.000000]  gp : ffffffff81a1ea70 tp : ffffffff8180f500 t0 : ffffffe07fe30000\n[    0.000000]  t1 : 0000000000000004 t2 : 0000000000000000 s0 : ffffffff81803e60\n[    0.000000]  s1 : 0000000000000000 a0 : ffffffff81a22238 a1 : ffffffff81803e10\n[    0.000000]  a2 : 0000000000000000 a3 : 0000000000000000 a4 : 0000000000000000\n[    0.000000]  a5 : 0000000000000000 a6 : ffffffff8000989c a7 : 0000000052464e43\n[    0.000000]  s2 : ffffffff81a220c8 s3 : 0000000000000000 s4 : 0000000000000000\n[    0.000000]  s5 : 0000000000000000 s6 : 0000000200000100 s7 : 0000000000000001\n[    0.000000]  s8 : ffffffe07fe04040 s9 : ffffffff81a22c80 s10: 0000000000001000\n[    0.000000]  s11: 0000000000000004 t3 : 0000000000000001 t4 : 0000000000000008\n[    0.000000]  t5 : ffffffcf04000808 t6 : ffffffe3ffddf188\n[    0.000000] status: 0000000200000100 badaddr: 0000000000000000 cause: 0000000000000002\n[    0.000000] [<ffffffff80007240>] riscv_cpuid_to_hartid_mask+0x6\/0xae\n[    0.000000] [<ffffffff80009474>] sbi_remote_fence_i+0x1e\/0x26\n[    0.000000] [<ffffffff8000b8f4>] flush_icache_all+0x12\/0x1a\n[    0.000000] [<ffffffff8000666c>] patch_text_nosync+0x26\/0x32\n[    0.000000] [<ffffffff8000884e>] ftrace_init_nop+0x52\/0x8c\n[    0.000000] [<ffffffff800f051e>] ftrace_process_locs.isra.0+0x29c\/0x360\n[    0.000000] [<ffffffff80a0e3c6>] ftrace_init+0x80\/0x130\n[    0.000000] [<ffffffff80a00f8c>] start_kernel+0x5c4\/0x8f6\n[    0.000000] ---[ end trace f67eb9af4d8d492b ]---\n[    0.000000] Kernel panic - not syncing: Attempted to kill the idle task!\n[    0.000000] ---[ end Kernel panic - not syncing: Attempted to kill the idle task! ]---\n\nWhile ftrace is looping over a list of addresses to patch, it always failed\nwhen patching the same function: riscv_cpuid_to_hartid_mask. Looking at the\nbacktrace, the illegal instruction is encountered in this same function.\nHowever, patch_text_nosync, after patching the instructions, calls\nflush_icache_range. But looking at what happens in this function:\n\nflush_icache_range -> flush_icache_all\n                   -> sbi_remote_fence_i\n                   -> __sbi_rfence_v02\n                   -> riscv_cpuid_to_hartid_mask\n\nThe icache and dcache of the current cpu are never synchronized between the\npatching of riscv_cpuid_to_hartid_mask and calling this same function.\n\nSo fix this by flushing the current cpu's icache before asking for the other\ncpus to do the same."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: riscv: vaciar el icache de la CPU actual antes que otras CPU. En SiFive Unmatched, recientemente encontré el siguiente BUGal arrancar: [0.000000] ftrace: asignar 36610 entradas en 144 páginas [0.000000] Ups - instrucción ilegal [#1] [ 0.000000] Módulos vinculados en: [ 0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 5.13.1+ #5 [ 0.000000] Nombre del hardware: SiFive HiFive Unmatched A00 (DT) [ 0.000000] epc: riscv_cpuid_to_hartid_mask+0x6\/0xae [ 0.000000] ra : __sbi_rfence_v02+0xc8\/0x10a [ 0.000000] epc : ffffffff80007240 ra : ffffffff80009964 sp : ffffffff81803e10 [ 0 .000000] gp : ffffffff81a1ea70 tp : ffffffff8180f500 t0 : ffffffe07fe30000 [ 0.000000] t1 : 00000000000000004 t2 : 00000000000000000 s0: ffffffff81803e60 [0.000000] s1: 0000000000000000 a0: ffffffff81a22238 a1: ffffffff81803e10 [0.000000] a2: 000000000000000 a3: 0000000 000000000 a4: 0000000000000000 [0.000000] a5: 0000000000000000 a6: ffffffff8000989c a7: 0000000052464e43 [0.000000] s2: ffffffff81a220c8 s3: 0000000000000000 s4: 0000000000000000 [ 0.000000] s5 : 0000000000000000 s6 : 0000000200000100 s7 : 0000000000000001 [ 0.000000] s8 : ffffffe07fe04040 s9 : ffffffff81a22c80 s10: 0000000000001000 [0.000000] s11: 0000000000000004 t3: 0000000000000001 t4: 0000000000000008 [0.000000] t5: ffcf04000808 t6: ffffffe3ffddf188 [0.000000] estado : 0000000200000100 badaddr: 0000000000000000 causa: 0000000000000002 [ 0.000000] [] riscv_cpuid_to_hartid_mask+0x6\/0xae [ 0.000000] ffffffff80009474&gt;] sbi_remote_fence_i+0x1e\/0x26 [ 0.000000] [] Flush_icache_all+0x12\/0x1a [ 0.000000] [] patch_text_nosync+0x26\/0x32 [ 0.000000] [] ftrace_init_nop+0x52\/0x8c [ 0.000000] [] ftrace_process_locs.isra.0+0x29c\/ 0x360 [ 0.000000] [] ftrace_init+ 0x80\/0x130 [ 0.000000] [] start_kernel+0x5c4\/0x8f6 [ 0.000000] ---[ end trace f67eb9af4d8d492b ]--- [ 0.000000] Pánico en el kernel - no se sincroniza: ¡Intentó finalizar la tarea inactiva! [0.000000] ---[ fin del pánico del kernel: no se sincroniza: ¡se intentó finalizar la tarea inactiva! ]--- Mientras ftrace recorre una lista de direcciones para parchear, siempre fallaba al parchear la misma función: riscv_cpuid_to_hartid_mask. Al observar el seguimiento, la instrucción ilegal se encuentra en esta misma función. Sin embargo, patch_text_nosync, después de parchear las instrucciones, llama a flush_icache_range. Pero observando lo que sucede en esta función: Flush_icache_range -&gt; Flush_icache_all -&gt; sbi_remote_fence_i -&gt; __sbi_rfence_v02 -&gt; riscv_cpuid_to_hartid_mask El icache y el dcache de la CPU actual nunca se sincronizan entre el parche de riscv_cpuid_to_hartid_mask y la llamada a esta misma función. Así que solucione este problema limpiando el icache de la CPU actual antes de pedirle a las otras CPU que hagan lo mismo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/427faa29e06f0709476ea1bd59758f997ec8b64e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bb8958d5dc79acbd071397abb57b8756375fe1ce","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f1c7aa87c423e765e3862349c2f095fdfccdd9b3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47415","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:26.983","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\niwlwifi: mvm: Fix possible NULL dereference\n\nIn __iwl_mvm_remove_time_event() check that 'te_data->vif' is NULL\nbefore dereferencing it."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: iwlwifi: mvm: Corrige posible desreferencia NULL En __iwl_mvm_remove_time_event() comprueba que 'te_data-&gt;vif' sea NULL antes de desreferenciarlo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/24d5f16e407b75bc59d5419b957a9cab423b2681","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/432d8185e9ffce97e3866ca71c39b0807a456920","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47416","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:27.083","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nphy: mdio: fix memory leak\n\nSyzbot reported memory leak in MDIO bus interface, the problem was in\nwrong state logic.\n\nMDIOBUS_ALLOCATED indicates 2 states:\n\t1. Bus is only allocated\n\t2. Bus allocated and __mdiobus_register() fails, but\n\t   device_register() was called\n\nIn case of device_register() has been called we should call put_device()\nto correctly free the memory allocated for this device, but mdiobus_free()\ncalls just kfree(dev) in case of MDIOBUS_ALLOCATED state\n\nTo avoid this behaviour we need to set bus->state to MDIOBUS_UNREGISTERED\n_before_ calling device_register(), because put_device() should be\ncalled even in case of device_register() failure."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: phy: mdio: arreglar pérdida de memoria. Syzbot informó una pérdida de memoria en la interfaz del bus MDIO, el problema estaba en una lógica de estado incorrecta. MDIOBUS_ALLOCATED indica 2 estados: 1. El bus solo está asignado 2. El bus asignado y __mdiobus_register() falla, pero se llamó a device_register() En caso de que se haya llamado a device_register() debemos llamar a put_device() para liberar correctamente la memoria asignada para esto dispositivo, pero mdiobus_free() llama solo a kfree(dev) en caso de estado MDIOBUS_ALLOCATED. Para evitar este comportamiento, necesitamos configurar bus-&gt;state en MDIOBUS_UNREGISTERED _antes_ de llamar a device_register(), porque put_device() debe llamarse incluso en caso de fallo de device_register( ."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/064c2616234a7394867c924b5c1303974f3a4f4d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0d2dd40a7be61b89a7c99dae8ee96389d27b413a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2250392d930bd0d989f24d355d6355b0150256e7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2397b9e118721292429fea8807a698e71b94795f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/25e9f88c7e3cc35f5e3d3db199660d28a15df639","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/414bb4ead1362ef2c8592db723c017258f213988","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca6e11c337daf7925ff8a2aac8e84490a8691905","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f4f502a04ee1e543825af78f47eb7785015cd9f6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47417","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:27.173","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nlibbpf: Fix memory leak in strset\n\nFree struct strset itself, not just its internal parts."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: libbpf: repara la pérdida de memoria en strset Libera la estructura strset en sí, no solo sus partes internas."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/9e8e7504e09831c469b67d6dc11d9a72654bdb8c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0e875bac0fab3e7a7431c2eee36a8ccc0c712ac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47418","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:27.257","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: fix NULL deref in fifo_set_limit()\n\nsyzbot reported another NULL deref in fifo_set_limit() [1]\n\nI could repro the issue with :\n\nunshare -n\ntc qd add dev lo root handle 1:0 tbf limit 200000 burst 70000 rate 100Mbit\ntc qd replace dev lo parent 1:0 pfifo_fast\ntc qd change dev lo root handle 1:0 tbf limit 300000 burst 70000 rate 100Mbit\n\npfifo_fast does not have a change() operation.\nMake fifo_set_limit() more robust about this.\n\n[1]\nBUG: kernel NULL pointer dereference, address: 0000000000000000\nPGD 1cf99067 P4D 1cf99067 PUD 7ca49067 PMD 0\nOops: 0010 [#1] PREEMPT SMP KASAN\nCPU: 1 PID: 14443 Comm: syz-executor959 Not tainted 5.15.0-rc3-syzkaller #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01\/2011\nRIP: 0010:0x0\nCode: Unable to access opcode bytes at RIP 0xffffffffffffffd6.\nRSP: 0018:ffffc9000e2f7310 EFLAGS: 00010246\nRAX: dffffc0000000000 RBX: ffffffff8d6ecc00 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: ffff888024c27910 RDI: ffff888071e34000\nRBP: ffff888071e34000 R08: 0000000000000001 R09: ffffffff8fcfb947\nR10: 0000000000000001 R11: 0000000000000000 R12: ffff888024c27910\nR13: ffff888071e34018 R14: 0000000000000000 R15: ffff88801ef74800\nFS:  00007f321d897700(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffffffffffffd6 CR3: 00000000722c3000 CR4: 00000000003506e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n fifo_set_limit net\/sched\/sch_fifo.c:242 [inline]\n fifo_set_limit+0x198\/0x210 net\/sched\/sch_fifo.c:227\n tbf_change+0x6ec\/0x16d0 net\/sched\/sch_tbf.c:418\n qdisc_change net\/sched\/sch_api.c:1332 [inline]\n tc_modify_qdisc+0xd9a\/0x1a60 net\/sched\/sch_api.c:1634\n rtnetlink_rcv_msg+0x413\/0xb80 net\/core\/rtnetlink.c:5572\n netlink_rcv_skb+0x153\/0x420 net\/netlink\/af_netlink.c:2504\n netlink_unicast_kernel net\/netlink\/af_netlink.c:1314 [inline]\n netlink_unicast+0x533\/0x7d0 net\/netlink\/af_netlink.c:1340\n netlink_sendmsg+0x86d\/0xdb0 net\/netlink\/af_netlink.c:1929\n sock_sendmsg_nosec net\/socket.c:704 [inline]\n sock_sendmsg+0xcf\/0x120 net\/socket.c:724\n ____sys_sendmsg+0x6e8\/0x810 net\/socket.c:2409\n ___sys_sendmsg+0xf3\/0x170 net\/socket.c:2463\n __sys_sendmsg+0xe5\/0x1b0 net\/socket.c:2492\n do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n do_syscall_64+0x35\/0xb0 arch\/x86\/entry\/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44\/0xae"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: net_sched: corrige el deref NULL en fifo_set_limit() syzbot informó otro deref NULL en fifo_set_limit() [1] Podría reproducir el problema con: unshare -n tc qd add dev lo root handle 1:0 tbf limit 200000 burst 70000 rate 100Mbit tc qd reemplazar dev lo parent 1:0 pfifo_fast tc qd cambiar dev lo root handle 1:0 tbf limit 300000 burst 70000 rate 100Mbit pfifo_fast no tiene una operación de cambio(). Haga que fifo_set_limit() sea más sólido al respecto. [1] BUG: desreferencia del puntero NULL del kernel, dirección: 0000000000000000 PGD 1cf99067 P4D 1cf99067 PUD 7ca49067 PMD 0 Ups: 0010 [#1] PREEMPT SMP KASAN CPU: 1 PID: 14443 Comm: syz-executor959 No contaminado 5. 15.0-rc3- syzkaller #0 Nombre del hardware: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01\/2011 RIP: 0010:0x0 Código: No se puede acceder a los bytes del código de operación en RIP 0xffffffffffffffd6. RSP: 0018:ffffc9000e2f7310 EFLAGS: 00010246 RAX: dffffc0000000000 RBX: ffffffff8d6ecc00 RCX: 0000000000000000 RDX: 0000000000000000 RSI: c27910 RDI: ffff888071e34000 RBP: ffff888071e34000 R08: 0000000000000001 R09: ffffffff8fcfb947 R10: 00000000000000001 R11: 0000000000000000 R12 : ffff888024c27910 R13: ffff888071e34018 R14: 00000000000000000 R15: ffff88801ef74800 FS: 00007f321d897700(0000) GS:ffff8880b9d00000(0000) knlGS:00000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 50033 CR2: ffffffffffffffd6 CR3: 00000000722c3000 CR4: 00000000003506e0 DR0: 0000000000000000 DR1: 00000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Seguimiento de llamadas: fifo_set_limit net\/sched\/sch_fifo.c:242 [en línea] fifo_set_limit+0x198\/0x210 net\/sched\/sch_fifo.c:227 6ec\/0x16d0 net\/sched\/sch_tbf.c: 418 qdisc_change net\/sched\/sch_api.c:1332 [en línea] tc_modify_qdisc+0xd9a\/0x1a60 net\/sched\/sch_api.c:1634 rtnetlink_rcv_msg+0x413\/0xb80 net\/core\/rtnetlink.c:5572 netlink_rcv_skb+0x153\/0x42 0 red\/enlace de red \/af_netlink.c:2504 netlink_unicast_kernel net\/netlink\/af_netlink.c:1314 [en línea] netlink_unicast+0x533\/0x7d0 net\/netlink\/af_netlink.c:1340 netlink_sendmsg+0x86d\/0xdb0 net\/netlink\/af_netlink.c:1929 sock_sendmsg_nosec net\/ socket.c:704 [en línea] sock_sendmsg+0xcf\/0x120 net\/socket.c:724 ____sys_sendmsg+0x6e8\/0x810 net\/socket.c:2409 ___sys_sendmsg+0xf3\/0x170 net\/socket.c:2463 __sys_sendmsg+0xe5\/0 x1b0 neto \/socket.c:2492 do_syscall_x64 arch\/x86\/entry\/common.c:50 [en línea] do_syscall_64+0x35\/0xb0 arch\/x86\/entry\/common.c:80 Entry_SYSCALL_64_after_hwframe+0x44\/0xae"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/08d7056e8e250fd2e67dbea5be5fdecdd75bf6b4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0dd7ddc462b9c2d31eb5a9926a2cc63eaa3e9f52","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/26af64d71b6277841285fa40e3f7164a378dfda9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/560ee196fe9e5037e5015e2cdb14b3aecb1cd7dc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/acff2d182c0768a713cee77442caeb07668bd68f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c951a3be5e8803e93bb49a0aca0d30457d3c1b67","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d07098f45be868a9cdce6c616563c36c64dbbd87","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fb58cd7991747b5e0b110c98c922d7b0e47a1f14","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47419","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:27.350","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/sched: sch_taprio: properly cancel timer from taprio_destroy()\n\nThere is a comment in qdisc_create() about us not calling ops->reset()\nin some cases.\n\nerr_out4:\n\t\/*\n\t * Any broken qdiscs that would require a ops->reset() here?\n\t * The qdisc was never in action so it shouldn't be necessary.\n\t *\/\n\nAs taprio sets a timer before actually receiving a packet, we need\nto cancel it from ops->destroy, just in case ops->reset has not\nbeen called.\n\nsyzbot reported:\n\nODEBUG: free active (active state 0) object type: hrtimer hint: advance_sched+0x0\/0x9a0 arch\/x86\/include\/asm\/atomic64_64.h:22\nWARNING: CPU: 0 PID: 8441 at lib\/debugobjects.c:505 debug_print_object+0x16e\/0x250 lib\/debugobjects.c:505\nModules linked in:\nCPU: 0 PID: 8441 Comm: syz-executor813 Not tainted 5.14.0-rc6-syzkaller #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01\/2011\nRIP: 0010:debug_print_object+0x16e\/0x250 lib\/debugobjects.c:505\nCode: ff df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 af 00 00 00 48 8b 14 dd e0 d3 e3 89 4c 89 ee 48 c7 c7 e0 c7 e3 89 e8 5b 86 11 05 <0f> 0b 83 05 85 03 92 09 01 48 83 c4 18 5b 5d 41 5c 41 5d 41 5e c3\nRSP: 0018:ffffc9000130f330 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: 0000000000000003 RCX: 0000000000000000\nRDX: ffff88802baeb880 RSI: ffffffff815d87b5 RDI: fffff52000261e58\nRBP: 0000000000000001 R08: 0000000000000000 R09: 0000000000000000\nR10: ffffffff815d25ee R11: 0000000000000000 R12: ffffffff898dd020\nR13: ffffffff89e3ce20 R14: ffffffff81653630 R15: dffffc0000000000\nFS:  0000000000f0d300(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffb64b3e000 CR3: 0000000036557000 CR4: 00000000001506e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n __debug_check_no_obj_freed lib\/debugobjects.c:987 [inline]\n debug_check_no_obj_freed+0x301\/0x420 lib\/debugobjects.c:1018\n slab_free_hook mm\/slub.c:1603 [inline]\n slab_free_freelist_hook+0x171\/0x240 mm\/slub.c:1653\n slab_free mm\/slub.c:3213 [inline]\n kfree+0xe4\/0x540 mm\/slub.c:4267\n qdisc_create+0xbcf\/0x1320 net\/sched\/sch_api.c:1299\n tc_modify_qdisc+0x4c8\/0x1a60 net\/sched\/sch_api.c:1663\n rtnetlink_rcv_msg+0x413\/0xb80 net\/core\/rtnetlink.c:5571\n netlink_rcv_skb+0x153\/0x420 net\/netlink\/af_netlink.c:2504\n netlink_unicast_kernel net\/netlink\/af_netlink.c:1314 [inline]\n netlink_unicast+0x533\/0x7d0 net\/netlink\/af_netlink.c:1340\n netlink_sendmsg+0x86d\/0xdb0 net\/netlink\/af_netlink.c:1929\n sock_sendmsg_nosec net\/socket.c:704 [inline]\n sock_sendmsg+0xcf\/0x120 net\/socket.c:724\n ____sys_sendmsg+0x6e8\/0x810 net\/socket.c:2403\n ___sys_sendmsg+0xf3\/0x170 net\/socket.c:2457\n __sys_sendmsg+0xe5\/0x1b0 net\/socket.c:2486\n do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n do_syscall_64+0x35\/0xb0 arch\/x86\/entry\/common.c:80"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net\/sched: sch_taprio: cancelar correctamente el temporizador de taprio_destroy(). Hay un comentario en qdisc_create() acerca de que no llamamos a ops-&gt;reset() en algunos casos. err_out4: \/* * ¿Alguna qdisc rota que requiera un ops-&gt;reset() aquí? * La qdisc nunca estuvo en acción por lo que no debería ser necesaria. *\/ Como taprio establece un temporizador antes de recibir un paquete, debemos cancelarlo desde ops-&gt;destroy, en caso de que no se haya llamado a ops-&gt;reset. syzbot informó: ODEBUG: libre activo (estado activo 0) tipo de objeto: hrtimer sugerencia: advanced_sched+0x0\/0x9a0 arch\/x86\/include\/asm\/atomic64_64.h:22 ADVERTENCIA: CPU: 0 PID: 8441 en lib\/debugobjects.c :505 debug_print_object+0x16e\/0x250 lib\/debugobjects.c:505 Módulos vinculados en: CPU: 0 PID: 8441 Comm: syz-executor813 No contaminado 5.14.0-rc6-syzkaller #0 Nombre del hardware: Google Google Compute Engine\/Google Compute Motor, BIOS Google 01\/01\/2011 RIP: 0010:debug_print_object+0x16e\/0x250 lib\/debugobjects.c:505 Código: ff df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 af 00 00 00 48 8b 14 dd e0 d3 e3 89 4c 89 ee 48 c7 c7 e0 c7 e3 89 e8 5b 86 11 05 &lt;0f&gt; 0b 83 05 85 03 92 09 01 48 83 c4 18 5b 5d 41 5c 41 5d 41 5e c3 RSP 0018:ffff c9000130f330 EFLAGS: 00010282 RAX: 0000000000000000 RBX: 00000000000000003 RCX: 0000000000000000 RDX: ffff88802baeb880 RSI: ffffffff815d87b5 RDI: fffff52000261e58 0000000000000001 R08: 0000000000000000 R09: 0000000000000000 R10: ffffffff815d25ee R11: 00000000000000000 R12: ffffffff898dd020 R13: 3ce20 R14: ffffffff81653630 R15: dffffc0000000000 FS: 0000000000f0d300( 0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007ffb64b3e000 CR3: 557000 CR4: 00000000001506e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 7: 0000000000000400 Seguimiento de llamadas: __debug_check_no_obj_freed lib\/debugobjects.c:987 [en línea] debug_check_no_obj_freed+0x301\/0x420 lib\/debugobjects.c:1018 slab_free_hook mm\/slub.c:1603 [en línea] slab_free_freelist_hook+0x171\/0x240 mm\/ slub.c:1653 slab_libre mm\/slub.c:3213 [en línea] kfree+0xe4\/0x540 mm\/slub.c:4267 qdisc_create+0xbcf\/0x1320 net\/sched\/sch_api.c:1299 tc_modify_qdisc+0x4c8\/0x1a60 net\/sched\/sch_api.c:1663 rtnetlink_rcv_msg+0x413\/0xb80 nore\/rtnetlink.c: 5571 netlink_rcv_skb+0x153\/0x420 net\/netlink\/af_netlink.c: 2504 netlink_unicast_kernel net\/netlink\/af_netlink.c: 1314 [netlin \/0x7d0 net\/netlink\/ af_netlink.c:1340 netlink_sendmsg+0x86d\/0xdb0 net\/netlink\/af_netlink.c:1929 sock_sendmsg_nosec net\/socket.c:704 [en línea] sock_sendmsg+0xcf\/0x120 net\/socket.c:724 ____sys_sendmsg+0x6e8\/0x810 net \/zócalo .c:2403 ___sys_sendmsg+0xf3\/0x170 net\/socket.c:2457 __sys_sendmsg+0xe5\/0x1b0 net\/socket.c:2486 do_syscall_x64 arch\/x86\/entry\/common.c:50 [en línea] arco\/ x86\/entrada\/common.c:80"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3ec73ffeef54596c32aff0e73fe60971b9c8b866","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7a1c1af341041221b3acb9d7036cc2b43e0efa75","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a56d447f196fa9973c568f54c0d76d5391c3b0c0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c951c08a5996365aecbc5f1a9bddec3905e1ddfc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47420","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:27.450","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdkfd: fix a potential ttm->sg memory leak\n\nMemory is allocated for ttm->sg by kmalloc in kfd_mem_dmamap_userptr,\nbut isn't freed by kfree in kfd_mem_dmaunmap_userptr. Free it!"},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amdkfd: soluciona una posible pérdida de memoria de ttm-&gt;sg. La memoria se asigna para ttm-&gt;sg mediante kmalloc en kfd_mem_dmamap_userptr, pero kfree no la libera en kfd_mem_dmaunmap_userptr. ¡Libérala!"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7e5ce6029b627efb4a004746cfdc1eeff850e6eb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b072ef1215aca33186e3a10109e872e528a9e516","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47421","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:27.537","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu: handle the case of pci_channel_io_frozen only in amdgpu_pci_resume\n\nIn current code, when a PCI error state pci_channel_io_normal is detectd,\nit will report PCI_ERS_RESULT_CAN_RECOVER status to PCI driver, and PCI\ndriver will continue the execution of PCI resume callback report_resume by\npci_walk_bridge, and the callback will go into amdgpu_pci_resume\nfinally, where write lock is releasd unconditionally without acquiring\nsuch lock first. In this case, a deadlock will happen when other threads\nstart to acquire the read lock.\n\nTo fix this, add a member in amdgpu_device strucutre to cache\npci_channel_state, and only continue the execution in amdgpu_pci_resume\nwhen it's pci_channel_io_frozen."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amdgpu: maneja el caso de pci_channel_io_frozen solo en amdgpu_pci_resume. En el código actual, cuando se detecta un estado de error de PCI pci_channel_io_normal, informará el estado de PCI_ERS_RESULT_CAN_RECOVER al controlador PCI, y el controlador PCI continúe la ejecución de PCI resume callback report_resume mediante pci_walk_bridge, y la devolución de llamada finalmente irá a amdgpu_pci_resume, donde el bloqueo de escritura se libera incondicionalmente sin adquirir dicho bloqueo primero. En este caso, se producirá un punto muerto cuando otros subprocesos comiencen a adquirir el bloqueo de lectura. Para solucionar este problema, agregue un miembro en la estructura amdgpu_device para almacenar en caché pci_channel_state y solo continúe la ejecución en amdgpu_pci_resume cuando sea pci_channel_io_frozen."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/248b061689a40f4fed05252ee2c89f87cf26d7d8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/72e9a1bf9b722628c28092e0c2cd8717edd201dc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47422","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:27.633","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/nouveau\/kms\/nv50-: fix file release memory leak\n\nWhen using single_open() for opening, single_release() should be\ncalled, otherwise the 'op' allocated in single_open() will be leaked."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/nouveau\/kms\/nv50-: corrige la pérdida de memoria de liberación de archivos. Cuando se usa single_open() para abrir, se debe llamar a single_release(); de lo contrario, se debe llamar a la 'op' asignada en single_open( ) se filtrará."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0b3d4945cc7e7ea1acd52cb06dfa83bfe265b6d5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0b4e9fc14973a94ac0520f19b3633493ae13c912","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/65fff0a8efcdca8d84ffe3e23057c3b32403482d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47423","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:27.727","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/nouveau\/debugfs: fix file release memory leak\n\nWhen using single_open() for opening, single_release() should be\ncalled, otherwise the 'op' allocated in single_open() will be leaked."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/nouveau\/debugfs: corrige la pérdida de memoria de liberación de archivos. Cuando se usa single_open() para abrir, se debe llamar a single_release(); de lo contrario, se ejecutará la 'op' asignada en single_open(). filtrado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/11cd944bb87d9e575b94c07c952105eda745b459","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1508b09945bde393326a9dab73b1fc35f672d771","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/88c3610045ca6e699331b6bb5c095c5565f30721","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9f9d4c88b2edc7924e19c44909cfc3fa4e4d3d43","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df0c9418923679bc6d0060bdb1b5bf2c755159e0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f5a8703a9c418c6fc54eb772712dfe7641e3991c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f69556a42043b5444ca712ee889829ba89fdcba8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47424","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:27.830","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: Fix freeing of uninitialized misc IRQ vector\n\nWhen VSI set up failed in i40e_probe() as part of PF switch set up\ndriver was trying to free misc IRQ vectors in\ni40e_clear_interrupt_scheme and produced a kernel Oops:\n\n   Trying to free already-free IRQ 266\n   WARNING: CPU: 0 PID: 5 at kernel\/irq\/manage.c:1731 __free_irq+0x9a\/0x300\n   Workqueue: events work_for_cpu_fn\n   RIP: 0010:__free_irq+0x9a\/0x300\n   Call Trace:\n   ? synchronize_irq+0x3a\/0xa0\n   free_irq+0x2e\/0x60\n   i40e_clear_interrupt_scheme+0x53\/0x190 [i40e]\n   i40e_probe.part.108+0x134b\/0x1a40 [i40e]\n   ? kmem_cache_alloc+0x158\/0x1c0\n   ? acpi_ut_update_ref_count.part.1+0x8e\/0x345\n   ? acpi_ut_update_object_reference+0x15e\/0x1e2\n   ? strstr+0x21\/0x70\n   ? irq_get_irq_data+0xa\/0x20\n   ? mp_check_pin_attr+0x13\/0xc0\n   ? irq_get_irq_data+0xa\/0x20\n   ? mp_map_pin_to_irq+0xd3\/0x2f0\n   ? acpi_register_gsi_ioapic+0x93\/0x170\n   ? pci_conf1_read+0xa4\/0x100\n   ? pci_bus_read_config_word+0x49\/0x70\n   ? do_pci_enable_device+0xcc\/0x100\n   local_pci_probe+0x41\/0x90\n   work_for_cpu_fn+0x16\/0x20\n   process_one_work+0x1a7\/0x360\n   worker_thread+0x1cf\/0x390\n   ? create_worker+0x1a0\/0x1a0\n   kthread+0x112\/0x130\n   ? kthread_flush_work_fn+0x10\/0x10\n   ret_from_fork+0x1f\/0x40\n\nThe problem is that at that point misc IRQ vectors\nwere not allocated yet and we get a call trace\nthat driver is trying to free already free IRQ vectors.\n\nAdd a check in i40e_clear_interrupt_scheme for __I40E_MISC_IRQ_REQUESTED\nPF state before calling i40e_free_misc_vector. This state is set only if\nmisc IRQ vectors were properly initialized."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: i40e: Se corrigió la liberación de un vector IRQ misceláneo no inicializado. Cuando la configuración de VSI falló en i40e_probe() como parte de la configuración del conmutador PF, el controlador intentaba liberar vectores IRQ misceláneos en i40e_clear_interrupt_scheme y produjo un kernel Oops: Intentando liberar IRQ 266 que ya está libre ADVERTENCIA: CPU: 0 PID: 5 en kernel\/irq\/manage.c:1731 __free_irq+0x9a\/0x300 Cola de trabajo: eventos work_for_cpu_fn RIP: 0010:__free_irq+0x9a\/0x300 Seguimiento de llamadas: ? synchronize_irq+0x3a\/0xa0 free_irq+0x2e\/0x60 i40e_clear_interrupt_scheme+0x53\/0x190 [i40e] i40e_probe.part.108+0x134b\/0x1a40 [i40e] ? kmem_cache_alloc+0x158\/0x1c0? acpi_ut_update_ref_count.part.1+0x8e\/0x345? acpi_ut_update_object_reference+0x15e\/0x1e2? chain+0x21\/0x70 ? irq_get_irq_data+0xa\/0x20 ? mp_check_pin_attr+0x13\/0xc0? irq_get_irq_data+0xa\/0x20 ? mp_map_pin_to_irq+0xd3\/0x2f0? acpi_register_gsi_ioapic+0x93\/0x170? pci_conf1_read+0xa4\/0x100? pci_bus_read_config_word+0x49\/0x70? do_pci_enable_device+0xcc\/0x100 local_pci_probe+0x41\/0x90 work_for_cpu_fn+0x16\/0x20 Process_one_work+0x1a7\/0x360 worker_thread+0x1cf\/0x390 ? create_worker+0x1a0\/0x1a0 kthread+0x112\/0x130? kthread_flush_work_fn+0x10\/0x10 ret_from_fork+0x1f\/0x40 El problema es que en ese momento aún no se habían asignado varios vectores IRQ y obtenemos un seguimiento de llamada de que el controlador está intentando liberar vectores IRQ que ya están libres. Agregue una verificación en i40e_clear_interrupt_scheme para el estado __I40E_MISC_IRQ_REQUESTED PF antes de llamar a i40e_free_misc_vector. Este estado se establece solo si se inicializaron correctamente varios vectores IRQ."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/17063cac4088b8e2fc0f633abddca5426ed58312","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2e5a20573a926302b233b0c2e1077f5debc7ab2e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/60ad4cde0ad28921f9ea25b0201c774b95ffa4b4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/75099439209d3cda439a1d9b00d19a50f0066fef","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/97aeed72af4f83ae51534f0a2473ff52f8d66236","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47425","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:27.930","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: acpi: fix resource leak in reconfiguration device addition\n\nacpi_i2c_find_adapter_by_handle() calls bus_find_device() which takes a\nreference on the adapter which is never released which will result in a\nreference count leak and render the adapter unremovable.  Make sure to\nput the adapter after creating the client in the same manner that we do\nfor OF.\n\n[wsa: fixed title]"},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: i2c: acpi: corrige la fuga de recursos en la reconfiguración del dispositivo añdido acpi_i2c_find_adapter_by_handle() llama a bus_find_device() que toma una referencia en el adaptador que nunca se libera, lo que resultará en una fuga de recuento de referencias y haga que el adaptador no sea extraíble. Asegúrese de colocar el adaptador después de crear el cliente de la misma manera que lo hacemos para OF. [wsa: título fijo]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3d9d458a8aaafa47268ea4f1b4114a9f12927989","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/60bacf259e8c2eb2324f3e13275200baaee9494b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6558b646ce1c2a872fe1c2c7cb116f05a2c1950f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90f1077c9184ec2ae9989e4642f211263f301694","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b8090a84d7758b929d348bafbd86bb7a10c5fb63","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f86de018fd7a24ee07372d55ffa7824f0c674a95","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47426","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:28.027","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, s390: Fix potential memory leak about jit_data\n\nMake sure to free jit_data through kfree() in the error path."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: bpf, s390: solucione una posible pérdida de memoria sobre jit_data. Asegúrese de liberar jit_data mediante kfree() en la ruta de error."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/29fdb11ca88d3c490a3d56f0dc77eb9444d086be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/686cb8b9f6b46787f035afe8fbd132a74e6b1bdd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a326f9c01cfbee4450ae49ce618ae6cbc0f76842","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d590a410e472417a22336c7c37685bfb38e801f2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47427","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:28.117","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: iscsi: Fix iscsi_task use after free\n\nCommit d39df158518c (\"scsi: iscsi: Have abort handler get ref to conn\")\nadded iscsi_get_conn()\/iscsi_put_conn() calls during abort handling but\nthen also changed the handling of the case where we detect an already\ncompleted task where we now end up doing a goto to the common put\/cleanup\ncode. This results in a iscsi_task use after free, because the common\ncleanup code will do a put on the iscsi_task.\n\nThis reverts the goto and moves the iscsi_get_conn() to after we've checked\nif the iscsi_task is valid."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: scsi: iscsi: corrige el uso after free de iscsi_task. Confirmación d39df158518c (\"scsi: iscsi: Have abort handler get ref to conn\") se agregaron llamadas iscsi_get_conn()\/iscsi_put_conn() durante el manejo de abortos pero luego también cambió el manejo del caso en el que detectamos una tarea ya completada y ahora terminamos haciendo un acceso al código común de put\/cleanup. Esto da como resultado un uso de iscsi_task después de la liberación, porque el código de limpieza común colocará iscsi_task. Esto revierte el ir a y mueve iscsi_get_conn() a después de haber verificado si iscsi_task es válido."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1642f51ac0d4f2b55d5748094c49ff8f7191b93c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/258aad75c62146453d03028a44f2f1590d58e1f6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47428","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:28.210","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc\/64s: fix program check interrupt emergency stack path\n\nEmergency stack path was jumping into a 3: label inside the\n__GEN_COMMON_BODY macro for the normal path after it had finished,\nrather than jumping over it. By a small miracle this is the correct\nplace to build up a new interrupt frame with the existing stack\npointer, so things basically worked okay with an added weird looking\n700 trap frame on top (which had the wrong ->nip so it didn't decode\nbug messages either).\n\nFix this by avoiding using numeric labels when jumping over non-trivial\nmacros.\n\nBefore:\n\n LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 NUMA PowerNV\n Modules linked in:\n CPU: 0 PID: 88 Comm: sh Not tainted 5.15.0-rc2-00034-ge057cdade6e5 #2637\n NIP:  7265677368657265 LR: c00000000006c0c8 CTR: c0000000000097f0\n REGS: c0000000fffb3a50 TRAP: 0700   Not tainted\n MSR:  9000000000021031 <SF,HV,ME,IR,DR,LE>  CR: 00000700  XER: 20040000\n CFAR: c0000000000098b0 IRQMASK: 0\n GPR00: c00000000006c964 c0000000fffb3cf0 c000000001513800 0000000000000000\n GPR04: 0000000048ab0778 0000000042000000 0000000000000000 0000000000001299\n GPR08: 000001e447c718ec 0000000022424282 0000000000002710 c00000000006bee8\n GPR12: 9000000000009033 c0000000016b0000 00000000000000b0 0000000000000001\n GPR16: 0000000000000000 0000000000000002 0000000000000000 0000000000000ff8\n GPR20: 0000000000001fff 0000000000000007 0000000000000080 00007fff89d90158\n GPR24: 0000000002000000 0000000002000000 0000000000000255 0000000000000300\n GPR28: c000000001270000 0000000042000000 0000000048ab0778 c000000080647e80\n NIP [7265677368657265] 0x7265677368657265\n LR [c00000000006c0c8] ___do_page_fault+0x3f8\/0xb10\n Call Trace:\n [c0000000fffb3cf0] [c00000000000bdac] soft_nmi_common+0x13c\/0x1d0 (unreliable)\n --- interrupt: 700 at decrementer_common_virt+0xb8\/0x230\n NIP:  c0000000000098b8 LR: c00000000006c0c8 CTR: c0000000000097f0\n REGS: c0000000fffb3d60 TRAP: 0700   Not tainted\n MSR:  9000000000021031 <SF,HV,ME,IR,DR,LE>  CR: 22424282  XER: 20040000\n CFAR: c0000000000098b0 IRQMASK: 0\n GPR00: c00000000006c964 0000000000002400 c000000001513800 0000000000000000\n GPR04: 0000000048ab0778 0000000042000000 0000000000000000 0000000000001299\n GPR08: 000001e447c718ec 0000000022424282 0000000000002710 c00000000006bee8\n GPR12: 9000000000009033 c0000000016b0000 00000000000000b0 0000000000000001\n GPR16: 0000000000000000 0000000000000002 0000000000000000 0000000000000ff8\n GPR20: 0000000000001fff 0000000000000007 0000000000000080 00007fff89d90158\n GPR24: 0000000002000000 0000000002000000 0000000000000255 0000000000000300\n GPR28: c000000001270000 0000000042000000 0000000048ab0778 c000000080647e80\n NIP [c0000000000098b8] decrementer_common_virt+0xb8\/0x230\n LR [c00000000006c0c8] ___do_page_fault+0x3f8\/0xb10\n --- interrupt: 700\n Instruction dump:\n XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n ---[ end trace 6d28218e0cc3c949 ]---\n\nAfter:\n\n ------------[ cut here ]------------\n kernel BUG at arch\/powerpc\/kernel\/exceptions-64s.S:491!\n Oops: Exception in kernel mode, sig: 5 [#1]\n LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 NUMA PowerNV\n Modules linked in:\n CPU: 0 PID: 88 Comm: login Not tainted 5.15.0-rc2-00034-ge057cdade6e5-dirty #2638\n NIP:  c0000000000098b8 LR: c00000000006bf04 CTR: c0000000000097f0\n REGS: c0000000fffb3d60 TRAP: 0700   Not tainted\n MSR:  9000000000021031 <SF,HV,ME,IR,DR,LE>  CR: 24482227  XER: 00040000\n CFAR: c0000000000098b0 IRQMASK: 0\n GPR00: c00000000006bf04 0000000000002400 c000000001513800 c000000001271868\n GPR04: 00000000100f0d29 0000000042000000 0000000000000007 0000000000000009\n GPR08: 00000000100f0d29 0000000024482227 0000000000002710 c000000000181b3c\n GPR12: 9000000000009033 c0000000016b0000 00000000100f0d29 c000000005b22f00\n GPR16: 00000000ffff0000 0000000000000001 0000000000000009 00000000100eed90\n GPR20: 00000000100eed90 00000\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: powerpc\/64s: programa de reparación, verificación, interrupción, ruta de pila de emergencia. La ruta de pila de emergencia saltaba a una etiqueta 3: dentro de la macro __GEN_COMMON_BODY para la ruta normal después de haber terminado, en lugar de saltar por encima. él. Por un pequeño milagro, este es el lugar correcto para construir un nuevo marco de interrupción con el puntero de pila existente, por lo que las cosas básicamente funcionaron bien con un marco de trampa 700 de aspecto extraño agregado en la parte superior (que tenía el -&gt;nip incorrecto, por lo que no decodificar mensajes de error tampoco). Solucione este problema evitando el uso de etiquetas numéricas al saltar sobre macros no triviales. Antes: LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 Módulos NUMA PowerNV vinculados en: CPU: 0 PID: 88 Comm: sh No contaminado 5.15.0-rc2-00034-ge057cdade6e5 #2637 NIP: 7265677368657265 LR c00000000 006c0c8 CTR: c0000000000097f0 REGS: c0000000fffb3a50 TRAP: 0700 No contaminado MSR: 9000000000021031  CR: 00000700 XER: 20040000 CFAR: c0000000000098b0 IRQMASK: 0 GPR00: 0000006c964 c0000000fffb3cf0 c000000001513800 0000000000000000 GPR04: 0000000048ab0778 0000000042000000 0000000000000000 0000000000 001299 GPR08: 000001e447c718ec 0000000022424282 0000000000002710 c00000000006bee8 GPR12: 9000000000009033 c0000000016b0000 00000000000000b0 000 0000000000001 GPR16: 0000000000000000 0000000000000002 0000000000000000 0000000000000ff8 GPR20: 0000000000001fff 0000000000000007 0000000000000080 00007fff89d90158 GPR24: 0000000002000000 0000000002000000 0000000000000255 0000000000000300 GPR28 c0000000012700 00 0000000042000000 0000000048ab0778 c000000080647e80 NIP [7265677368657265] 0x7265677368657265 LR [c00000000006c0c8] \/0xb10 Seguimiento de llamadas : [c0000000fffb3cf0] [c00000000000bdac] soft_nmi_common+0x13c\/0x1d0 (no confiable) --- interrupción: 700 en decrementer_common_virt+0xb8\/0x230 NIP: c0000000000098b8 LR: c00000000006c0 c8 CTR: c0000000000097f0 REGS: c0000000fffb3d60 TRAP: 0700 MSR no contaminado: 9000000000021031  CR: 22424282 XER: 20040000 CFAR: c0000000000098b0 IRQMASK: 0 GPR00: c00000000006c964 0000000000002400 c000000001513800 00000000 00000000 GPR04: 0000000048ab0778 0000000042000000 0000000000000000 0000000000001299 GPR08: 000001e447c718ec 0000000022424282 00000002710 c00000000006bee8 GPR12: 9000000000009033 c0000000016b0000 00000000000000b0 00000000000000001 GPR16: 0000000000000000 0000 000000000002 0000000000000000 0000000000000ff8 GPR20: 0000000000001fff 0000000000000007 00000000000000080 00007fff89d90158 GPR24: 000 0000000002000000 0000000000000255 0000000000000300 GPR28: c000000001270000 0000000042000000 0000000048ab0778 c000000080647e80 NIP [c0000000000098b8] decrementer_common_virt+0xb8\/0x230 LR [c00000000006c0c8] ___do_page_fault+0x3f8\/0xb10 --- interrupción: 700 Volcado de instrucciones: XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX ---[ final de seguimiento 6d28218e0cc3c949 ]--- Después: ------------[ cortar aquí ]-------- ---- ¡ERROR del kernel en arch\/powerpc\/kernel\/exceptions-64s.S:491! Vaya: Excepción en modo kernel, sign: 5 [#1] LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 Módulos NUMA PowerNV vinculados en: CPU: 0 PID: 88 Comm: iniciar sesión No está contaminado 5.15.0-rc2-00034- ge057cdade6e5-dirty #2638 NIP: c0000000000098b8 LR: c00000000006bf04 CTR: c0000000000097f0 REGS: c0000000fffb3d60 TRAP: 0700 No contaminado MSR: 90000000000210 31  CR: 24482227 XER: 00040000 CFAR: c0000000000098b0 IRQMASK: 0 GPR00: c00000000006bf04 0000000000002400 c000000001513800 c000000001271868 GPR04: 00000000100f0d29 0000000042000000 0000000000000 007 0000000000000009 GPR08: 00000000100f0d29 0000000024482227 0000000000002710 c000000000181b3c GPR12: 9000000000009033 c000000001 6b0000 00000000100f0d29 c000000005b22f00 GPR16: 00000000ffff0000 0000000000000001 ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3e607dc4df180b72a38e75030cb0f94d12808712","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/411b38fe68ba20a8bbe724b0939762c3f16e16ca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c835b3d1d6362b4a4ebb192da7e7fd27a0a45d01","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47429","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:28.303","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc\/64s: Fix unrecoverable MCE calling async handler from NMI\n\nThe machine check handler is not considered NMI on 64s. The early\nhandler is the true NMI handler, and then it schedules the\nmachine_check_exception handler to run when interrupts are enabled.\n\nThis works fine except the case of an unrecoverable MCE, where the true\nNMI is taken when MSR[RI] is clear, it can not recover, so it calls\nmachine_check_exception directly so something might be done about it.\n\nCalling an async handler from NMI context can result in irq state and\nother things getting corrupted. This can also trigger the BUG at\n  arch\/powerpc\/include\/asm\/interrupt.h:168\n  BUG_ON(!arch_irq_disabled_regs(regs) && !(regs->msr & MSR_EE));\n\nFix this by making an _async version of the handler which is called\nin the normal case, and a NMI version that is called for unrecoverable\ninterrupts."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: powerpc\/64s: corrige un MCE irrecuperable que llama al controlador asíncrono desde NMI. El controlador de verificación de la máquina no se considera NMI en 64s. El controlador inicial es el verdadero controlador NMI y luego programa el controlador machine_check_exception para que se ejecute cuando las interrupciones estén habilitadas. Esto funciona bien excepto en el caso de un MCE irrecuperable, donde el NMI verdadero se toma cuando MSR[RI] está claro, no se puede recuperar, por lo que llama a machine_check_exception directamente para que se pueda hacer algo al respecto. Llamar a un controlador asíncrono desde el contexto NMI puede provocar que el estado irq y otras cosas se corrompan. Esto también puede desencadenar el ERROR en arch\/powerpc\/include\/asm\/interrupt.h:168 BUG_ON(!arch_irq_disabled_regs(regs) &amp;&amp; !(regs-&gt;msr &amp; MSR_EE)); Solucione este problema creando una versión _async del controlador que se llama en el caso normal, y una versión NMI que se llama para interrupciones irrecuperables."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/d7a8e38999fbd6910516e44cb43f9f4317e54f73","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f08fb25bc66986b0952724530a640d9970fa52c1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47430","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:28.400","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nx86\/entry: Clear X86_FEATURE_SMAP when CONFIG_X86_SMAP=n\n\nCommit\n\n  3c73b81a9164 (\"x86\/entry, selftests: Further improve user entry sanity checks\")\n\nadded a warning if AC is set when in the kernel.\n\nCommit\n\n  662a0221893a3d (\"x86\/entry: Fix AC assertion\")\n\nchanged the warning to only fire if the CPU supports SMAP.\n\nHowever, the warning can still trigger on a machine that supports SMAP\nbut where it's disabled in the kernel config and when running the\nsyscall_nt selftest, for example:\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 49 at irqentry_enter_from_user_mode\n  CPU: 0 PID: 49 Comm: init Tainted: G                T 5.15.0-rc4+ #98 e6202628ee053b4f310759978284bd8bb0ce6905\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04\/01\/2014\n  RIP: 0010:irqentry_enter_from_user_mode\n  ...\n  Call Trace:\n   ? irqentry_enter\n   ? exc_general_protection\n   ? asm_exc_general_protection\n   ? asm_exc_general_protectio\n\nIS_ENABLED(CONFIG_X86_SMAP) could be added to the warning condition, but\neven this would not be enough in case SMAP is disabled at boot time with\nthe \"nosmap\" parameter.\n\nTo be consistent with \"nosmap\" behaviour, clear X86_FEATURE_SMAP when\n!CONFIG_X86_SMAP.\n\nFound using entry-fuzz + satrandconfig.\n\n [ bp: Massage commit message. ]"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: x86\/entry: borra X86_FEATURE_SMAP cuando CONFIG_X86_SMAP=n confirmación 3c73b81a9164 (\"x86\/entry, selftests: mejora aún más las comprobaciones de seguridad de entrada del usuario\") agregó una advertencia si AC está configurado en el núcleo. La confirmación 662a0221893a3d (\"x86\/entry: Reparar aserción de AC\") cambió la advertencia para que solo se active si la CPU admite SMAP. Sin embargo, la advertencia aún puede activarse en una máquina que admite SMAP pero donde está deshabilitado en la configuración del kernel y cuando se ejecuta la autoprueba syscall_nt, por ejemplo: ------------[ cortar aquí ]--- --------- ADVERTENCIA: CPU: 0 PID: 49 en irqentry_enter_from_user_mode CPU: 0 PID: 49 Comm: init Tainted: GT 5.15.0-rc4+ #98 e6202628ee053b4f310759978284bd8bb0ce6905 Nombre del hardware: PC estándar QEMU (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 01\/04\/2014 RIP: 0010:irqentry_enter_from_user_mode... Seguimiento de llamadas:? irqentry_enter? exc_general_protection? asm_exc_general_protection? Se podría agregar asm_exc_general_protectio IS_ENABLED(CONFIG_X86_SMAP) a la condición de advertencia, pero incluso esto no sería suficiente en caso de que SMAP esté deshabilitado en el momento del arranque con el parámetro \"nosmap\". Para ser coherente con el comportamiento de \"nosmap\", borre X86_FEATURE_SMAP cuando !CONFIG_X86_SMAP. Encontrado usando Entry-fuzz + satrandconfig. [pb: mensaje de confirmación de masaje. ]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3958b9c34c2729597e182cc606cc43942fd19f7c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4e9ec1c65da98c293f75d83755dfa5e03075a6d0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f2447f6587b8ffe42ba04d14ce67d429a1163e5e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47431","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T15:15:28.487","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu: fix gart.bo pin_count leak\n\ngmc_v{9,10}_0_gart_disable() isn't called matched with\ncorrespoding gart_enbale function in SRIOV case. This will\nlead to gart.bo pin_count leak on driver unload."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amdgpu: corrige la fuga de pin_count de gart.bo gmc_v{9,10}_0_gart_disable() no se llama y coincide con la función gart_enbale correspondiente en el caso SRIOV. Esto provocará una pérdida de pin_count de gart.bo al descargar el controlador."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/18d1c5ea3798ba42cfa0f8b2264d873463facb03","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/621ddffb70db824eabd63d18ac635180fe9500f9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/66805763a97f8f7bdf742fc0851d85c02ed9411f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/83d857d6b0967b6709cd38750c3ce2ed8ced1a95","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-33526","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T15:15:28.933","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A Stored Cross-site Scripting (XSS) vulnerability in the \"Import of user role and title of user role\" feature in ILIAS 7 before 7.30 and ILIAS 8 before 8.11 allows remote authenticated attackers with administrative privileges to inject arbitrary web script or HTML via XML file upload."},{"lang":"es","value":" Una vulnerabilidad de Cross Site Scripting Almacenado (XSS) en la característica \"Importación de rol de usuario y título de rol de usuario\" en ILIAS 7 anterior a 7.30 e ILIAS 8 anterior a 8.11 permite a atacantes remotos autenticados con privilegios administrativos inyectar scripts web o HTML de su elección a través de subir archivo XML."}],"metrics":{},"references":[{"url":"https:\/\/docu.ilias.de\/ilias.php?baseClass=illmpresentationgui&cmd=layout&ref_id=1719&obj_id=170029","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33527","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T15:15:29.050","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A Stored Cross-site Scripting (XSS) vulnerability in the \"Import of Users and login name of user\" feature in ILIAS 7 before 7.30 and ILIAS 8 before 8.11 allows remote authenticated attackers with administrative privileges to inject arbitrary web script or HTML via XML file upload."},{"lang":"es","value":"Una vulnerabilidad de Cross Site Scripting Almacenado (XSS) en la función \"Importación de usuarios y nombre de inicio de sesión del usuario\" en ILIAS 7 anterior a 7.30 e ILIAS 8 anterior a 8.11 permite a atacantes remotos autenticados con privilegios administrativos inyectar scripts web o HTML de su elección mediante la carga de archivos XML."}],"metrics":{},"references":[{"url":"https:\/\/docu.ilias.de\/ilias.php?baseClass=illmpresentationgui&cmd=layout&ref_id=1719&obj_id=170029","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33528","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T15:15:29.167","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A Stored Cross-site Scripting (XSS) vulnerability in ILIAS 7 before 7.30 and ILIAS 8 before 8.11 allows remote authenticated attackers with tutor privileges to inject arbitrary web script or HTML via XML file upload."},{"lang":"es","value":" Una vulnerabilidad de Cross Site Scripting Almacenado (XSS) en ILIAS 7 anterior a 7.30 e ILIAS 8 anterior a 8.11 permite a atacantes remotos autenticados con privilegios de tutor inyectar scripts web o HTML de su elección mediante la carga de archivos XML."}],"metrics":{},"references":[{"url":"https:\/\/docu.ilias.de\/ilias.php?baseClass=illmpresentationgui&cmd=layout&ref_id=1719&obj_id=170029","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-33529","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T15:15:29.290","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"ILIAS 7 before 7.30 and ILIAS 8 before 8.11 as well as ILIAS 9.0 allow remote authenticated attackers with administrative privileges to execute operating system commands via file uploads with dangerous types."},{"lang":"es","value":" ILIAS 7 anterior a 7.30 e ILIAS 8 anterior a 8.11, así como ILIAS 9.0, permiten a atacantes remotos autenticados con privilegios administrativos ejecutar comandos del sistema operativo mediante la carga de archivos con tipos peligrosos."}],"metrics":{},"references":[{"url":"https:\/\/docu.ilias.de\/ilias.php?baseClass=illmpresentationgui&cmd=layout&ref_id=1719&obj_id=170040","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2021-47432","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.007","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nlib\/generic-radix-tree.c: Don't overflow in peek()\n\nWhen we started spreading new inode numbers throughout most of the 64\nbit inode space, that triggered some corner case bugs, in particular\nsome integer overflows related to the radix tree code. Oops."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: lib\/generic-radix-tree.c: No se desborda en peek() Cuando comenzamos a distribuir nuevos números de inodos en la mayor parte del espacio de inodos de 64 bits, eso activó algunas esquinas. errores de casos, en particular algunos desbordamientos de enteros relacionados con el código del árbol de base. Ups."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/784d01f9bbc282abb0c5ade5beb98a87f50343ac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9492261ff2460252cf2d8de89cdf854c7e2b28a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aa7f1827953100cdde0795289a80c6c077bfe437","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ec298b958cb0c40d70c68079da933c8f31c5134c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2022-48706","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.100","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nvdpa: ifcvf: Do proper cleanup if IFCVF init fails\n\nifcvf_mgmt_dev leaks memory if it is not freed before\nreturning. Call is made to correct return statement\nso memory does not leak. ifcvf_init_hw does not take\ncare of this so it is needed to do it here."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: vdpa: ifcvf: realice una limpieza adecuada si falla el inicio de IFCVF. ifcvf_mgmt_dev pierde memoria si no se libera antes de regresar. Se realiza una llamada para corregir la declaración de devolución para que no se pierda memoria. ifcvf_init_hw no se encarga de esto, por lo que es necesario hacerlo aquí."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5d2cc32c1c10bd889125d2adc16a6bc3338dcd3e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6b04456e248761cf68f562f2fd7c04e591fcac94","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2022-48707","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.173","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncxl\/region: Fix null pointer dereference for resetting decoder\n\nNot all decoders have a reset callback.\n\nThe CXL specification allows a host bridge with a single root port to\nhave no explicit HDM decoders. Currently the region driver assumes there\nare none.  As such the CXL core creates a special pass through decoder\ninstance without a commit\/reset callback.\n\nPrior to this patch, the ->reset() callback was called unconditionally when\ncalling cxl_region_decode_reset. Thus a configuration with 1 Host Bridge,\n1 Root Port, and one directly attached CXL type 3 device or multiple CXL\ntype 3 devices attached to downstream ports of a switch can cause a null\npointer dereference.\n\nBefore the fix, a kernel crash was observed when we destroy the region, and\na pass through decoder is reset.\n\nThe issue can be reproduced as below,\n    1) create a region with a CXL setup which includes a HB with a\n    single root port under which a memdev is attached directly.\n    2) destroy the region with cxl destroy-region regionX -f."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: cxl\/region: corrige la desreferencia del puntero null para restablecer el decodificador. No todos los decodificadores tienen una devolución de llamada de reinicio. La especificación CXL permite que un puente de host con un único puerto raíz no tenga decodificadores HDM explícitos. Actualmente, el controlador de región supone que no hay ninguno. Como tal, el núcleo CXL crea una instancia de decodificador de paso especial sin una devolución de llamada de confirmación\/restablecimiento. Antes de este parche, la devolución de llamada -&gt;reset() se llamaba incondicionalmente al llamar a cxl_region_decode_reset. Por lo tanto, una configuración con 1 puente de host, 1 puerto raíz y un dispositivo CXL tipo 3 conectado directamente o varios dispositivos CXL tipo 3 conectados a puertos descendentes de un conmutador puede provocar una desreferencia de puntero null. Antes de la solución, se observaba un fallo del kernel cuando destruíamos la región y se restablecía un decodificador de paso. El problema se puede reproducir como se muestra a continuación: 1) cree una región con una configuración CXL que incluya un HB con un único puerto raíz bajo el cual se conecta directamente un memdev. 2) destruir la región con cxl destroy-region regionX -f."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4fa4302d6dc7de7e8e74dc7405611a2efb4bf54b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a04c7d062b537ff787d00da95bdfe343260d4beb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2022-48708","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.253","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npinctrl: single: fix potential NULL dereference\n\nAdded checking of pointer \"function\" in pcs_set_mux().\npinmux_generic_get_function() can return NULL and the pointer\n\"function\" was dereferenced without checking against NULL.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: pinctrl: single: corrige una posible desreferencia NULL. Se agregó la verificación de la \"función\" del puntero en pcs_set_mux(). pinmux_generic_get_function() puede devolver NULL y se eliminó la referencia al puntero \"función\" sin compararlo con NULL. Encontrado por el Centro de verificación de Linux (linuxtesting.org) con SVACE."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1177bdafe87cbe543a2dc48a9bbac265aa5864db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2b763f7de108cb1a5ad5ed08e617d677341947cb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6e2a0521e4e84a2698f2da3950fb5c5496a4d208","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/71668706fbe7d20e6f172fa3287fa8aac1b56c26","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bcc487001a15f71f103d102cba4ac8145d7a68f2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d2d73e6d4822140445ad4a7b1c6091e0f5fe703b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e671e63587c92b3fd767cf82e73129f6d5feeb33","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2022-48709","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.330","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nice: switch: fix potential memleak in ice_add_adv_recipe()\n\nWhen ice_add_special_words() fails, the 'rm' is not released, which will\nlead to a memory leak. Fix this up by going to 'err_unroll' label.\n\nCompile tested only."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ice: switch: soluciona una posible fuga de memoria en ice_add_adv_recipe(). Cuando ice_add_special_words() falla, el 'rm' no se libera, lo que provocará una pérdida de memoria. Solucione este problema yendo a la etiqueta 'err_unroll'. Compilación probada únicamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/47f4ff6f23f00f5501ff2d7054c1a37c170a7aa0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4a606ce68426c88ff2563382b33cc34f3485fe57","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2022-48710","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.393","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/radeon: fix a possible null pointer dereference\n\nIn radeon_fp_native_mode(), the return value of drm_mode_duplicate()\nis assigned to mode, which will lead to a NULL pointer dereference\non failure of drm_mode_duplicate(). Add a check to avoid npd.\n\nThe failure status of drm_cvt_mode() on the other path is checked too."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/radeon: corrige una posible desreferencia del puntero null. En radeon_fp_native_mode(), el valor de retorno de drm_mode_duplicate() se asigna al modo, lo que conducirá a una desreferencia del puntero NULL en caso de falla de drm_mode_duplicate(). Agregue una marca para evitar npd. También se verifica el estado de falla de drm_cvt_mode() en la otra ruta."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/140d9807b96e1303f6f2675a7ae8710a2094bd17","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/16a0f0b63c4c7eb46fc4c3f00bf2836e6ee46a9f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/28fd384c78d7d8ed8af0d086d778c3e438ba7f60","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7b7fba107b2c4ec7673d0f45bdbb9d1af697d9b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a89bfeef9abe93371e3ea8796377f2d132eee29","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a2b28708b645c5632dc93669ab06e97874c8244f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b33f7d99c9226892c7794dc2500fae35966020c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e938d24f0b7392e142b8aa434f18590d99dbe479","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fee8ae0a0bb66eb7730c22f44fbd7203f63c2eab","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52700","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.480","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: fix kernel warning when sending SYN message\n\nWhen sending a SYN message, this kernel stack trace is observed:\n\n...\n[   13.396352] RIP: 0010:_copy_from_iter+0xb4\/0x550\n...\n[   13.398494] Call Trace:\n[   13.398630]  <TASK>\n[   13.398630]  ? __alloc_skb+0xed\/0x1a0\n[   13.398630]  tipc_msg_build+0x12c\/0x670 [tipc]\n[   13.398630]  ? shmem_add_to_page_cache.isra.71+0x151\/0x290\n[   13.398630]  __tipc_sendmsg+0x2d1\/0x710 [tipc]\n[   13.398630]  ? tipc_connect+0x1d9\/0x230 [tipc]\n[   13.398630]  ? __local_bh_enable_ip+0x37\/0x80\n[   13.398630]  tipc_connect+0x1d9\/0x230 [tipc]\n[   13.398630]  ? __sys_connect+0x9f\/0xd0\n[   13.398630]  __sys_connect+0x9f\/0xd0\n[   13.398630]  ? preempt_count_add+0x4d\/0xa0\n[   13.398630]  ? fpregs_assert_state_consistent+0x22\/0x50\n[   13.398630]  __x64_sys_connect+0x16\/0x20\n[   13.398630]  do_syscall_64+0x42\/0x90\n[   13.398630]  entry_SYSCALL_64_after_hwframe+0x63\/0xcd\n\nIt is because commit a41dad905e5a (\"iov_iter: saner checks for attempt\nto copy to\/from iterator\") has introduced sanity check for copying\nfrom\/to iov iterator. Lacking of copy direction from the iterator\nviewpoint would lead to kernel stack trace like above.\n\nThis commit fixes this issue by initializing the iov iterator with\nthe correct copy direction when sending SYN or ACK without data."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tipc: corrige la advertencia del kernel al enviar un mensaje SYN Al enviar un mensaje SYN, se observa este seguimiento de la pila del kernel: ... [ 13.396352] RIP: 0010:_copy_from_iter+0xb4\/0x550 . .. [ 13.398494] Seguimiento de llamadas: [ 13.398630]  [ 13.398630] ? __alloc_skb+0xed\/0x1a0 [13.398630] tipc_msg_build+0x12c\/0x670 [tipc] [13.398630]? shmem_add_to_page_cache.isra.71+0x151\/0x290 [13.398630] __tipc_sendmsg+0x2d1\/0x710 [tipc] [13.398630] ? tipc_connect+0x1d9\/0x230 [tipc] [13.398630]? __local_bh_enable_ip+0x37\/0x80 [13.398630] tipc_connect+0x1d9\/0x230 [tipc] [13.398630]? __sys_connect+0x9f\/0xd0 [ 13.398630] __sys_connect+0x9f\/0xd0 [ 13.398630] ? preempt_count_add+0x4d\/0xa0 [13.398630]? fpregs_assert_state_consistent+0x22\/0x50 [ 13.398630] __x64_sys_connect+0x16\/0x20 [ 13.398630] do_syscall_64+0x42\/0x90 [ 13.398630] Entry_SYSCALL_64_after_hwframe+0x63\/0xcd Es porque la confirmación 41dad905e5a (\"iov_iter: comprobaciones más sensatas para intentar copiar hacia\/desde el iterador\") ha introducido una verificación de cordura para copiar desde\/hacia el iterador iov. La falta de dirección de copia desde el punto de vista del iterador conduciría a un seguimiento de la pila del kernel como se muestra arriba. Esta confirmación soluciona este problema al inicializar el iterador iov con la dirección de copia correcta al enviar SYN o ACK sin datos."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/11a4d6f67cf55883dc78e31c247d1903ed7feccc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/54b6082aec178f16ad6d193b4ecdc9c4823d9a32","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52701","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.547","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: use a bounce buffer for copying skb->mark\n\nsyzbot found arm64 builds would crash in sock_recv_mark()\nwhen CONFIG_HARDENED_USERCOPY=y\n\nx86 and powerpc are not detecting the issue because\nthey define user_access_begin.\nThis will be handled in a different patch,\nbecause a check_object_size() is missing.\n\nOnly data from skb->cb[] can be copied directly to\/from user space,\nas explained in commit 79a8a642bf05 (\"net: Whitelist\nthe skbuff_head_cache \"cb\" field\")\n\nsyzbot report was:\nusercopy: Kernel memory exposure attempt detected from SLUB object 'skbuff_head_cache' (offset 168, size 4)!\n------------[ cut here ]------------\nkernel BUG at mm\/usercopy.c:102 !\nInternal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\nModules linked in:\nCPU: 0 PID: 4410 Comm: syz-executor533 Not tainted 6.2.0-rc7-syzkaller-17907-g2d3827b3f393 #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/21\/2023\npstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : usercopy_abort+0x90\/0x94 mm\/usercopy.c:90\nlr : usercopy_abort+0x90\/0x94 mm\/usercopy.c:90\nsp : ffff80000fb9b9a0\nx29: ffff80000fb9b9b0 x28: ffff0000c6073400 x27: 0000000020001a00\nx26: 0000000000000014 x25: ffff80000cf52000 x24: fffffc0000000000\nx23: 05ffc00000000200 x22: fffffc000324bf80 x21: ffff0000c92fe1a8\nx20: 0000000000000001 x19: 0000000000000004 x18: 0000000000000000\nx17: 656a626f2042554c x16: ffff0000c6073dd0 x15: ffff80000dbd2118\nx14: ffff0000c6073400 x13: 00000000ffffffff x12: ffff0000c6073400\nx11: ff808000081bbb4c x10: 0000000000000000 x9 : 7b0572d7cc0ccf00\nx8 : 7b0572d7cc0ccf00 x7 : ffff80000bf650d4 x6 : 0000000000000000\nx5 : 0000000000000001 x4 : 0000000000000001 x3 : 0000000000000000\nx2 : ffff0001fefbff08 x1 : 0000000100000000 x0 : 000000000000006c\nCall trace:\nusercopy_abort+0x90\/0x94 mm\/usercopy.c:90\n__check_heap_object+0xa8\/0x100 mm\/slub.c:4761\ncheck_heap_object mm\/usercopy.c:196 [inline]\n__check_object_size+0x208\/0x6b8 mm\/usercopy.c:251\ncheck_object_size include\/linux\/thread_info.h:199 [inline]\n__copy_to_user include\/linux\/uaccess.h:115 [inline]\nput_cmsg+0x408\/0x464 net\/core\/scm.c:238\nsock_recv_mark net\/socket.c:975 [inline]\n__sock_recv_cmsgs+0x1fc\/0x248 net\/socket.c:984\nsock_recv_cmsgs include\/net\/sock.h:2728 [inline]\npacket_recvmsg+0x2d8\/0x678 net\/packet\/af_packet.c:3482\n____sys_recvmsg+0x110\/0x3a0\n___sys_recvmsg net\/socket.c:2737 [inline]\n__sys_recvmsg+0x194\/0x210 net\/socket.c:2767\n__do_sys_recvmsg net\/socket.c:2777 [inline]\n__se_sys_recvmsg net\/socket.c:2774 [inline]\n__arm64_sys_recvmsg+0x2c\/0x3c net\/socket.c:2774\n__invoke_syscall arch\/arm64\/kernel\/syscall.c:38 [inline]\ninvoke_syscall+0x64\/0x178 arch\/arm64\/kernel\/syscall.c:52\nel0_svc_common+0xbc\/0x180 arch\/arm64\/kernel\/syscall.c:142\ndo_el0_svc+0x48\/0x110 arch\/arm64\/kernel\/syscall.c:193\nel0_svc+0x58\/0x14c arch\/arm64\/kernel\/entry-common.c:637\nel0t_64_sync_handler+0x84\/0xf0 arch\/arm64\/kernel\/entry-common.c:655\nel0t_64_sync+0x190\/0x194 arch\/arm64\/kernel\/entry.S:591\nCode: 91388800 aa0903e1 f90003e8 94e6d752 (d4210000)"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: net: use un búfer de rebote para copiar skb-&gt;mark syzbot encontró que las compilaciones arm64 fallarían en sock_recv_mark() cuando CONFIG_HARDENED_USERCOPY=y x86 y powerpc no detectan el problema porque definen user_access_begin . Esto se manejará en un parche diferente, porque falta check_object_size(). Solo los datos de skb-&gt;cb[] se pueden copiar directamente hacia\/desde el espacio de usuario, como se explica en la confirmación 79a8a642bf05 (\"net: Lista blanca del campo skbuff_head_cache \"cb\") El informe de syzbot fue: copia de usuario: intento de exposición de la memoria del kernel detectado desde SLUB objeto 'skbuff_head_cache' (desplazamiento 168, tamaño 4)! ------------[ cortar aquí ]------------ ¡ERROR del kernel en mm\/usercopy.c:102! Error interno: Ups - ERROR: 00000000f2000800 [#1] PREEMPT Módulos SMP vinculados en: CPU: 0 PID: 4410 Comm: syz-executor533 No contaminado 6.2.0-rc7-syzkaller-17907-g2d3827b3f393 #0 Nombre de hardware: Google Google Compute Engine\/Google Compute Engine, BIOS Google 21\/01\/2023 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc: usercopy_abort+0x90\/0x94 mm\/usercopy.c:90 lr: usercopy_abort+0x90\/0x94 mm\/usercopy.c:90 sp: ffff80000fb9b9a0 x29: ffff80000fb9b9b0 x28: ffff0000c6073400 x27: 0000000020001a00 x26: 0000000000000014 5: ffff80000cf52000 x24: ffffc0000000000 x23: 05ffc00000000200 x22: ffffc000324bf80 x21: ffff0000c92fe1a8 x20: 0000000000000001 x19: 00000004 x18: 0000000000000000 x17: 656a626f2042554c x16: ffff0000c6073dd0 x15: ffff80000dbd2118 x14: ffff0000c6073400 x13: 00000000ffffffff x12: 073400 x11: ff808000081bbb4c x10: 0000000000000000 x9: 7b0572d7cc0ccf00 x8: 7b0572d7cc0ccf00 x7: ffff80000bf650d4 x6: 0000000000000000 x5: 0000000000000001 x4: 0000000000000001 x3: 0000000000000000 x2: ffff0001fefbff08 x1 : 0000000100000000 x0 : 000000000000006c Rastreo de llamadas: usercopy_abort+0x90\/0x94 mm\/usercopy.c:90 __check_heap_object+0xa8\/0x100 mm\/slub.c:4761 check_heap_object mm\/usercopy.c:196 __check_object _tamaño+0x208\/0x6b8 mm\/ usercopy.c:251 check_object_size include\/linux\/thread_info.h:199 [en línea] __copy_to_user include\/linux\/uaccess.h:115 [en línea] put_cmsg+0x408\/0x464 net\/core\/scm.c:238 sock_recv_mark net\/socket. c:975 [en línea] __sock_recv_cmsgs+0x1fc\/0x248 net\/socket.c:984 sock_recv_cmsgs include\/net\/sock.h:2728 [en línea] paquete_recvmsg+0x2d8\/0x678 net\/packet\/af_packet.c:3482 ____sys_recvmsg+0x1 10\/0x3a0 ___sys_recvmsg net\/socket.c:2737 [en línea] __sys_recvmsg+0x194\/0x210 net\/socket.c:2767 __do_sys_recvmsg net\/socket.c:2777 [en línea] __se_sys_recvmsg net\/socket.c:2774 [en línea] 64_sys_recvmsg+0x2c\/0x3c net\/socket.c:2774 __invoke_syscall arch\/arm64\/kernel\/syscall.c:38 [en línea] invoke_syscall+0x64\/0x178 arch\/arm64\/kernel\/syscall.c:52 el0_svc_common+0xbc\/0x180 arch\/arm64\/kernel\/syscall .c:142 do_el0_svc+0x48\/0x110 arch\/arm64\/kernel\/syscall.c:193 el0_svc+0x58\/0x14c arch\/arm64\/kernel\/entry-common.c:637 el0t_64_sync_handler+0x84\/0xf0 arch\/arm64\/kernel\/entry -common.c:655 el0t_64_sync+0x190\/0x194 arch\/arm64\/kernel\/entry.S:591 Código: 91388800 aa0903e1 f90003e8 94e6d752 (d4210000)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2558b8039d059342197610498c8749ad294adee5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/863a7de987f02a901bf215509276a7de0370e0f9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52702","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.617","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: openvswitch: fix possible memory leak in ovs_meter_cmd_set()\n\nold_meter needs to be free after it is detached regardless of whether\nthe new meter is successfully attached."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: net: openvswitch: corrige una posible pérdida de memoria en ovs_meter_cmd_set() old_meter debe estar libre después de desconectarlo, independientemente de si el nuevo medidor se conectó correctamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1563e998a938f095548054ef09e277b562b79536","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2fa28f5c6fcbfc794340684f36d2581b4f2d20b5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c0f65ee0a3329eb4b94beaef0268633696e2d0c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e336a9e08618203a456fb5367f1387b14554f55e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52703","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.683","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/usb: kalmia: Don't pass act_len in usb_bulk_msg error path\n\nsyzbot reported that act_len in kalmia_send_init_packet() is\nuninitialized when passing it to the first usb_bulk_msg error path. Jiri\nPirko noted that it's pointless to pass it in the error path, and that\nthe value that would be printed in the second error path would be the\nvalue of act_len from the first call to usb_bulk_msg.[1]\n\nWith this in mind, let's just not pass act_len to the usb_bulk_msg error\npaths.\n\n1: https:\/\/lore.kernel.org\/lkml\/Y9pY61y1nwTuzMOa@nanopsycho\/"},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: net\/usb: kalmia: No pasar act_len en la ruta de error usb_bulk_msg syzbot informó que act_len en kalmia_send_init_packet() no está inicializado al pasarlo a la primera ruta de error usb_bulk_msg. Jiri Pirko señaló que no tiene sentido pasarlo en la ruta de error y que el valor que se imprimiría en la segunda ruta de error sería el valor de act_len de la primera llamada a usb_bulk_msg.[1] Con esto en mente, simplemente no pasemos act_len a las rutas de error usb_bulk_msg. 1: https:\/\/lore.kernel.org\/lkml\/Y9pY61y1nwTuzMOa@nanopsycho\/"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/02df3170c04a8356cd571ab9155a42f030190abc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1b5de7d44890b78519acbcc80d8d1f23ff2872e5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/338f826d3afead6e4df521f7972a4bef04a72efb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/525bdcb0838d19d918c7786151ee14661967a030","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/723ef7b66f37c0841f5a451ccbce47ee1641e081","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a753352622b4f3c0219e0e9c73114b2848ae6042","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c68f345b7c425b38656e1791a0486769a8797016","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52704","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.760","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nfreezer,umh: Fix call_usermode_helper_exec() vs SIGKILL\n\nTetsuo-San noted that commit f5d39b020809 (\"freezer,sched: Rewrite\ncore freezer logic\") broke call_usermodehelper_exec() for the KILLABLE\ncase.\n\nSpecifically it was missed that the second, unconditional,\nwait_for_completion() was not optional and ensures the on-stack\ncompletion is unused before going out-of-scope."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: freezer,umh: Fix call_usermode_helper_exec() vs SIGKILL .Tetsuo-San notó que la confirmación f5d39b020809 (\"freezer,sched: Rewrite core freezer logic\") rompió call_usermodehelper_exec() para el caso KILLABLE. Específicamente, se pasó por alto que el segundo wait_for_completion() incondicional no era opcional y garantiza que la finalización en la pila no se utilice antes de salir del alcance."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7f9f6c54da876b3f0bece2b569456ceb96965ed7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eedeb787ebb53de5c5dcf7b7b39d01bf1b0f037d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52705","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.840","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix underflow in second superblock position calculations\n\nMacro NILFS_SB2_OFFSET_BYTES, which computes the position of the second\nsuperblock, underflows when the argument device size is less than 4096\nbytes.  Therefore, when using this macro, it is necessary to check in\nadvance that the device size is not less than a lower limit, or at least\nthat underflow does not occur.\n\nThe current nilfs2 implementation lacks this check, causing out-of-bound\nblock access when mounting devices smaller than 4096 bytes:\n\n I\/O error, dev loop0, sector 36028797018963960 op 0x0:(READ) flags 0x0\n phys_seg 1 prio class 2\n NILFS (loop0): unable to read secondary superblock (blocksize = 1024)\n\nIn addition, when trying to resize the filesystem to a size below 4096\nbytes, this underflow occurs in nilfs_resize_fs(), passing a huge number\nof segments to nilfs_sufile_resize(), corrupting parameters such as the\nnumber of segments in superblocks.  This causes excessive loop iterations\nin nilfs_sufile_resize() during a subsequent resize ioctl, causing\nsemaphore ns_segctor_sem to block for a long time and hang the writer\nthread:\n\n INFO: task segctord:5067 blocked for more than 143 seconds.\n      Not tainted 6.2.0-rc8-syzkaller-00015-gf6feea56f66d #0\n \"echo 0 > \/proc\/sys\/kernel\/hung_task_timeout_secs\" disables this message.\n task:segctord        state:D stack:23456 pid:5067  ppid:2\n flags:0x00004000\n Call Trace:\n  <TASK>\n  context_switch kernel\/sched\/core.c:5293 [inline]\n  __schedule+0x1409\/0x43f0 kernel\/sched\/core.c:6606\n  schedule+0xc3\/0x190 kernel\/sched\/core.c:6682\n  rwsem_down_write_slowpath+0xfcf\/0x14a0 kernel\/locking\/rwsem.c:1190\n  nilfs_transaction_lock+0x25c\/0x4f0 fs\/nilfs2\/segment.c:357\n  nilfs_segctor_thread_construct fs\/nilfs2\/segment.c:2486 [inline]\n  nilfs_segctor_thread+0x52f\/0x1140 fs\/nilfs2\/segment.c:2570\n  kthread+0x270\/0x300 kernel\/kthread.c:376\n  ret_from_fork+0x1f\/0x30 arch\/x86\/entry\/entry_64.S:308\n  <\/TASK>\n ...\n Call Trace:\n  <TASK>\n  folio_mark_accessed+0x51c\/0xf00 mm\/swap.c:515\n  __nilfs_get_page_block fs\/nilfs2\/page.c:42 [inline]\n  nilfs_grab_buffer+0x3d3\/0x540 fs\/nilfs2\/page.c:61\n  nilfs_mdt_submit_block+0xd7\/0x8f0 fs\/nilfs2\/mdt.c:121\n  nilfs_mdt_read_block+0xeb\/0x430 fs\/nilfs2\/mdt.c:176\n  nilfs_mdt_get_block+0x12d\/0xbb0 fs\/nilfs2\/mdt.c:251\n  nilfs_sufile_get_segment_usage_block fs\/nilfs2\/sufile.c:92 [inline]\n  nilfs_sufile_truncate_range fs\/nilfs2\/sufile.c:679 [inline]\n  nilfs_sufile_resize+0x7a3\/0x12b0 fs\/nilfs2\/sufile.c:777\n  nilfs_resize_fs+0x20c\/0xed0 fs\/nilfs2\/super.c:422\n  nilfs_ioctl_resize fs\/nilfs2\/ioctl.c:1033 [inline]\n  nilfs_ioctl+0x137c\/0x2440 fs\/nilfs2\/ioctl.c:1301\n  ...\n\nThis fixes these issues by inserting appropriate minimum device size\nchecks or anti-underflow checks, depending on where the macro is used."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nilfs2: corrige el desbordamiento en los cálculos de la posición del segundo superbloque. La macro NILFS_SB2_OFFSET_BYTES, que calcula la posición del segundo superbloque, sufre un desbordamiento cuando el tamaño del dispositivo del argumento es inferior a 4096 bytes. Por lo tanto, al utilizar esta macro, es necesario comprobar de antemano que el tamaño del dispositivo no sea inferior a un límite inferior, o al menos que no se produzca un desbordamiento insuficiente. La implementación actual de nilfs2 carece de esta verificación, lo que provoca un acceso a bloques fuera de los límites al montar dispositivos de menos de 4096 bytes: error de E\/S, dev loop0, sector 36028797018963960 op 0x0:(READ) flags 0x0 phys_seg 1 prio class 2 NILFS (loop0 ): no se puede leer el superbloque secundario (tamaño de bloque = 1024) Además, al intentar cambiar el tamaño del sistema de archivos a un tamaño inferior a 4096 bytes, este desbordamiento se produce en nilfs_resize_fs(), pasando una gran cantidad de segmentos a nilfs_sufile_resize(), corrompiendo parámetros como como el número de segmentos en supermanzanas. Esto provoca iteraciones de bucle excesivas en nilfs_sufile_resize() durante un cambio de tamaño de ioctl posterior, lo que provoca que el semáforo ns_segctor_sem se bloquee durante mucho tiempo y cuelgue el hilo de escritura: INFORMACIÓN: tarea segctord:5067 bloqueada durante más de 143 segundos. No contaminado 6.2.0-rc8-syzkaller-00015-gf6feea56f66d #0 \"echo 0 &gt; \/proc\/sys\/kernel\/hung_task_timeout_secs\" desactiva este mensaje. tarea:segctord estado:D pila:23456 pid:5067 ppid:2 banderas:0x00004000 Seguimiento de llamadas:  context_switch kernel\/sched\/core.c:5293 [en línea] __schedule+0x1409\/0x43f0 kernel\/sched\/core.c: 6606 programación+0xc3\/0x190 kernel\/sched\/core.c:6682 rwsem_down_write_slowpath+0xfcf\/0x14a0 kernel\/locking\/rwsem.c:1190 nilfs_transaction_lock+0x25c\/0x4f0 fs\/nilfs2\/segment.c:357 nilfs_segctor_thread_construct fs \/nilfs2\/segmento. c:2486 [en línea] nilfs_segctor_thread+0x52f\/0x1140 fs\/nilfs2\/segment.c:2570 kthread+0x270\/0x300 kernel\/kthread.c:376 ret_from_fork+0x1f\/0x30 arch\/x86\/entry\/entry_64.S:308 ... Seguimiento de llamadas:  folio_mark_accessed+0x51c\/0xf00 mm\/swap.c:515 __nilfs_get_page_block fs\/nilfs2\/page.c:42 [en línea] nilfs_grab_buffer+0x3d3\/0x540 fs\/nilfs2\/page.c:61 nilfs_mdt_submit_block+0xd7\/0x8f0 fs\/nilfs2\/mdt.c:121 nilfs_mdt_read_block+0xeb\/0x430 fs\/nilfs2\/mdt.c:176 nilfs_mdt_get_block+0x12d\/0xbb0 fs\/nilfs2\/mdt.c:251 _get_segment_usage_block fs\/nilfs2\/sufile.c :92 [en línea] nilfs_sufile_truncate_range fs\/nilfs2\/sufile.c:679 [en línea] nilfs_sufile_resize+0x7a3\/0x12b0 fs\/nilfs2\/sufile.c:777 nilfs_resize_fs+0x20c\/0xed0 fs\/nilfs2\/super.c:422 nilfs_ioctl_resize f s\/nilfs2 \/ioctl.c:1033 [en línea] nilfs_ioctl+0x137c\/0x2440 fs\/nilfs2\/ioctl.c:1301 ... Esto soluciona estos problemas insertando comprobaciones de tamaño mínimo de dispositivo adecuadas o comprobaciones anti-desbordamiento, dependiendo de dónde se utilice la macro ."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0ee5ed0126a2211f7174492da2ca2c29f43755c5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2f7a1135b202977b82457adde7db6c390056863b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/52844d8382cd9166d708032def8905ffc3ae550f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/99b9402a36f0799f25feee4465bfa4b8dfa74b4d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a158782b56b070485d54d25fc9aaf2c8f3752205","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a8ef5109f93cea9933bbac0455d8c18757b3fcb4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b96591e2c35c8b47db0ec816b5fc6cb8868000ff","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52706","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.920","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ngpio: sim: fix a memory leak\n\nFix an inverted logic bug in gpio_sim_remove_hogs() that leads to GPIO\nhog structures never being freed."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: gpio: sim: corrige una pérdida de memoria. Se corrige un error de lógica invertida en gpio_sim_remove_hogs() que hace que las estructuras GPIO hog nunca se liberen."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/79eeab1d85e0fee4c0bc36f3b6ddf3920f39f74b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/854e1ecff266033d3149666d3c5b8b0e174b4210","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52707","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:12.993","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nsched\/psi: Fix use-after-free in ep_remove_wait_queue()\n\nIf a non-root cgroup gets removed when there is a thread that registered\ntrigger and is polling on a pressure file within the cgroup, the polling\nwaitqueue gets freed in the following path:\n\n do_rmdir\n   cgroup_rmdir\n     kernfs_drain_open_files\n       cgroup_file_release\n         cgroup_pressure_release\n           psi_trigger_destroy\n\nHowever, the polling thread still has a reference to the pressure file and\nwill access the freed waitqueue when the file is closed or upon exit:\n\n fput\n   ep_eventpoll_release\n     ep_free\n       ep_remove_wait_queue\n         remove_wait_queue\n\nThis results in use-after-free as pasted below.\n\nThe fundamental problem here is that cgroup_file_release() (and\nconsequently waitqueue's lifetime) is not tied to the file's real lifetime.\nUsing wake_up_pollfree() here might be less than ideal, but it is in line\nwith the comment at commit 42288cb44c4b (\"wait: add wake_up_pollfree()\")\nsince the waitqueue's lifetime is not tied to file's one and can be\nconsidered as another special case. While this would be fixable by somehow\nmaking cgroup_file_release() be tied to the fput(), it would require\nsizable refactoring at cgroups or higher layer which might be more\njustifiable if we identify more cases like this.\n\n  BUG: KASAN: use-after-free in _raw_spin_lock_irqsave+0x60\/0xc0\n  Write of size 4 at addr ffff88810e625328 by task a.out\/4404\n\n\tCPU: 19 PID: 4404 Comm: a.out Not tainted 6.2.0-rc6 #38\n\tHardware name: Amazon EC2 c5a.8xlarge\/, BIOS 1.0 10\/16\/2017\n\tCall Trace:\n\t<TASK>\n\tdump_stack_lvl+0x73\/0xa0\n\tprint_report+0x16c\/0x4e0\n\tkasan_report+0xc3\/0xf0\n\tkasan_check_range+0x2d2\/0x310\n\t_raw_spin_lock_irqsave+0x60\/0xc0\n\tremove_wait_queue+0x1a\/0xa0\n\tep_free+0x12c\/0x170\n\tep_eventpoll_release+0x26\/0x30\n\t__fput+0x202\/0x400\n\ttask_work_run+0x11d\/0x170\n\tdo_exit+0x495\/0x1130\n\tdo_group_exit+0x100\/0x100\n\tget_signal+0xd67\/0xde0\n\tarch_do_signal_or_restart+0x2a\/0x2b0\n\texit_to_user_mode_prepare+0x94\/0x100\n\tsyscall_exit_to_user_mode+0x20\/0x40\n\tdo_syscall_64+0x52\/0x90\n\tentry_SYSCALL_64_after_hwframe+0x63\/0xcd\n\t<\/TASK>\n\n Allocated by task 4404:\n\n\tkasan_set_track+0x3d\/0x60\n\t__kasan_kmalloc+0x85\/0x90\n\tpsi_trigger_create+0x113\/0x3e0\n\tpressure_write+0x146\/0x2e0\n\tcgroup_file_write+0x11c\/0x250\n\tkernfs_fop_write_iter+0x186\/0x220\n\tvfs_write+0x3d8\/0x5c0\n\tksys_write+0x90\/0x110\n\tdo_syscall_64+0x43\/0x90\n\tentry_SYSCALL_64_after_hwframe+0x63\/0xcd\n\n Freed by task 4407:\n\n\tkasan_set_track+0x3d\/0x60\n\tkasan_save_free_info+0x27\/0x40\n\t____kasan_slab_free+0x11d\/0x170\n\tslab_free_freelist_hook+0x87\/0x150\n\t__kmem_cache_free+0xcb\/0x180\n\tpsi_trigger_destroy+0x2e8\/0x310\n\tcgroup_file_release+0x4f\/0xb0\n\tkernfs_drain_open_files+0x165\/0x1f0\n\tkernfs_drain+0x162\/0x1a0\n\t__kernfs_remove+0x1fb\/0x310\n\tkernfs_remove_by_name_ns+0x95\/0xe0\n\tcgroup_addrm_files+0x67f\/0x700\n\tcgroup_destroy_locked+0x283\/0x3c0\n\tcgroup_rmdir+0x29\/0x100\n\tkernfs_iop_rmdir+0xd1\/0x140\n\tvfs_rmdir+0xfe\/0x240\n\tdo_rmdir+0x13d\/0x280\n\t__x64_sys_rmdir+0x2c\/0x30\n\tdo_syscall_64+0x43\/0x90\n\tentry_SYSCALL_64_after_hwframe+0x63\/0xcd"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: sched\/psi: corrige el use after free en ep_remove_wait_queue() si se elimina un cgroup no raíz cuando hay un subproceso que registró un activador y está sondeando un archivo de presión dentro en cgroup, la cola de espera de sondeo se libera en la siguiente ruta: do_rmdir cgroup_rmdir kernfs_drain_open_files cgroup_file_release cgroup_pression_release psi_trigger_destroy Sin embargo, el hilo de sondeo aún tiene una referencia al archivo de presión y accederá a la cola de espera liberada cuando el archivo se cierre o al salir: fput ep_eventpoll_release ep_free ep_remove_wait_queue remove_wait_queue Esto da como resultado un use after free como se pega a continuación. El problema fundamental aquí es que cgroup_file_release() (y en consecuencia la vida útil de la cola de espera) no está ligada a la vida real del archivo. Usar wake_up_pollfree() aquí puede no ser ideal, pero está en línea con el comentario en la confirmación 42288cb44c4b (\"espera: agregar wake_up_pollfree()\") ya que la vida útil de la cola de espera no está ligada a la del archivo y puede considerarse como otro caso especial. . Si bien esto se podría solucionar haciendo que cgroup_file_release() esté vinculado de alguna manera a fput(), requeriría una refactorización considerable en cgroups o en una capa superior, lo que podría ser más justificable si identificamos más casos como este. ERROR: KASAN: use-after-free en _raw_spin_lock_irqsave+0x60\/0xc0 Escritura de tamaño 4 en la dirección ffff88810e625328 por tarea a.out\/4404 CPU: 19 PID: 4404 Comm: a.out No contaminado 6.2.0-rc6 #38 Hardware nombre: Amazon EC2 c5a.8xlarge\/, BIOS 1.0 16\/10\/2017 Seguimiento de llamadas:  dump_stack_lvl+0x73\/0xa0 print_report+0x16c\/0x4e0 kasan_report+0xc3\/0xf0 kasan_check_range+0x2d2\/0x310 _raw_spin_lock_irqsave+0x60\/0x c0 remove_wait_queue+0x1a \/0xa0 ep_free+0x12c\/0x170 ep_eventpoll_release+0x26\/0x30 __fput+0x202\/0x400 task_work_run+0x11d\/0x170 do_exit+0x495\/0x1130 do_group_exit+0x100\/0x100 get_signal+0xd67\/0xde0 arch _do_signal_or_restart+0x2a\/0x2b0 exit_to_user_mode_prepare+0x94\/0x100 syscall_exit_to_user_mode+0x20 \/0x40 do_syscall_64+0x52\/0x90 Entry_SYSCALL_64_after_hwframe+0x63\/0xcd  Asignado por tarea 4404: kasan_set_track+0x3d\/0x60 __kasan_kmalloc+0x85\/0x90 psi_trigger_create+0x113\/0x3e0 Pressure_write+0x1 46\/0x2e0 cgroup_file_write+0x11c\/0x250 kernfs_fop_write_iter+0x186\/ 0x220 vfs_write+0x3d8\/0x5c0 ksys_write+0x90\/0x110 do_syscall_64+0x43\/0x90 Entry_SYSCALL_64_after_hwframe+0x63\/0xcd Liberado por la tarea 4407: kasan_set_track+0x3d\/0x60 kasan_save_free_info+0x27\/ 0x40 ____kasan_slab_free+0x11d\/0x170 slab_free_freelist_hook+0x87\/0x150 __kmem_cache_free+0xcb\/ 0x180 psi_trigger_destroy+0x2e8\/0x310 cgroup_file_release+0x4f\/0xb0 kernfs_drain_open_files+0x165\/0x1f0 kernfs_drain+0x162\/0x1a0 __kernfs_remove+0x1fb\/0x310 ns+0x95\/0xe0 cgroup_addrm_files+0x67f\/0x700 cgroup_destroy_locked+0x283\/0x3c0 cgroup_rmdir+0x29\/0x100 kernfs_iop_rmdir+0xd1\/ 0x140 vfs_rmdir+0xfe\/0x240 do_rmdir+0x13d\/0x280 __x64_sys_rmdir+0x2c\/0x30 do_syscall_64+0x43\/0x90 Entry_SYSCALL_64_after_hwframe+0x63\/0xcd"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7caeb5457bd01ccba0df1d6f4872f20d28e50b38","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c2dbe32d5db5c4ead121cf86dabd5ab691fb47fe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c6879a4dcefe92d870ab68cabaa9caeda4f2af5a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cca2b3feb70170ef6f0fbc4b4d91eea235a2b73a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ec9c7aa08819f976b2492fa63c41b5712d2924b5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52708","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.080","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmmc: mmc_spi: fix error handling in mmc_spi_probe()\n\nIf mmc_add_host() fails, it doesn't need to call mmc_remove_host(),\nor it will cause null-ptr-deref, because of deleting a not added\ndevice in mmc_remove_host().\n\nTo fix this, goto label 'fail_glue_init', if mmc_add_host() fails,\nand change the label 'fail_add_host' to 'fail_gpiod_request'."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mmc: mmc_spi: corrige el manejo de errores en mmc_spi_probe(). Si mmc_add_host() falla, no es necesario llamar a mmc_remove_host(), o causará null-ptr-deref, debido a la eliminación de un dispositivo no agregado en mmc_remove_host(). Para solucionar este problema, vaya a la etiqueta 'fail_glue_init', si mmc_add_host() falla, y cambie la etiqueta 'fail_add_host' a 'fail_gpiod_request'."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0b3edcb24bd81b3b2e3dac89f4733bfd47d283be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/82645bf4ed02abe930a659c5fe16d593a6dbd93f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cf4c9d2ac1e42c7d18b921bec39486896645b714","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e9b488d60f51ae312006e224e03a30a151c28bdd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ecad2fafd424ffdc203b2748ded0b37e4bbecef3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52730","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.157","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmmc: sdio: fix possible resource leaks in some error paths\n\nIf sdio_add_func() or sdio_init_func() fails, sdio_remove_func() can\nnot release the resources, because the sdio function is not presented\nin these two cases, it won't call of_node_put() or put_device().\n\nTo fix these leaks, make sdio_func_present() only control whether\ndevice_del() needs to be called or not, then always call of_node_put()\nand put_device().\n\nIn error case in sdio_init_func(), the reference of 'card->dev' is\nnot get, to avoid redundant put in sdio_free_func_cis(), move the\nget_device() to sdio_alloc_func() and put_device() to sdio_release_func(),\nit can keep the get\/put function be balanced.\n\nWithout this patch, while doing fault inject test, it can get the\nfollowing leak reports, after this fix, the leak is gone.\n\nunreferenced object 0xffff888112514000 (size 2048):\n  comm \"kworker\/3:2\", pid 65, jiffies 4294741614 (age 124.774s)\n  hex dump (first 32 bytes):\n    00 e0 6f 12 81 88 ff ff 60 58 8d 06 81 88 ff ff  ..o.....`X......\n    10 40 51 12 81 88 ff ff 10 40 51 12 81 88 ff ff  .@Q......@Q.....\n  backtrace:\n    [<000000009e5931da>] kmalloc_trace+0x21\/0x110\n    [<000000002f839ccb>] mmc_alloc_card+0x38\/0xb0 [mmc_core]\n    [<0000000004adcbf6>] mmc_sdio_init_card+0xde\/0x170 [mmc_core]\n    [<000000007538fea0>] mmc_attach_sdio+0xcb\/0x1b0 [mmc_core]\n    [<00000000d4fdeba7>] mmc_rescan+0x54a\/0x640 [mmc_core]\n\nunreferenced object 0xffff888112511000 (size 2048):\n  comm \"kworker\/3:2\", pid 65, jiffies 4294741623 (age 124.766s)\n  hex dump (first 32 bytes):\n    00 40 51 12 81 88 ff ff e0 58 8d 06 81 88 ff ff  .@Q......X......\n    10 10 51 12 81 88 ff ff 10 10 51 12 81 88 ff ff  ..Q.......Q.....\n  backtrace:\n    [<000000009e5931da>] kmalloc_trace+0x21\/0x110\n    [<00000000fcbe706c>] sdio_alloc_func+0x35\/0x100 [mmc_core]\n    [<00000000c68f4b50>] mmc_attach_sdio.cold.18+0xb1\/0x395 [mmc_core]\n    [<00000000d4fdeba7>] mmc_rescan+0x54a\/0x640 [mmc_core]"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mmc: sdio: soluciona posibles fugas de recursos en algunas rutas de error. Si sdio_add_func() o sdio_init_func() falla, sdio_remove_func() no puede liberar los recursos, porque no se presenta la función sdio en estos dos casos, no llamará a of_node_put() o put_device(). Para solucionar estas fugas, haga que sdio_func_present() solo controle si es necesario llamar a device_del() o no, luego llame siempre a of_node_put() y put_device(). En caso de error en sdio_init_func(), la referencia de 'card-&gt;dev' no se obtiene, para evitar la colocación redundante en sdio_free_func_cis(), mueva get_device() a sdio_alloc_func() y put_device() a sdio_release_func(), puede mantenga equilibrada la función get\/put. Sin este parche, mientras realiza la prueba de inyección de fallas, puede obtener los siguientes informes de fugas; después de esta solución, la fuga desaparece. objeto sin referencia 0xffff888112514000 (tamaño 2048): comunicación \"kworker\/3:2\", pid 65, jiffies 4294741614 (edad 124,774 s) volcado hexadecimal (primeros 32 bytes): 00 e0 6f 12 81 88 ff ff 60 58 8d 06 81 8 y siguientes ff ..o.....`X...... 10 40 51 12 81 88 ff ff 10 40 51 12 81 88 ff ff .@Q......@Q..... retroceso : [&lt;000000009e5931da&gt;] kmalloc_trace+0x21\/0x110 [&lt;000000002f839ccb&gt;] mmc_alloc_card+0x38\/0xb0 [mmc_core] [&lt;0000000004adcbf6&gt;] mmc_sdio_init_card+0xde\/0x170 [mmc_core] [&lt;000000007538fea0&gt;] mmc_attach_sdio+0xcb\/0x1b0 [mmc_core] [&lt;00000000d4fdeba7&gt;] mmc_rescan+0x54a\/0x640 [mmc_core] objeto sin referencia 0xffff888112511000 (tamaño 2048): comm \"kworker\/3:2\", pid 65, santiamén 4294741623 (edad 124,766 s) volcado hexadecimal (primero 32 bytes): 00 40 51 12 81 88 ff ff e0 58 8d 06 81 88 ff ff .@Q......X...... 10 10 51 12 81 88 ff ff 10 10 51 12 81 88 ff ff ..Q. ......P..... rastreo inverso: [&lt;000000009e5931da&gt;] kmalloc_trace+0x21\/0x110 [&lt;00000000fcbe706c&gt;] sdio_alloc_func+0x35\/0x100 [mmc_core] [&lt;00000000c68f4b50&gt;] mmc_attach_sdio.cold. 18+0xb1\/ 0x395 [mmc_core] [&lt;00000000d4fdeba7&gt;] mmc_rescan+0x54a\/0x640 [mmc_core]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1e06cf04239e202248c8fa356bf11449dc73cfbd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/30716d9f0fa1766e522cf24c8a456244e4fc9931","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5c7858adada31dbed042448cff6997dd6efc472a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/605d9fb9556f8f5fb4566f4df1480f280f308ded","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/761db46b29b496946046d8cb33c7ea6de6bef36e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/92ff03c2563c9b57a027c744750f3b7d2f261c58","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f855d31bb38d663c3ba672345d7cce9324ba3b72","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52731","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.237","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: Fix invalid page access after closing deferred I\/O devices\n\nWhen a fbdev with deferred I\/O is once opened and closed, the dirty\npages still remain queued in the pageref list, and eventually later\nthose may be processed in the delayed work.  This may lead to a\ncorruption of pages, hitting an Oops.\n\nThis patch makes sure to cancel the delayed work and clean up the\npageref list at closing the device for addressing the bug.  A part of\nthe cleanup code is factored out as a new helper function that is\ncalled from the common fb_release()."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: fbdev: corrige el acceso a páginas no válidas después de cerrar dispositivos de E\/S diferidas. Cuando un fbdev con E\/S diferidas se abre y cierra una vez, las páginas sucias aún permanecen en cola en la lista pageref. y, eventualmente, más adelante, podrán procesarse en el trabajo retrasado. Esto puede provocar la corrupción de las páginas y provocar un error. Este parche garantiza cancelar el trabajo retrasado y limpiar la lista de referencias de página al cerrar el dispositivo para solucionar el error. Una parte del código de limpieza se factoriza como una nueva función auxiliar que se llama desde el fb_release() común."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3efc61d95259956db25347e2a9562c3e54546e20","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/87b9802ca824fcee7915e717e9a60471af62e8e9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f1d91f0e9d5a240a809698d7d9c5a538e7dcc149","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52732","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.303","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nceph: blocklist the kclient when receiving corrupted snap trace\n\nWhen received corrupted snap trace we don't know what exactly has\nhappened in MDS side. And we shouldn't continue IOs and metadatas\naccess to MDS, which may corrupt or get incorrect contents.\n\nThis patch will just block all the further IO\/MDS requests\nimmediately and then evict the kclient itself.\n\nThe reason why we still need to evict the kclient just after\nblocking all the further IOs is that the MDS could revoke the caps\nfaster."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ceph: lista de bloqueo del kclient cuando se recibe un seguimiento instantáneo corrupto. Cuando recibimos un seguimiento instantáneo corrupto, no sabemos qué ha sucedido exactamente en el lado MDS. Y no debemos continuar con el acceso de IO y metadatos a MDS, lo que puede dañar u obtener contenidos incorrectos. Este parche simplemente bloqueará todas las solicitudes IO\/MDS adicionales inmediatamente y luego expulsará al propio kclient. La razón por la que todavía necesitamos desalojar al kclient justo después de bloquear todas las IO adicionales es que el MDS podría revocar los límites más rápido."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/66ec619e4591f8350f99c5269a7ce160cccc7a7c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a68e564adcaa69b0930809fb64d9d5f7d9c32ba9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52733","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.380","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ns390\/decompressor: specify __decompress() buf len to avoid overflow\n\nHistorically calls to __decompress() didn't specify \"out_len\" parameter\non many architectures including s390, expecting that no writes beyond\nuncompressed kernel image are performed. This has changed since commit\n2aa14b1ab2c4 (\"zstd: import usptream v1.5.2\") which includes zstd library\ncommit 6a7ede3dfccb (\"Reduce size of dctx by reutilizing dst buffer\n(#2751)\"). Now zstd decompression code might store literal buffer in\nthe unwritten portion of the destination buffer. Since \"out_len\" is\nnot set, it is considered to be unlimited and hence free to use for\noptimization needs. On s390 this might corrupt initrd or ipl report\nwhich are often placed right after the decompressor buffer. Luckily the\nsize of uncompressed kernel image is already known to the decompressor,\nso to avoid the problem simply specify it in the \"out_len\" parameter."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: s390\/decompressor: especifique __decompress() buf len para evitar el desbordamiento. Históricamente, las llamadas a __decompress() no especificaban el parámetro \"out_len\" en muchas arquitecturas, incluido s390, esperando que no se escribieran más allá Se realizan imágenes del kernel sin comprimir. Esto ha cambiado desde la confirmación 2aa14b1ab2c4 (\"zstd: import usptream v1.5.2\") que incluye la confirmación de la biblioteca zstd 6a7ede3dfccb (\"Reducir el tamaño de dctx reutilizando el búfer dst (#2751)\"). Ahora el código de descompresión zstd podría almacenar un búfer literal en la parte no escrita del búfer de destino. Dado que \"out_len\" no está configurado, se considera ilimitado y, por lo tanto, de uso gratuito para las necesidades de optimización. En s390, esto podría dañar el informe initrd o ipl que a menudo se coloca justo después del buffer del descompresor. Afortunadamente, el descompresor ya conoce el tamaño de la imagen del kernel sin comprimir, por lo que para evitar el problema simplemente especifíquelo en el parámetro \"out_len\"."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/16409f7d9ca5bb8220e1049ea9aae0d3c94d2dfb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/55dbd6f4ea954751340f4f73d5dcd7c8f12208b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7ab41c2c08a32132ba8c14624910e2fe8ce4ba4b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9ed522143f959630f8b7782ddc212900d8f609a9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f1eb22d0ff064ad458b3b1a1eaa84ac3996206c2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52734","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.450","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: sch: Bounds check priority\n\nNothing was explicitly bounds checking the priority index used to access\nclpriop[]. WARN and bail out early if it's pathological. Seen with GCC 13:\n\n..\/net\/sched\/sch_htb.c: In function 'htb_activate_prios':\n..\/net\/sched\/sch_htb.c:437:44: warning: array subscript [0, 31] is outside array bounds of 'struct htb_prio[8]' [-Warray-bounds=]\n  437 |                         if (p->inner.clprio[prio].feed.rb_node)\n      |                             ~~~~~~~~~~~~~~~^~~~~~\n..\/net\/sched\/sch_htb.c:131:41: note: while referencing 'clprio'\n  131 |                         struct htb_prio clprio[TC_HTB_NUMPRIO];\n      |                                         ^~~~~~"},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: sched: sch: Prioridad de verificación de límites. Nada estaba explícitamente limitado al verificar el índice de prioridad utilizado para acceder a clpriop[]. AVISO y salga temprano si es patológico. Visto con GCC 13: ..\/net\/sched\/sch_htb.c: En función 'htb_activate_prios': ..\/net\/sched\/sch_htb.c:437:44: advertencia: el subíndice de matriz [0, 31] está fuera de los límites de la matriz de 'struct htb_prio[8]' [-Warray-bounds=] 437 | si (p-&gt;inner.clprio[prio].feed.rb_node) | ~~~~~~~~~~~~~~~^~~~~~ ..\/net\/sched\/sch_htb.c:131:41: nota: al hacer referencia a 'clprio' 131 | estructura htb_prio clprio[TC_HTB_NUMPRIO]; | ^~~~~~"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/90fcf55d83b20da1091f926a291af05fb74f61c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/99875ea9b5b47995bfb3c684d21eb17feb4b7e6a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/de5ca4c3852f896cacac2bf259597aab5e17d9e3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f6415c9c9a0b3881543d38528a58b54af4351522","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fbe71c5dacaa5a9960323215f118958174c81aa0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52735","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.523","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, sockmap: Don't let sock_map_{close,destroy,unhash} call itself\n\nsock_map proto callbacks should never call themselves by design. Protect\nagainst bugs like [1] and break out of the recursive loop to avoid a stack\noverflow in favor of a resource leak.\n\n[1] https:\/\/lore.kernel.org\/all\/00000000000073b14905ef2e7401@google.com\/"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf, sockmap: no permita que sock_map_{close,destroy,unhash} se llame a sí mismo. Las devoluciones de llamada del proto sock_map nunca deberían llamarse a sí mismas por diseño. Protéjase contra bugs como [1] y salga del bucle recursivo para evitar un desbordamiento de la pila que favorezca una fuga de recursos. [1] https:\/\/lore.kernel.org\/all\/00000000000073b14905ef2e7401@google.com\/"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5b4a79ba65a1ab479903fff2e604865d229b70a9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7499859881488da97589f3c79cc66fa75748ad49","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f312367f5246e04df564d341044286e9e37a97ba","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52736","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.597","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: hda: Do not unset preset when cleaning up codec\n\nSeveral functions that take part in codec's initialization and removal\nare re-used by ASoC codec drivers implementations. Drivers mimic the\nbehavior of hda_codec_driver_probe\/remove() found in\nsound\/pci\/hda\/hda_bind.c with their component->probe\/remove() instead.\n\nOne of the reasons for that is the expectation of\nsnd_hda_codec_device_new() to receive a valid pointer to an instance of\nstruct snd_card. This expectation can be met only once sound card\ncomponents probing commences.\n\nAs ASoC sound card may be unbound without codec device being actually\nremoved from the system, unsetting ->preset in\nsnd_hda_codec_cleanup_for_unbind() interferes with module unload -> load\nscenario causing null-ptr-deref. Preset is assigned only once, during\ndevice\/driver matching whereas ASoC codec driver's module reloading may\noccur several times throughout the lifetime of an audio stack."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ALSA: hda: no desarmar el valor predeterminado al limpiar el códec. Varias funciones que participan en la inicialización y eliminación del códec son reutilizadas por las implementaciones de controladores de códec ASoC. Los controladores imitan el comportamiento de hda_codec_driver_probe\/remove() que se encuentra en sound\/pci\/hda\/hda_bind.c con su componente-&gt;probe\/remove(). Una de las razones de esto es la expectativa de que snd_hda_codec_device_new() reciba un puntero válido a una instancia de struct snd_card. Esta expectativa sólo podrá cumplirse una vez que comience la investigación de los componentes de la tarjeta de sonido. Como la tarjeta de sonido ASoC puede desconectarse sin que el dispositivo códec se elimine realmente del sistema, desarmar -&gt;preset en snd_hda_codec_cleanup_for_unbind() interfiere con la descarga del módulo -&gt; escenario de carga causando null-ptr-deref. El ajuste preestablecido se asigna solo una vez, durante la coincidencia de dispositivo\/controlador, mientras que la recarga del módulo del controlador del códec ASoC puede ocurrir varias veces durante la vida útil de una pila de audio."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/427ca2530da8dc61a42620d7113b05e187b6c2c0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7fc4e7191eae9d9325511e03deadfdb2224914f8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/87978e6ad45a16835cc58234451111091be3c59a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e909f5f2aa55a8f9aa6919cce08015cb0e8d4668","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52737","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.667","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: lock the inode in shared mode before starting fiemap\n\nCurrently fiemap does not take the inode's lock (VFS lock), it only locks\na file range in the inode's io tree. This however can lead to a deadlock\nif we have a concurrent fsync on the file and fiemap code triggers a fault\nwhen accessing the user space buffer with fiemap_fill_next_extent(). The\ndeadlock happens on the inode's i_mmap_lock semaphore, which is taken both\nby fsync and btrfs_page_mkwrite(). This deadlock was recently reported by\nsyzbot and triggers a trace like the following:\n\n   task:syz-executor361 state:D stack:20264 pid:5668  ppid:5119   flags:0x00004004\n   Call Trace:\n    <TASK>\n    context_switch kernel\/sched\/core.c:5293 [inline]\n    __schedule+0x995\/0xe20 kernel\/sched\/core.c:6606\n    schedule+0xcb\/0x190 kernel\/sched\/core.c:6682\n    wait_on_state fs\/btrfs\/extent-io-tree.c:707 [inline]\n    wait_extent_bit+0x577\/0x6f0 fs\/btrfs\/extent-io-tree.c:751\n    lock_extent+0x1c2\/0x280 fs\/btrfs\/extent-io-tree.c:1742\n    find_lock_delalloc_range+0x4e6\/0x9c0 fs\/btrfs\/extent_io.c:488\n    writepage_delalloc+0x1ef\/0x540 fs\/btrfs\/extent_io.c:1863\n    __extent_writepage+0x736\/0x14e0 fs\/btrfs\/extent_io.c:2174\n    extent_write_cache_pages+0x983\/0x1220 fs\/btrfs\/extent_io.c:3091\n    extent_writepages+0x219\/0x540 fs\/btrfs\/extent_io.c:3211\n    do_writepages+0x3c3\/0x680 mm\/page-writeback.c:2581\n    filemap_fdatawrite_wbc+0x11e\/0x170 mm\/filemap.c:388\n    __filemap_fdatawrite_range mm\/filemap.c:421 [inline]\n    filemap_fdatawrite_range+0x175\/0x200 mm\/filemap.c:439\n    btrfs_fdatawrite_range fs\/btrfs\/file.c:3850 [inline]\n    start_ordered_ops fs\/btrfs\/file.c:1737 [inline]\n    btrfs_sync_file+0x4ff\/0x1190 fs\/btrfs\/file.c:1839\n    generic_write_sync include\/linux\/fs.h:2885 [inline]\n    btrfs_do_write_iter+0xcd3\/0x1280 fs\/btrfs\/file.c:1684\n    call_write_iter include\/linux\/fs.h:2189 [inline]\n    new_sync_write fs\/read_write.c:491 [inline]\n    vfs_write+0x7dc\/0xc50 fs\/read_write.c:584\n    ksys_write+0x177\/0x2a0 fs\/read_write.c:637\n    do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n    do_syscall_64+0x3d\/0xb0 arch\/x86\/entry\/common.c:80\n    entry_SYSCALL_64_after_hwframe+0x63\/0xcd\n   RIP: 0033:0x7f7d4054e9b9\n   RSP: 002b:00007f7d404fa2f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n   RAX: ffffffffffffffda RBX: 00007f7d405d87a0 RCX: 00007f7d4054e9b9\n   RDX: 0000000000000090 RSI: 0000000020000000 RDI: 0000000000000006\n   RBP: 00007f7d405a51d0 R08: 0000000000000000 R09: 0000000000000000\n   R10: 0000000000000000 R11: 0000000000000246 R12: 61635f65646f6e69\n   R13: 65646f7475616f6e R14: 7261637369646f6e R15: 00007f7d405d87a8\n    <\/TASK>\n   INFO: task syz-executor361:5697 blocked for more than 145 seconds.\n         Not tainted 6.2.0-rc3-syzkaller-00376-g7c6984405241 #0\n   \"echo 0 > \/proc\/sys\/kernel\/hung_task_timeout_secs\" disables this message.\n   task:syz-executor361 state:D stack:21216 pid:5697  ppid:5119   flags:0x00004004\n   Call Trace:\n    <TASK>\n    context_switch kernel\/sched\/core.c:5293 [inline]\n    __schedule+0x995\/0xe20 kernel\/sched\/core.c:6606\n    schedule+0xcb\/0x190 kernel\/sched\/core.c:6682\n    rwsem_down_read_slowpath+0x5f9\/0x930 kernel\/locking\/rwsem.c:1095\n    __down_read_common+0x54\/0x2a0 kernel\/locking\/rwsem.c:1260\n    btrfs_page_mkwrite+0x417\/0xc80 fs\/btrfs\/inode.c:8526\n    do_page_mkwrite+0x19e\/0x5e0 mm\/memory.c:2947\n    wp_page_shared+0x15e\/0x380 mm\/memory.c:3295\n    handle_pte_fault mm\/memory.c:4949 [inline]\n    __handle_mm_fault mm\/memory.c:5073 [inline]\n    handle_mm_fault+0x1b79\/0x26b0 mm\/memory.c:5219\n    do_user_addr_fault+0x69b\/0xcb0 arch\/x86\/mm\/fault.c:1428\n    handle_page_fault arch\/x86\/mm\/fault.c:1519 [inline]\n    exc_page_fault+0x7a\/0x110 arch\/x86\/mm\/fault.c:1575\n    asm_exc_page_fault+0x22\/0x30 arch\/x86\/include\/asm\/idtentry.h:570\n   RIP: 0010:copy_user_short_string+0xd\/0x40 arch\/x86\/lib\/copy_user_64.S:233\n   Code: 74 0a 89 (...)\n   RSP: 0018:ffffc9000570f330 EFLAGS: 000502\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs: bloquea el inodo en modo compartido antes de iniciar fiemap. Actualmente, fiemap no toma el bloqueo del inodo (bloqueo VFS), solo bloquea un rango de archivos en el árbol io del inodo. Sin embargo, esto puede llevar a un punto muerto si tenemos un fsync simultáneo en el archivo y el código fiemap desencadena una falla al acceder al búfer de espacio de usuario con fiemap_fill_next_extent(). El punto muerto ocurre en el semáforo i_mmap_lock del inodo, que es tomado tanto por fsync como por btrfs_page_mkwrite(). Syzbot informó recientemente de este punto muerto y activa un seguimiento como el siguiente: task:syz-executor361 state:D stack:20264 pid:5668 ppid:5119 flags:0x00004004 Call Trace:  context_switch kernel\/sched\/core.c: 5293 [en línea] __schedule+0x995\/0xe20 kernel\/sched\/core.c:6606 Schedule+0xcb\/0x190 kernel\/sched\/core.c:6682 wait_on_state fs\/btrfs\/extent-io-tree.c:707 [en línea] wait_extent_bit +0x577\/0x6f0 fs\/btrfs\/extent-io-tree.c:751 lock_extent+0x1c2\/0x280 fs\/btrfs\/extent-io-tree.c:1742 find_lock_delalloc_range+0x4e6\/0x9c0 fs\/btrfs\/extent_io.c:488 writepage_delalloc +0x1ef\/0x540 fs\/btrfs\/extent_io.c:1863 __extent_writepage+0x736\/0x14e0 fs\/btrfs\/extent_io.c:2174 extensión_write_cache_pages+0x983\/0x1220 fs\/btrfs\/extent_io.c:3091 extensión_writepages+0x219\/0 x540 fs\/btrfs\/ extend_io.c:3211 do_writepages+0x3c3\/0x680 mm\/page-writeback.c:2581 filemap_fdatawrite_wbc+0x11e\/0x170 mm\/filemap.c:388 __filemap_fdatawrite_range mm\/filemap.c:421 [en línea] filemap_fdatawrite_range+0x175\/0x200 mm\/filemap .c:439 btrfs_fdatawrite_range fs\/btrfs\/file.c:3850 [en línea] start_ordered_ops fs\/btrfs\/file.c:1737 [en línea] btrfs_sync_file+0x4ff\/0x1190 fs\/btrfs\/file.c:1839 generic_write_sync include\/linux\/fs .h:2885 [en línea] btrfs_do_write_iter+0xcd3\/0x1280 fs\/btrfs\/file.c:1684 call_write_iter include\/linux\/fs.h:2189 [en línea] new_sync_write fs\/read_write.c:491 [en línea] vfs_write+0x7dc\/0xc50 fs\/read_write.c:584 ksys_write+0x177\/0x2a0 fs\/read_write.c:637 do_syscall_x64 arch\/x86\/entry\/common.c:50 [en línea] do_syscall_64+0x3d\/0xb0 arch\/x86\/entry\/common.c:80 Entry_SYSCALL_64_after_hwframe+0x63\/0xcd RIP: 0033:0x7f7d4054e9b9 RSP: 002b:00007f7d404fa2f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001 RAX: fffffffffffffda 00007f7d405d87a0 RCX: 00007f7d4054e9b9 RDX: 0000000000000090 RSI: 0000000020000000 RDI: 0000000000000006 RBP: 00007f7d405a51d0 R08: 000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 61635f65646f6e69 R13: 65646f7475616f6e R14: 7261637369646f6e R15: 00007f7d405d87a8  INFORMACIÓN: tarea syz-executor361:5697 bloqueada durante más de 145 segundos. No contaminado 6.2.0-rc3-syzkaller-00376-g7c6984405241 #0 \"echo 0 &gt; \/proc\/sys\/kernel\/hung_task_timeout_secs\" desactiva este mensaje. tarea:syz-executor361 estado:D pila:21216 pid:5697 ppid:5119 banderas:0x00004004 Seguimiento de llamadas:  context_switch kernel\/sched\/core.c:5293 [en línea] __schedule+0x995\/0xe20 kernel\/sched\/core. c:6606 Schedule+0xcb\/0x190 kernel\/sched\/core.c:6682 rwsem_down_read_slowpath+0x5f9\/0x930 kernel\/locking\/rwsem.c:1095 __down_read_common+0x54\/0x2a0 kernel\/locking\/rwsem.c:1260 btrfs_page_mkwrite+0x417\/ 0xc80 fs\/btrfs\/inode.c:8526 do_page_mkwrite+0x19e\/0x5e0 mm\/memory.c:2947 wp_page_shared+0x15e\/0x380 mm\/memory.c:3295 handle_pte_fault mm\/memory.c:4949 [en línea] __handle_mm_fault mm\/memory.c :5073 [en línea] handle_mm_fault+0x1b79\/0x26b0 mm\/memory.c:5219 do_user_addr_fault+0x69b\/0xcb0 arch\/x86\/mm\/fault.c:1428 handle_page_fault arch\/x86\/mm\/fault.c:1519 [en línea] exc_page_fault+ 0x7a\/0x110 arch\/x86\/mm\/fault.c:1575 asm_exc_page_fault+0x22\/0x30 arch\/x86\/include\/asm\/idtentry.h:570 RIP: 0010:copy_user_short_string+0xd\/0x40 arch\/x86\/lib\/copy_user_64.S :233 Código: 74 0a 89 (...) RSP: 0018:ffffc9000570f330 EFLAGS: 000502 ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/519b7e13b5ae8dd38da1e52275705343be6bb508","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d8c594da79bc0244e610a70594e824a401802be1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52738","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.740","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu\/fence: Fix oops due to non-matching drm_sched init\/fini\n\nCurrently amdgpu calls drm_sched_fini() from the fence driver sw fini\nroutine - such function is expected to be called only after the\nrespective init function - drm_sched_init() - was executed successfully.\n\nHappens that we faced a driver probe failure in the Steam Deck\nrecently, and the function drm_sched_fini() was called even without\nits counter-part had been previously called, causing the following oops:\n\namdgpu: probe of 0000:04:00.0 failed with error -110\nBUG: kernel NULL pointer dereference, address: 0000000000000090\nPGD 0 P4D 0\nOops: 0002 [#1] PREEMPT SMP NOPTI\nCPU: 0 PID: 609 Comm: systemd-udevd Not tainted 6.2.0-rc3-gpiccoli #338\nHardware name: Valve Jupiter\/Jupiter, BIOS F7A0113 11\/04\/2022\nRIP: 0010:drm_sched_fini+0x84\/0xa0 [gpu_sched]\n[...]\nCall Trace:\n <TASK>\n amdgpu_fence_driver_sw_fini+0xc8\/0xd0 [amdgpu]\n amdgpu_device_fini_sw+0x2b\/0x3b0 [amdgpu]\n amdgpu_driver_release_kms+0x16\/0x30 [amdgpu]\n devm_drm_dev_init_release+0x49\/0x70\n [...]\n\nTo prevent that, check if the drm_sched was properly initialized for a\ngiven ring before calling its fini counter-part.\n\nNotice ideally we'd use sched.ready for that; such field is set as the latest\nthing on drm_sched_init(). But amdgpu seems to \"override\" the meaning of such\nfield - in the above oops for example, it was a GFX ring causing the crash, and\nthe sched.ready field was set to true in the ring init routine, regardless of\nthe state of the DRM scheduler. Hence, we ended-up using sched.ops as per\nChristian's suggestion [0], and also removed the no_scheduler check [1].\n\n[0] https:\/\/lore.kernel.org\/amd-gfx\/984ee981-2906-0eaf-ccec-9f80975cb136@amd.com\/\n[1] https:\/\/lore.kernel.org\/amd-gfx\/cd0e2994-f85f-d837-609f-7056d5fb7231@amd.com\/"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amdgpu\/fence: se solucionó el error debido a que drm_sched init\/fini no coincide. Actualmente, amdgpu llama a drm_sched_fini() desde la rutina SW fini del controlador de valla; se espera que se llame a dicha función. sólo después de que la función de inicio respectiva, drm_sched_init(), se haya ejecutado correctamente. Sucede que recientemente nos enfrentamos a una falla en la sonda del controlador en Steam Deck, y se llamó a la función drm_sched_fini() incluso sin que su contraparte se hubiera llamado previamente, lo que provocó el siguiente error: amdgpu: la sonda de 0000:04:00.0 falló con error -110 ERROR: desreferencia del puntero NULL del kernel, dirección: 0000000000000090 PGD 0 P4D 0 Ups: 0002 [#1] PREEMPT SMP NOPTI CPU: 0 PID: 609 Comm: systemd-udevd No contaminado 6.2.0-rc3-gpiccoli #338 Nombre del hardware : Valve Jupiter\/Jupiter, BIOS F7A0113 04\/11\/2022 RIP: 0010:drm_sched_fini+0x84\/0xa0 [gpu_sched] [...] Seguimiento de llamadas:  amdgpu_fence_driver_sw_fini+0xc8\/0xd0 [amdgpu] amdgpu_device_fini_sw+0x2b\/0x3b0 [ amdgpu] amdgpu_driver_release_kms+0x16\/0x30 [amdgpu] devm_drm_dev_init_release+0x49\/0x70 [...] Para evitar eso, verifique si drm_sched se inicializó correctamente para un anillo determinado antes de llamar a su contraparte fini. Observe que idealmente usaríamos sched.ready para eso; dicho campo se establece como lo último en drm_sched_init(). Pero amdgpu parece \"sobreescribir\" el significado de dicho campo; en el ejemplo anterior, por ejemplo, fue un anillo GFX el que provocó el bloqueo y el campo sched.ready se configuró en verdadero en la rutina de inicio del anillo, independientemente del estado de el programador DRM. Por lo tanto, terminamos usando sched.ops según la sugerencia de Christian [0] y también eliminamos la verificación no_scheduler [1]. [0] https:\/\/lore.kernel.org\/amd-gfx\/984ee981-2906-0eaf-ccec-9f80975cb136@amd.com\/ [1] https:\/\/lore.kernel.org\/amd-gfx\/cd0e2994- f85f-d837-609f-7056d5fb7231@amd.com\/"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2bcbbef9cace772f5b7128b11401c515982de34b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2e557c8ca2c585bdef591b8503ba83b85f5d0afd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5ad7bbf3dba5c4a684338df1f285080f2588b535","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52739","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.820","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nFix page corruption caused by racy check in __free_pages\n\nWhen we upgraded our kernel, we started seeing some page corruption like\nthe following consistently:\n\n  BUG: Bad page state in process ganesha.nfsd  pfn:1304ca\n  page:0000000022261c55 refcount:0 mapcount:-128 mapping:0000000000000000 index:0x0 pfn:0x1304ca\n  flags: 0x17ffffc0000000()\n  raw: 0017ffffc0000000 ffff8a513ffd4c98 ffffeee24b35ec08 0000000000000000\n  raw: 0000000000000000 0000000000000001 00000000ffffff7f 0000000000000000\n  page dumped because: nonzero mapcount\n  CPU: 0 PID: 15567 Comm: ganesha.nfsd Kdump: loaded Tainted: P    B      O      5.10.158-1.nutanix.20221209.el7.x86_64 #1\n  Hardware name: VMware, Inc. VMware Virtual Platform\/440BX Desktop Reference Platform, BIOS 6.00 04\/05\/2016\n  Call Trace:\n   dump_stack+0x74\/0x96\n   bad_page.cold+0x63\/0x94\n   check_new_page_bad+0x6d\/0x80\n   rmqueue+0x46e\/0x970\n   get_page_from_freelist+0xcb\/0x3f0\n   ? _cond_resched+0x19\/0x40\n   __alloc_pages_nodemask+0x164\/0x300\n   alloc_pages_current+0x87\/0xf0\n   skb_page_frag_refill+0x84\/0x110\n   ...\n\nSometimes, it would also show up as corruption in the free list pointer\nand cause crashes.\n\nAfter bisecting the issue, we found the issue started from commit\ne320d3012d25 (\"mm\/page_alloc.c: fix freeing non-compound pages\"):\n\n\tif (put_page_testzero(page))\n\t\tfree_the_page(page, order);\n\telse if (!PageHead(page))\n\t\twhile (order-- > 0)\n\t\t\tfree_the_page(page + (1 << order), order);\n\nSo the problem is the check PageHead is racy because at this point we\nalready dropped our reference to the page.  So even if we came in with\ncompound page, the page can already be freed and PageHead can return\nfalse and we will end up freeing all the tail pages causing double free."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: Repare la corrupción de la página causada por el control racy en __free_pages. Cuando actualizamos nuestro kernel, comenzamos a ver algunos daños en la página como los siguientes de manera consistente: ERROR: Estado incorrecto de la página en el proceso ganesha.nfsd pfn: 1304ca página:0000000022261c55 refcount:0 mapcount:-128 mapeo:0000000000000000 índice:0x0 pfn:0x1304ca banderas: 0x17ffffc0000000() raw: 0017ffffc0000000 ffff8a513ffd4c98 24b35ec08 0000000000000000 raw: 00000000000000000 0000000000000001 00000000ffffff7f 00000000000000000 página volcada porque: recuento de mapas distinto de cero CPU: 0 PID: 15567 Comm : ganesha.nfsd Kdump: cargado Contaminado: PBO 5.10.158-1.nutanix.20221209.el7.x86_64 #1 Nombre del hardware: VMware, Inc. Plataforma virtual VMware\/Plataforma de referencia de escritorio 440BX, BIOS 6.00 05\/04\/2016 Seguimiento de llamadas : dump_stack+0x74\/0x96 bad_page.cold+0x63\/0x94 check_new_page_bad+0x6d\/0x80 rmqueue+0x46e\/0x970 get_page_from_freelist+0xcb\/0x3f0 ? _cond_resched+0x19\/0x40 __alloc_pages_nodemask+0x164\/0x300 alloc_pages_current+0x87\/0xf0 skb_page_frag_refill+0x84\/0x110 ... A veces, también aparecería como corrupción en el puntero de la lista libre y provocaría fallos. Después de dividir el problema en dos, encontramos que el problema comenzó desde la confirmación e320d3012d25 (\"mm\/page_alloc.c: corrige la liberación de páginas no compuestas\"): if (put_page_testzero(page)) free_the_page(page, order); else if (!PageHead(página)) while (orden-- &gt; 0) free_the_page(página + (1 &lt;&lt; orden), orden); Entonces, el problema es que la verificación PageHead es picante porque en este punto ya eliminamos nuestra referencia a la página. Entonces, incluso si ingresamos con una página compuesta, la página ya se puede liberar y PageHead puede devolver falso y terminaremos liberando todas las páginas finales causando un double free."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0a626e27f984dfbe96bd8e4fd08f20a2ede3ea23","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3af734f3eac6f70ef8e272a80da40544b9d0f2b5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3b4c045a98f53a8890a94bb5846a390c8e39e673","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/462a8e08e0e6287e5ce13187257edbf24213ed03","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52740","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:13.900","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc\/64s\/interrupt: Fix interrupt exit race with security mitigation switch\n\nThe RFI and STF security mitigation options can flip the\ninterrupt_exit_not_reentrant static branch condition concurrently with\nthe interrupt exit code which tests that branch.\n\nInterrupt exit tests this condition to set MSR[EE|RI] for exit, then\nagain in the case a soft-masked interrupt is found pending, to recover\nthe MSR so the interrupt can be replayed before attempting to exit\nagain. If the condition changes between these two tests, the MSR and irq\nsoft-mask state will become corrupted, leading to warnings and possible\ncrashes. For example, if the branch is initially true then false,\nMSR[EE] will be 0 but PACA_IRQ_HARD_DIS clear and EE may not get\nenabled, leading to warnings in irq_64.c."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: powerpc\/64s\/interrupt: corrige la ejecución de salida de interrupción con un interruptor de mitigación de seguridad. Las opciones de mitigación de seguridad RFI y STF pueden invertir la condición de rama estática interrupt_exit_not_reentrant al mismo tiempo que el código de salida de interrupción que prueba esa rama. . La salida de interrupción prueba esta condición para configurar MSR[EE|RI] para la salida, luego nuevamente en el caso de que se encuentre pendiente una interrupción enmascarada, para recuperar el MSR para que la interrupción pueda reproducirse antes de intentar salir nuevamente. Si la condición cambia entre estas dos pruebas, el estado de la máscara suave MSR e irq se dañará, lo que generará advertencias y posibles fallas. Por ejemplo, si la rama es inicialmente verdadera y luego falsa, MSR[EE] será 0 pero PACA_IRQ_HARD_DIS estará clara y es posible que EE no se habilite, lo que generará advertencias en irq_64.c."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2ea31e2e62bbc4d11c411eeb36f1b02841dbcab1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6f097c24815e67909a1fcc2c605586d02babd673","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/86f7e423933608d536015a0f2eb9e0338c1227e0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52741","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.000","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix use-after-free in rdata->read_into_pages()\n\nWhen the network status is unstable, use-after-free may occur when\nread data from the server.\n\n  BUG: KASAN: use-after-free in readpages_fill_pages+0x14c\/0x7e0\n\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x38\/0x4c\n   print_report+0x16f\/0x4a6\n   kasan_report+0xb7\/0x130\n   readpages_fill_pages+0x14c\/0x7e0\n   cifs_readv_receive+0x46d\/0xa40\n   cifs_demultiplex_thread+0x121c\/0x1490\n   kthread+0x16b\/0x1a0\n   ret_from_fork+0x2c\/0x50\n   <\/TASK>\n\n  Allocated by task 2535:\n   kasan_save_stack+0x22\/0x50\n   kasan_set_track+0x25\/0x30\n   __kasan_kmalloc+0x82\/0x90\n   cifs_readdata_direct_alloc+0x2c\/0x110\n   cifs_readdata_alloc+0x2d\/0x60\n   cifs_readahead+0x393\/0xfe0\n   read_pages+0x12f\/0x470\n   page_cache_ra_unbounded+0x1b1\/0x240\n   filemap_get_pages+0x1c8\/0x9a0\n   filemap_read+0x1c0\/0x540\n   cifs_strict_readv+0x21b\/0x240\n   vfs_read+0x395\/0x4b0\n   ksys_read+0xb8\/0x150\n   do_syscall_64+0x3f\/0x90\n   entry_SYSCALL_64_after_hwframe+0x72\/0xdc\n\n  Freed by task 79:\n   kasan_save_stack+0x22\/0x50\n   kasan_set_track+0x25\/0x30\n   kasan_save_free_info+0x2e\/0x50\n   __kasan_slab_free+0x10e\/0x1a0\n   __kmem_cache_free+0x7a\/0x1a0\n   cifs_readdata_release+0x49\/0x60\n   process_one_work+0x46c\/0x760\n   worker_thread+0x2a4\/0x6f0\n   kthread+0x16b\/0x1a0\n   ret_from_fork+0x2c\/0x50\n\n  Last potentially related work creation:\n   kasan_save_stack+0x22\/0x50\n   __kasan_record_aux_stack+0x95\/0xb0\n   insert_work+0x2b\/0x130\n   __queue_work+0x1fe\/0x660\n   queue_work_on+0x4b\/0x60\n   smb2_readv_callback+0x396\/0x800\n   cifs_abort_connection+0x474\/0x6a0\n   cifs_reconnect+0x5cb\/0xa50\n   cifs_readv_from_socket.cold+0x22\/0x6c\n   cifs_read_page_from_socket+0xc1\/0x100\n   readpages_fill_pages.cold+0x2f\/0x46\n   cifs_readv_receive+0x46d\/0xa40\n   cifs_demultiplex_thread+0x121c\/0x1490\n   kthread+0x16b\/0x1a0\n   ret_from_fork+0x2c\/0x50\n\nThe following function calls will cause UAF of the rdata pointer.\n\nreadpages_fill_pages\n cifs_read_page_from_socket\n  cifs_readv_from_socket\n   cifs_reconnect\n    __cifs_reconnect\n     cifs_abort_connection\n      mid->callback() --> smb2_readv_callback\n       queue_work(&rdata->work)  # if the worker completes first,\n                                 # the rdata is freed\n          cifs_readv_complete\n            kref_put\n              cifs_readdata_release\n                kfree(rdata)\n return rdata->...               # UAF in readpages_fill_pages()\n\nSimilarly, this problem also occurs in the uncache_fill_pages().\n\nFix this by adjusts the order of condition judgment in the return\nstatement."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: cifs: corrige el use after free en rdata-&gt;read_into_pages(). Cuando el estado de la red es inestable, puede ocurrir el use after free al leer datos del servidor. BUG: KASAN: use after free en readpages_fill_pages+0x14c\/0x7e0 Seguimiento de llamadas:  dump_stack_lvl+0x38\/0x4c print_report+0x16f\/0x4a6 kasan_report+0xb7\/0x130 readpages_fill_pages+0x14c\/0x7e0 cifs_readv_receive+0x 46d\/0xa40 cifs_demultiplex_thread+0x121c\/ 0x1490 kthread+0x16b\/0x1a0 ret_from_fork+0x2c\/0x50  Asignado por tarea 2535: kasan_save_stack+0x22\/0x50 kasan_set_track+0x25\/0x30 __kasan_kmalloc+0x82\/0x90 cifs_readdata_direct_alloc+0x2c \/0x110 cifs_readdata_alloc+0x2d\/0x60 cifs_readahead+0x393\/0xfe0 read_pages+0x12f\/0x470 page_cache_ra_unbounded+0x1b1\/0x240 filemap_get_pages+0x1c8\/0x9a0 filemap_read+0x1c0\/0x540 cifs_strict_readv+0x21b\/0x240 vfs_read+0x395\/0x4b0 ksys_read+0xb8\/0 x150 do_syscall_64+0x3f\/0x90 Entry_SYSCALL_64_after_hwframe+0x72\/0xdc Liberado por la tarea 79: kasan_save_stack+0x22\/0x50 kasan_set_track+0x25\/0x30 kasan_save_free_info+0x2e\/0x50 __kasan_slab_free+0x10e\/0x1a0 __kmem_cache_free+0x7a\/0x1a0 cifs_readdata_release+0x49\/0x60 Process_one_work+0x46c \/0x760 worker_thread+0x2a4\/0x6f0 kthread+0x16b\/0x1a0 ret_from_fork+0x2c\/0x50 Última creación de trabajo potencialmente relacionado: kasan_save_stack+0x22\/0x50 __kasan_record_aux_stack+0x95\/0xb0 insert_work+0x2b\/0x130 __queue_work+0x1fe\/0x660 queue_work_on+0x4b\/0x60 smb2_readv_callback+0x396\/0x800 ion+0x474\/0x6a0 cifs_reconnect+0x5cb\/0xa50 cifs_readv_from_socket.cold+ 0x22\/0x6c cifs_read_page_from_socket+0xc1\/0x100 readpages_fill_pages.cold+0x2f\/0x46 cifs_readv_receive+0x46d\/0xa40 cifs_demultiplex_thread+0x121c\/0x1490 kthread+0x16b\/0x1a0 x2c\/0x50 Las siguientes llamadas a funciones causarán UAF del puntero rdata. readpages_fill_pages cifs_read_page_from_socket cifs_readv_from_socket cifs_reconnect __cifs_reconnect cifs_abort_connection mid-&gt;callback() --&gt; smb2_readv_callback queue_work(&amp;rdata-&gt;work) # si el trabajador completa primero, # los rdata se liberan cifs_readv_complete kref_put cifs_readdata_release kfree( rdata) devolver rdata-&gt;... # UAF en readpages_fill_pages() De manera similar, este problema también ocurre en uncache_fill_pages(). Solucione este problema ajustando el orden del juicio de condición en la declaración de devolución."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2b693fe3f760c87fd9768e759f6297f743a1b3b0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3684a2f6affa1ca52a5d4a12f04d0652efdee65e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aa5465aeca3c66fecdf7efcf554aed79b4c4b211","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d1fba1e096ffc7ec11df863a97c50203c47315b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52742","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.080","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: USB: Fix wrong-direction WARNING in plusb.c\n\nThe syzbot fuzzer detected a bug in the plusb network driver: A\nzero-length control-OUT transfer was treated as a read instead of a\nwrite.  In modern kernels this error provokes a WARNING:\n\nusb 1-1: BOGUS control dir, pipe 80000280 doesn't match bRequestType c0\nWARNING: CPU: 0 PID: 4645 at drivers\/usb\/core\/urb.c:411\nusb_submit_urb+0x14a7\/0x1880 drivers\/usb\/core\/urb.c:411\nModules linked in:\nCPU: 1 PID: 4645 Comm: dhcpcd Not tainted\n6.2.0-rc6-syzkaller-00050-g9f266ccaa2f5 #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google\n01\/12\/2023\nRIP: 0010:usb_submit_urb+0x14a7\/0x1880 drivers\/usb\/core\/urb.c:411\n...\nCall Trace:\n <TASK>\n usb_start_wait_urb+0x101\/0x4b0 drivers\/usb\/core\/message.c:58\n usb_internal_control_msg drivers\/usb\/core\/message.c:102 [inline]\n usb_control_msg+0x320\/0x4a0 drivers\/usb\/core\/message.c:153\n __usbnet_read_cmd+0xb9\/0x390 drivers\/net\/usb\/usbnet.c:2010\n usbnet_read_cmd+0x96\/0xf0 drivers\/net\/usb\/usbnet.c:2068\n pl_vendor_req drivers\/net\/usb\/plusb.c:60 [inline]\n pl_set_QuickLink_features drivers\/net\/usb\/plusb.c:75 [inline]\n pl_reset+0x2f\/0xf0 drivers\/net\/usb\/plusb.c:85\n usbnet_open+0xcc\/0x5d0 drivers\/net\/usb\/usbnet.c:889\n __dev_open+0x297\/0x4d0 net\/core\/dev.c:1417\n __dev_change_flags+0x587\/0x750 net\/core\/dev.c:8530\n dev_change_flags+0x97\/0x170 net\/core\/dev.c:8602\n devinet_ioctl+0x15a2\/0x1d70 net\/ipv4\/devinet.c:1147\n inet_ioctl+0x33f\/0x380 net\/ipv4\/af_inet.c:979\n sock_do_ioctl+0xcc\/0x230 net\/socket.c:1169\n sock_ioctl+0x1f8\/0x680 net\/socket.c:1286\n vfs_ioctl fs\/ioctl.c:51 [inline]\n __do_sys_ioctl fs\/ioctl.c:870 [inline]\n __se_sys_ioctl fs\/ioctl.c:856 [inline]\n __x64_sys_ioctl+0x197\/0x210 fs\/ioctl.c:856\n do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n do_syscall_64+0x39\/0xb0 arch\/x86\/entry\/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63\/0xcd\n\nThe fix is to call usbnet_write_cmd() instead of usbnet_read_cmd() and\nremove the USB_DIR_IN flag."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: net: USB: corrija la dirección incorrecta ADVERTENCIA en plusb.c. El syzbot fuzzer detectó un error en el controlador de red plusb: una transferencia de control de salida de longitud cero se trató como una lectura en lugar de escribir. En los kernels modernos, este error provoca una ADVERTENCIA: usb 1-1: directorio de control BOGUS, la tubería 80000280 no coincide con bRequestType c0 ADVERTENCIA: CPU: 0 PID: 4645 en drivers\/usb\/core\/urb.c:411 usb_submit_urb+0x14a7\/ 0x1880 drivers\/usb\/core\/urb.c:411 Módulos vinculados en: CPU: 1 PID: 4645 Comm: dhcpcd Not tainted 6.2.0-rc6-syzkaller-00050-g9f266ccaa2f5 #0 Nombre del hardware: Google Google Compute Engine\/Google Compute Motor, BIOS Google 12\/01\/2023 RIP: 0010:usb_submit_urb+0x14a7\/0x1880 drivers\/usb\/core\/urb.c:411... Seguimiento de llamadas:  usb_start_wait_urb+0x101\/0x4b0 drivers\/usb\/core\/message .c:58 controladores usb_internal_control_msg\/usb\/core\/message.c:102 [en línea] usb_control_msg+0x320\/0x4a0 controladores\/usb\/core\/message.c:153 __usbnet_read_cmd+0xb9\/0x390 controladores\/net\/usb\/usbnet.c: 2010 usbnet_read_cmd+0x96\/0xf0 drivers\/net\/usb\/usbnet.c:2068 pl_vendor_req drivers\/net\/usb\/plusb.c:60 [en línea] pl_set_QuickLink_features drivers\/net\/usb\/plusb.c:75 [en línea] pl_reset+0x2f \/0xf0 drivers\/net\/usb\/plusb.c:85 usbnet_open+0xcc\/0x5d0 drivers\/net\/usb\/usbnet.c:889 __dev_open+0x297\/0x4d0 net\/core\/dev.c:1417 __dev_change_flags+0x587\/0x750 net\/ core\/dev.c:8530 dev_change_flags+0x97\/0x170 net\/core\/dev.c:8602 devinet_ioctl+0x15a2\/0x1d70 net\/ipv4\/devinet.c:1147 inet_ioctl+0x33f\/0x380 net\/ipv4\/af_inet.c:979 sock_do_ioctl +0xcc\/0x230 net\/socket.c:1169 sock_ioctl+0x1f8\/0x680 net\/socket.c:1286 vfs_ioctl fs\/ioctl.c:51 [en línea] __do_sys_ioctl fs\/ioctl.c:870 [en línea] __se_sys_ioctl fs\/ioctl. c:856 [en línea] __x64_sys_ioctl+0x197\/0x210 fs\/ioctl.c:856 do_syscall_x64 arch\/x86\/entry\/common.c:50 [en línea] do_syscall_64+0x39\/0xb0 arch\/x86\/entry\/common.c:80 Entry_SYSCALL_64_after_h marco w +0x63\/0xcd La solución es llamar a usbnet_write_cmd() en lugar de usbnet_read_cmd() y eliminar el indicador USB_DIR_IN."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0d2cf3fae701646061e295815bb7588d2f3671cc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1be271c52bf3554edcb8d124d1f8c7f777ee5727","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/25141fb4119112f4ebf8f00cf52014abbc8020b1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/43379fcacea2dcee35d02efc9c8fe97807a503c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6f69307f625904feed189008381fd83bd1a35b63","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/811d581194f7412eda97acc03d17fc77824b561f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f0ad46ef772438c0596df370450d8bdc8a12dbfb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52743","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.157","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nice: Do not use WQ_MEM_RECLAIM flag for workqueue\n\nWhen both ice and the irdma driver are loaded, a warning in\ncheck_flush_dependency is being triggered. This is due to ice driver\nworkqueue being allocated with the WQ_MEM_RECLAIM flag and the irdma one\nis not.\n\nAccording to kernel documentation, this flag should be set if the\nworkqueue will be involved in the kernel's memory reclamation flow.\nSince it is not, there is no need for the ice driver's WQ to have this\nflag set so remove it.\n\nExample trace:\n\n[  +0.000004] workqueue: WQ_MEM_RECLAIM ice:ice_service_task [ice] is flushing !WQ_MEM_RECLAIM infiniband:0x0\n[  +0.000139] WARNING: CPU: 0 PID: 728 at kernel\/workqueue.c:2632 check_flush_dependency+0x178\/0x1a0\n[  +0.000011] Modules linked in: bonding tls xt_CHECKSUM xt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_cha\nin_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink bridge stp llc rfkill vfat fat intel_rapl_msr intel\n_rapl_common isst_if_common skx_edac nfit libnvdimm x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm irqbypass crct1\n0dif_pclmul crc32_pclmul ghash_clmulni_intel rapl intel_cstate rpcrdma sunrpc rdma_ucm ib_srpt ib_isert iscsi_target_mod target_\ncore_mod ib_iser libiscsi scsi_transport_iscsi rdma_cm ib_cm iw_cm iTCO_wdt iTCO_vendor_support ipmi_ssif irdma mei_me ib_uverbs\nib_core intel_uncore joydev pcspkr i2c_i801 acpi_ipmi mei lpc_ich i2c_smbus intel_pch_thermal ioatdma ipmi_si acpi_power_meter\nacpi_pad xfs libcrc32c sd_mod t10_pi crc64_rocksoft crc64 sg ahci ixgbe libahci ice i40e igb crc32c_intel mdio i2c_algo_bit liba\nta dca wmi dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler fuse\n[  +0.000161]  [last unloaded: bonding]\n[  +0.000006] CPU: 0 PID: 728 Comm: kworker\/0:2 Tainted: G S                 6.2.0-rc2_next-queue-13jan-00458-gc20aabd57164 #1\n[  +0.000006] Hardware name: Intel Corporation S2600WFT\/S2600WFT, BIOS SE5C620.86B.02.01.0010.010620200716 01\/06\/2020\n[  +0.000003] Workqueue: ice ice_service_task [ice]\n[  +0.000127] RIP: 0010:check_flush_dependency+0x178\/0x1a0\n[  +0.000005] Code: 89 8e 02 01 e8 49 3d 40 00 49 8b 55 18 48 8d 8d d0 00 00 00 48 8d b3 d0 00 00 00 4d 89 e0 48 c7 c7 e0 3b 08\n9f e8 bb d3 07 01 <0f> 0b e9 be fe ff ff 80 3d 24 89 8e 02 00 0f 85 6b ff ff ff e9 06\n[  +0.000004] RSP: 0018:ffff88810a39f990 EFLAGS: 00010282\n[  +0.000005] RAX: 0000000000000000 RBX: ffff888141bc2400 RCX: 0000000000000000\n[  +0.000004] RDX: 0000000000000001 RSI: dffffc0000000000 RDI: ffffffffa1213a80\n[  +0.000003] RBP: ffff888194bf3400 R08: ffffed117b306112 R09: ffffed117b306112\n[  +0.000003] R10: ffff888bd983088b R11: ffffed117b306111 R12: 0000000000000000\n[  +0.000003] R13: ffff888111f84d00 R14: ffff88810a3943ac R15: ffff888194bf3400\n[  +0.000004] FS:  0000000000000000(0000) GS:ffff888bd9800000(0000) knlGS:0000000000000000\n[  +0.000003] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  +0.000003] CR2: 000056035b208b60 CR3: 000000017795e005 CR4: 00000000007706f0\n[  +0.000003] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  +0.000003] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  +0.000002] PKRU: 55555554\n[  +0.000003] Call Trace:\n[  +0.000002]  <TASK>\n[  +0.000003]  __flush_workqueue+0x203\/0x840\n[  +0.000006]  ? mutex_unlock+0x84\/0xd0\n[  +0.000008]  ? __pfx_mutex_unlock+0x10\/0x10\n[  +0.000004]  ? __pfx___flush_workqueue+0x10\/0x10\n[  +0.000006]  ? mutex_lock+0xa3\/0xf0\n[  +0.000005]  ib_cache_cleanup_one+0x39\/0x190 [ib_core]\n[  +0.000174]  __ib_unregister_device+0x84\/0xf0 [ib_core]\n[  +0.000094]  ib_unregister_device+0x25\/0x30 [ib_core]\n[  +0.000093]  irdma_ib_unregister_device+0x97\/0xc0 [irdma]\n[  +0.000064]  ? __pfx_irdma_ib_unregister_device+0x10\/0x10 [irdma]\n[  +0.000059]  ? up_write+0x5c\/0x90\n[  +0.000005]  irdma_remove+0x36\/0x90 [irdma]\n[  +0.000062]  auxiliary_bus_remove+0x32\/0x50\n[  +0.000007]  device_r\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ice: no utilice el indicador WQ_MEM_RECLAIM para la cola de trabajo. Cuando se cargan ice y el controlador irdma, se activa una advertencia en check_flush_dependency. Esto se debe a que la cola de trabajo del controlador de hielo está asignada con el indicador WQ_MEM_RECLAIM y el de irdma no. Según la documentación del kernel, este indicador debe establecerse si la cola de trabajo participará en el flujo de recuperación de memoria del kernel. Como no es así, no es necesario que el WQ del conductor de hielo tenga esta bandera configurada, así que elimínela. Seguimiento de ejemplo: [+0.000004] cola de trabajo: WQ_MEM_RECLAIM ice:ice_service_task [ice] se está vaciando! WQ_MEM_RECLAIM infiniband:0x0 [+0.000139] ADVERTENCIA: CPU: 0 PID: 728 en kernel\/workqueue.c:2632 check_flush_dependency+0x178\/0x1a0 [ + 0.000011] Módulos vinculados en: vinculación tls xt_CHECKSUM xt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_cha in_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink bridge stp llc fkill vfat fat intel_rapl_msr intel _rapl_common isst_if_common skx_edac nfit libnvdimm x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm irqbypass crct1 0dif_pclmul crc32_pclmul ghash_clmulni_intel rapl intel_cstate rpcrdma sunrpc ucm ib_srpt ib_isert iscsi_target_mod target_ core_mod ib_iser libiscsi scsi_transport_iscsi rdma_cm ib_cm iw_cm iTCO_wdt iTCO_vendor_support ipmi_ssif irdma mei_me ib_uverbs ib_core intel_uncore joydev pcspkr i2c_i801 acpi_ipmi mei lpc_ich i2c_smbus intel_pch_thermal ioatdma ipmi_si acpi_power_meter acpi_pad xfs libcrc32c sd_mod t10_pi crc64_rocksoft crc64 sg ahci ixgbe libahci ice i40e igb crc32c_intel mdio i2c_algo_bit liba ta dca wmi dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler fuse [+0.000161] [última descarga: unión] [+0.000006] CPU: 0 PID: 728 Comm: kworker\/0:2 Contaminado: GS 6.2.0-rc2_next-queue-13jan-0045 8- gc20aabd57164 #1 [ +0.000006] Nombre del hardware: Intel Corporation S2600WFT\/S2600WFT, BIOS SE5C620.86B.02.01.0010.010620200716 06\/01\/2020 [ +0.000003] Cola de trabajo: ice ice_service_task [ice] [ +0.00 0127] RIP: 0010:check_flush_dependency+ 0x178\/0x1a0 [ +0.000005] Código: 89 8e 02 01 e8 49 3d 40 00 49 8b 55 18 48 8d 8d d0 00 00 00 48 8d b3 d0 00 00 00 4d 89 e0 48 c7 c7 e0 3b 08 9f e8 bb d3 07 01 &lt;0f&gt; 0b e9 be fe ff ff 80 3d 24 89 8e 02 00 0f 85 6b ff ff ff e9 06 [ +0.000004] RSP: 0018:ffff88810a39f990 EFLAGS: 00010282 [ +0.000005] RAX: 000000000000000 RBX: ffff888141bc2400 RCX: 0000000000000000 [ +0.000004] RDX: 0000000000000001 RSI: dffffc0000000000 RDI: ffffffffa1213a80 [ +0.000003] RBP: ffff888194bf3400 R08: fffffed117b306112 R09: 306112 [ +0.000003] R10: ffff888bd983088b R11: ffffed117b306111 R12: 0000000000000000 [ +0.000003] R13: ffff888111f84d00 R14: 15 : ffff888194bf3400 [ +0.000004] FS: 0000000000000000(0000) GS:ffff888bd9800000(0000) knlGS:00000000000000000 [ +0.000003] CS: 0010 DS: 0000 0000 CR0: 0000000080050033 [+0.000003] CR2: 000056035b208b60 CR3: 000000017795e005 CR4: 00000000007706f0 [ +0.000003] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ +0.000003] DR3: 00000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ +0.000002] PKRU: 55555554 [ +0.000003] Seguimiento de llamadas: [ +0.000002]  [ +0.000003 ] __flush_workqueue+0x203\/0x840 [ +0.000006] ? mutex_unlock+0x84\/0xd0 [+0.000008]? __pfx_mutex_unlock+0x10\/0x10 [+0.000004]? __pfx___flush_workqueue+0x10\/0x10 [+0.000006]? mutex_lock+0xa3\/0xf0 [ +0.000005] ib_cache_cleanup_one+0x39\/0x190 [ib_core] [ +0.000174] __ib_unregister_device+0x84\/0xf0 [ib_core] [ +0.000094] ib_unregister_device+0x25\/0x30 [ib_core] [ + 0.000093] irdma_ib_unregister_device+0x97\/0xc0 [irdma] [ +0.000064] ? __pfx_irdma_ib_unregister_device+0x10\/0x10 [irdma] [ +0.000059] ? up_write+0x5c\/0x90 [ +0.000005] irdma_remove+0x36\/0x90 [irdma] [ +0.000062] auxiliar_bus_remove+0x32\/0x50 [ +0.000007] dispositivo_r ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1ad4112c9fcf0bc08222b2b1614fba52ffd12255","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4d159f7884f78b1aacb99b4fc37d1e3cb1194e39","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/87a5e3fc8416106e290c448fc8a6dd50ab24c634","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca834a017851c50464c25a85f3cb2daefff7bede","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df59e05401450973c8c7e96fd74b49e24442dc1f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52744","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.230","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA\/irdma: Fix potential NULL-ptr-dereference\n\nin_dev_get() can return NULL which will cause a failure once idev is\ndereferenced in in_dev_for_each_ifa_rtnl(). This patch adds a\ncheck for NULL value in idev beforehand.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: RDMA\/irdma: se corrige una posible referencia NULL-ptr-dereference in_dev_get() que puede devolver NULL, lo que provocará una falla una vez que se elimine la referencia a idev en in_dev_for_each_ifa_rtnl(). Este parche agrega una verificación previa del valor NULL en idev. Encontrado por el Centro de verificación de Linux (linuxtesting.org) con SVACE."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/360682fe7df262d94fae54f737c487bec0f9190d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5d9745cead1f121974322b94ceadfb4d1e67960e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f5fe1cd8e6a97f94840b55f59ed08cbc397086f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52745","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.303","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nIB\/IPoIB: Fix legacy IPoIB due to wrong number of queues\n\nThe cited commit creates child PKEY interfaces over netlink will\nmultiple tx and rx queues, but some devices doesn't support more than 1\ntx and 1 rx queues. This causes to a crash when traffic is sent over the\nPKEY interface due to the parent having a single queue but the child\nhaving multiple queues.\n\nThis patch fixes the number of queues to 1 for legacy IPoIB at the\nearliest possible point in time.\n\nBUG: kernel NULL pointer dereference, address: 000000000000036b\nPGD 0 P4D 0\nOops: 0000 [#1] SMP\nCPU: 4 PID: 209665 Comm: python3 Not tainted 6.1.0_for_upstream_min_debug_2022_12_12_17_02 #1\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04\/01\/2014\nRIP: 0010:kmem_cache_alloc+0xcb\/0x450\nCode: ce 7e 49 8b 50 08 49 83 78 10 00 4d 8b 28 0f 84 cb 02 00 00 4d 85 ed 0f 84 c2 02 00 00 41 8b 44 24 28 48 8d 4a\n01 49 8b 3c 24 <49> 8b 5c 05 00 4c 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 74 b8 41 8b\nRSP: 0018:ffff88822acbbab8 EFLAGS: 00010202\nRAX: 0000000000000070 RBX: ffff8881c28e3e00 RCX: 00000000064f8dae\nRDX: 00000000064f8dad RSI: 0000000000000a20 RDI: 0000000000030d00\nRBP: 0000000000000a20 R08: ffff8882f5d30d00 R09: ffff888104032f40\nR10: ffff88810fade828 R11: 736f6d6570736575 R12: ffff88810081c000\nR13: 00000000000002fb R14: ffffffff817fc865 R15: 0000000000000000\nFS:  00007f9324ff9700(0000) GS:ffff8882f5d00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000000000036b CR3: 00000001125af004 CR4: 0000000000370ea0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n skb_clone+0x55\/0xd0\n ip6_finish_output2+0x3fe\/0x690\n ip6_finish_output+0xfa\/0x310\n ip6_send_skb+0x1e\/0x60\n udp_v6_send_skb+0x1e5\/0x420\n udpv6_sendmsg+0xb3c\/0xe60\n ? ip_mc_finish_output+0x180\/0x180\n ? __switch_to_asm+0x3a\/0x60\n ? __switch_to_asm+0x34\/0x60\n sock_sendmsg+0x33\/0x40\n __sys_sendto+0x103\/0x160\n ? _copy_to_user+0x21\/0x30\n ? kvm_clock_get_cycles+0xd\/0x10\n ? ktime_get_ts64+0x49\/0xe0\n __x64_sys_sendto+0x25\/0x30\n do_syscall_64+0x3d\/0x90\n entry_SYSCALL_64_after_hwframe+0x46\/0xb0\nRIP: 0033:0x7f9374f1ed14\nCode: 42 41 f8 ff 44 8b 4c 24 2c 4c 8b 44 24 20 89 c5 44 8b 54 24 28 48 8b 54 24 18 b8 2c 00 00 00 48 8b 74 24 10 8b\n7c 24 08 0f 05 <48> 3d 00 f0 ff ff 77 34 89 ef 48 89 44 24 08 e8 68 41 f8 ff 48 8b\nRSP: 002b:00007f9324ff7bd0 EFLAGS: 00000293 ORIG_RAX: 000000000000002c\nRAX: ffffffffffffffda RBX: 00007f9324ff7cc8 RCX: 00007f9374f1ed14\nRDX: 00000000000002fb RSI: 00007f93000052f0 RDI: 0000000000000030\nRBP: 0000000000000000 R08: 00007f9324ff7d40 R09: 000000000000001c\nR10: 0000000000000000 R11: 0000000000000293 R12: 0000000000000000\nR13: 000000012a05f200 R14: 0000000000000001 R15: 00007f9374d57bdc\n <\/TASK>"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: IB\/IPoIB: corrige el IPoIB heredado debido a un número incorrecto de colas. La confirmación citada crea interfaces PKEY secundarias a través de netlink y tendrá múltiples colas de transmisión y recepción, pero algunos dispositivos no admiten más de Colas 1 tx y 1 rx. Esto provoca un bloqueo cuando el tráfico se envía a través de la interfaz PKEY debido a que el padre tiene una sola cola pero el hijo tiene varias colas. Este parche fija el número de colas en 1 para IPoIB heredado lo antes posible. ERROR: desreferencia del puntero NULL del kernel, dirección: 000000000000036b PGD 0 P4D 0 Ups: 0000 [#1] SMP CPU: 4 PID: 209665 Comm: python3 Not tainted 6.1.0_for_upstream_min_debug_2022_12_12_17_02 #1 Nombre de hardware: PC estándar (Q35 + ICH9, 2009 ), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 01\/04\/2014 RIP: 0010:kmem_cache_alloc+0xcb\/0x450 Código: ce 7e 49 8b 50 08 49 83 78 10 00 4d 8b 28 0f 84 cb 02 00 00 4d 85 ed 0f 84 c2 02 00 00 41 8b 44 24 28 48 8d 4a 01 49 8b 3c 24 &lt;49&gt; 8b 5c 05 00 4c 89 e8 65 48 0f c7 0f 0f 94 c0 4 c0 74 b8 41 8b RSP: 0018:ffff88822acbbab8 EFLAGS: 00010202 RAX: 0000000000000070 RBX: ffff8881c28e3e00 RCX: 00000000064f8dae RDX: 00000000064f8dad RSI: 00000a20 RDI: 0000000000030d00 RBP: 0000000000000a20 R08: ffff8882f5d30d00 R09: ffff888104032f40 R10: ffff88810fade828 R11: 736f6d6570736575 R12: ffff88810081c000 R13: 00000000000002fb R14: ffffffff817fc865 R15: 0000000000000000 FS: 00007f9324ff9700(0000) GS:ffff8882f5d00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0050033 CR2: 000000000000036b CR3: 00000001125af004 CR4: 0000000000370ea0 DR0: 00000000000000000 DR1: 00000000000000000 DR2: 0000000000000000 0DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Seguimiento de llamadas:  skb_clone+0x55\/0xd0 ip6_finish_output2+0x3fe\/0x690 ip6_finish_output+0xfa\/0x310 _skb+0x1e\/0x60 udp_v6_send_skb+0x1e5\/0x420 udpv6_sendmsg+0xb3c\/0xe60 ? ip_mc_finish_output+0x180\/0x180? __switch_to_asm+0x3a\/0x60? __switch_to_asm+0x34\/0x60 sock_sendmsg+0x33\/0x40 __sys_sendto+0x103\/0x160 ? _copy_to_user+0x21\/0x30 ? kvm_clock_get_cycles+0xd\/0x10? ktime_get_ts64+0x49\/0xe0 __x64_sys_sendto+0x25\/0x30 do_syscall_64+0x3d\/0x90 Entry_SYSCALL_64_after_hwframe+0x46\/0xb0 RIP: 0033:0x7f9374f1ed14 Código: 42 41 f8 ff 44 8b 4c 24 2c 4c 8b 44 24 20 89 c5 44 8b 54 24 28 48 8b 54 24 18 b8 2c 00 00 00 48 8b 74 24 10 8b 7c 24 08 0f 05 &lt;48&gt; 3d 00 f0 ff ff 77 34 89 ef 48 89 44 24 08 e8 68 41 f8 ff 48 8b RSP 002 b:00007f9324ff7bd0 EFLAGS: 00000293 ORIG_RAX: 000000000000002c RAX: ffffffffffffffda RBX: 00007f9324ff7cc8 RCX: 00007f9374f1ed14 RDX: 00000000000002fb RSI: 00007f93000052f0 RDI: 0000000000000030 RBP: 0000000000000000 R08: 00007f9324ff7d40 R09: 000000000000001c R10: 0000000000000000 R11: 00000000000000293 R 12: 0000000000000000 R13: 000000012a05f200 R14: 0000000000000001 R15: 00007f9374d57bdc &lt; \/TAREA&gt;"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1b4ef90cbcfa603b3bb536fbd6f261197012b6f6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4a779187db39b2f32d048a752573e56e4e77807f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7197460dcd43ff0e4a502ba855dd82d37c2848cc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b1afb666c32931667c15ad1b58e7203f0119dcaf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e632291a2dbce45a24cddeb5fe28fe71d724ba43","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52746","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.377","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nxfrm\/compat: prevent potential spectre v1 gadget in xfrm_xlate32_attr()\n\n  int type = nla_type(nla);\n\n  if (type > XFRMA_MAX) {\n            return -EOPNOTSUPP;\n  }\n\n@type is then used as an array index and can be used\nas a Spectre v1 gadget.\n\n  if (nla_len(nla) < compat_policy[type].len) {\n\narray_index_nospec() can be used to prevent leaking\ncontent of kernel memory to malicious users."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: xfrm\/compat: previene el posible gadget spectre v1 en xfrm_xlate32_attr() int type = nla_type(nla); if (tipo &gt; XFRMA_MAX) { return -EOPNOTSUPP; } @type luego se usa como índice de matriz y se puede usar como un gadget Spectre v1. if (nla_len(nla) &lt; compat_policy[type].len) { array_index_nospec() se puede utilizar para evitar la filtración de contenido de la memoria del kernel a usuarios malintencionados."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/419674224390fca298020fc0751a20812f84b12d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5dc688fae6b7be9dbbf5304a3d2520d038e06db5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a893cc644812728e86e9aff517fd5698812ecef0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b6ee896385380aa621102e8ea402ba12db1cabff","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52747","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.443","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nIB\/hfi1: Restore allocated resources on failed copyout\n\nFix a resource leak if an error occurs."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: IB\/hfi1: restaurar los recursos asignados en caso de copia fallida. Reparar una fuga de recursos si se produce un error."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/00d9e212b8a39e6ffcf31b9d2e503d2bf6009d45","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0a4f811f2e5d07bbd0c9226f4afb0a1270a831ae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6601fc0d15ffc20654e39486f9bef35567106d68","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7896accedf5bf1277d2f305718e36dc8bac7e321","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/79b595d9591426156a9e0635a5b5115508a36fef","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9bae58d58b6bb73b572356b31a62d2afc7378d12","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52748","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.517","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: avoid format-overflow warning\n\nWith gcc and W=1 option, there's a warning like this:\n\nfs\/f2fs\/compress.c: In function ‘f2fs_init_page_array_cache’:\nfs\/f2fs\/compress.c:1984:47: error: ‘%u’ directive writing between\n1 and 7 bytes into a region of size between 5 and 8\n[-Werror=format-overflow=]\n 1984 |  sprintf(slab_name, \"f2fs_page_array_entry-%u:%u\", MAJOR(dev),\n\t\tMINOR(dev));\n      |                                               ^~\n\nString \"f2fs_page_array_entry-%u:%u\" can up to 35. The first \"%u\" can up\nto 4 and the second \"%u\" can up to 7, so total size is \"24 + 4 + 7 = 35\".\nslab_name's size should be 35 rather than 32."},{"lang":"es","value":"En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: f2fs: evitar aviso de desbordamiento de formato. Con la opción gcc y W=1, aparece un aviso como este: fs\/f2fs\/compress.c: En la función 'f2fs_init_page_array_cache': fs\/f2fs \/compress.c:1984:47: error: directiva '%u' escribiendo entre 1 y 7 bytes en una región de tamaño entre 5 y 8 [-Werror=format-overflow=] 1984 | sprintf(slab_name, \"f2fs_page_array_entry-%u:%u\", MAJOR(dev), MINOR(dev)); | ^~ La cadena \"f2fs_page_array_entry-%u:%u\" puede tener hasta 35. El primer \"%u\" puede tener hasta 4 y el segundo \"%u\" puede hasta 7, por lo que el tamaño total es \"24 + 4 + 7 = 35\". El tamaño de slab_name debe ser 35 en lugar de 32."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3eebe636cac53886bd5d1cdd55e082ec9e84983f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/526dd7540a09ecf87b5f54f3ab4e0a2528f25a79","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6fca08fd3085253b48fcb1bd243a0a5e18821a00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c041f5ddef00c731c541e00bc8ae97b8c84c682f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e0d4e8acb3789c5a8651061fbab62ca24a45c063","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e4088d7d8f1123006d46a42edf51b8c960a58ef9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52749","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.587","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nspi: Fix null dereference on suspend\n\nA race condition exists where a synchronous (noqueue) transfer can be\nactive during a system suspend. This can cause a null pointer\ndereference exception to occur when the system resumes.\n\nExample order of events leading to the exception:\n1. spi_sync() calls __spi_transfer_message_noqueue() which sets\n   ctlr->cur_msg\n2. Spi transfer begins via spi_transfer_one_message()\n3. System is suspended interrupting the transfer context\n4. System is resumed\n6. spi_controller_resume() calls spi_start_queue() which resets cur_msg\n   to NULL\n7. Spi transfer context resumes and spi_finalize_current_message() is\n   called which dereferences cur_msg (which is now NULL)\n\nWait for synchronous transfers to complete before suspending by\nacquiring the bus mutex and setting\/checking a suspend flag."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: spi: corrige la desreferencia nula en suspensión. Existe una condición de ejecución donde una transferencia sincrónica (sin cola) puede estar activa durante una suspensión del sistema. Esto puede provocar que se produzca una excepción de desreferencia de puntero null cuando se reanude el sistema. Ejemplo de orden de eventos que conducen a la excepción: 1. spi_sync() llama a __spi_transfer_message_noqueue() que configura ctlr-&gt;cur_msg 2. La transferencia Spi comienza a través de spi_transfer_one_message() 3. El sistema se suspende interrumpiendo el contexto de transferencia 4. El sistema se reanuda 6. spi_controller_resume () llama a spi_start_queue(), lo que restablece cur_msg a NULL 7. El contexto de transferencia de Spi se reanuda y se llama a spi_finalize_current_message(), lo que desreferencia cur_msg (que ahora es NULL) Espere a que se completen las transferencias sincrónicas antes de suspender adquiriendo el mutex del bus y configurando\/verificando una bandera suspendida."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4ec4508db97502a12daee88c74782e8d35ced068","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/96474ea47dc67b0704392d59192b233c8197db0e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bef4a48f4ef798c4feddf045d49e53c8a97d5e37","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52750","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.687","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\narm64: Restrict CPU_BIG_ENDIAN to GNU as or LLVM IAS 15.x or newer\n\nPrior to LLVM 15.0.0, LLVM's integrated assembler would incorrectly\nbyte-swap NOP when compiling for big-endian, and the resulting series of\nbytes happened to match the encoding of FNMADD S21, S30, S0, S0.\n\nThis went unnoticed until commit:\n\n  34f66c4c4d5518c1 (\"arm64: Use a positive cpucap for FP\/SIMD\")\n\nPrior to that commit, the kernel would always enable the use of FPSIMD\nearly in boot when __cpu_setup() initialized CPACR_EL1, and so usage of\nFNMADD within the kernel was not detected, but could result in the\ncorruption of user or kernel FPSIMD state.\n\nAfter that commit, the instructions happen to trap during boot prior to\nFPSIMD being detected and enabled, e.g.\n\n| Unhandled 64-bit el1h sync exception on CPU0, ESR 0x000000001fe00000 -- ASIMD\n| CPU: 0 PID: 0 Comm: swapper Not tainted 6.6.0-rc3-00013-g34f66c4c4d55 #1\n| Hardware name: linux,dummy-virt (DT)\n| pstate: 400000c9 (nZcv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n| pc : __pi_strcmp+0x1c\/0x150\n| lr : populate_properties+0xe4\/0x254\n| sp : ffffd014173d3ad0\n| x29: ffffd014173d3af0 x28: fffffbfffddffcb8 x27: 0000000000000000\n| x26: 0000000000000058 x25: fffffbfffddfe054 x24: 0000000000000008\n| x23: fffffbfffddfe000 x22: fffffbfffddfe000 x21: fffffbfffddfe044\n| x20: ffffd014173d3b70 x19: 0000000000000001 x18: 0000000000000005\n| x17: 0000000000000010 x16: 0000000000000000 x15: 00000000413e7000\n| x14: 0000000000000000 x13: 0000000000001bcc x12: 0000000000000000\n| x11: 00000000d00dfeed x10: ffffd414193f2cd0 x9 : 0000000000000000\n| x8 : 0101010101010101 x7 : ffffffffffffffc0 x6 : 0000000000000000\n| x5 : 0000000000000000 x4 : 0101010101010101 x3 : 000000000000002a\n| x2 : 0000000000000001 x1 : ffffd014171f2988 x0 : fffffbfffddffcb8\n| Kernel panic - not syncing: Unhandled exception\n| CPU: 0 PID: 0 Comm: swapper Not tainted 6.6.0-rc3-00013-g34f66c4c4d55 #1\n| Hardware name: linux,dummy-virt (DT)\n| Call trace:\n|  dump_backtrace+0xec\/0x108\n|  show_stack+0x18\/0x2c\n|  dump_stack_lvl+0x50\/0x68\n|  dump_stack+0x18\/0x24\n|  panic+0x13c\/0x340\n|  el1t_64_irq_handler+0x0\/0x1c\n|  el1_abort+0x0\/0x5c\n|  el1h_64_sync+0x64\/0x68\n|  __pi_strcmp+0x1c\/0x150\n|  unflatten_dt_nodes+0x1e8\/0x2d8\n|  __unflatten_device_tree+0x5c\/0x15c\n|  unflatten_device_tree+0x38\/0x50\n|  setup_arch+0x164\/0x1e0\n|  start_kernel+0x64\/0x38c\n|  __primary_switched+0xbc\/0xc4\n\nRestrict CONFIG_CPU_BIG_ENDIAN to a known good assembler, which is\neither GNU as or LLVM's IAS 15.0.0 and newer, which contains the linked\ncommit."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: arm64: restringe CPU_BIG_ENDIAN a GNU como o LLVM IAS 15.x o posterior. Antes de LLVM 15.0.0, el ensamblador integrado de LLVM intercambiaba bytes incorrectamente con NOP al compilar para big-endian. y la serie de bytes resultante coincidió con la codificación de FNMADD S21, S30, S0, S0. Esto pasó desapercibido hasta la confirmación: 34f66c4c4d5518c1 (\"arm64: use un cpucap positivo para FP\/SIMD\") Antes de esa confirmación, el kernel siempre habilitaba el uso de FPSIMD al principio del arranque cuando __cpu_setup() inicializaba CPACR_EL1, y por lo tanto el uso de FNMADD dentro del kernel no se detectó, pero podría provocar la corrupción del estado FPSIMD del usuario o del kernel. Después de esa confirmación, las instrucciones se bloquean durante el arranque antes de que se detecte y habilite FPSIMD, por ejemplo | Excepción de sincronización el1h de 64 bits no controlada en CPU0, ESR 0x000000001fe00000 - ASIMD | CPU: 0 PID: 0 Comunicaciones: intercambiador No contaminado 6.6.0-rc3-00013-g34f66c4c4d55 #1 | Nombre del hardware: linux,dummy-virt (DT) | pstate: 400000c9 (nZcv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--) | ordenador personal: __pi_strcmp+0x1c\/0x150 | lr: poblar_properties+0xe4\/0x254 | sp: ffffd014173d3ad0 | x29: ffffd014173d3af0 x28: ffffbfffddffcb8 x27: 0000000000000000 | x26: 0000000000000058 x25: ffffbfffddfe054 x24: 0000000000000008 | x23: ffffbffffddfe000 x22: ffffbfffddfe000 x21: ffffbfffddfe044 | x20: ffffd014173d3b70 x19: 0000000000000001 x18: 0000000000000005 | x17: 0000000000000010 x16: 0000000000000000 x15: 00000000413e7000 | x14: 0000000000000000 x13: 0000000000001bcc x12: 0000000000000000 | x11: 00000000d00dfeed x10: ffffd414193f2cd0 x9: 0000000000000000 | x8: 0101010101010101 x7: ffffffffffffffc0 x6: 0000000000000000 | x5: 0000000000000000 x4: 0101010101010101 x3: 000000000000002a | x2: 0000000000000001 x1: ffffd014171f2988 x0: ffffbfffddffcb8 | Pánico del kernel: no se sincroniza: excepción no controlada | CPU: 0 PID: 0 Comunicaciones: intercambiador No contaminado 6.6.0-rc3-00013-g34f66c4c4d55 #1 | Nombre del hardware: linux,dummy-virt (DT) | Rastreo de llamadas: | dump_backtrace+0xec\/0x108 | show_stack+0x18\/0x2c | dump_stack_lvl+0x50\/0x68 | dump_stack+0x18\/0x24 | pánico+0x13c\/0x340 | el1t_64_irq_handler+0x0\/0x1c | el1_abort+0x0\/0x5c | el1h_64_sync+0x64\/0x68 | __pi_strcmp+0x1c\/0x150 | unflatten_dt_nodes+0x1e8\/0x2d8 | __unflatten_device_tree+0x5c\/0x15c | unflatten_device_tree+0x38\/0x50 | setup_arch+0x164\/0x1e0 | start_kernel+0x64\/0x38c | __primary_switched+0xbc\/0xc4 Restrinja CONFIG_CPU_BIG_ENDIAN a un buen ensamblador conocido, que sea GNU o LLVM's IAS 15.0.0 y posteriores, que contiene la confirmación vinculada."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/146a15b873353f8ac28dc281c139ff611a3c4848","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/69e619d2fd056fe1f5d0adf01584f2da669e0d28","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/936c9c10efaefaf1ab3ef020e1f8aaaaff1ad2f9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bd31e534721ab95ef237020fe6995c899ffdf21a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d08a1e75253b4e19ae290b1c35349f12cfcebc0a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ef0224ee5399ea8a46bc07dc6c6494961ed5fdd2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52751","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.763","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix use-after-free in smb2_query_info_compound()\n\nThe following UAF was triggered when running fstests generic\/072 with\nKASAN enabled against Windows Server 2022 and mount options\n'multichannel,max_channels=2,vers=3.1.1,mfsymlinks,noperm'\n\n  BUG: KASAN: slab-use-after-free in smb2_query_info_compound+0x423\/0x6d0 [cifs]\n  Read of size 8 at addr ffff888014941048 by task xfs_io\/27534\n\n  CPU: 0 PID: 27534 Comm: xfs_io Not tainted 6.6.0-rc7 #1\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\n  rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04\/01\/2014\n  Call Trace:\n   dump_stack_lvl+0x4a\/0x80\n   print_report+0xcf\/0x650\n   ? srso_alias_return_thunk+0x5\/0x7f\n   ? srso_alias_return_thunk+0x5\/0x7f\n   ? __phys_addr+0x46\/0x90\n   kasan_report+0xda\/0x110\n   ? smb2_query_info_compound+0x423\/0x6d0 [cifs]\n   ? smb2_query_info_compound+0x423\/0x6d0 [cifs]\n   smb2_query_info_compound+0x423\/0x6d0 [cifs]\n   ? __pfx_smb2_query_info_compound+0x10\/0x10 [cifs]\n   ? srso_alias_return_thunk+0x5\/0x7f\n   ? __stack_depot_save+0x39\/0x480\n   ? kasan_save_stack+0x33\/0x60\n   ? kasan_set_track+0x25\/0x30\n   ? ____kasan_slab_free+0x126\/0x170\n   smb2_queryfs+0xc2\/0x2c0 [cifs]\n   ? __pfx_smb2_queryfs+0x10\/0x10 [cifs]\n   ? __pfx___lock_acquire+0x10\/0x10\n   smb311_queryfs+0x210\/0x220 [cifs]\n   ? __pfx_smb311_queryfs+0x10\/0x10 [cifs]\n   ? srso_alias_return_thunk+0x5\/0x7f\n   ? __lock_acquire+0x480\/0x26c0\n   ? lock_release+0x1ed\/0x640\n   ? srso_alias_return_thunk+0x5\/0x7f\n   ? do_raw_spin_unlock+0x9b\/0x100\n   cifs_statfs+0x18c\/0x4b0 [cifs]\n   statfs_by_dentry+0x9b\/0xf0\n   fd_statfs+0x4e\/0xb0\n   __do_sys_fstatfs+0x7f\/0xe0\n   ? __pfx___do_sys_fstatfs+0x10\/0x10\n   ? srso_alias_return_thunk+0x5\/0x7f\n   ? lockdep_hardirqs_on_prepare+0x136\/0x200\n   ? srso_alias_return_thunk+0x5\/0x7f\n   do_syscall_64+0x3f\/0x90\n   entry_SYSCALL_64_after_hwframe+0x6e\/0xd8\n\n  Allocated by task 27534:\n   kasan_save_stack+0x33\/0x60\n   kasan_set_track+0x25\/0x30\n   __kasan_kmalloc+0x8f\/0xa0\n   open_cached_dir+0x71b\/0x1240 [cifs]\n   smb2_query_info_compound+0x5c3\/0x6d0 [cifs]\n   smb2_queryfs+0xc2\/0x2c0 [cifs]\n   smb311_queryfs+0x210\/0x220 [cifs]\n   cifs_statfs+0x18c\/0x4b0 [cifs]\n   statfs_by_dentry+0x9b\/0xf0\n   fd_statfs+0x4e\/0xb0\n   __do_sys_fstatfs+0x7f\/0xe0\n   do_syscall_64+0x3f\/0x90\n   entry_SYSCALL_64_after_hwframe+0x6e\/0xd8\n\n  Freed by task 27534:\n   kasan_save_stack+0x33\/0x60\n   kasan_set_track+0x25\/0x30\n   kasan_save_free_info+0x2b\/0x50\n   ____kasan_slab_free+0x126\/0x170\n   slab_free_freelist_hook+0xd0\/0x1e0\n   __kmem_cache_free+0x9d\/0x1b0\n   open_cached_dir+0xff5\/0x1240 [cifs]\n   smb2_query_info_compound+0x5c3\/0x6d0 [cifs]\n   smb2_queryfs+0xc2\/0x2c0 [cifs]\n\nThis is a race between open_cached_dir() and cached_dir_lease_break()\nwhere the cache entry for the open directory handle receives a lease\nbreak while creating it.  And before returning from open_cached_dir(),\nwe put the last reference of the new @cfid because of\n!@cfid->has_lease.\n\nBesides the UAF, while running xfstests a lot of missed lease breaks\nhave been noticed in tests that run several concurrent statfs(2) calls\non those cached fids\n\n  CIFS: VFS: \\\\w22-root1.gandalf.test No task to wake, unknown frame...\n  CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1...\n  CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 00000000715bfe83 len 108\n  CIFS: VFS: Dump pending requests:\n  CIFS: VFS: \\\\w22-root1.gandalf.test No task to wake, unknown frame...\n  CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1...\n  CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 000000005aa7316e len 108\n  ...\n\nTo fix both, in open_cached_dir() ensure that @cfid->has_lease is set\nright before sending out compounded request so that any potential\nlease break will be get processed by demultiplex thread while we're\nstill caching @cfid.  And, if open failed for some reason, re-check\n@cfid->has_lease to decide whether or not put lease reference."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: smb: client: corrige use-after-free en smb2_query_info_compound(). El siguiente UAF se activó al ejecutar fstests generic\/072 con KASAN habilitado en Windows Server 2022 y opciones de montaje 'multicanal, max_channels=2,vers=3.1.1,mfsymlinks,noperm' BUG: KASAN: slab-use-after-free en smb2_query_info_compound+0x423\/0x6d0 [cifs] Lectura de tamaño 8 en la dirección ffff888014941048 por tarea xfs_io\/27534 CPU: 0 PID : 27534 Comm: xfs_io Not tainted 6.6.0-rc7 #1 Nombre del hardware: PC estándar QEMU (Q35 + ICH9, 2009), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 01\/04\/2014 Llamada Seguimiento: dump_stack_lvl+0x4a\/0x80 print_report+0xcf\/0x650 ? srso_alias_return_thunk+0x5\/0x7f? srso_alias_return_thunk+0x5\/0x7f? __phys_addr+0x46\/0x90 kasan_report+0xda\/0x110 ? smb2_query_info_compound+0x423\/0x6d0 [cifs]? smb2_query_info_compound+0x423\/0x6d0 [cifs] smb2_query_info_compound+0x423\/0x6d0 [cifs] ? __pfx_smb2_query_info_compound+0x10\/0x10 [cifs] ? srso_alias_return_thunk+0x5\/0x7f? __stack_depot_save+0x39\/0x480? kasan_save_stack+0x33\/0x60? kasan_set_track+0x25\/0x30? ____kasan_slab_free+0x126\/0x170 smb2_queryfs+0xc2\/0x2c0 [cifs] ? __pfx_smb2_queryfs+0x10\/0x10 [cifs] ? __pfx___lock_acquire+0x10\/0x10 smb311_queryfs+0x210\/0x220 [cifs]? __pfx_smb311_queryfs+0x10\/0x10 [cifs] ? srso_alias_return_thunk+0x5\/0x7f? __lock_acquire+0x480\/0x26c0? lock_release+0x1ed\/0x640? srso_alias_return_thunk+0x5\/0x7f? do_raw_spin_unlock+0x9b\/0x100 cifs_statfs+0x18c\/0x4b0 [cifs] statfs_by_dentry+0x9b\/0xf0 fd_statfs+0x4e\/0xb0 __do_sys_fstatfs+0x7f\/0xe0 ? __pfx___do_sys_fstatfs+0x10\/0x10 ? srso_alias_return_thunk+0x5\/0x7f? lockdep_hardirqs_on_prepare+0x136\/0x200? srso_alias_return_thunk+0x5\/0x7f do_syscall_64+0x3f\/0x90 Entry_SYSCALL_64_after_hwframe+0x6e\/0xd8 Asignado por tarea 27534: kasan_save_stack+0x33\/0x60 kasan_set_track+0x25\/0x30 __kasan_kmalloc+0x8f \/0xa0 open_cached_dir+0x71b\/0x1240 [cifs] smb2_query_info_compound+0x5c3\/0x6d0 [cifs ] smb2_queryfs+0xc2\/0x2c0 [cifs] smb311_queryfs+0x210\/0x220 [cifs] cifs_statfs+0x18c\/0x4b0 [cifs] statfs_by_dentry+0x9b\/0xf0 fd_statfs+0x4e\/0xb0 statfs+0x7f\/0xe0 do_syscall_64+0x3f\/0x90 entrada_SYSCALL_64_after_hwframe+0x6e\/0xd8 Liberado por la tarea 27534: kasan_save_stack+0x33\/0x60 kasan_set_track+0x25\/0x30 kasan_save_free_info+0x2b\/0x50 ____kasan_slab_free+0x126\/0x170 slab_free_freelist_hook+0xd0\/0x1e0 __kmem_cache_free+0x9d\/0x 1b0 open_cached_dir+0xff5\/0x1240 [cifs] smb2_query_info_compound+0x5c3\/0x6d0 [cifs ] smb2_queryfs+0xc2\/0x2c0 [cifs] Esta es una ejecución entre open_cached_dir() y cached_dir_lease_break() donde la entrada de caché para el identificador de directorio abierto recibe una interrupción de arrendamiento mientras se crea. Y antes de volver de open_cached_dir(), ponemos la última referencia del nuevo @cfid por !@cfid-&gt;has_lease. Además de UAF, al ejecutar xfstests se han observado muchas interrupciones de arrendamiento perdidas en pruebas que ejecutan varias llamadas statfs(2) simultáneas en esos fids almacenados en caché CIFS: VFS: \\\\w22-root1.gandalf.test No hay tarea para activar, desconocida marco... CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Banderas: 0x1... CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 00000000715bfe83 len 108 CIFS: VFS : Volcado de solicitudes pendientes: CIFS: VFS: \\\\w22-root1.gandalf.test No hay tarea para activar, marco desconocido... CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Banderas: 0x1 ... CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 000000005aa7316e len 108 ... Para arreglar ambos, en open_cached_dir() asegúrese de que @cfid-&gt;has_lease esté configurado justo antes de enviar una solicitud compuesta para que cualquier La posible interrupción del arrendamiento será procesada por el subproceso demultiplex mientras todavía estamos almacenando en caché @cfid. Y, si la apertura falla por algún motivo, vuelva a verificar @cfid-&gt;has_lease para decidir si coloca o no la referencia del arrendamiento."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5c86919455c1edec99ebd3338ad213b59271a71b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6db94d08359c43f2c8fe372811cdee04564a41b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/93877b9afc2994c89362007aac480a7b150f386f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52752","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.833","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix use-after-free bug in cifs_debug_data_proc_show()\n\nSkip SMB sessions that are being teared down\n(e.g. @ses->ses_status == SES_EXITING) in cifs_debug_data_proc_show()\nto avoid use-after-free in @ses.\n\nThis fixes the following GPF when reading from \/proc\/fs\/cifs\/DebugData\nwhile mounting and umounting\n\n  [ 816.251274] general protection fault, probably for non-canonical\n  address 0x6b6b6b6b6b6b6d81: 0000 [#1] PREEMPT SMP NOPTI\n  ...\n  [  816.260138] Call Trace:\n  [  816.260329]  <TASK>\n  [  816.260499]  ? die_addr+0x36\/0x90\n  [  816.260762]  ? exc_general_protection+0x1b3\/0x410\n  [  816.261126]  ? asm_exc_general_protection+0x26\/0x30\n  [  816.261502]  ? cifs_debug_tcon+0xbd\/0x240 [cifs]\n  [  816.261878]  ? cifs_debug_tcon+0xab\/0x240 [cifs]\n  [  816.262249]  cifs_debug_data_proc_show+0x516\/0xdb0 [cifs]\n  [  816.262689]  ? seq_read_iter+0x379\/0x470\n  [  816.262995]  seq_read_iter+0x118\/0x470\n  [  816.263291]  proc_reg_read_iter+0x53\/0x90\n  [  816.263596]  ? srso_alias_return_thunk+0x5\/0x7f\n  [  816.263945]  vfs_read+0x201\/0x350\n  [  816.264211]  ksys_read+0x75\/0x100\n  [  816.264472]  do_syscall_64+0x3f\/0x90\n  [  816.264750]  entry_SYSCALL_64_after_hwframe+0x6e\/0xd8\n  [  816.265135] RIP: 0033:0x7fd5e669d381"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: smb: cliente: corrige el error de use after free en cifs_debug_data_proc_show(). Omitir sesiones SMB que se están eliminando (por ejemplo, @ses-&gt;ses_status == SES_EXITING) en cifs_debug_data_proc_show() para evitar el use after free en @ses. Esto corrige el siguiente GPF al leer desde \/proc\/fs\/cifs\/DebugData mientras se monta y desmonta [816.251274] falla de protección general, probablemente para la dirección no canónica 0x6b6b6b6b6b6b6d81: 0000 [#1] PREEMPT SMP NOPTI... [816.260138] Llamada Seguimiento: [816.260329]  [816.260499] ? die_addr+0x36\/0x90 [816.260762]? exc_general_protection+0x1b3\/0x410 [816.261126]? asm_exc_general_protection+0x26\/0x30 [816.261502]? cifs_debug_tcon+0xbd\/0x240 [cifs] [816.261878]? cifs_debug_tcon+0xab\/0x240 [cifs] [816.262249] cifs_debug_data_proc_show+0x516\/0xdb0 [cifs] [816.262689]? seq_read_iter+0x379\/0x470 [816.262995] seq_read_iter+0x118\/0x470 [816.263291] proc_reg_read_iter+0x53\/0x90 [816.263596] ? srso_alias_return_thunk+0x5\/0x7f [ 816.263945] vfs_read+0x201\/0x350 [ 816.264211] ksys_read+0x75\/0x100 [ 816.264472] do_syscall_64+0x3f\/0x90 [ 816.2647 50] entrada_SYSCALL_64_after_hwframe+0x6e\/0xd8 [816.265135] RIP: 0033:0x7fd5e669d381"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0ab6f842452ce2cae04209d4671ac6289d0aef8a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/558817597d5fbd7af31f891b67b0fd20f0d047b7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/89929ea46f9cc11ba66d2c64713aa5d5dc723b09","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d328c09ee9f15ee5a26431f5aad7c9239fa85e62","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52753","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.900","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/display: Avoid NULL dereference of timing generator\n\n[Why & How]\nCheck whether assigned timing generator is NULL or not before\naccessing its funcs to prevent NULL dereference."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amd\/display: Evite la desreferencia NULL del generador de temporización [Por qué y cómo] Verifique si el generador de temporización asignado es NULL o no antes de acceder a sus funciones para evitar la desreferencia NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/09909f515032fa80b921fd3118efe66b185d10fd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4e497f1acd99075b13605b2e7fa0cba721a2cfd9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6d8653b1a7a8dc938b566ae8c4f373b36e792c68","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/79b6a90f4f2433312154cd68452b0ba501fa74db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a06894666e0b462c9316b26ab615cefdd0d676c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b1904ed480cee3f9f4036ea0e36d139cb5fee2d6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df8bc953eed72371e43ca407bd063507f760cf89","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eac3e4760aa12159f7f5475d55a67b7933abc195","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52754","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:14.970","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: imon: fix access to invalid resource for the second interface\n\nimon driver probes two USB interfaces, and at the probe of the second\ninterface, the driver assumes blindly that the first interface got\nbound with the same imon driver.  It's usually true, but it's still\npossible that the first interface is bound with another driver via a\nmalformed descriptor.  Then it may lead to a memory corruption, as\nspotted by syzkaller; imon driver accesses the data from drvdata as\nstruct imon_context object although it's a completely different one\nthat was assigned by another driver.\n\nThis patch adds a sanity check -- whether the first interface is\nreally bound with the imon driver or not -- for avoiding the problem\nabove at the probe time."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: medios: imon: corrige el acceso a un recurso no válido para la segunda interfaz. El controlador imon prueba dos interfaces USB y, en la prueba de la segunda interfaz, el controlador asume ciegamente que la primera interfaz obtuvo atado con el mismo conductor imon. Generalmente es cierto, pero aún es posible que la primera interfaz esté vinculada con otro controlador a través de un descriptor con formato incorrecto. Entonces puede provocar una corrupción de la memoria, como descubrió syzkaller; El controlador imon accede a los datos de drvdata como objeto struct imon_context aunque es uno completamente diferente asignado por otro controlador. Este parche agrega una verificación de cordura (si la primera interfaz está realmente vinculada con el controlador imon o no) para evitar el problema anterior en el momento de la prueba."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0f5068519f89d928d6c51100e4b274479123829f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/10ec5a97f8f5a772a1a42b4eb27196b447cd3aa9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2a493a34bd6e496c55fabedd82b957193ace178f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5e0b788fb96be36d1baf1a5c88d09c7c82a0452a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a1766a4fd83befa0b34d932d532e7ebb7fab1fa7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b083aaf5db2eeca9e362723258e5d8698f7dd84e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52755","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.037","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: fix slab out of bounds write in smb_inherit_dacl()\n\nslab out-of-bounds write is caused by that offsets is bigger than pntsd\nallocation size. This patch add the check to validate 3 offsets using\nallocation size."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ksmbd: corrige la escritura fuera de los límites de slab en smb_inherit_dacl(). La escritura fuera de los límites de slab se debe a que las compensaciones son mayores que el tamaño de asignación de pntsd. Este parche agrega la verificación para validar 3 compensaciones usando el tamaño de asignación."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/09d9d8b40a3338193619c14ed4dc040f4f119e70","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/712e01f32e577e7e48ab0adb5fe550646a3d93cb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8387c94d73ec66eb597c7a23a8d9eadf64bfbafa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aaf0a07d60887d6c36fc46a24de0083744f07819","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eebff19acaa35820cb09ce2ccb3d21bee2156ffb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52756","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.113","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npwm: Fix double shift bug\n\nThese enums are passed to set\/test_bit().  The set\/test_bit() functions\ntake a bit number instead of a shifted value.  Passing a shifted value\nis a double shift bug like doing BIT(BIT(1)).  The double shift bug\ndoesn't cause a problem here because we are only checking 0 and 1 but\nif the value was 5 or above then it can lead to a buffer overflow."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: pwm: corrige el error de double shift. Estas enumeraciones se pasan a set\/test_bit(). Las funciones set\/test_bit() toman un número de bit en lugar de un valor desplazado. Pasar un valor desplazado es un error de doble desplazamiento, como hacer BIT(BIT(1)). El error de doble turno no causa un problema aquí porque solo estamos verificando 0 y 1, pero si el valor era 5 o superior, puede provocar un desbordamiento del búfer."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1fb3a9c59e7f7d2b1d737a0d6e02e31d5b516455","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/45d0a298e05adee521f6fe605d6a88341ba07edd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7ee519e8095d9c834086d0ff40da11415e1e4d7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a98ff250b5af87f92f17bb9725cb21de1931ee57","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bce1f7c7e9812da57de1dda293cba87c693e9958","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c19a8794bf4fe45cff997f07a75ea84cc9e5d89c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d27abbfd4888d79dd24baf50e774631046ac4732","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e52518b9cb9fc98fc043c8fb2b8cfc619ca8a88b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eca19db60f99925461f49c3fd743733881395728","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52757","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.187","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential deadlock when releasing mids\n\nAll release_mid() callers seem to hold a reference of @mid so there is\nno need to call kref_put(&mid->refcount, __release_mid) under\n@server->mid_lock spinlock.  If they don't, then an use-after-free bug\nwould have occurred anyways.\n\nBy getting rid of such spinlock also fixes a potential deadlock as\nshown below\n\nCPU 0                                CPU 1\n------------------------------------------------------------------\ncifs_demultiplex_thread()            cifs_debug_data_proc_show()\n release_mid()\n  spin_lock(&server->mid_lock);\n                                     spin_lock(&cifs_tcp_ses_lock)\n\t\t\t\t      spin_lock(&server->mid_lock)\n  __release_mid()\n   smb2_find_smb_tcon()\n    spin_lock(&cifs_tcp_ses_lock) *deadlock*"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: smb: client: corrige un posible punto muerto al liberar mids. Todos los llamadores de release_mid() parecen tener una referencia de @mid, por lo que no hay necesidad de llamar a kref_put(&amp;mid-&gt;refcount, __release_mid ) en @servidor-&gt;mid_lock spinlock. Si no lo hacen, de todos modos se habría producido un error de use after free. Al deshacerse de dicho bloqueo de giro, también se soluciona un posible punto muerto como se muestra a continuación CPU 0 CPU 1 -------------------------------- ---------------------------------- cifs_demultiplex_thread() cifs_debug_data_proc_show() release_mid() spin_lock(&amp;servidor-&gt;mid_lock) ; spin_lock(&amp;cifs_tcp_ses_lock) spin_lock(&amp;servidor-&gt;mid_lock) __release_mid() smb2_find_smb_tcon() spin_lock(&amp;cifs_tcp_ses_lock) *punto muerto*"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/9eb44db68c5b7f5aa22b8fc7de74a3e2e08d1f29","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b9bb9607b1fc12fca51f5632da25b36975f599bf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c1a5962f1462b64fe7b69f20a4b6af8067bc2d26","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e6322fd177c6885a21dd4609dc5e5c973d1a2eb7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52758","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.257","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: dev: copy userspace array safely\n\ni2c-dev.c utilizes memdup_user() to copy a userspace array. This is done\nwithout an overflow check.\n\nUse the new wrapper memdup_array_user() to copy the array more safely."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: i2c: dev: copie una matriz de espacio de usuario de forma segura i2c-dev.c utiliza memdup_user() para copiar una matriz de espacio de usuario. Esto se hace sin una verificación de desbordamiento. Utilice el nuevo contenedor memdup_array_user() para copiar la matriz de forma más segura."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/38ada2f304f6f2065dd59613ef236a26f4dd73cd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aff8be2cad74a22525cd89cdff0b72a5c9a4c0c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bef76b8544939518dafa3325bcd438b111136437","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cc9c54232f04aef3a5d7f64a0ece7df00f1aaa3d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fe4eb2157d8c45b127bd88b1376c38c27b741293","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52759","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.330","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: ignore negated quota changes\n\nWhen lots of quota changes are made, there may be cases in which an\ninode's quota information is increased and then decreased, such as when\nblocks are added to a file, then deleted from it. If the timing is\nright, function do_qc can add pending quota changes to a transaction,\nthen later, another call to do_qc can negate those changes, resulting\nin a net gain of 0. The quota_change information is recorded in the qc\nbuffer (and qd element of the inode as well). The buffer is added to the\ntransaction by the first call to do_qc, but a subsequent call changes\nthe value from non-zero back to zero. At that point it's too late to\nremove the buffer_head from the transaction. Later, when the quota sync\ncode is called, the zero-change qd element is discovered and flagged as\nan assert warning. If the fs is mounted with errors=panic, the kernel\nwill panic.\n\nThis is usually seen when files are truncated and the quota changes are\nnegated by punch_hole\/truncate which uses gfs2_quota_hold and\ngfs2_quota_unhold rather than block allocations that use gfs2_quota_lock\nand gfs2_quota_unlock which automatically do quota sync.\n\nThis patch solves the problem by adding a check to qd_check_sync such\nthat net-zero quota changes already added to the transaction are no\nlonger deemed necessary to be synced, and skipped.\n\nIn this case references are taken for the qd and the slot from do_qc\nso those need to be put. The normal sequence of events for a normal\nnon-zero quota change is as follows:\n\ngfs2_quota_change\n   do_qc\n      qd_hold\n      slot_hold\n\nLater, when the changes are to be synced:\n\ngfs2_quota_sync\n   qd_fish\n      qd_check_sync\n         gets qd ref via lockref_get_not_dead\n   do_sync\n      do_qc(QC_SYNC)\n         qd_put\n\t    lockref_put_or_lock\n   qd_unlock\n      qd_put\n         lockref_put_or_lock\n\nIn the net-zero change case, we add a check to qd_check_sync so it puts\nthe qd and slot references acquired in gfs2_quota_change and skip the\nunneeded sync."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: gfs2: ignora los cambios de cuota negados. Cuando se realizan muchos cambios de cuota, puede haber casos en los que la información de cuota de un inodo aumenta y luego disminuye, como cuando se agregan bloques a un archivo, luego eliminado de él. Si es el momento adecuado, la función do_qc puede agregar cambios de cuota pendientes a una transacción, luego, otra llamada a do_qc puede negar esos cambios, lo que resulta en una ganancia neta de 0. La información de cuota_cambio se registra en el búfer qc (y en el elemento qd). del inodo también). El búfer se agrega a la transacción mediante la primera llamada a do_qc, pero una llamada posterior cambia el valor de distinto de cero a cero. En ese momento ya es demasiado tarde para eliminar buffer_head de la transacción. Más tarde, cuando se llama al código de sincronización de cuota, el elemento qd de cambio cero se descubre y se marca como una advertencia de afirmación. Si fs se monta con errores = pánico, el kernel entrará en pánico. Esto generalmente se ve cuando los archivos se truncan y los cambios de cuota se niegan mediante punch_hole\/truncate, que usa gfs2_quota_hold y gfs2_quota_unhold en lugar de bloquear asignaciones que usan gfs2_quota_lock y gfs2_quota_unlock, que sincronizan automáticamente la cuota. Este parche resuelve el problema agregando una verificación a qd_check_sync de modo que los cambios de cuota neta cero ya agregados a la transacción ya no se consideren necesarios para sincronizarse y omitirse. En este caso, se toman referencias para el qd y el slot de do_qc, por lo que es necesario ponerlas. La secuencia normal de eventos para un cambio de cuota normal distinto de cero es la siguiente: gfs2_quota_change do_qc qd_hold slot_hold Más tarde, cuando se van a sincronizar los cambios: gfs2_quota_sync qd_fish qd_check_sync obtiene qd ref mediante lockref_get_not_dead do_sync do_qc(QC_SYNC) qd_put lockref_put_or_lock qd_unlock qd_put lockref_put_or_lock En el caso de cambio neto cero, agregamos una verificación a qd_check_sync para que coloque las referencias de qd y slot adquiridas en gfs2_quota_change y omita la sincronización innecesaria."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/119565e566f91ff3588ffcd5812f0c8061586c6b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1c28dace66015b675a343b89b0c87abbfda05ff4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/212f112fe5e90e98eb8d48585682880dae139f4c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2a054b87a1b799b391e578597a42ee6e57a987ae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2bb42a27a92ff3984c9fa5fbe128eced3ea693f2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4c6a08125f2249531ec01783a5f4317d7342add5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/53fc16c1ad84f5467ec24341670b63aa759335d3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5bfda356e903633d16ae1bac1ee38364e12628a3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4deec69fe32b58dc5fb4ace52456ece85b75561","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52760","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.410","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: Fix slab-use-after-free in gfs2_qd_dealloc\n\nIn gfs2_put_super(), whether withdrawn or not, the quota should\nbe cleaned up by gfs2_quota_cleanup().\n\nOtherwise, struct gfs2_sbd will be freed before gfs2_qd_dealloc (rcu\ncallback) has run for all gfs2_quota_data objects, resulting in\nuse-after-free.\n\nAlso, gfs2_destroy_threads() and gfs2_quota_cleanup() is already called\nby gfs2_make_fs_ro(), so in gfs2_put_super(), after calling\ngfs2_make_fs_ro(), there is no need to call them again."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: gfs2: corrige slab-use-after-free en gfs2_qd_dealloc. En gfs2_put_super(), ya sea retirada o no, gfs2_quota_cleanup() debe limpiar la cuota. De lo contrario, la estructura gfs2_sbd se liberará antes de que se ejecute gfs2_qd_dealloc (devolución de llamada de rcu) para todos los objetos gfs2_quota_data, lo que dará como resultado un use after free. Además, gfs2_destroy_threads() y gfs2_quota_cleanup() ya son llamados por gfs2_make_fs_ro(), por lo que en gfs2_put_super(), después de llamar a gfs2_make_fs_ro(), no es necesario volver a llamarlos."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/08a28272faa750d4357ea2cb48d2baefd778ea81","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bdcb8aa434c6d36b5c215d02a9ef07551be25a37","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52761","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.487","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: VMAP_STACK overflow detection thread-safe\n\ncommit 31da94c25aea (\"riscv: add VMAP_STACK overflow detection\") added\nsupport for CONFIG_VMAP_STACK. If overflow is detected, CPU switches to\n`shadow_stack` temporarily before switching finally to per-cpu\n`overflow_stack`.\n\nIf two CPUs\/harts are racing and end up in over flowing kernel stack, one\nor both will end up corrupting each other state because `shadow_stack` is\nnot per-cpu. This patch optimizes per-cpu overflow stack switch by\ndirectly picking per-cpu `overflow_stack` and gets rid of `shadow_stack`.\n\nFollowing are the changes in this patch\n\n - Defines an asm macro to obtain per-cpu symbols in destination\n   register.\n - In entry.S, when overflow is detected, per-cpu overflow stack is\n   located using per-cpu asm macro. Computing per-cpu symbol requires\n   a temporary register. x31 is saved away into CSR_SCRATCH\n   (CSR_SCRATCH is anyways zero since we're in kernel).\n\nPlease see Links for additional relevant disccussion and alternative\nsolution.\n\nTested by `echo EXHAUST_STACK > \/sys\/kernel\/debug\/provoke-crash\/DIRECT`\nKernel crash log below\n\n Insufficient stack space to handle exception!\/debug\/provoke-crash\/DIRECT\n Task stack:     [0xff20000010a98000..0xff20000010a9c000]\n Overflow stack: [0xff600001f7d98370..0xff600001f7d99370]\n CPU: 1 PID: 205 Comm: bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34\n Hardware name: riscv-virtio,qemu (DT)\n epc : __memset+0x60\/0xfc\n  ra : recursive_loop+0x48\/0xc6 [lkdtm]\n epc : ffffffff808de0e4 ra : ffffffff0163a752 sp : ff20000010a97e80\n  gp : ffffffff815c0330 tp : ff600000820ea280 t0 : ff20000010a97e88\n  t1 : 000000000000002e t2 : 3233206874706564 s0 : ff20000010a982b0\n  s1 : 0000000000000012 a0 : ff20000010a97e88 a1 : 0000000000000000\n  a2 : 0000000000000400 a3 : ff20000010a98288 a4 : 0000000000000000\n  a5 : 0000000000000000 a6 : fffffffffffe43f0 a7 : 00007fffffffffff\n  s2 : ff20000010a97e88 s3 : ffffffff01644680 s4 : ff20000010a9be90\n  s5 : ff600000842ba6c0 s6 : 00aaaaaac29e42b0 s7 : 00fffffff0aa3684\n  s8 : 00aaaaaac2978040 s9 : 0000000000000065 s10: 00ffffff8a7cad10\n  s11: 00ffffff8a76a4e0 t3 : ffffffff815dbaf4 t4 : ffffffff815dbaf4\n  t5 : ffffffff815dbab8 t6 : ff20000010a9bb48\n status: 0000000200000120 badaddr: ff20000010a97e88 cause: 000000000000000f\n Kernel panic - not syncing: Kernel stack overflow\n CPU: 1 PID: 205 Comm: bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34\n Hardware name: riscv-virtio,qemu (DT)\n Call Trace:\n [<ffffffff80006754>] dump_backtrace+0x30\/0x38\n [<ffffffff808de798>] show_stack+0x40\/0x4c\n [<ffffffff808ea2a8>] dump_stack_lvl+0x44\/0x5c\n [<ffffffff808ea2d8>] dump_stack+0x18\/0x20\n [<ffffffff808dec06>] panic+0x126\/0x2fe\n [<ffffffff800065ea>] walk_stackframe+0x0\/0xf0\n [<ffffffff0163a752>] recursive_loop+0x48\/0xc6 [lkdtm]\n SMP: stopping secondary CPUs\n ---[ end Kernel panic - not syncing: Kernel stack overflow ]---"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: riscv: detección de desbordamiento de VMAP_STACK confirmación segura para subprocesos 31da94c25aea (\"riscv: agregar detección de desbordamiento de VMAP_STACK\") se agregó soporte para CONFIG_VMAP_STACK. Si se detecta un desbordamiento, la CPU cambia a `shadow_stack` temporalmente antes de cambiar finalmente a `overflow_stack` por CPU. Si dos CPU\/harts están corriendo y terminan en una pila de kernel desbordada, uno o ambos terminarán corrompiendo el estado del otro porque `shadow_stack` no es por CPU. Este parche optimiza el cambio de pila de desbordamiento por CPU seleccionando directamente `overflow_stack` por CPU y elimina `shadow_stack`. Los siguientes son los cambios en este parche: Define una macro asm para obtener símbolos por CPU en el registro de destino. - En Entry.S, cuando se detecta un desbordamiento, la pila de desbordamiento por CPU se ubica mediante la macro ASM por CPU. Calcular el símbolo por CPU requiere un registro temporal. x31 se guarda en CSR_SCRATCH (CSR_SCRATCH es de todos modos cero ya que estamos en el kernel). Consulte los enlaces para obtener información adicional relevante y una solución alternativa. Probado por `echo EXHAUST_STACK &gt; \/sys\/kernel\/debug\/provoke-crash\/DIRECT` Registro de fallas del kernel debajo ¡Espacio de pila insuficiente para manejar la excepción!\/debug\/provoke-crash\/DIRECT Pila de tareas: [0xff20000010a98000..0xff20000010a9c000] Pila de desbordamiento: [0xff600001f7d98370..0xff600001f7d99370] CPU: 1 PID: 205 Comm: bash No contaminado 6.1.0-rc2-00001-g328a1f96f7b9 #34 Nombre de hardware: riscv-virtio,qemu (DT) epc: __memset+0x60\/0x fc ra: bucle_recursivo+ 0x48\/0xc6 [lkdtm] epc: ffffffff808de0e4 ra: ffffffff0163a752 sp: ff20000010a97e80 gp: ffffffff815c0330 tp: ff600000820ea280 t0: ff20000010a97e88 t1: 0000000000002e t2: 3233206874706564 s0: ff20000010a982b0 s1: 0000000000000012 a0: ff20000010a97e88 a1: 0000000000000000 a2: 000000 0000000400 a3: ff20000010a98288 a4: 0000000000000000 a5: 0000000000000000 a6: fffffffffffe43f0 a7: 00007ffffffffff s2: ff20000010a97e88 s3: ffffffff01644680 s4: ff20000010a9be90 5: ff600000842ba6c0 s6: 00aaaaaac29e42b0 s7: 00fffffff0aa3684 s8: 00aaaaaac2978040 s9: 00000000000000065 s10: 00ffffff8a7cad10 s11: ff8a76a4e0 t3: ffffffff815dbaf4 t4: ffffffff815dbaf4 t5: ffffffff815dbab8 t6 : ff20000010a9bb48 estado: 0000000200000120 badaddr: ff20000010a97e88 causa: 000000000000000f Pánico del kernel: no se sincroniza: desbordamiento de la pila del kernel CPU: 1 PID: 205 Comm: bash no contaminado 6.1.0-rc2-0000 1-g328a1f96f7b9 #34 Nombre del hardware: riscv-virtio,qemu (DT) Seguimiento de llamadas: [] dump_backtrace+0x30\/0x38 [] show_stack+0x40\/0x4c [] dump_stack_lvl+0x44\/0x5c [] dump_stack+0x18 \/0x20 [ ] panic+0x126\/0x2fe [] walk_stackframe+0x0\/0xf0 [] recursive_loop+0x48\/0xc6 [lkdtm] SMP: deteniendo las CPU secundarias ---[ fin del pánico del kernel - no se sincroniza: desbordamiento de la pila del kernel]- --"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1493baaf09e3c1899959c8a107cd1207e16d1788","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/be97d0db5f44c0674480cb79ac6f5b0529b84c76","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eff53aea3855f71992c043cebb1c00988c17ee20","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52762","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.560","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio-blk: fix implicit overflow on virtio_max_dma_size\n\nThe following codes have an implicit conversion from size_t to u32:\n(u32)max_size = (size_t)virtio_max_dma_size(vdev);\n\nThis may lead overflow, Ex (size_t)4G -> (u32)0. Once\nvirtio_max_dma_size() has a larger size than U32_MAX, use U32_MAX\ninstead."},{"lang":"es","value":" En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: virtio-blk: corrige el desbordamiento implícito en virtio_max_dma_size. Los siguientes códigos tienen una conversión implícita de size_t a u32: (u32)max_size = (size_t)virtio_max_dma_size(vdev); Esto puede provocar un desbordamiento, Ex (size_t)4G -&gt; (u32)0. Una vez que virtio_max_dma_size() tenga un tamaño mayor que U32_MAX, use U32_MAX en su lugar."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/017278f141141367f7d14b203e930b45b6ffffb9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/472bd4787406bef2e8b41ee4c74d960a06a49a48","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/72775cad7f572bb2501f9ea609e1d20e68f0b38b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d667fe301dcbcb12d1d6494fc4b8abee2cb75d90","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fafb51a67fb883eb2dde352539df939a251851be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52763","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.630","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ni3c: master: mipi-i3c-hci: Fix a kernel panic for accessing DAT_data.\n\nThe `i3c_master_bus_init` function may attach the I2C devices before the\nI3C bus initialization. In this flow, the DAT `alloc_entry`` will be used\nbefore the DAT `init`. Additionally, if the `i3c_master_bus_init` fails,\nthe DAT `cleanup` will execute before the device is detached, which will\nexecue DAT `free_entry` function. The above scenario can cause the driver\nto use DAT_data when it is NULL."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: i3c: master: mipi-i3c-hci: se corrigió un pánico del kernel al acceder a DAT_data. La función `i3c_master_bus_init` puede conectar los dispositivos I2C antes de la inicialización del bus I3C. En este flujo, el DAT `alloc_entry`` se utilizará antes del DAT `init`. Además, si `i3c_master_bus_init` falla, la `limpieza` de DAT se ejecutará antes de desconectar el dispositivo, lo que ejecutará la función DAT `free_entry`. El escenario anterior puede hacer que el controlador utilice DAT_data cuando es NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/39c71357e68e2f03766f9321b9f4882e49ff1442","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3cb79a365e7cce8f121bba91312e2ddd206b9781","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b53e9758a31c683fc8615df930262192ed5f034b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e64d23dc65810be4e3395d72df0c398f60c991f9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eed74230435c61eeb58abaa275b1820e6a4b7f02","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52764","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.700","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: gspca: cpia1: shift-out-of-bounds in set_flicker\n\nSyzkaller reported the following issue:\nUBSAN: shift-out-of-bounds in drivers\/media\/usb\/gspca\/cpia1.c:1031:27\nshift exponent 245 is too large for 32-bit type 'int'\n\nWhen the value of the variable \"sd->params.exposure.gain\" exceeds the\nnumber of bits in an integer, a shift-out-of-bounds error is reported. It\nis triggered because the variable \"currentexp\" cannot be left-shifted by\nmore than the number of bits in an integer. In order to avoid invalid\nrange during left-shift, the conditional expression is added."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: media: gspca: cpia1: desplazamiento fuera de los límites en set_flicker. Syzkaller informó el siguiente problema: UBSAN: desplazamiento fuera de los límites en drivers\/media\/usb\/gspca \/cpia1.c:1031:27 el exponente de desplazamiento 245 es demasiado grande para el tipo 'int' de 32 bits. Cuando el valor de la variable \"sd-&gt;params.exposure.gain\" excede el número de bits en un número entero, se realiza un desplazamiento. Se informa un error fuera de los límites. Se activa porque la variable \"currentexp\" no puede desplazarse hacia la izquierda más que el número de bits de un número entero. Para evitar un rango no válido durante el desplazamiento a la izquierda, se agrega la expresión condicional."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/099be1822d1f095433f4b08af9cc9d6308ec1953","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/09cd8b561aa9796903710a1046957f2b112c8f26","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2eee8edfff90e22980a6b22079d238c3c9d323bb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/69bba62600bd91d6b7c1e8ca181faf8ac64f7060","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f83c85ee88225319c52680792320c02158c2a9b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/93bddd6529f187f510eec759f37d0569243c9809","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a647f27a7426d2fe1b40da7c8fa2b81354a51177","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c6b6b8692218da73b33b310d7c1df90f115bdd9a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e2d7149b913d14352c82624e723ce1c211ca06d3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52765","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.777","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmfd: qcom-spmi-pmic: Fix revid implementation\n\nThe Qualcomm SPMI PMIC revid implementation is broken in multiple ways.\n\nFirst, it assumes that just because the sibling base device has been\nregistered that means that it is also bound to a driver, which may not\nbe the case (e.g. due to probe deferral or asynchronous probe). This\ncould trigger a NULL-pointer dereference when attempting to access the\ndriver data of the unbound device.\n\nSecond, it accesses driver data of a sibling device directly and without\nany locking, which means that the driver data may be freed while it is\nbeing accessed (e.g. on driver unbind).\n\nThird, it leaks a struct device reference to the sibling device which is\nlooked up using the spmi_device_from_of() every time a function (child)\ndevice is calling the revid function (e.g. on probe).\n\nFix this mess by reimplementing the revid lookup so that it is done only\nat probe of the PMIC device; the base device fetches the revid info from\nthe hardware, while any secondary SPMI device fetches the information\nfrom the base device and caches it so that it can be accessed safely\nfrom its children. If the base device has not been probed yet then probe\nof a secondary device is deferred."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: mfd: qcom-spmi-pmic: reparación de la implementación revid. La implementación revid de Qualcomm SPMI PMIC está rota de varias maneras. En primer lugar, se supone que el hecho de que el dispositivo base hermano se haya registrado significa que también está vinculado a un controlador, lo que puede no ser el caso (por ejemplo, debido a un aplazamiento de la sonda o una sonda asincrónica). Esto podría desencadenar una desreferencia del puntero NULL al intentar acceder a los datos del controlador del dispositivo independiente. En segundo lugar, accede a los datos del controlador de un dispositivo hermano directamente y sin ningún bloqueo, lo que significa que los datos del controlador pueden liberarse mientras se accede a ellos (por ejemplo, al desvincular el controlador). En tercer lugar, filtra una referencia de dispositivo de estructura al dispositivo hermano que se busca usando spmi_device_from_of() cada vez que un dispositivo de función (secundario) llama a la función revid (por ejemplo, en la sonda). Solucione este problema volviendo a implementar la búsqueda revid para que se realice solo en la sonda del dispositivo PMIC; el dispositivo base obtiene la información revid del hardware, mientras que cualquier dispositivo SPMI secundario obtiene la información del dispositivo base y la almacena en caché para que sus hijos puedan acceder a ella de forma segura. Si el dispositivo base aún no ha sido sondeado, se pospone la sonda de un dispositivo secundario."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4ce77b023d42a9f1062eecf438df1af4b4072eb2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7b439aaa62fee474a0d84d67a25f4984467e7b95","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/affae18838db5e6b463ee30c821385695af56dc2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/db98de0809f12b0edb9cd1be78e1ec1bfeba8f40","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52766","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.847","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ni3c: mipi-i3c-hci: Fix out of bounds access in hci_dma_irq_handler\n\nDo not loop over ring headers in hci_dma_irq_handler() that are not\nallocated and enabled in hci_dma_init(). Otherwise out of bounds access\nwill occur from rings->headers[i] access when i >= number of allocated\nring headers."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: i3c: mipi-i3c-hci: corrige el acceso fuera de los límites en hci_dma_irq_handler. No realice bucles sobre encabezados de anillo en hci_dma_irq_handler() que no estén asignados y habilitados en hci_dma_init(). De lo contrario, el acceso fuera de los límites se producirá desde el acceso de anillos-&gt;encabezados[i] cuando i &gt;= número de encabezados de anillo asignados."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/45a832f989e520095429589d5b01b0c65da9b574","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4c86cb2321bd9c72d3b945ce7f747961beda8e65","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7c2b91b30d74d7c407118ad72502d4ca28af1af6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8be39f66915b40d26ea2c18ba84b5c3d5da6809b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d23ad76f240c0f597b7a9eb79905d246f27d40df","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52767","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.917","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntls: fix NULL deref on tls_sw_splice_eof() with empty record\n\nsyzkaller discovered that if tls_sw_splice_eof() is executed as part of\nsendfile() when the plaintext\/ciphertext sk_msg are empty, the send path\ngets confused because the empty ciphertext buffer does not have enough\nspace for the encryption overhead. This causes tls_push_record() to go on\nthe `split = true` path (which is only supposed to be used when interacting\nwith an attached BPF program), and then get further confused and hit the\ntls_merge_open_record() path, which then assumes that there must be at\nleast one populated buffer element, leading to a NULL deref.\n\nIt is possible to have empty plaintext\/ciphertext buffers if we previously\nbailed from tls_sw_sendmsg_locked() via the tls_trim_both_msgs() path.\ntls_sw_push_pending_record() already handles this case correctly; let's do\nthe same check in tls_sw_splice_eof()."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: tls: corrige NULL deref en tls_sw_splice_eof() con registro vacío syzkaller descubrió que si tls_sw_splice_eof() se ejecuta como parte de sendfile() cuando el texto plano\/texto cifrado sk_msg está vacío, el envío La ruta se confunde porque el búfer de texto cifrado vacío no tiene suficiente espacio para la sobrecarga de cifrado. Esto hace que tls_push_record() vaya a la ruta `split = true` (que se supone que solo debe usarse al interactuar con un programa BPF adjunto), y luego se confunda aún más y acceda a la ruta tls_merge_open_record(), que luego supone que hay debe haber al menos un elemento de búfer poblado, lo que lleva a una deref NULL. Es posible tener buffers de texto plano\/texto cifrado vacíos si previamente salimos de tls_sw_sendmsg_locked() a través de la ruta tls_trim_both_msgs(). tls_sw_push_pending_record() ya maneja este caso correctamente; hagamos la misma verificación en tls_sw_splice_eof()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2214e2bb5489145aba944874d0ee1652a0a63dc8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/53f2cb491b500897a619ff6abd72f565933760f0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/944900fe2736c07288efe2d9394db4d3ca23f2c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52768","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:15.983","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: wilc1000: use vmm_table as array in wilc struct\n\nEnabling KASAN and running some iperf tests raises some memory issues with\nvmm_table:\n\nBUG: KASAN: slab-out-of-bounds in wilc_wlan_handle_txq+0x6ac\/0xdb4\nWrite of size 4 at addr c3a61540 by task wlan0-tx\/95\n\nKASAN detects that we are writing data beyond range allocated to vmm_table.\nThere is indeed a mismatch between the size passed to allocator in\nwilc_wlan_init, and the range of possible indexes used later: allocation\nsize is missing a multiplication by sizeof(u32)"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: wifi: wilc1000: use vmm_table como matriz en wilc struct. Al habilitar KASAN y ejecutar algunas pruebas de iperf se generan algunos problemas de memoria con vmm_table: BUG: KASAN: slab-out-of-bounds en wilc_wlan_handle_txq +0x6ac\/0xdb4 Escritura de tamaño 4 en la dirección c3a61540 mediante la tarea wlan0-tx\/95 KASAN detecta que estamos escribiendo datos más allá del rango asignado a vmm_table. De hecho, existe una discrepancia entre el tamaño pasado al asignador en wilc_wlan_init y el rango de posibles índices utilizados más adelante: al tamaño de la asignación le falta una multiplicación por sizeof(u32)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/05ac1a198a63ad66bf5ae8b7321407c102d40ef3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3ce1c2c3999b232258f7aabab311d47dda75605c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4b0d6ddb6466d10df878a7787f175a0e4adc3e27","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/541b3757fd443a68ed8d25968eae511a8275e7c8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6aaf7cd8bdfe245d3c9a8b48fe70c2011965948e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52769","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.140","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath12k: fix htt mlo-offset event locking\n\nThe ath12k active pdevs are protected by RCU but the htt mlo-offset\nevent handling code calling ath12k_mac_get_ar_by_pdev_id() was not\nmarked as a read-side critical section.\n\nMark the code in question as an RCU read-side critical section to avoid\nany potential use-after-free issues.\n\nCompile tested only."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: wifi: ath12k: corrige el bloqueo de eventos htt mlo-offset Los pdevs activos de ath12k están protegidos por RCU, pero el código de manejo de eventos htt mlo-offset que llama a ath12k_mac_get_ar_by_pdev_id() no se marcó como read-side de Sección crítica. Marque el código en cuestión como una sección crítica del lado de lectura de RCU para evitar posibles problemas de use after free. Compilación probada únicamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6afc57ea315e0f660b1f870a681737bb7b71faef","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/afd3425bd69610f318403084fe491e24a1357fb9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d908ca431e20b0e4bfc5d911d1744910ed779bdb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52770","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.220","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: split initial and dynamic conditions for extent_cache\n\nLet's allocate the extent_cache tree without dynamic conditions to avoid a\nmissing condition causing a panic as below.\n\n # create a file w\/ a compressed flag\n # disable the compression\n # panic while updating extent_cache\n\nF2FS-fs (dm-64): Swapfile: last extent is not aligned to section\nF2FS-fs (dm-64): Swapfile (3) is not align to section: 1) creat(), 2) ioctl(F2FS_IOC_SET_PIN_FILE), 3) fallocate(2097152 * N)\nAdding 124996k swap on .\/swap-file.  Priority:0 extents:2 across:17179494468k\n==================================================================\nBUG: KASAN: null-ptr-deref in instrument_atomic_read_write out\/common\/include\/linux\/instrumented.h:101 [inline]\nBUG: KASAN: null-ptr-deref in atomic_try_cmpxchg_acquire out\/common\/include\/asm-generic\/atomic-instrumented.h:705 [inline]\nBUG: KASAN: null-ptr-deref in queued_write_lock out\/common\/include\/asm-generic\/qrwlock.h:92 [inline]\nBUG: KASAN: null-ptr-deref in __raw_write_lock out\/common\/include\/linux\/rwlock_api_smp.h:211 [inline]\nBUG: KASAN: null-ptr-deref in _raw_write_lock+0x5a\/0x110 out\/common\/kernel\/locking\/spinlock.c:295\nWrite of size 4 at addr 0000000000000030 by task syz-executor154\/3327\n\nCPU: 0 PID: 3327 Comm: syz-executor154 Tainted: G           O      5.10.185 #1\nHardware name: emulation qemu-x86\/qemu-x86, BIOS 2023.01-21885-gb3cc1cd24d 01\/01\/2023\nCall Trace:\n __dump_stack out\/common\/lib\/dump_stack.c:77 [inline]\n dump_stack_lvl+0x17e\/0x1c4 out\/common\/lib\/dump_stack.c:118\n __kasan_report+0x16c\/0x260 out\/common\/mm\/kasan\/report.c:415\n kasan_report+0x51\/0x70 out\/common\/mm\/kasan\/report.c:428\n kasan_check_range+0x2f3\/0x340 out\/common\/mm\/kasan\/generic.c:186\n __kasan_check_write+0x14\/0x20 out\/common\/mm\/kasan\/shadow.c:37\n instrument_atomic_read_write out\/common\/include\/linux\/instrumented.h:101 [inline]\n atomic_try_cmpxchg_acquire out\/common\/include\/asm-generic\/atomic-instrumented.h:705 [inline]\n queued_write_lock out\/common\/include\/asm-generic\/qrwlock.h:92 [inline]\n __raw_write_lock out\/common\/include\/linux\/rwlock_api_smp.h:211 [inline]\n _raw_write_lock+0x5a\/0x110 out\/common\/kernel\/locking\/spinlock.c:295\n __drop_extent_tree+0xdf\/0x2f0 out\/common\/fs\/f2fs\/extent_cache.c:1155\n f2fs_drop_extent_tree+0x17\/0x30 out\/common\/fs\/f2fs\/extent_cache.c:1172\n f2fs_insert_range out\/common\/fs\/f2fs\/file.c:1600 [inline]\n f2fs_fallocate+0x19fd\/0x1f40 out\/common\/fs\/f2fs\/file.c:1764\n vfs_fallocate+0x514\/0x9b0 out\/common\/fs\/open.c:310\n ksys_fallocate out\/common\/fs\/open.c:333 [inline]\n __do_sys_fallocate out\/common\/fs\/open.c:341 [inline]\n __se_sys_fallocate out\/common\/fs\/open.c:339 [inline]\n __x64_sys_fallocate+0xb8\/0x100 out\/common\/fs\/open.c:339\n do_syscall_64+0x35\/0x50 out\/common\/arch\/x86\/entry\/common.c:46"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: f2fs: condiciones iniciales y dinámicas divididas para extend_cache. Asignemos el árbol extend_cache sin condiciones dinámicas para evitar que una condición faltante cause pánico como se muestra a continuación. # crear un archivo con una bandera comprimida # desactivar la compresión # entrar en pánico al actualizar extend_cache F2FS-fs (dm-64): Swapfile: la última extensión no está alineada con la sección F2FS-fs (dm-64): Swapfile (3) es no alinearse con la sección: 1) creat(), 2) ioctl(F2FS_IOC_SET_PIN_FILE), 3) fallocate(2097152 * N) Agregando 124996k swap en .\/swap-file. Prioridad:0 extensiones:2 a través de:17179494468k ========================================== ========================= ERROR: KASAN: null-ptr-deref en instrument_atomic_read_write out\/common\/include\/linux\/instrumented.h:101 [ en línea] ERROR: KASAN: null-ptr-deref en atomic_try_cmpxchg_acquire out\/common\/include\/asm-generic\/atomic-instrumented.h:705 [en línea] ERROR: KASAN: null-ptr-deref en queued_write_lock out\/common\/include\/ asm-generic\/qrwlock.h:92 [en línea] ERROR: KASAN: null-ptr-deref en __raw_write_lock out\/common\/include\/linux\/rwlock_api_smp.h:211 [en línea] ERROR: KASAN: null-ptr-deref en _raw_write_lock +0x5a\/0x110 out\/common\/kernel\/locking\/spinlock.c:295 Escritura de tamaño 4 en la dirección 0000000000000030 por tarea syz-executor154\/3327 CPU: 0 PID: 3327 Comm: syz-executor154 Contaminado: GO 5.10.185 #1 Nombre del hardware: emulación qemu-x86\/qemu-x86, BIOS 2023.01-21885-gb3cc1cd24d 01\/01\/2023 Seguimiento de llamadas: dump_stack out\/common\/lib\/dump_stack.c:77 [inline] dump_stack_lvl+0x17e\/0x1c4 out\/common\/lib\/dump_stack.c:118 __kasan_report+0x16c\/0x260 out\/common\/mm\/kasan\/report.c:415 kasan_report+0x51\/0x70 out\/common\/mm\/kasan\/report.c:428 kasan_check_range+0x2f3\/0x340 out\/common\/mm\/kasan\/generic.c:186 __kasan_check_write+0x14\/0x20 out\/common\/mm\/kasan\/shadow.c:37 instrument_atomic_read_write out\/common\/include\/linux\/instrumented.h:101 [inline] atomic_try_cmpxchg_acquire out\/common\/include\/asm-generic\/atomic-instrumented.h:705 [inline] queued_write_lock out\/common\/include\/asm-generic\/qrwlock.h:92 [inline] __raw_write_lock out\/common\/include\/linux\/rwlock_api_smp.h:211 [inline] _raw_write_lock+0x5a\/0x110 out\/common\/kernel\/locking\/spinlock.c:295 __drop_extent_tree+0xdf\/0x2f0 out\/common\/fs\/f2fs\/extent_cache.c:1155 f2fs_drop_extent_tree+0x17\/0x30 out\/common\/fs\/f2fs\/extent_cache.c:1172 f2fs_insert_range out\/common\/fs\/f2fs\/file.c:1600 [inline] f2fs_fallocate+0x19fd\/0x1f40 out\/common\/fs\/f2fs\/file.c:1764 vfs_fallocate+0x514\/0x9b0 out\/common\/fs\/open.c:310 ksys_fallocate out\/common\/fs\/open.c:333 [inline] __do_sys_fallocate out\/common\/fs\/open.c:341 [inline] __se_sys_fallocate out\/common\/fs\/open.c:339 [inline] __x64_sys_fallocate+0xb8\/0x100 out\/common\/fs\/open.c:339 do_syscall_64+0x35\/0x50 out\/common\/arch\/x86\/entry\/common.c:46"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/9de787139b0258a5dd1f498780c26d76b61d2958","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d83309e7e006cee8afca83523559017c824fbf7a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f803982190f0265fd36cf84670aa6daefc2b0768","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52771","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.323","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncxl\/port: Fix delete_endpoint() vs parent unregistration race\n\nThe CXL subsystem, at cxl_mem ->probe() time, establishes a lineage of\nports (struct cxl_port objects) between an endpoint and the root of a\nCXL topology. Each port including the endpoint port is attached to the\ncxl_port driver.\n\nGiven that setup, it follows that when either any port in that lineage\ngoes through a cxl_port ->remove() event, or the memdev goes through a\ncxl_mem ->remove() event. The hierarchy below the removed port, or the\nentire hierarchy if the memdev is removed needs to come down.\n\nThe delete_endpoint() callback is careful to check whether it is being\ncalled to tear down the hierarchy, or if it is only being called to\nteardown the memdev because an ancestor port is going through\n->remove().\n\nThat care needs to take the device_lock() of the endpoint's parent.\nWhich requires 2 bugs to be fixed:\n\n1\/ A reference on the parent is needed to prevent use-after-free\n   scenarios like this signature:\n\n    BUG: spinlock bad magic on CPU#0, kworker\/u56:0\/11\n    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS edk2-20230524-3.fc38 05\/24\/2023\n    Workqueue: cxl_port detach_memdev [cxl_core]\n    RIP: 0010:spin_bug+0x65\/0xa0\n    Call Trace:\n      do_raw_spin_lock+0x69\/0xa0\n     __mutex_lock+0x695\/0xb80\n     delete_endpoint+0xad\/0x150 [cxl_core]\n     devres_release_all+0xb8\/0x110\n     device_unbind_cleanup+0xe\/0x70\n     device_release_driver_internal+0x1d2\/0x210\n     detach_memdev+0x15\/0x20 [cxl_core]\n     process_one_work+0x1e3\/0x4c0\n     worker_thread+0x1dd\/0x3d0\n\n2\/ In the case of RCH topologies, the parent device that needs to be\n   locked is not always @port->dev as returned by cxl_mem_find_port(), use\n   endpoint->dev.parent instead."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: cxl\/port: corrige delete_endpoint() frente a la ejecución de cancelación del registro principal. El subsistema CXL, en el momento cxl_mem -&gt;probe(), establece un linaje de puertos (objetos struct cxl_port) entre un punto final y la raíz de una topología CXL. Cada puerto, incluido el puerto del punto final, está conectado al controlador cxl_port. Dada esa configuración, se deduce que cuando cualquier puerto en ese linaje pasa por un evento cxl_port -&gt;remove(), o el memdev pasa por un evento cxl_mem -&gt;remove(). La jerarquía debajo del puerto eliminado, o toda la jerarquía si se elimina el memdev, debe bajar. La devolución de llamada delete_endpoint() tiene cuidado de verificar si se llama para derribar la jerarquía o si solo se llama para derribar memdev porque un puerto ancestro está pasando por -&gt;remove(). Ese cuidado debe tenerse en cuenta con el dispositivo_lock() del padre del punto final. Lo que requiere la corrección de 2 errores: 1\/ Se necesita una referencia en el padre para evitar escenarios de use after free como esta firma: ERROR: spinlock bad magic en CPU#0, kworker\/u56:0\/11 Nombre del hardware: QEMU PC estándar (Q35 + ICH9, 2009), BIOS edk2-20230524-3.fc38 24\/05\/2023 Cola de trabajo: cxl_port detach_memdev [cxl_core] RIP: 0010:spin_bug+0x65\/0xa0 Seguimiento de llamadas: do_raw_spin_lock+0x69\/0xa0 5 \/0xb80 delete_endpoint+0xad\/0x150 [cxl_core] devres_release_all+0xb8\/0x110 device_unbind_cleanup+0xe\/0x70 device_release_driver_internal+0x1d2\/0x210 detach_memdev+0x15\/0x20 [cxl_core] proceso_one_work+0x1e3\/0x4c0 _thread+0x1dd\/0x3d0 2\/ En el caso de RCH topologías, el dispositivo principal que debe bloquearse no siempre es @port-&gt;dev como lo devuelve cxl_mem_find_port(); utilice endpoint-&gt;dev.parent en su lugar."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/37179fcc916bce8c3cc7b36d67ef814cce55142b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6b2e428e673b3f55965674a426c40922e91388aa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8d2ad999ca3c64cb08cf6a58d227b9d9e746d708","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52772","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.390","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: fix use-after-free in unix_stream_read_actor()\n\nsyzbot reported the following crash [1]\n\nAfter releasing unix socket lock, u->oob_skb can be changed\nby another thread. We must temporarily increase skb refcount\nto make sure this other thread will not free the skb under us.\n\n[1]\n\nBUG: KASAN: slab-use-after-free in unix_stream_read_actor+0xa7\/0xc0 net\/unix\/af_unix.c:2866\nRead of size 4 at addr ffff88801f3b9cc4 by task syz-executor107\/5297\n\nCPU: 1 PID: 5297 Comm: syz-executor107 Not tainted 6.6.0-syzkaller-15910-gb8e3a87a627b #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 10\/09\/2023\nCall Trace:\n<TASK>\n__dump_stack lib\/dump_stack.c:88 [inline]\ndump_stack_lvl+0xd9\/0x1b0 lib\/dump_stack.c:106\nprint_address_description mm\/kasan\/report.c:364 [inline]\nprint_report+0xc4\/0x620 mm\/kasan\/report.c:475\nkasan_report+0xda\/0x110 mm\/kasan\/report.c:588\nunix_stream_read_actor+0xa7\/0xc0 net\/unix\/af_unix.c:2866\nunix_stream_recv_urg net\/unix\/af_unix.c:2587 [inline]\nunix_stream_read_generic+0x19a5\/0x2480 net\/unix\/af_unix.c:2666\nunix_stream_recvmsg+0x189\/0x1b0 net\/unix\/af_unix.c:2903\nsock_recvmsg_nosec net\/socket.c:1044 [inline]\nsock_recvmsg+0xe2\/0x170 net\/socket.c:1066\n____sys_recvmsg+0x21f\/0x5c0 net\/socket.c:2803\n___sys_recvmsg+0x115\/0x1a0 net\/socket.c:2845\n__sys_recvmsg+0x114\/0x1e0 net\/socket.c:2875\ndo_syscall_x64 arch\/x86\/entry\/common.c:51 [inline]\ndo_syscall_64+0x3f\/0x110 arch\/x86\/entry\/common.c:82\nentry_SYSCALL_64_after_hwframe+0x63\/0x6b\nRIP: 0033:0x7fc67492c559\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fc6748ab228 EFLAGS: 00000246 ORIG_RAX: 000000000000002f\nRAX: ffffffffffffffda RBX: 000000000000001c RCX: 00007fc67492c559\nRDX: 0000000040010083 RSI: 0000000020000140 RDI: 0000000000000004\nRBP: 00007fc6749b6348 R08: 00007fc6748ab6c0 R09: 00007fc6748ab6c0\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007fc6749b6340\nR13: 00007fc6749b634c R14: 00007ffe9fac52a0 R15: 00007ffe9fac5388\n<\/TASK>\n\nAllocated by task 5295:\nkasan_save_stack+0x33\/0x50 mm\/kasan\/common.c:45\nkasan_set_track+0x25\/0x30 mm\/kasan\/common.c:52\n__kasan_slab_alloc+0x81\/0x90 mm\/kasan\/common.c:328\nkasan_slab_alloc include\/linux\/kasan.h:188 [inline]\nslab_post_alloc_hook mm\/slab.h:763 [inline]\nslab_alloc_node mm\/slub.c:3478 [inline]\nkmem_cache_alloc_node+0x180\/0x3c0 mm\/slub.c:3523\n__alloc_skb+0x287\/0x330 net\/core\/skbuff.c:641\nalloc_skb include\/linux\/skbuff.h:1286 [inline]\nalloc_skb_with_frags+0xe4\/0x710 net\/core\/skbuff.c:6331\nsock_alloc_send_pskb+0x7e4\/0x970 net\/core\/sock.c:2780\nsock_alloc_send_skb include\/net\/sock.h:1884 [inline]\nqueue_oob net\/unix\/af_unix.c:2147 [inline]\nunix_stream_sendmsg+0xb5f\/0x10a0 net\/unix\/af_unix.c:2301\nsock_sendmsg_nosec net\/socket.c:730 [inline]\n__sock_sendmsg+0xd5\/0x180 net\/socket.c:745\n____sys_sendmsg+0x6ac\/0x940 net\/socket.c:2584\n___sys_sendmsg+0x135\/0x1d0 net\/socket.c:2638\n__sys_sendmsg+0x117\/0x1e0 net\/socket.c:2667\ndo_syscall_x64 arch\/x86\/entry\/common.c:51 [inline]\ndo_syscall_64+0x3f\/0x110 arch\/x86\/entry\/common.c:82\nentry_SYSCALL_64_after_hwframe+0x63\/0x6b\n\nFreed by task 5295:\nkasan_save_stack+0x33\/0x50 mm\/kasan\/common.c:45\nkasan_set_track+0x25\/0x30 mm\/kasan\/common.c:52\nkasan_save_free_info+0x2b\/0x40 mm\/kasan\/generic.c:522\n____kasan_slab_free mm\/kasan\/common.c:236 [inline]\n____kasan_slab_free+0x15b\/0x1b0 mm\/kasan\/common.c:200\nkasan_slab_free include\/linux\/kasan.h:164 [inline]\nslab_free_hook mm\/slub.c:1800 [inline]\nslab_free_freelist_hook+0x114\/0x1e0 mm\/slub.c:1826\nslab_free mm\/slub.c:3809 [inline]\nkmem_cache_free+0xf8\/0x340 mm\/slub.c:3831\nkfree_skbmem+0xef\/0x1b0 net\/core\/skbuff.c:1015\n__kfree_skb net\/core\/skbuff.c:1073 [inline]\nconsume_skb net\/core\/skbuff.c:1288 [inline]\nconsume_skb+0xdf\/0x170 net\/core\/skbuff.c:1282\nqueue_oob net\/unix\/af_unix.c:2178 [inline]\nu\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: af_unix: corrige use-after-free en unix_stream_read_actor() syzbot informó el siguiente bloqueo [1] Después de liberar el bloqueo del socket Unix, otro subproceso puede cambiar u-&gt;oob_skb. Debemos aumentar temporalmente el recuento de skb para asegurarnos de que este otro hilo no libere el skb que está debajo de nosotros. [1] ERROR: KASAN: slab-use-after-free en unix_stream_read_actor+0xa7\/0xc0 net\/unix\/af_unix.c:2866 Lectura de tamaño 4 en la dirección ffff88801f3b9cc4 por tarea syz-executor107\/5297 CPU: 1 PID: 5297 Comm : syz-executor107 No contaminado 6.6.0-syzkaller-15910-gb8e3a87a627b #0 Nombre del hardware: Google Google Compute Engine\/Google Compute Engine, BIOS Google 09\/10\/2023 Seguimiento de llamadas:  __dump_stack lib\/dump_stack.c:88 [en línea] dump_stack_lvl+0xd9\/0x1b0 lib\/dump_stack.c:106 print_address_description mm\/kasan\/report.c:364 [en línea] print_report+0xc4\/0x620 mm\/kasan\/report.c:475 kasan_report+0xda\/0x110 mm\/kasan \/report.c:588 unix_stream_read_actor+0xa7\/0xc0 net\/unix\/af_unix.c:2866 unix_stream_recv_urg net\/unix\/af_unix.c:2587 [en línea] unix_stream_read_generic+0x19a5\/0x2480 net\/unix\/af_unix.c:2666 +0x189 \/0x1b0 net\/unix\/af_unix.c:2903 sock_recvmsg_nosec net\/socket.c:1044 [en línea] sock_recvmsg+0xe2\/0x170 net\/socket.c:1066 ____sys_recvmsg+0x21f\/0x5c0 net\/socket.c:2803 ___sys_recv mensaje+0x115\/ 0x1a0 net\/socket.c:2845 __sys_recvmsg+0x114\/0x1e0 net\/socket.c:2875 do_syscall_x64 arch\/x86\/entry\/common.c:51 [en línea] do_syscall_64+0x3f\/0x110 arch\/x86\/entry\/common.c: 82 Entry_SYSCALL_64_after_hwframe+0x63\/0x6b RIP: 0033:0x7fc67492c559 Código: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48 89 f7 48 89 d 6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fc6748ab228 EFLAGS: 00000246 ORIG_RAX: 0000002f RAX: ffffffffffffffda RBX: 000000000000001c RCX: 00007fc67492c559 RDX : 0000000040010083 RSI: 0000000020000140 RDI: 0000000000000004 RBP: 00007fc6749b6348 R08: 00007fc6748ab6c0 R09: 00007fc6748ab6c0 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fc6749b6340 R13: 00007fc6749b634c R14: 00007ffe9fac52a0 R15: 00007ffe9fac5388  tarea 5295: kasan_save_stack+0x33\/0x50 mm \/kasan\/common.c:45 kasan_set_track+0x25\/0x30 mm\/kasan\/common.c:52 __kasan_slab_alloc+0x81\/0x90 mm\/kasan\/common.c:328 kasan_slab_alloc include\/linux\/kasan.h:188 [en línea] slab_post_alloc_hook mm\/slab.h:763 [en línea] slab_alloc_node mm\/slub.c:3478 [en línea] kmem_cache_alloc_node+0x180\/0x3c0 mm\/slub.c:3523 __alloc_skb+0x287\/0x330 net\/core\/skbuff.c:641 alloc_skb include\/ linux\/skbuff.h:1286 [en línea] alloc_skb_with_frags+0xe4\/0x710 net\/core\/skbuff.c:6331 sock_alloc_send_pskb+0x7e4\/0x970 net\/core\/sock.c:2780 sock_alloc_send_skb include\/net\/sock.h:1884 [en línea ] queue_oob net\/unix\/af_unix.c:2147 [en línea] unix_stream_sendmsg+0xb5f\/0x10a0 net\/unix\/af_unix.c:2301 sock_sendmsg_nosec net\/socket.c:730 [en línea] __sock_sendmsg+0xd5\/0x180 net\/socket.c: 745 ____sys_sendmsg+0x6ac\/0x940 net\/socket.c:2584 ___sys_sendmsg+0x135\/0x1d0 net\/socket.c:2638 __sys_sendmsg+0x117\/0x1e0 net\/socket.c:2667 do_syscall_x64 arch\/x86\/entry\/ common.c:51 [ Inline] do_syscall_64+0x3f\/0x110 Arch\/x86\/entry\/Common.c: 82 entry_syscall_64_after_hwframe+0x63\/0x6b liberado por tarea 5295: kasan_save_stack+0x33\/0x50 mm\/kasan\/common.c:52 kasan_save_free_info+0x2b\/0x40 mm\/kasan\/generic.c:522 ____kasan_slab_free mm\/kasan\/common.c:236 [en línea] ____kasan_slab_free+0x15b\/0x1b0 mm\/kasan\/common.c:200 kasan_slab_free include\/ linux\/kasan.h:164 [en línea] slab_free_hook mm\/slub.c:1800 [en línea] slab_free_freelist_hook+0x114\/0x1e0 mm\/slub.c:1826 slab_free mm\/slub.c:3809 [en línea] kmem_cache_free+0xf8\/0x340 mm \/slub.c:3831 kfree_skbmem+0xef\/0x1b0 net\/core\/skbuff.c:1015 __kfree_skb net\/core\/skbuff.c:1073 [en línea] consume_skb net\/core\/skbuff.c:1288 [en línea] consume_skb+0xdf\/ 0x170 net\/core\/skbuff.c:1282 queue_oob net\/unix\/af_unix.c:2178 [en línea] u ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/069a3ec329ff43e7869a3d94c62cd03203016bce","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4b7b492615cf3017190f55444f7016812b66611d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/75bcfc188abf4fae9c1d5f5dc0a03540be602eef","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d179189eec426fe4801e4b91efa1889faed12700","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eae0b295ce16d8c8b4114c3037993191b4bb92f0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52773","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.467","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/display: fix a NULL pointer dereference in amdgpu_dm_i2c_xfer()\n\nWhen ddc_service_construct() is called, it explicitly checks both the\nlink type and whether there is something on the link which will\ndictate whether the pin is marked as hw_supported.\n\nIf the pin isn't set or the link is not set (such as from\nunloading\/reloading amdgpu in an IGT test) then fail the\namdgpu_dm_i2c_xfer() call."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amd\/display: corrige una desreferencia de puntero NULL en amdgpu_dm_i2c_xfer(). Cuando se llama a ddc_service_construct(), comprueba explícitamente tanto el tipo de enlace como si hay algo en el enlace que dictará si el pin está marcado como hw_supported. Si el pin no está configurado o el enlace no está configurado (por ejemplo, al descargar\/recargar amdgpu en una prueba de IGT), falle la llamada amdgpu_dm_i2c_xfer()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1d07b7e84276777dad3c8cfebdf8e739606f90c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5b14cf37b9f01de0b28c6f8960019d4c7883ce42","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b71f4ade1b8900d30c661d6c27f87c35214c398c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fb5c134ca589fe670430acc9e7ebf2691ca2476d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52774","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.537","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ns390\/dasd: protect device queue against concurrent access\n\nIn dasd_profile_start() the amount of requests on the device queue are\ncounted. The access to the device queue is unprotected against\nconcurrent access. With a lot of parallel I\/O, especially with alias\ndevices enabled, the device queue can change while dasd_profile_start()\nis accessing the queue. In the worst case this leads to a kernel panic\ndue to incorrect pointer accesses.\n\nFix this by taking the device lock before accessing the queue and\ncounting the requests. Additionally the check for a valid profile data\npointer can be done earlier to avoid unnecessary locking in a hot path."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: s390\/dasd: protege la cola de dispositivos contra el acceso concurrente. En dasd_profile_start() se cuenta la cantidad de solicitudes en la cola de dispositivos. El acceso a la cola de dispositivos no está protegido contra el acceso simultáneo. Con muchas E\/S paralelas, especialmente con dispositivos alias habilitados, la cola de dispositivos puede cambiar mientras dasd_profile_start() accede a la cola. En el peor de los casos, esto provoca un pánico en el kernel debido a accesos incorrectos al puntero. Solucione este problema bloqueando el dispositivo antes de acceder a la cola y contando las solicitudes. Además, la verificación de un puntero de datos de perfil válido se puede realizar antes para evitar bloqueos innecesarios en una ruta activa."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6062c527d0403cef27c54b91ac8390c3a497b250","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9372aab5d0ff621ea203c8c603e7e5f75e888240","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c841de6247e94e07566d57163d3c0d8b29278f7a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/db46cd1e0426f52999d50fa72cfa97fa39952885","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dc96fde8fcb2b896fd6c64802a7f4ece2e69b0be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ebdc569a07a3e8dbe66b4184922ad6f88ac0b96f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f1ac7789406e2ca9ac51c41ad2daa597f47bdd4d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f75617cc8df4155374132f0b500b0b3ebb967458","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52775","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.610","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/smc: avoid data corruption caused by decline\n\nWe found a data corruption issue during testing of SMC-R on Redis\napplications.\n\nThe benchmark has a low probability of reporting a strange error as\nshown below.\n\n\"Error: Protocol error, got \"\\xe2\" as reply type byte\"\n\nFinally, we found that the retrieved error data was as follows:\n\n0xE2 0xD4 0xC3 0xD9 0x04 0x00 0x2C 0x20 0xA6 0x56 0x00 0x16 0x3E 0x0C\n0xCB 0x04 0x02 0x01 0x00 0x00 0x20 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xE2\n\nIt is quite obvious that this is a SMC DECLINE message, which means that\nthe applications received SMC protocol message.\nWe found that this was caused by the following situations:\n\nclient                  server\n        ¦  clc proposal\n        ------------->\n        ¦  clc accept\n        <-------------\n        ¦  clc confirm\n        ------------->\nwait llc confirm\n\t\t\tsend llc confirm\n        ¦failed llc confirm\n        ¦   x------\n(after 2s)timeout\n                        wait llc confirm rsp\n\nwait decline\n\n(after 1s) timeout\n                        (after 2s) timeout\n        ¦   decline\n        -------------->\n        ¦   decline\n        <--------------\n\nAs a result, a decline message was sent in the implementation, and this\nmessage was read from TCP by the already-fallback connection.\n\nThis patch double the client timeout as 2x of the server value,\nWith this simple change, the Decline messages should never cross or\ncollide (during Confirm link timeout).\n\nThis issue requires an immediate solution, since the protocol updates\ninvolve a more long-term solution."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: net\/smc: evita la corrupción de datos causada por el rechazo. Encontramos un problema de corrupción de datos durante las pruebas de SMC-R en aplicaciones Redis. El punto de referencia tiene una baja probabilidad de informar un error extraño, como se muestra a continuación. \"Error: Error de protocolo, obtuve \"\\xe2\" como byte de tipo de respuesta\" Finalmente, encontramos que los datos de error recuperados eran los siguientes: 0xE2 0xD4 0xC3 0xD9 0x04 0x00 0x2C 0x20 0xA6 0x56 0x00 0x16 0x3E 0x0C 0xCB 0x04 0x02 1 0x00 0x00 0x20 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xE2 Es bastante obvio que este es un mensaje SMC DECLINE, lo que significa que las aplicaciones recibieron un mensaje de protocolo SMC. Descubrimos que esto se debía a las siguientes situaciones: cliente servidor ¦ propuesta clc -------------&gt; ¦ clc aceptar &lt;------------- ¦ clc confirmar -------------&gt; esperar confirmación de llc enviar confirmación de llc ¦ confirmación de llc fallida ¦ x------ (después de 2 s) tiempo de espera de espera llc confirmar rsp esperar declinar (después de 1 s) tiempo de espera (después de 2s) tiempo de espera ¦ rechazo --------------&gt; ¦ rechazo &lt;-------------- Como resultado, se envió un mensaje de rechazo en la implementación, y este mensaje fue leído desde TCP por la conexión que ya estaba en reserva. Este parche duplica el tiempo de espera del cliente al doble del valor del servidor. Con este simple cambio, los mensajes de rechazo nunca deberían cruzarse ni colisionar (durante el tiempo de espera de confirmación del enlace). Este problema requiere una solución inmediata, ya que las actualizaciones del protocolo implican una solución a más largo plazo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5ada292b5c504720a0acef8cae9acc62a694d19c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7234d2b5dffa5af77fd4e0deaebab509e130c6b1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90072af9efe8c7bd7d086709014ddd44cebd5e7c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/94a0ae698b4d5d5bb598e23228002a1491c50add","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e6d71b437abc2f249e3b6a1ae1a7228e09c6e563","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52776","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.680","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath12k: fix dfs-radar and temperature event locking\n\nThe ath12k active pdevs are protected by RCU but the DFS-radar and\ntemperature event handling code calling ath12k_mac_get_ar_by_pdev_id()\nwas not marked as a read-side critical section.\n\nMark the code in question as RCU read-side critical sections to avoid\nany potential use-after-free issues.\n\nNote that the temperature event handler looks like a place holder\ncurrently but would still trigger an RCU lockdep splat.\n\nCompile tested only."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: wifi: ath12k: corrige el bloqueo de eventos de temperatura y radar dfs. Los pdev activos de ath12k están protegidos por RCU, pero el código de manejo de eventos de temperatura y radar DFS que llama a ath12k_mac_get_ar_by_pdev_id() no estaba marcado como una sección crítica del lado de lectura. Marque el código en cuestión como secciones críticas del lado de lectura de RCU para evitar posibles problemas de use after free. Tenga en cuenta que el controlador de eventos de temperatura actualmente parece un marcador de posición, pero aún así activaría un bloqueo de bloqueo de RCU. Compilación probada únicamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/69bd216e049349886405b1c87a55dce3d35d1ba7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/774de37c147fea81f2c2e4be5082304f4f71d535","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d7a5f7f76568e48869916d769e28b9f3ca70c78e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52777","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.747","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: fix gtk offload status event locking\n\nThe ath11k active pdevs are protected by RCU but the gtk offload status\nevent handling code calling ath11k_mac_get_arvif_by_vdev_id() was not\nmarked as a read-side critical section.\n\nMark the code in question as an RCU read-side critical section to avoid\nany potential use-after-free issues.\n\nCompile tested only."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: wifi: ath11k: corrige el bloqueo de eventos de estado de descarga de gtk. Los pdevs activos de ath11k están protegidos por RCU, pero el código de manejo de eventos de estado de descarga de gtk que llama a ath11k_mac_get_arvif_by_vdev_id() no se marcó como lado de lectura sección crítica. Marque el código en cuestión como una sección crítica del lado de lectura de RCU para evitar posibles problemas de use after free. Compilación probada únicamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0cf7577b6b3153b4b49deea9719fe43f96469c6d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1dea3c0720a146bd7193969f2847ccfed5be2221","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cf9c7d783a2bf9305df4ef5b93d9063a52e18fca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e83246ecd3b193f8d91fce778e8a5ba747fc7d8a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52778","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.817","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: deal with large GSO size\n\nAfter the blamed commit below, the TCP sockets (and the MPTCP subflows)\ncan build egress packets larger than 64K. That exceeds the maximum DSS\ndata size, the length being misrepresent on the wire and the stream being\ncorrupted, as later observed on the receiver:\n\n  WARNING: CPU: 0 PID: 9696 at net\/mptcp\/protocol.c:705 __mptcp_move_skbs_from_subflow+0x2604\/0x26e0\n  CPU: 0 PID: 9696 Comm: syz-executor.7 Not tainted 6.6.0-rc5-gcd8bdf563d46 #45\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-2.el7 04\/01\/2014\n  netlink: 8 bytes leftover after parsing attributes in process `syz-executor.4'.\n  RIP: 0010:__mptcp_move_skbs_from_subflow+0x2604\/0x26e0 net\/mptcp\/protocol.c:705\n  RSP: 0018:ffffc90000006e80 EFLAGS: 00010246\n  RAX: ffffffff83e9f674 RBX: ffff88802f45d870 RCX: ffff888102ad0000\n  netlink: 8 bytes leftover after parsing attributes in process `syz-executor.4'.\n  RDX: 0000000080000303 RSI: 0000000000013908 RDI: 0000000000003908\n  RBP: ffffc90000007110 R08: ffffffff83e9e078 R09: 1ffff1100e548c8a\n  R10: dffffc0000000000 R11: ffffed100e548c8b R12: 0000000000013908\n  R13: dffffc0000000000 R14: 0000000000003908 R15: 000000000031cf29\n  FS:  00007f239c47e700(0000) GS:ffff88811b200000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007f239c45cd78 CR3: 000000006a66c006 CR4: 0000000000770ef0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\n  PKRU: 55555554\n  Call Trace:\n   <IRQ>\n   mptcp_data_ready+0x263\/0xac0 net\/mptcp\/protocol.c:819\n   subflow_data_ready+0x268\/0x6d0 net\/mptcp\/subflow.c:1409\n   tcp_data_queue+0x21a1\/0x7a60 net\/ipv4\/tcp_input.c:5151\n   tcp_rcv_established+0x950\/0x1d90 net\/ipv4\/tcp_input.c:6098\n   tcp_v6_do_rcv+0x554\/0x12f0 net\/ipv6\/tcp_ipv6.c:1483\n   tcp_v6_rcv+0x2e26\/0x3810 net\/ipv6\/tcp_ipv6.c:1749\n   ip6_protocol_deliver_rcu+0xd6b\/0x1ae0 net\/ipv6\/ip6_input.c:438\n   ip6_input+0x1c5\/0x470 net\/ipv6\/ip6_input.c:483\n   ipv6_rcv+0xef\/0x2c0 include\/linux\/netfilter.h:304\n   __netif_receive_skb+0x1ea\/0x6a0 net\/core\/dev.c:5532\n   process_backlog+0x353\/0x660 net\/core\/dev.c:5974\n   __napi_poll+0xc6\/0x5a0 net\/core\/dev.c:6536\n   net_rx_action+0x6a0\/0xfd0 net\/core\/dev.c:6603\n   __do_softirq+0x184\/0x524 kernel\/softirq.c:553\n   do_softirq+0xdd\/0x130 kernel\/softirq.c:454\n\nAddress the issue explicitly bounding the maximum GSO size to what MPTCP\nactually allows."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: mptcp: trata con un tamaño GSO grande. Después del compromiso culpable a continuación, los sockets TCP (y los subflujos MPTCP) pueden generar paquetes de salida de más de 64 KB. Eso excede el tamaño máximo de datos DSS, la longitud se tergiversa en el cable y la transmisión se corrompe, como se observó más tarde en el receptor: ADVERTENCIA: CPU: 0 PID: 9696 en net\/mptcp\/protocol.c:705 __mptcp_move_skbs_from_subflow+0x2604\/ 0x26e0 CPU: 0 PID: 9696 Comm: syz-executor.7 No contaminado 6.6.0-rc5-gcd8bdf563d46 #45 Nombre del hardware: PC estándar QEMU (i440FX + PIIX, 1996), BIOS 1.11.0-2.el7 04\/01 \/2014 netlink: 8 bytes sobrantes después de analizar los atributos en el proceso `syz-executor.4'. RIP: 0010:__mptcp_move_skbs_from_subflow+0x2604\/0x26e0 net\/mptcp\/protocol.c:705 RSP: 0018:ffffc90000006e80 EFLAGS: 00010246 RAX: ffffffff83e9f674 RBX: ffff88802f45 d870 RCX: ffff888102ad0000 netlink: 8 bytes sobrantes después de analizar los atributos en el proceso `syz-executor. 4'. RDX: 0000000080000303 RSI: 0000000000013908 RDI: 0000000000003908 RBP: ffffc90000007110 R08: ffffffff83e9e078 R09: 1ffff1100e548c8a R10: 0000000000 R11: fffffed100e548c8b R12: 0000000000013908 R13: dffffc0000000000 R14: 0000000000003908 R15: 000000000031cf29 FS: 00007f239c47 e700(0000) GS:ffff88811b200000(0000) knlGS: 0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f239c45cd78 CR3: 000000006a66c006 CR4: 0000000000770ef0 DR0: 0000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600 PKRU: 55555554 Llamar Seguimiento:  mptcp_data_ready +0x263\/0xac0 net\/mptcp\/protocol.c:819 subflow_data_ready+0x268\/0x6d0 net\/mptcp\/subflow.c:1409 tcp_data_queue+0x21a1\/0x7a60 net\/ipv4\/tcp_input.c:5151 tcp_rcv_establecido+0x950\/0x1d 90 netos\/ipv4\/ tcp_input.c:6098 tcp_v6_do_rcv+0x554\/0x12f0 net\/ipv6\/tcp_ipv6.c:1483 tcp_v6_rcv+0x2e26\/0x3810 net\/ipv6\/tcp_ipv6.c:1749 ip6_protocol_deliver_rcu+0xd6b\/0x1 ae0 net\/ipv6\/ip6_input.c:438 ip6_input+0x1c5 \/0x470 net\/ipv6\/ip6_input.c:483 ipv6_rcv+0xef\/0x2c0 include\/linux\/netfilter.h:304 __netif_receive_skb+0x1ea\/0x6a0 net\/core\/dev.c:5532 Process_backlog+0x353\/0x660 net\/core\/dev. c:5974 __napi_poll+0xc6\/0x5a0 net\/core\/dev.c:6536 net_rx_action+0x6a0\/0xfd0 net\/core\/dev.c:6603 __do_softirq+0x184\/0x524 kernel\/softirq.c:553 do_softirq+0xdd\/0x130 kernel\/ softirq.c:454 Aborde el problema limitando explícitamente el tamaño máximo de GSO a lo que MPTCP realmente permite."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/342b528c0e849bed9def76dadaa470d3af678e94","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/57ced2eb77343a91d28f4a73675b05fe7b555def","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/70ff9b65a72885b3a2dfde6709da1f19b85fa696","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9fce92f050f448a0d1ddd9083ef967d9930f1e52","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52779","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.890","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nfs: Pass AT_GETATTR_NOSEC flag to getattr interface function\n\nWhen vfs_getattr_nosec() calls a filesystem's getattr interface function\nthen the 'nosec' should propagate into this function so that\nvfs_getattr_nosec() can again be called from the filesystem's gettattr\nrather than vfs_getattr(). The latter would add unnecessary security\nchecks that the initial vfs_getattr_nosec() call wanted to avoid.\nTherefore, introduce the getattr flag GETATTR_NOSEC and allow to pass\nwith the new getattr_flags parameter to the getattr interface function.\nIn overlayfs and ecryptfs use this flag to determine which one of the\ntwo functions to call.\n\nIn a recent code change introduced to IMA vfs_getattr_nosec() ended up\ncalling vfs_getattr() in overlayfs, which in turn called\nsecurity_inode_getattr() on an exiting process that did not have\ncurrent->fs set anymore, which then caused a kernel NULL pointer\ndereference. With this change the call to security_inode_getattr() can\nbe avoided, thus avoiding the NULL pointer dereference."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: fs: pasar el indicador AT_GETATTR_NOSEC a la función de interfaz getattr. Cuando vfs_getattr_nosec() llama a la función de interfaz getattr de un sistema de archivos, entonces 'nosec' debe propagarse a esta función para que se pueda volver a llamar a vfs_getattr_nosec() desde gettattr del sistema de archivos en lugar de vfs_getattr(). Esto último agregaría controles de seguridad innecesarios que la llamada inicial a vfs_getattr_nosec() quería evitar. Por lo tanto, introduzca el indicador getattr GETATTR_NOSEC y permita pasar con el nuevo parámetro getattr_flags a la función de interfaz getattr. En overlayfs y ecryptfs use este indicador para determinar cuál de las dos funciones llamar. En un cambio de código reciente introducido en IMA, vfs_getattr_nosec() terminó llamando a vfs_getattr() en overlayfs, que a su vez llamó a security_inode_getattr() en un proceso saliente que ya no tenía current-&gt;fs configurado, lo que luego provocó una desreferencia del puntero NULL del kernel . Con este cambio se puede evitar la llamada a security_inode_getattr(), evitando así la desreferencia del puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3fb0fa08641903304b9d81d52a379ff031dc41d4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a924db2d7b5eb69ba08b1a0af46e9f1359a9bdf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52780","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:16.957","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: mvneta: fix calls to page_pool_get_stats\n\nCalling page_pool_get_stats in the mvneta driver without checks\nleads to kernel crashes.\nFirst the page pool is only available if the bm is not used.\nThe page pool is also not allocated when the port is stopped.\nIt can also be not allocated in case of errors.\n\nThe current implementation leads to the following crash calling\nethstats on a port that is down or when calling it at the wrong moment:\n\nble to handle kernel NULL pointer dereference at virtual address 00000070\n[00000070] *pgd=00000000\nInternal error: Oops: 5 [#1] SMP ARM\nHardware name: Marvell Armada 380\/385 (Device Tree)\nPC is at page_pool_get_stats+0x18\/0x1cc\nLR is at mvneta_ethtool_get_stats+0xa0\/0xe0 [mvneta]\npc : [<c0b413cc>]    lr : [<bf0a98d8>]    psr: a0000013\nsp : f1439d48  ip : f1439dc0  fp : 0000001d\nr10: 00000100  r9 : c4816b80  r8 : f0d75150\nr7 : bf0b400c  r6 : c238f000  r5 : 00000000  r4 : f1439d68\nr3 : c2091040  r2 : ffffffd8  r1 : f1439d68  r0 : 00000000\nFlags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none\nControl: 10c5387d  Table: 066b004a  DAC: 00000051\nRegister r0 information: NULL pointer\nRegister r1 information: 2-page vmalloc region starting at 0xf1438000 allocated at kernel_clone+0x9c\/0x390\nRegister r2 information: non-paged memory\nRegister r3 information: slab kmalloc-2k start c2091000 pointer offset 64 size 2048\nRegister r4 information: 2-page vmalloc region starting at 0xf1438000 allocated at kernel_clone+0x9c\/0x390\nRegister r5 information: NULL pointer\nRegister r6 information: slab kmalloc-cg-4k start c238f000 pointer offset 0 size 4096\nRegister r7 information: 15-page vmalloc region starting at 0xbf0a8000 allocated at load_module+0xa30\/0x219c\nRegister r8 information: 1-page vmalloc region starting at 0xf0d75000 allocated at ethtool_get_stats+0x138\/0x208\nRegister r9 information: slab task_struct start c4816b80 pointer offset 0\nRegister r10 information: non-paged memory\nRegister r11 information: non-paged memory\nRegister r12 information: 2-page vmalloc region starting at 0xf1438000 allocated at kernel_clone+0x9c\/0x390\nProcess snmpd (pid: 733, stack limit = 0x38de3a88)\nStack: (0xf1439d48 to 0xf143a000)\n9d40:                   000000c0 00000001 c238f000 bf0b400c f0d75150 c4816b80\n9d60: 00000100 bf0a98d8 00000000 00000000 00000000 00000000 00000000 00000000\n9d80: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n9da0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n9dc0: 00000dc0 5335509c 00000035 c238f000 bf0b2214 01067f50 f0d75000 c0b9b9c8\n9de0: 0000001d 00000035 c2212094 5335509c c4816b80 c238f000 c5ad6e00 01067f50\n9e00: c1b0be80 c4816b80 00014813 c0b9d7f0 00000000 00000000 0000001d 0000001d\n9e20: 00000000 00001200 00000000 00000000 c216ed90 c73943b8 00000000 00000000\n9e40: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n9e60: 00000000 c0ad9034 00000000 00000000 00000000 00000000 00000000 00000000\n9e80: 00000000 00000000 00000000 5335509c c1b0be80 f1439ee4 00008946 c1b0be80\n9ea0: 01067f50 f1439ee3 00000000 00000046 b6d77ae0 c0b383f0 00008946 becc83e8\n9ec0: c1b0be80 00000051 0000000b c68ca480 c7172d00 c0ad8ff0 f1439ee3 cf600e40\n9ee0: 01600e40 32687465 00000000 00000000 00000000 01067f50 00000000 00000000\n9f00: 00000000 5335509c 00008946 00008946 00000000 c68ca480 becc83e8 c05e2de0\n9f20: f1439fb0 c03002f0 00000006 5ac3c35a c4816b80 00000006 b6d77ae0 c030caf0\n9f40: c4817350 00000014 f1439e1c 0000000c 00000000 00000051 01000000 00000014\n9f60: 00003fec f1439edc 00000001 c0372abc b6d77ae0 c0372abc cf600e40 5335509c\n9f80: c21e6800 01015c9c 0000000b 00008946 00000036 c03002f0 c4816b80 00000036\n9fa0: b6d77ae0 c03000c0 01015c9c 0000000b 0000000b 00008946 becc83e8 00000000\n9fc0: 01015c9c 0000000b 00008946 00000036 00000035 010678a0 b6d797ec b6d77ae0\n9fe0: b6dbf738 becc838c b6d186d7 b6baa858 40000030 0000000b 00000000 00000000\n page_pool_get_s\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: mvneta: corrige llamadas a page_pool_get_stats. Llamar a page_pool_get_stats en el controlador mvneta sin comprobaciones provoca fallos del kernel. Primero, el grupo de páginas solo está disponible si no se utiliza bm. El grupo de páginas tampoco se asigna cuando se detiene el puerto. También se puede no asignar en caso de errores. La implementación actual provoca el siguiente fallo al llamar a ethstats en un puerto que está inactivo o al llamarlo en el momento equivocado: ble para manejar la desreferencia del puntero NULL del kernel en la dirección virtual 00000070 [00000070] *pgd=00000000 Error interno: Ups: 5 [ #1] Nombre del hardware SMP ARM: Marvell Armada 380\/385 (árbol de dispositivos) La PC está en page_pool_get_stats+0x18\/0x1cc LR está en mvneta_ethtool_get_stats+0xa0\/0xe0 [mvneta] pc: [] lr: [] psr: a0000013 sp: f1439d48 ip: f1439dc0 fp: 0000001d r10: 00000100 r9: c4816b80 r8: f0d75150 r7: bf0b400c r6: c238f000 r5: 00000000 : f1439d68 r3 : c2091040 r2 : ffffffd8 r1 : f1439d68 r0 : 00000000 Banderas: NzCv IRQ activadas FIQ en modo SVC_32 ISA ARM Segmento ninguno Control: 10c5387d Tabla: 066b004a DAC: 00000051 Información del registro r0: puntero NULL Información del registro r1: región vmalloc de 2 páginas que comienza en 0xf1438000 asignada en kernel_clone+0x9c\/0x390 Información del registro r2: memoria no paginada Registre información de r3: slab kmalloc-2k start c2091000 desplazamiento del puntero 64 tamaño 2048 Registre información de r4: región vmalloc de 2 páginas que comienza en 0xf1438000 asignada en kernel_clone+0x9c\/0x390 Registre información de r5: puntero NULL Registre información de r6: slab kmalloc-cg-4k inicio c238f000 desplazamiento del puntero 0 tamaño 4096 Información del registro r7: región vmalloc de 15 páginas que comienza en 0xbf0a8000 asignada en load_module+0xa30\/0x219c Información del registro r8: región vmalloc de 1 página que comienza en 0xf0d75000 asignada en ethtool_get_stats+0x138\/0x208 Información del registro r9: laboratorio task_struct start c4816b80 desplazamiento del puntero 0 Registrar información r10: memoria no paginada Registrar información r11: memoria no paginada Registrar información r12: región vmalloc de 2 páginas que comienza en 0xf1438000 asignada en kernel_clone+0x9c\/0x390 Procesar snmpd (pid: 733, límite de pila = 0x38de3a88) Pila: (0xf1439d48 a 0xf143a000) 9d40: 000000c0 00000001 c238f000 bf0b400c f0d75150 c4816b80 9d60: 00000100 bf0a98d8 000 00000000 00000000 00000000 00000000 00000000 9d80: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000000 00 9da0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 9dc0: 00000dc0 5335509c 00000035 c238f000 bf0b2214 01067f50 f0d75000 c0b9b9c8 9de0: 0000001d 00000035 c2212094 5335509c c4816b80 0 c5ad6e00 01067f50 9e00: c1b0be80 c4816b80 00014813 c0b9d7f0 00000000 00000000 0000001d 0000001d 9e20: 00000000 00001200 00000000 00000000 c216ed90 c73943b8 00000000 00000000 9e40: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 9e6 0: 00000000 c0ad9034 00000000 00000000 00000000 00000000 00000000 00000000 9e80: 00000000 00000000 00000000 5335509c c1b0be80 9ee4 00008946 c1b0be80 9ea0: 01067f50 f1439ee3 00000000 00000046 b6d77ae0 c0b383f0 00008946 becc83e8 9ec0: c1b0be80 00000051 0000000b c68ca48 0 c7172d00 c0ad8ff0 f1439ee3 cf600e40 9ee0: 01600e40 32687465 00000000 00000000 00000000 01067f50 00000000 00000000 9f00: 00000000 5335509c 00008946 00008946 00000000 c68ca480 becc83e8 c05e2de0 9f20: f1439fb0 c03002f0 00000006 5ac3c35a c4816b80 00000006 b6 d77ae0 c030caf0 9f40: c4817350 00000014 f1439e1c 0000000c 00000000 00000051 01000000 00000014 9f60: 00003fec f1439edc 00000001 c0372abc b6d77ae0 c0372abc cf600e40 5335509c 9f80: c21e6800 01015c9c 0000000b 00008946 00000036 c03002f0 c4816b80 00000036 9fa0: b6d77ae0 c03000c0 01015c9c 0000000b 0000000b 00008946 becc83e8 00000000 9fc0: 01015c9c 0000000b 00008946 00000036 00000035 8a0 b6d797ec b6d77ae0 -truncado-"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/00768b3e90e648227eaa959d9d279f5e32823df1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/230dc06e2495487d88b3410da055bb618febb19b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2b0e99072654edd601d05c0061a20337af5008ba","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca8add922f9c7f6e2e3c71039da8e0dcc64b87ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52781","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.023","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: config: fix iteration issue in 'usb_get_bos_descriptor()'\n\nThe BOS descriptor defines a root descriptor and is the base descriptor for\naccessing a family of related descriptors.\n\nFunction 'usb_get_bos_descriptor()' encounters an iteration issue when\nskipping the 'USB_DT_DEVICE_CAPABILITY' descriptor type. This results in\nthe same descriptor being read repeatedly.\n\nTo address this issue, a 'goto' statement is introduced to ensure that the\npointer and the amount read is updated correctly. This ensures that the\nfunction iterates to the next descriptor instead of reading the same\ndescriptor repeatedly."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: usb: config: soluciona el problema de iteración en 'usb_get_bos_descriptor()'. El descriptor BOS define un descriptor raíz y es el descriptor base para acceder a una familia de descriptores relacionados. La función 'usb_get_bos_descriptor()' encuentra un problema de iteración al omitir el tipo de descriptor 'USB_DT_DEVICE_CAPABILITY'. Esto da como resultado que el mismo descriptor se lea repetidamente. Para solucionar este problema, se introduce una declaración 'goto' para garantizar que el puntero y la cantidad leída se actualicen correctamente. Esto garantiza que la función pase al siguiente descriptor en lugar de leer el mismo descriptor repetidamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/64c27b7b2357ddb38b6afebaf46d5bff4d250702","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7c0244cc311a4038505b73682b7c8ceaa5c7a8c8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/974bba5c118f4c2baf00de0356e3e4f7928b4cbc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9ef94ec8e52eaf7b9abc5b5f8f5b911751112223","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f89fef7710b2ba0f7a1e46594e530dcf2f77be91","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52782","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.097","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/mlx5e: Track xmit submission to PTP WQ after populating metadata map\n\nEnsure the skb is available in metadata mapping to skbs before tracking the\nmetadata index for detecting undelivered CQEs. If the metadata index is put\nin the tracking list before putting the skb in the map, the metadata index\nmight be used for detecting undelivered CQEs before the relevant skb is\navailable in the map, which can lead to a null-ptr-deref.\n\nLog:\n    general protection fault, probably for non-canonical address 0xdffffc0000000005: 0000 [#1] SMP KASAN\n    KASAN: null-ptr-deref in range [0x0000000000000028-0x000000000000002f]\n    CPU: 0 PID: 1243 Comm: kworker\/0:2 Not tainted 6.6.0-rc4+ #108\n    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04\/01\/2014\n    Workqueue: events mlx5e_rx_dim_work [mlx5_core]\n    RIP: 0010:mlx5e_ptp_napi_poll+0x9a4\/0x2290 [mlx5_core]\n    Code: 8c 24 38 cc ff ff 4c 8d 3c c1 4c 89 f9 48 c1 e9 03 42 80 3c 31 00 0f 85 97 0f 00 00 4d 8b 3f 49 8d 7f 28 48 89 f9 48 c1 e9 03 <42> 80 3c 31 00 0f 85 8b 0f 00 00 49 8b 47 28 48 85 c0 0f 84 05 07\n    RSP: 0018:ffff8884d3c09c88 EFLAGS: 00010206\n    RAX: 0000000000000069 RBX: ffff8881160349d8 RCX: 0000000000000005\n    RDX: ffffed10218f48cf RSI: 0000000000000004 RDI: 0000000000000028\n    RBP: ffff888122707700 R08: 0000000000000001 R09: ffffed109a781383\n    R10: 0000000000000003 R11: 0000000000000003 R12: ffff88810c7a7a40\n    R13: ffff888122707700 R14: dffffc0000000000 R15: 0000000000000000\n    FS:  0000000000000000(0000) GS:ffff8884d3c00000(0000) knlGS:0000000000000000\n    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    CR2: 00007f4f878dd6e0 CR3: 000000014d108002 CR4: 0000000000370eb0\n    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n    Call Trace:\n    <IRQ>\n    ? die_addr+0x3c\/0xa0\n    ? exc_general_protection+0x144\/0x210\n    ? asm_exc_general_protection+0x22\/0x30\n    ? mlx5e_ptp_napi_poll+0x9a4\/0x2290 [mlx5_core]\n    ? mlx5e_ptp_napi_poll+0x8f6\/0x2290 [mlx5_core]\n    __napi_poll.constprop.0+0xa4\/0x580\n    net_rx_action+0x460\/0xb80\n    ? _raw_spin_unlock_irqrestore+0x32\/0x60\n    ? __napi_poll.constprop.0+0x580\/0x580\n    ? tasklet_action_common.isra.0+0x2ef\/0x760\n    __do_softirq+0x26c\/0x827\n    irq_exit_rcu+0xc2\/0x100\n    common_interrupt+0x7f\/0xa0\n    <\/IRQ>\n    <TASK>\n    asm_common_interrupt+0x22\/0x40\n    RIP: 0010:__kmem_cache_alloc_node+0xb\/0x330\n    Code: 41 5d 41 5e 41 5f c3 8b 44 24 14 8b 4c 24 10 09 c8 eb d5 e8 b7 43 ca 01 0f 1f 80 00 00 00 00 0f 1f 44 00 00 55 48 89 e5 41 57 <41> 56 41 89 d6 41 55 41 89 f5 41 54 49 89 fc 53 48 83 e4 f0 48 83\n    RSP: 0018:ffff88812c4079c0 EFLAGS: 00000246\n    RAX: 1ffffffff083c7fe RBX: ffff888100042dc0 RCX: 0000000000000218\n    RDX: 00000000ffffffff RSI: 0000000000000dc0 RDI: ffff888100042dc0\n    RBP: ffff88812c4079c8 R08: ffffffffa0289f96 R09: ffffed1025880ea9\n    R10: ffff888138839f80 R11: 0000000000000002 R12: 0000000000000dc0\n    R13: 0000000000000100 R14: 000000000000008c R15: ffff8881271fc450\n    ? cmd_exec+0x796\/0x2200 [mlx5_core]\n    kmalloc_trace+0x26\/0xc0\n    cmd_exec+0x796\/0x2200 [mlx5_core]\n    mlx5_cmd_do+0x22\/0xc0 [mlx5_core]\n    mlx5_cmd_exec+0x17\/0x30 [mlx5_core]\n    mlx5_core_modify_cq_moderation+0x139\/0x1b0 [mlx5_core]\n    ? mlx5_add_cq_to_tasklet+0x280\/0x280 [mlx5_core]\n    ? lockdep_set_lock_cmp_fn+0x190\/0x190\n    ? process_one_work+0x659\/0x1220\n    mlx5e_rx_dim_work+0x9d\/0x100 [mlx5_core]\n    process_one_work+0x730\/0x1220\n    ? lockdep_hardirqs_on_prepare+0x400\/0x400\n    ? max_active_store+0xf0\/0xf0\n    ? assign_work+0x168\/0x240\n    worker_thread+0x70f\/0x12d0\n    ? __kthread_parkme+0xd1\/0x1d0\n    ? process_one_work+0x1220\/0x1220\n    kthread+0x2d9\/0x3b0\n    ? kthread_complete_and_exit+0x20\/0x20\n    ret_from_fork+0x2d\/0x70\n    ? kthread_complete_and_exit+0x20\/0x20\n    ret_from_fork_as\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: net\/mlx5e: realice un seguimiento del envío de xmit a PTP WQ después de completar el mapa de metadatos. Asegúrese de que el skb esté disponible en el mapeo de metadatos a skbs antes de realizar un seguimiento del índice de metadatos para detectar CQE no entregados. Si el índice de metadatos se coloca en la lista de seguimiento antes de colocar el skb en el mapa, el índice de metadatos podría usarse para detectar CQE no entregados antes de que el skb relevante esté disponible en el mapa, lo que puede generar un null-ptr-deref. Registro: falla de protección general, probablemente para dirección no canónica 0xdffffc0000000005: 0000 [#1] SMP KASAN KASAN: null-ptr-deref en rango [0x0000000000000028-0x0000000000000002f] CPU: 0 PID: 1243 Comm: kworker\/0:2 Not tain ted 6.6.0-rc4+ #108 Nombre del hardware: PC estándar QEMU (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 01\/04\/2014 Cola de trabajo: eventos mlx5e_rx_dim_work [mlx5_core] RIP : 0010:mlx5e_ptp_napi_poll+0x9a4\/0x2290 [mlx5_core] Código: 8c 24 38 cc ff ff 4c 8d 3c c1 4c 89 f9 48 c1 e9 03 42 80 3c 31 00 0f 85 97 0f 00 00 4d 8b 3f 49 8d 7f 28 48 89 f9 48 c1 e9 03 &lt;42&gt; 80 3c 31 00 0f 85 8b 0f 00 00 49 8b 47 28 48 85 c0 0f 84 05 07 RSP: 0018:ffff8884d3c09c88 EFLAGS: 00010206 RAX: 000000000069 RBX: ffff8881160349d8 RCX: 0000000000000005 RDX: ffffed10218f48cf RSI : 0000000000000004 RDI: 0000000000000028 RBP: ffff888122707700 R08: 0000000000000001 R09: ffffed109a781383 R10: 0000000000000003 R11: 00000000000003 R12: ffff88810c7a7a40 R13: ffff888122707700 R14: dffffc0000000000 R15: 0000000000000000 FS: 0000000000000000(0000) GS:ffff888 4d3c00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f4f878dd6e0 CR3: 000000014d108002 CR4: 0000000000370eb0 DR0: 0000000000000000 DR1: 0000000 000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 00000000000000400 Seguimiento de llamadas:  ? die_addr+0x3c\/0xa0? exc_general_protection+0x144\/0x210? asm_exc_general_protection+0x22\/0x30? mlx5e_ptp_napi_poll+0x9a4\/0x2290 [mlx5_core] ? mlx5e_ptp_napi_poll+0x8f6\/0x2290 [mlx5_core] __napi_poll.constprop.0+0xa4\/0x580 net_rx_action+0x460\/0xb80 ? _raw_spin_unlock_irqrestore+0x32\/0x60? __napi_poll.constprop.0+0x580\/0x580? tasklet_action_common.isra.0+0x2ef\/0x760 __do_softirq+0x26c\/0x827 irq_exit_rcu+0xc2\/0x100 common_interrupt+0x7f\/0xa0   asm_common_interrupt+0x22\/0x40 RIP 0010:__kmem_cache_alloc_node+ 0xb\/0x330 Código: 41 5d 41 5e 41 5f c3 8b 44 24 14 8b 4c 24 10 09 c8 eb d5 e8 b7 43 ca 01 0f 1f 80 00 00 00 00 0f 1f 44 00 00 55 48 89 e5 41 57 &lt;41&gt; 56 41 89 41 55 41 89 f5 41 54 49 89 fc 53 48 83 e4 f0 48 83 RSP: 0018:ffff88812c4079c0 EFLAGS: 00000246 RAX: 1ffffffff083c7fe RBX: ffff888100042dc0 RCX: 218 RDX: 00000000ffffffff RSI: 0000000000000dc0 RDI: ffff888100042dc0 RBP: ffff88812c4079c8 R08: ffffffffa0289f96 R09: ffffed1025880ea9 R10: ffff888138839f80 R11: 00000000000000002 R12: 0000000000000dc0 R13: 0000000000000100 R14: 0000000000000008c R15: ffff8881271fc450 ? cmd_exec+0x796\/0x2200 [mlx5_core] kmalloc_trace+0x26\/0xc0 cmd_exec+0x796\/0x2200 [mlx5_core] mlx5_cmd_do+0x22\/0xc0 [mlx5_core] mlx5_cmd_exec+0x17\/0x30 [mlx5_core] modificar_cq_moderation+0x139\/0x1b0 [mlx5_core] ? mlx5_add_cq_to_tasklet+0x280\/0x280 [mlx5_core] ? lockdep_set_lock_cmp_fn+0x190\/0x190? Process_one_work+0x659\/0x1220 mlx5e_rx_dim_work+0x9d\/0x100 [mlx5_core] Process_one_work+0x730\/0x1220 ? lockdep_hardirqs_on_prepare+0x400\/0x400? max_active_store+0xf0\/0xf0? assign_work+0x168\/0x240 worker_thread+0x70f\/0x12d0? __kthread_parkme+0xd1\/0x1d0 ? process_one_work+0x1220\/0x1220 kthread+0x2d9\/0x3b0 ? kthread_complete_and_exit+0x20\/0x20 ret_from_fork+0x2d\/0x70 ? kthread_complete_and_exit+0x20\/0x20 ret_from_fork_as ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4d510506b46504664eacf8a44a9e8f3e54c137b8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7e3f3ba97e6cc6fce5bf62df2ca06c8e59040167","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a9d6c0c5a6bd9ca88e964f8843ea41bc085de866","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52783","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.167","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: wangxun: fix kernel panic due to null pointer\n\nWhen the device uses a custom subsystem vendor ID, the function\nwx_sw_init() returns before the memory of 'wx->mac_table' is allocated.\nThe null pointer will causes the kernel panic."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: wangxun: corrige el pánico del kernel debido a un puntero null. Cuando el dispositivo utiliza un ID de proveedor de subsistema personalizado, la función wx_sw_init() regresa antes de que se agote la memoria de 'wx-&gt;mac_table'. asignado. El puntero null provocará el pánico en el kernel."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/61a55071653974dab172d4c5d699bb365cfd13c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8ba2c459668cfe2aaacc5ebcd35b4b9ef8643013","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52784","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.233","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbonding: stop the device in bond_setup_by_slave()\n\nCommit 9eed321cde22 (\"net: lapbether: only support ethernet devices\")\nhas been able to keep syzbot away from net\/lapb, until today.\n\nIn the following splat [1], the issue is that a lapbether device has\nbeen created on a bonding device without members. Then adding a non\nARPHRD_ETHER member forced the bonding master to change its type.\n\nThe fix is to make sure we call dev_close() in bond_setup_by_slave()\nso that the potential linked lapbether devices (or any other devices\nhaving assumptions on the physical device) are removed.\n\nA similar bug has been addressed in commit 40baec225765\n(\"bonding: fix panic on non-ARPHRD_ETHER enslave failure\")\n\n[1]\nskbuff: skb_under_panic: text:ffff800089508810 len:44 put:40 head:ffff0000c78e7c00 data:ffff0000c78e7bea tail:0x16 end:0x140 dev:bond0\nkernel BUG at net\/core\/skbuff.c:192 !\nInternal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\nModules linked in:\nCPU: 0 PID: 6007 Comm: syz-executor383 Not tainted 6.6.0-rc3-syzkaller-gbf6547d8715b #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 08\/04\/2023\npstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : skb_panic net\/core\/skbuff.c:188 [inline]\npc : skb_under_panic+0x13c\/0x140 net\/core\/skbuff.c:202\nlr : skb_panic net\/core\/skbuff.c:188 [inline]\nlr : skb_under_panic+0x13c\/0x140 net\/core\/skbuff.c:202\nsp : ffff800096a06aa0\nx29: ffff800096a06ab0 x28: ffff800096a06ba0 x27: dfff800000000000\nx26: ffff0000ce9b9b50 x25: 0000000000000016 x24: ffff0000c78e7bea\nx23: ffff0000c78e7c00 x22: 000000000000002c x21: 0000000000000140\nx20: 0000000000000028 x19: ffff800089508810 x18: ffff800096a06100\nx17: 0000000000000000 x16: ffff80008a629a3c x15: 0000000000000001\nx14: 1fffe00036837a32 x13: 0000000000000000 x12: 0000000000000000\nx11: 0000000000000201 x10: 0000000000000000 x9 : cb50b496c519aa00\nx8 : cb50b496c519aa00 x7 : 0000000000000001 x6 : 0000000000000001\nx5 : ffff800096a063b8 x4 : ffff80008e280f80 x3 : ffff8000805ad11c\nx2 : 0000000000000001 x1 : 0000000100000201 x0 : 0000000000000086\nCall trace:\nskb_panic net\/core\/skbuff.c:188 [inline]\nskb_under_panic+0x13c\/0x140 net\/core\/skbuff.c:202\nskb_push+0xf0\/0x108 net\/core\/skbuff.c:2446\nip6gre_header+0xbc\/0x738 net\/ipv6\/ip6_gre.c:1384\ndev_hard_header include\/linux\/netdevice.h:3136 [inline]\nlapbeth_data_transmit+0x1c4\/0x298 drivers\/net\/wan\/lapbether.c:257\nlapb_data_transmit+0x8c\/0xb0 net\/lapb\/lapb_iface.c:447\nlapb_transmit_buffer+0x178\/0x204 net\/lapb\/lapb_out.c:149\nlapb_send_control+0x220\/0x320 net\/lapb\/lapb_subr.c:251\n__lapb_disconnect_request+0x9c\/0x17c net\/lapb\/lapb_iface.c:326\nlapb_device_event+0x288\/0x4e0 net\/lapb\/lapb_iface.c:492\nnotifier_call_chain+0x1a4\/0x510 kernel\/notifier.c:93\nraw_notifier_call_chain+0x3c\/0x50 kernel\/notifier.c:461\ncall_netdevice_notifiers_info net\/core\/dev.c:1970 [inline]\ncall_netdevice_notifiers_extack net\/core\/dev.c:2008 [inline]\ncall_netdevice_notifiers net\/core\/dev.c:2022 [inline]\n__dev_close_many+0x1b8\/0x3c4 net\/core\/dev.c:1508\ndev_close_many+0x1e0\/0x470 net\/core\/dev.c:1559\ndev_close+0x174\/0x250 net\/core\/dev.c:1585\nlapbeth_device_event+0x2e4\/0x958 drivers\/net\/wan\/lapbether.c:466\nnotifier_call_chain+0x1a4\/0x510 kernel\/notifier.c:93\nraw_notifier_call_chain+0x3c\/0x50 kernel\/notifier.c:461\ncall_netdevice_notifiers_info net\/core\/dev.c:1970 [inline]\ncall_netdevice_notifiers_extack net\/core\/dev.c:2008 [inline]\ncall_netdevice_notifiers net\/core\/dev.c:2022 [inline]\n__dev_close_many+0x1b8\/0x3c4 net\/core\/dev.c:1508\ndev_close_many+0x1e0\/0x470 net\/core\/dev.c:1559\ndev_close+0x174\/0x250 net\/core\/dev.c:1585\nbond_enslave+0x2298\/0x30cc drivers\/net\/bonding\/bond_main.c:2332\nbond_do_ioctl+0x268\/0xc64 drivers\/net\/bonding\/bond_main.c:4539\ndev_ifsioc+0x754\/0x9ac\ndev_ioctl+0x4d8\/0xd34 net\/core\/dev_ioctl.c:786\nsock_do_ioctl+0x1d4\/0x2d0 net\/socket.c:1217\nsock_ioctl+0x4e8\/0x834 net\/socket.c:1322\nvfs_ioctl fs\/ioctl.c:51 [inline]\n__do_\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bonding: detener el dispositivo en bond_setup_by_slave(). El compromiso 9eed321cde22 (\"net: lapbether: solo admite dispositivos ethernet\") ha podido mantener a syzbot alejado de net\/lapb, hasta hoy. En el siguiente símbolo [1], el problema es que se ha creado un dispositivo lapbether sobre un dispositivo de unión sin miembros. Luego, agregar un miembro que no sea ARPHRD_ETHER obligó al maestro de vinculación a cambiar su tipo. La solución es asegurarnos de llamar a dev_close() en bond_setup_by_slave() para que se eliminen los posibles dispositivos lapbether vinculados (o cualquier otro dispositivo que tenga suposiciones sobre el dispositivo físico). Se solucionó un error similar en la confirmación 40baec225765 (\"vinculación: corregir el pánico en caso de falla de esclavitud no ARPHRD_ETHER\") [1] skbuff: skb_under_panic: text:ffff800089508810 len:44 put:40 head:ffff0000c78e7c00 data:ffff0000c78e7bea tail:0x16 end: 0x140 dev:bond0 ERROR del kernel en net\/core\/skbuff.c:192! Error interno: Ups - ERROR: 00000000f2000800 [#1] PREEMPT Módulos SMP vinculados en: CPU: 0 PID: 6007 Comm: syz-executor383 No contaminado 6.6.0-rc3-syzkaller-gbf6547d8715b #0 Nombre de hardware: Google Google Compute Engine\/ Google Compute Engine, BIOS Google 04\/08\/2023 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc: skb_panic net\/core\/skbuff.c:188 [en línea] pc: skb_under_panic +0x13c\/0x140 net\/core\/skbuff.c:202 lr: skb_panic net\/core\/skbuff.c:188 [en línea] lr: skb_under_panic+0x13c\/0x140 net\/core\/skbuff.c:202 sp: ffff800096a06aa0 x29: ffff800096a06ab0 x28: ffff800096a06ba0 x27: dfff800000000000 x26: ffff0000ce9b9b50 x25: 0000000000000016 x24: ffff0000c78e7bea x23: ffff0000c78e7c00 x22: 0000000002c x21: 0000000000000140 x20: 0000000000000028 x19: ffff800089508810 x18: ffff800096a06100 x17: 0000000000000000 x16: ffff80008 a629a3c x15: 0000000000000001 x14: 1fffe00036837a32 x13: 0000000000000000 x12: 0000000000000000 x11: 0000000000000201 x10: 000000000000000 x9: cb50b496c519aa00 x8: cb50b496c519aa00 x7: 0000000000000001 x6: 00000000000001 x5: ffff800096a063b8 x4: ffff80008e280f80 x3: ffff8000805ad11c x2: 0000000000000001 x1: 0000000100000201 x0: 00000000000000 086 Rastreo de llamadas: skb_panic net\/core\/skbuff.c:188 [en línea] skb_under_panic+0x13c\/0x140 net\/core\/skbuff.c:202 skb_push+0xf0\/0x108 net\/core\/skbuff.c:2446 ip6gre_header+0xbc\/0x738 net\/ipv6\/ip6_gre.c:1384 dev_hard_header include\/linux\/ netdevice.h:3136 [en línea] lapbeth_data_transmit+0x1c4\/0x298 drivers\/net\/wan\/lapbether.c:257 lapb_data_transmit+0x8c\/0xb0 net\/lapb\/lapb_iface.c:447 lapb_transmit_buffer+0x178\/0x204 net\/lapb\/lapb_out.c :149 lapb_send_control+0x220\/0x320 net\/lapb\/lapb_subr.c:251 __lapb_disconnect_request+0x9c\/0x17c net\/lapb\/lapb_iface.c:326 lapb_device_event+0x288\/0x4e0 net\/lapb\/lapb_iface.c:492 notifier_call_chain+0 núcleo x1a4\/0x510 \/notifier.c:93 raw_notifier_call_chain+0x3c\/0x50 kernel\/notifier.c:461 call_netdevice_notifiers_info net\/core\/dev.c:1970 [en línea] call_netdevice_notifiers_extack net\/core\/dev.c:2008 [en línea] call_netdevice_notifiers net\/core\/dev .c:2022 [en línea] __dev_close_many+0x1b8\/0x3c4 net\/core\/dev.c:1508 dev_close_many+0x1e0\/0x470 net\/core\/dev.c:1559 dev_close+0x174\/0x250 net\/core\/dev.c:1585 lapbeth_device_event +0x2e4\/0x958 drivers\/net\/wan\/lapbether.c:466 notifier_call_chain+0x1a4\/0x510 kernel\/notifier.c:93 raw_notifier_call_chain+0x3c\/0x50 kernel\/notifier.c:461 call_netdevice_notifiers_info net\/core\/dev.c:1970 [ en línea] call_netdevice_notifiers_extack net\/core\/dev.c:2008 [en línea] call_netdevice_notifiers net\/core\/dev.c:2022 [en línea] __dev_close_many+0x1b8\/0x3c4 net\/core\/dev.c:1508 dev_close_many+0x1e0\/0x470 net\/core \/dev.c:1559 dev_close+0x174\/0x250 net\/core\/dev.c:1585 bond_enslave+0x2298\/0x30cc drivers\/net\/bonding\/bond_main.c:2332 bond_do_ioctl+0x268\/0xc64 drivers\/net\/bonding\/bond_main.c :4539 dev_ifsioc+0x754\/0x9ac dev_ioctl+0x4d8\/0xd34 net\/core\/dev_ioctl.c:786 sock_do_ioctl+0x1d4\/0x2d0 net\/socket.c:1217 ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/19554aa901b5833787df4417a05ccdebf351b7f4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/396baca6683f415b5bc2b380289387bef1406edc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3cffa2ddc4d3fcf70cde361236f5a614f81a09b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/53064e8239dd2ecfefc5634e991f1025abc2ee0c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/87c49806a37f88eddde3f537c162fd0c2834170c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4f0e605a508f6d7cda6df2f03a0c676b778b1fe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d98c91215a5748a0f536e7ccea26027005196859","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52785","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.330","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ufs: core: Fix racing issue between ufshcd_mcq_abort() and ISR\n\nIf command timeout happens and cq complete IRQ is raised at the same time,\nufshcd_mcq_abort clears lprb->cmd and a NULL pointer deref happens in the\nISR. Error log:\n\nufshcd_abort: Device abort task at tag 18\nUnable to handle kernel NULL pointer dereference at virtual address\n0000000000000108\npc : [0xffffffe27ef867ac] scsi_dma_unmap+0xc\/0x44\nlr : [0xffffffe27f1b898c] ufshcd_release_scsi_cmd+0x24\/0x114"},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: scsi: ufs: core: soluciona el problema de ejecuciones entre ufshcd_mcq_abort() e ISR. Si se agota el tiempo de espera del comando y se genera cq complete IRQ al mismo tiempo, ufshcd_mcq_abort borra lprb-&gt;cmd y un La eliminación del puntero NULL ocurre en el ISR. Registro de errores: ufshcd_abort: tarea de cancelación del dispositivo en la etiqueta 18 No se puede manejar la desreferencia del puntero NULL del kernel en la dirección virtual 0000000000000108 pc: [0xffffffe27ef867ac] scsi_dma_unmap+0xc\/0x44 lr: [0xffffffe27f1b898c] ufshcd_release_scsi_cmd+0x24 \/0x114"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/27900d7119c464b43cd9eac69c85884d17bae240","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f15a7e3c054d960bbd1521110700450bbf798a1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f84d461f33a6b27304d468d9cfb56c0cefdb4ee7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52786","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.413","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix racy may inline data check in dio write\n\nsyzbot reports that the following warning from ext4_iomap_begin()\ntriggers as of the commit referenced below:\n\n        if (WARN_ON_ONCE(ext4_has_inline_data(inode)))\n                return -ERANGE;\n\nThis occurs during a dio write, which is never expected to encounter\nan inode with inline data. To enforce this behavior,\next4_dio_write_iter() checks the current inline state of the inode\nand clears the MAY_INLINE_DATA state flag to either fall back to\nbuffered writes, or enforce that any other writers in progress on\nthe inode are not allowed to create inline data.\n\nThe problem is that the check for existing inline data and the state\nflag can span a lock cycle. For example, if the ilock is originally\nlocked shared and subsequently upgraded to exclusive, another writer\nmay have reacquired the lock and created inline data before the dio\nwrite task acquires the lock and proceeds.\n\nThe commit referenced below loosens the lock requirements to allow\nsome forms of unaligned dio writes to occur under shared lock, but\nAFAICT the inline data check was technically already racy for any\ndio write that would have involved a lock cycle. Regardless, lift\nclearing of the state bit to the same lock critical section that\nchecks for preexisting inline data on the inode to close the race."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ext4: corrige la verificación de datos en línea de racy may en dio write syzbot informa que la siguiente advertencia de ext4_iomap_begin() se activa a partir de la confirmación a la que se hace referencia a continuación: if (WARN_ON_ONCE(ext4_has_inline_data(inode)) ) devolver -ERANGE; Esto ocurre durante una escritura dio, que nunca se espera que encuentre un inodo con datos en línea. Para imponer este comportamiento, ext4_dio_write_iter() verifica el estado en línea actual del inodo y borra el indicador de estado MAY_INLINE_DATA para volver a las escrituras almacenadas en el búfer o imponer que otros escritores en progreso en el inodo no puedan crear datos en línea. El problema es que la verificación de datos en línea existentes y la bandera de estado puede abarcar un ciclo de bloqueo. Por ejemplo, si el ilock originalmente estaba bloqueado como compartido y posteriormente actualizado a exclusivo, es posible que otro escritor haya vuelto a adquirir el bloqueo y haya creado datos en línea antes de que la tarea de escritura dio adquiera el bloqueo y continúe. El compromiso al que se hace referencia a continuación afloja los requisitos de bloqueo para permitir que se produzcan algunas formas de escrituras de dio no alineadas bajo un bloqueo compartido, pero AFAICT, la verificación de datos en línea técnicamente ya era picante para cualquier escritura de dio que hubiera involucrado un ciclo de bloqueo. De todos modos, limpie el bit de estado en la misma sección crítica de bloqueo que verifica si hay datos en línea preexistentes en el inodo para cerrar la ejecución."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7343c23ebcadbedc23a7063d1e24d976eccb0d0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ce56d21355cd6f6937aca32f1f44ca749d1e4808","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e3b83d87c93eb6fc96a80b5e8527f7dc9f5a11bc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52787","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.500","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nblk-mq: make sure active queue usage is held for bio_integrity_prep()\n\nblk_integrity_unregister() can come if queue usage counter isn't held\nfor one bio with integrity prepared, so this request may be completed with\ncalling profile->complete_fn, then kernel panic.\n\nAnother constraint is that bio_integrity_prep() needs to be called\nbefore bio merge.\n\nFix the issue by:\n\n- call bio_integrity_prep() with one queue usage counter grabbed reliably\n\n- call bio_integrity_prep() before bio merge"},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: blk-mq: asegúrese de que el uso de la cola activa se mantenga para bio_integrity_prep() blk_integrity_unregister() puede aparecer si el contador de uso de la cola no se mantiene para una biografía con integridad preparada, por lo que esta solicitud se puede completar llamando al perfil-&gt;complete_fn, luego kernel panic. Otra restricción es que es necesario llamar a bio_integrity_prep() antes de la fusión biológica. Solucione el problema de la siguiente manera: - llame a bio_integrity_prep() con un contador de uso de cola capturado de manera confiable - llame a bio_integrity_prep() antes de fusionar la biografía"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/b0077e269f6c152e807fdac90b58caf012cdbaab","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b5c8e0ff76d10f6bf70a7237678f27c20cf59bc9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b80056bd75a16e4550873ecefe12bc8fd190b1cf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e9c309ded295b7f8849097d71ae231456ca79f78","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52788","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.570","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ni915\/perf: Fix NULL deref bugs with drm_dbg() calls\n\nWhen i915 perf interface is not available dereferencing it will lead to\nNULL dereferences.\n\nAs returning -ENOTSUPP is pretty clear return when perf interface is not\navailable.\n\n[tursulin: added stable tag]\n(cherry picked from commit 36f27350ff745bd228ab04d7845dfbffc177a889)"},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: i915\/perf: corrige errores de desreferencia NULL con llamadas drm_dbg(). Cuando la interfaz i915 perf no está disponible, la desreferenciación conducirá a desreferencias NULL. Como devolver -ENOTSUPP es un retorno bastante claro cuando la interfaz perf no está disponible. [tursulin: etiqueta estable agregada] (cereza seleccionada del compromiso 36f27350ff745bd228ab04d7845dfbffc177a889)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/10f49cdfd5fb342a1a9641930dc040c570694e98","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1566e8be73fd5fa424e88d2a4cffdc34f970f0e1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/471aa951bf1206d3c10d0daa67005b8e4db4ff83","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/55db76caa782baa4a1bf02296e2773c38a524a3e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bf8e105030083e7b71591cdf437e464bcd8a0c09","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52789","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.637","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntty: vcc: Add check for kstrdup() in vcc_probe()\n\nAdd check for the return value of kstrdup() and return the error, if it\nfails in order to avoid NULL pointer dereference."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tty: vcc: Agregar verificación para kstrdup() en vcc_probe(). Agregar verificación para el valor de retorno de kstrdup() y devolver el error, si falla, para evitar la desreferencia de puntero NULL ."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/38cd56fc9de78bf3c878790785e8c231116ef9d3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/460284dfb10b207980c6f3f7046e33446ceb38ac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4a24a31826246b15477399febd13292b0c9f0ee9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4ef41a7f33ffe1a335e7db7e1564ddc6afad47cc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6c80f48912b5bd4965352d1a9a989e21743a4a06","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7cebc86481bf16049e266f6774d90f2fd4f8d5d2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f8771757b130383732195497e47fba2aba76d3a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/909963e0c16778cec28efb1affc21558825f4200","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d81ffb87aaa75f842cd7aa57091810353755b3e6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52790","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.707","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nswiotlb: fix out-of-bounds TLB allocations with CONFIG_SWIOTLB_DYNAMIC\n\nLimit the free list length to the size of the IO TLB. Transient pool can be\nsmaller than IO_TLB_SEGSIZE, but the free list is initialized with the\nassumption that the total number of slots is a multiple of IO_TLB_SEGSIZE.\nAs a result, swiotlb_area_find_slots() may allocate slots past the end of\na transient IO TLB buffer."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: swiotlb: corrige asignaciones de TLB fuera de los límites con CONFIG_SWIOTLB_DYNAMIC Limita la longitud de la lista libre al tamaño del IO TLB. El grupo transitorio puede ser más pequeño que IO_TLB_SEGSIZE, pero la lista libre se inicializa asumiendo que el número total de ranuras es un múltiplo de IO_TLB_SEGSIZE. Como resultado, swiotlb_area_find_slots() puede asignar ranuras más allá del final de un búfer IO TLB transitorio."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/53c87e846e335e3c18044c397cc35178163d7827","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ce7612496a4ba6068bc68aa1fa9d947dadb4ad9b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52791","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.777","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: core: Run atomic i2c xfer when !preemptible\n\nSince bae1d3a05a8b, i2c transfers are non-atomic if preemption is\ndisabled. However, non-atomic i2c transfers require preemption (e.g. in\nwait_for_completion() while waiting for the DMA).\n\npanic() calls preempt_disable_notrace() before calling\nemergency_restart(). Therefore, if an i2c device is used for the\nrestart, the xfer should be atomic. This avoids warnings like:\n\n[   12.667612] WARNING: CPU: 1 PID: 1 at kernel\/rcu\/tree_plugin.h:318 rcu_note_context_switch+0x33c\/0x6b0\n[   12.676926] Voluntary context switch within RCU read-side critical section!\n...\n[   12.742376]  schedule_timeout from wait_for_completion_timeout+0x90\/0x114\n[   12.749179]  wait_for_completion_timeout from tegra_i2c_wait_completion+0x40\/0x70\n...\n[   12.994527]  atomic_notifier_call_chain from machine_restart+0x34\/0x58\n[   13.001050]  machine_restart from panic+0x2a8\/0x32c\n\nUse !preemptible() instead, which is basically the same check as\npre-v5.2."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: i2c: core: ejecute atomic i2c xfer cuando !preemptible. Desde bae1d3a05a8b, las transferencias i2c no son atómicas si la preferencia está deshabilitada. Sin embargo, las transferencias i2c no atómicas requieren preferencia (por ejemplo, en wait_for_completion() mientras se espera el DMA). pánico() llama a preempt_disable_notrace() antes de llamar a emergence_restart(). Por lo tanto, si se utiliza un dispositivo i2c para el reinicio, el xfer debe ser atómico. Esto evita advertencias como: [12.667612] ADVERTENCIA: CPU: 1 PID: 1 en kernel\/rcu\/tree_plugin.h:318 rcu_note_context_switch+0x33c\/0x6b0 [12.676926] ¡Cambio de contexto voluntario dentro de la sección crítica del lado de lectura de RCU! ... [12.742376] Schedule_timeout de wait_for_completion_timeout+0x90\/0x114 [12.749179] wait_for_completion_timeout de tegra_i2c_wait_completion+0x40\/0x70 ... [12.994527] atomic_notifier_call_chain de machine_restart+0x34\/0x58 13.001050] machine_restart desde panic+0x2a8\/0x32c Utilice !preemptible( ) en su lugar, que es básicamente la misma verificación que la versión anterior a la v5.2."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/185f3617adc8fe45e40489b458f03911f0dec46c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/25284c46b657f48c0f3880a2e0706c70d81182c0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/25eb381a736e7ae39a4245ef5c96484eb1073809","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3473cf43b9068b9dfef2f545f833f33c6a544b91","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8c3fa52a46ff4d208cefb1a462ec94e0043a91e1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aa49c90894d06e18a1ee7c095edbd2f37c232d02","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f6237afabc349c1c7909db00e15d2816519e0d2b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52792","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.857","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncxl\/region: Do not try to cleanup after cxl_region_setup_targets() fails\n\nCommit 5e42bcbc3fef (\"cxl\/region: decrement ->nr_targets on error in\ncxl_region_attach()\") tried to avoid 'eiw' initialization errors when\n->nr_targets exceeded 16, by just decrementing ->nr_targets when\ncxl_region_setup_targets() failed.\n\nCommit 86987c766276 (\"cxl\/region: Cleanup target list on attach error\")\nextended that cleanup to also clear cxled->pos and p->targets[pos]. The\ninitialization error was incidentally fixed separately by:\nCommit 8d4285425714 (\"cxl\/region: Fix port setup uninitialized variable\nwarnings\") which was merged a few days after 5e42bcbc3fef.\n\nBut now the original cleanup when cxl_region_setup_targets() fails\nprevents endpoint and switch decoder resources from being reused:\n\n1) the cleanup does not set the decoder's region to NULL, which results\n   in future dpa_size_store() calls returning -EBUSY\n2) the decoder is not properly freed, which results in future commit\n   errors associated with the upstream switch\n\nNow that the initialization errors were fixed separately, the proper\ncleanup for this case is to just return immediately. Then the resources\nassociated with this target get cleanup up as normal when the failed\nregion is deleted.\n\nThe ->nr_targets decrement in the error case also helped prevent\na p->targets[] array overflow, so add a new check to prevent against\nthat overflow.\n\nTested by trying to create an invalid region for a 2 switch * 2 endpoint\ntopology, and then following up with creating a valid region."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: cxl\/region: no intente realizar la limpieza después de que cxl_region_setup_targets() falle. Confirme 5e42bcbc3fef (\"cxl\/region: decrement -&gt;nr_targets on error in cxl_region_attach()\") intentó evitar ' Los mismos errores de inicialización cuando -&gt;nr_targets excedieron 16, simplemente disminuyendo -&gt;nr_targets cuando cxl_region_setup_targets() falló. La confirmación 86987c766276 (\"cxl\/region: Limpiar lista de objetivos al adjuntar error\") extendió esa limpieza para borrar también cxled-&gt;pos y p-&gt;targets[pos]. El error de inicialización se solucionó por separado mediante: Commit 8d4285425714 (\"cxl\/region: Reparar advertencias de variables no inicializadas de configuración de puerto\") que se fusionó unos días después de 5e42bcbc3fef. Pero ahora la limpieza original cuando falla cxl_region_setup_targets() impide que se reutilicen los recursos del decodificador de conmutador y punto final: 1) la limpieza no establece la región del decodificador en NULL, lo que da como resultado que futuras llamadas a dpa_size_store() devuelvan -EBUSY 2) el decodificador no liberado correctamente, lo que resulta en futuros errores de confirmación asociados con el conmutador ascendente. Ahora que los errores de inicialización se solucionaron por separado, la limpieza adecuada para este caso es simplemente regresar inmediatamente. Luego, los recursos asociados con este objetivo se limpian normalmente cuando se elimina la región fallida. La disminución de -&gt;nr_targets en el caso de error también ayudó a evitar un desbordamiento de la matriz p-&gt;targets[], así que agregue una nueva verificación para evitar ese desbordamiento. Probado intentando crear una región no válida para una topología de 2 conmutadores * 2 puntos finales y luego creando una región válida."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0718588c7aaa7a1510b4de972370535b61dddd0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/07ffcd8ec79cf7383e1e45815f4842fd357991c2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9090c5537c93cd0811ab7bfbd925b57addfffb60","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90db4c1d5ebaf574d3c3065c055977982c378a83","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52793","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:17.927","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nsamples\/bpf: syscall_tp_user: Fix array out-of-bound access\n\nCommit 06744f24696e (\"samples\/bpf: Add openat2() enter\/exit tracepoint\nto syscall_tp sample\") added two more eBPF programs to support the\nopenat2() syscall. However, it did not increase the size of the array\nthat holds the corresponding bpf_links. This leads to an out-of-bound\naccess on that array in the bpf_object__for_each_program loop and could\ncorrupt other variables on the stack. On our testing QEMU, it corrupts\nthe map1_fds array and causes the sample to fail:\n\n  # .\/syscall_tp\n  prog #0: map ids 4 5\n  verify map:4 val: 5\n  map_lookup failed: Bad file descriptor\n\nDynamically allocate the array based on the number of programs reported\nby libbpf to prevent similar inconsistencies in the future"},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: samples\/bpf: syscall_tp_user: corrige el acceso fuera de los límites de la matriz. Commit 06744f24696e (\"samples\/bpf: agrega openat2() entrada\/salida del punto de seguimiento a la muestra syscall_tp\") agregó dos más Programas eBPF para soportar la llamada al sistema openat2(). Sin embargo, no aumentó el tamaño de la matriz que contiene los bpf_links correspondientes. Esto conduce a un acceso fuera de los límites a esa matriz en el bucle bpf_object__for_each_program y podría dañar otras variables en la pila. En nuestra prueba QEMU, corrompe la matriz map1_fds y hace que la muestra falle: # .\/syscall_tp prog #0: map ids 4 5 verificar map:4 val: 5 map_lookup falló: descriptor de archivo incorrecto Asigne dinámicamente la matriz según el número de programas reportados por libbpf para evitar inconsistencias similares en el futuro"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/61576b7a0f28f924da06bead92a39a6d9aa2404a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9220c3ef6fefbf18f24aeedb1142a642b3de0596","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/de4825a444560f8cb78b03dda3ba873fab88bc4f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52794","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.000","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nthermal: intel: powerclamp: fix mismatch in get function for max_idle\n\nKASAN reported this\n\n      [ 444.853098] BUG: KASAN: global-out-of-bounds in param_get_int+0x77\/0x90\n      [ 444.853111] Read of size 4 at addr ffffffffc16c9220 by task cat\/2105\n      ...\n      [ 444.853442] The buggy address belongs to the variable:\n      [ 444.853443] max_idle+0x0\/0xffffffffffffcde0 [intel_powerclamp]\n\nThere is a mismatch between the param_get_int and the definition of\nmax_idle.  Replacing param_get_int with param_get_byte resolves this\nissue."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: térmica: intel: powerclamp: corrige la falta de coincidencia en la función get para max_idle KASAN informó esto [444.853098] BUG: KASAN: global-fuera de los límites en param_get_int+0x77\/0x90 [444.853111 ] Lectura de tamaño 4 en addr ffffffffc16c9220 por tarea cat\/2105... [444.853442] La dirección con errores pertenece a la variable: [444.853443] max_idle+0x0\/0xffffffffffffffcde0 [intel_powerclamp] Hay una discrepancia entre param_get_int y la definición de max_idle . Reemplazar param_get_int con param_get_byte resuelve este problema."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0a8585281b11e3a0723bba8d8085d61f0b55f37c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6a3866dbdcf39ac93e98708e6abced511733dc18","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fae633cfb729da2771b5433f6b84ae7e8b4aa5f7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52795","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.073","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nvhost-vdpa: fix use after free in vhost_vdpa_probe()\n\nThe put_device() calls vhost_vdpa_release_dev() which calls\nida_simple_remove() and frees \"v\".  So this call to\nida_simple_remove() is a use after free and a double free."},{"lang":"es","value":" En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: vhost-vdpa: corrige el use after free en vhost_vdpa_probe(). El put_device() llama a vhost_vdpa_release_dev() que llama a ida_simple_remove() y libera \"v\". Entonces esta llamada a ida_simple_remove() es un use after free y double free."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/ae8ea4e200675a940c365b496ef8e3fb4123601c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bf04132cd64ccde4e9e9765d489c83fe83c09b7f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c0f8b8fb7df9d1a38652eb5aa817afccd3c56111","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e07754e0a1ea2d63fb29574253d1fd7405607343","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52796","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.157","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nipvlan: add ipvlan_route_v6_outbound() helper\n\nInspired by syzbot reports using a stack of multiple ipvlan devices.\n\nReduce stack size needed in ipvlan_process_v6_outbound() by moving\nthe flowi6 struct used for the route lookup in an non inlined\nhelper. ipvlan_route_v6_outbound() needs 120 bytes on the stack,\nimmediately reclaimed.\n\nAlso make sure ipvlan_process_v4_outbound() is not inlined.\n\nWe might also have to lower MAX_NEST_DEV, because only syzbot uses\nsetups with more than four stacked devices.\n\nBUG: TASK stack guard page was hit at ffffc9000e803ff8 (stack is ffffc9000e804000..ffffc9000e808000)\nstack guard page: 0000 [#1] SMP KASAN\nCPU: 0 PID: 13442 Comm: syz-executor.4 Not tainted 6.1.52-syzkaller #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 10\/09\/2023\nRIP: 0010:kasan_check_range+0x4\/0x2a0 mm\/kasan\/generic.c:188\nCode: 48 01 c6 48 89 c7 e8 db 4e c1 03 31 c0 5d c3 cc 0f 0b eb 02 0f 0b b8 ea ff ff ff 5d c3 cc 00 00 cc cc 00 00 cc cc 55 48 89 e5 <41> 57 41 56 41 55 41 54 53 b0 01 48 85 f6 0f 84 a4 01 00 00 48 89\nRSP: 0018:ffffc9000e804000 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff817e5bf2\nRDX: 0000000000000000 RSI: 0000000000000008 RDI: ffffffff887c6568\nRBP: ffffc9000e804000 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: dffffc0000000001 R12: 1ffff92001d0080c\nR13: dffffc0000000000 R14: ffffffff87e6b100 R15: 0000000000000000\nFS: 00007fd0c55826c0(0000) GS:ffff8881f6800000(0000) knlGS:0000000000000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffc9000e803ff8 CR3: 0000000170ef7000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n<#DF>\n<\/#DF>\n<TASK>\n[<ffffffff81f281d1>] __kasan_check_read+0x11\/0x20 mm\/kasan\/shadow.c:31\n[<ffffffff817e5bf2>] instrument_atomic_read include\/linux\/instrumented.h:72 [inline]\n[<ffffffff817e5bf2>] _test_bit include\/asm-generic\/bitops\/instrumented-non-atomic.h:141 [inline]\n[<ffffffff817e5bf2>] cpumask_test_cpu include\/linux\/cpumask.h:506 [inline]\n[<ffffffff817e5bf2>] cpu_online include\/linux\/cpumask.h:1092 [inline]\n[<ffffffff817e5bf2>] trace_lock_acquire include\/trace\/events\/lock.h:24 [inline]\n[<ffffffff817e5bf2>] lock_acquire+0xe2\/0x590 kernel\/locking\/lockdep.c:5632\n[<ffffffff8563221e>] rcu_lock_acquire+0x2e\/0x40 include\/linux\/rcupdate.h:306\n[<ffffffff8561464d>] rcu_read_lock include\/linux\/rcupdate.h:747 [inline]\n[<ffffffff8561464d>] ip6_pol_route+0x15d\/0x1440 net\/ipv6\/route.c:2221\n[<ffffffff85618120>] ip6_pol_route_output+0x50\/0x80 net\/ipv6\/route.c:2606\n[<ffffffff856f65b5>] pol_lookup_func include\/net\/ip6_fib.h:584 [inline]\n[<ffffffff856f65b5>] fib6_rule_lookup+0x265\/0x620 net\/ipv6\/fib6_rules.c:116\n[<ffffffff85618009>] ip6_route_output_flags_noref+0x2d9\/0x3a0 net\/ipv6\/route.c:2638\n[<ffffffff8561821a>] ip6_route_output_flags+0xca\/0x340 net\/ipv6\/route.c:2651\n[<ffffffff838bd5a3>] ip6_route_output include\/net\/ip6_route.h:100 [inline]\n[<ffffffff838bd5a3>] ipvlan_process_v6_outbound drivers\/net\/ipvlan\/ipvlan_core.c:473 [inline]\n[<ffffffff838bd5a3>] ipvlan_process_outbound drivers\/net\/ipvlan\/ipvlan_core.c:529 [inline]\n[<ffffffff838bd5a3>] ipvlan_xmit_mode_l3 drivers\/net\/ipvlan\/ipvlan_core.c:602 [inline]\n[<ffffffff838bd5a3>] ipvlan_queue_xmit+0xc33\/0x1be0 drivers\/net\/ipvlan\/ipvlan_core.c:677\n[<ffffffff838c2909>] ipvlan_start_xmit+0x49\/0x100 drivers\/net\/ipvlan\/ipvlan_main.c:229\n[<ffffffff84d03900>] netdev_start_xmit include\/linux\/netdevice.h:4966 [inline]\n[<ffffffff84d03900>] xmit_one net\/core\/dev.c:3644 [inline]\n[<ffffffff84d03900>] dev_hard_start_xmit+0x320\/0x980 net\/core\/dev.c:3660\n[<ffffffff84d080e2>] __dev_queue_xmit+0x16b2\/0x3370 net\/core\/dev.c:4324\n[<ffffffff855ce4cd>] dev_queue_xmit include\/linux\/netdevice.h:3067 [inline]\n[<ffffffff855ce4cd>] neigh_hh_output include\/net\/neighbour.h:529 [inline]\n[<f\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: ipvlan: agregue el asistente ipvlan_route_v6_outbound(). Inspirado en los informes de syzbot que utilizan una pila de múltiples dispositivos ipvlan. Reduzca el tamaño de pila necesario en ipvlan_process_v6_outbound() moviendo la estructura flowi6 utilizada para la búsqueda de rutas en un asistente no integrado. ipvlan_route_v6_outbound() necesita 120 bytes en la pila, que se recuperan inmediatamente. También asegúrese de que ipvlan_process_v4_outbound() no esté incluido. Es posible que también tengamos que reducir MAX_NEST_DEV, porque solo syzbot usa configuraciones con más de cuatro dispositivos apilados. ERROR: La página de protección de la pila de TAREA fue alcanzada en ffffc9000e803ff8 (la pila es ffffc9000e804000..ffffc9000e808000) página de protección de la pila: 0000 [#1] SMP KASAN CPU: 0 PID: 13442 Comm: syz-executor.4 No contaminado 6.1.52-syzkaller # 0 Nombre del hardware: Google Google Compute Engine\/Google Compute Engine, BIOS Google 09\/10\/2023 RIP: 0010:kasan_check_range+0x4\/0x2a0 mm\/kasan\/generic.c:188 Código: 48 01 c6 48 89 c7 e8 db 4e c1 03 31 c0 5d c3 cc 0f 0b eb 02 0f 0b b8 ea ff ff ff 5d c3 cc 00 00 cc cc 00 00 cc cc 55 48 89 e5 &lt;41&gt; 57 41 56 41 55 41 54 53 b0 01 48 85 f6 0 f 84 a4 01 00 00 48 89 RSP: 0018:ffffc9000e804000 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 00000000000000000 RCX: ffffffff817e5bf2 RDX: 000000000 RSI: 0000000000000008 RDI: ffffffff887c6568 RBP: ffffc9000e804000 R08: 00000000000000000 R09: 0000000000000000 R10: 000000000000000 00 R11: dffffc0000000001 R12: 1ffff92001d0080c R13: dffffc0000000000 R14: ffffffff87e6b100 R15: 0000000000000000 FS: 00007fd0c55826c0(0000) GS:ffff8881f6800000(0000) knlGS:00000000000000 00 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffc9000e803ff8 CR3: 0000000170ef7000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Seguimiento de llamadas: &lt;#DF&gt;   [] __kasan_check_read+0x11\/0x20 mm\/kasan\/shadow.c:31 [] instrument_atomic_read include\/linux\/instrumented.h:72 [en línea] [] _test_bit include\/asm-generic\/bitops\/instrumented-non-atomic.h:141 [en línea] [] cpumask_test_cpu include\/linux \/cpumask.h:506 [en línea] [] cpu_online include\/linux\/cpumask.h:1092 [en línea] [] trace_lock_acquire include\/trace\/events\/lock.h:24 [en línea] [] lock_acquire+0xe2\/0x590 kernel\/locking\/lockdep.c:5632 [] rcu_lock_acquire+0x2e\/0x40 include\/linux\/rcupdate.h:306 [] rcu_read_lock include\/linux\/rcupdate.h:747 [en línea] [] ip6_pol_route+0x15d\/0x1440 net\/ipv6\/route.c:2221 [] ip6_pol_route_output+0x50\/0x80 net\/ipv6\/route.c:2606 [ ] pol_lookup_func incluir\/net \/ip6_fib.h:584 [en línea] [] fib6_rule_lookup+0x265\/0x620 net\/ipv6\/fib6_rules.c:116 [] ip6_route_output_flags_noref+0x2d9\/0x3a0 net\/ipv6\/route .c:2638 [] ip6_route_output_flags+0xca\/0x340 net\/ipv6\/route.c:2651 [] ip6_route_output include\/net\/ip6_route.h:100 [en línea] [] ipvlan_process_v6_outbound drivers\/net\/ipvlan\/ipvlan _core.c: 473 [en línea] [] ipvlan_process_outbound drivers\/net\/ipvlan\/ipvlan_core.c:529 [en línea] [] ipvlan_xmit_mode_l3 drivers\/net\/ipvlan\/ipvlan_core.c:602 [en línea] [ ] ipvlan_queue_xmit +0xc33\/0x1be0 drivers\/net\/ipvlan\/ipvlan_core.c:677 [] ipvlan_start_xmit+0x49\/0x100 drivers\/net\/ipvlan\/ipvlan_main.c:229 [] netdev_start_xmit include\/linux\/netdevice.h: 4966 [en línea] [] xmit_one net\/core\/dev.c:3644 [en línea] [] dev_hard_start_xmit+0x320\/0x980 net\/core\/dev.c:3660 [] __dev_queue_xmit+ 0x16b2\/ 0x3370 net\/core\/dev.c:4324  --truncado--"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/03cddc4df8c6be47fd27c8f8b87e5f9a989e1458","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/18f039428c7df183b09c69ebf10ffd4e521035d2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1f64cad3ac38ac5978b53c40e6c5e6fd3477c68f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/43b781e7cb5cd0b435de276111953bf2bacd1f02","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4d2d30f0792b47908af64c4d02ed1ee25ff50542","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4f7f850611aa27aaaf1bf5687702ad2240ae442a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/732a67ca436887b594ebc43bb5a04ffb0971a760","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8872dc638c24bb774cd2224a69d72a7f661a4d56","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52797","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.230","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers: perf: Check find_first_bit() return value\n\nWe must check the return value of find_first_bit() before using the\nreturn value as an index array since it happens to overflow the array\nand then panic:\n\n[  107.318430] Kernel BUG [#1]\n[  107.319434] CPU: 3 PID: 1238 Comm: kill Tainted: G            E      6.6.0-rc6ubuntu-defconfig #2\n[  107.319465] Hardware name: riscv-virtio,qemu (DT)\n[  107.319551] epc : pmu_sbi_ovf_handler+0x3a4\/0x3ae\n[  107.319840]  ra : pmu_sbi_ovf_handler+0x52\/0x3ae\n[  107.319868] epc : ffffffff80a0a77c ra : ffffffff80a0a42a sp : ffffaf83fecda350\n[  107.319884]  gp : ffffffff823961a8 tp : ffffaf8083db1dc0 t0 : ffffaf83fecda480\n[  107.319899]  t1 : ffffffff80cafe62 t2 : 000000000000ff00 s0 : ffffaf83fecda520\n[  107.319921]  s1 : ffffaf83fecda380 a0 : 00000018fca29df0 a1 : ffffffffffffffff\n[  107.319936]  a2 : 0000000001073734 a3 : 0000000000000004 a4 : 0000000000000000\n[  107.319951]  a5 : 0000000000000040 a6 : 000000001d1c8774 a7 : 0000000000504d55\n[  107.319965]  s2 : ffffffff82451f10 s3 : ffffffff82724e70 s4 : 000000000000003f\n[  107.319980]  s5 : 0000000000000011 s6 : ffffaf8083db27c0 s7 : 0000000000000000\n[  107.319995]  s8 : 0000000000000001 s9 : 00007fffb45d6558 s10: 00007fffb45d81a0\n[  107.320009]  s11: ffffaf7ffff60000 t3 : 0000000000000004 t4 : 0000000000000000\n[  107.320023]  t5 : ffffaf7f80000000 t6 : ffffaf8000000000\n[  107.320037] status: 0000000200000100 badaddr: 0000000000000000 cause: 0000000000000003\n[  107.320081] [<ffffffff80a0a77c>] pmu_sbi_ovf_handler+0x3a4\/0x3ae\n[  107.320112] [<ffffffff800b42d0>] handle_percpu_devid_irq+0x9e\/0x1a0\n[  107.320131] [<ffffffff800ad92c>] generic_handle_domain_irq+0x28\/0x36\n[  107.320148] [<ffffffff8065f9f8>] riscv_intc_irq+0x36\/0x4e\n[  107.320166] [<ffffffff80caf4a0>] handle_riscv_irq+0x54\/0x86\n[  107.320189] [<ffffffff80cb0036>] do_irq+0x64\/0x96\n[  107.320271] Code: 85a6 855e b097 ff7f 80e7 9220 b709 9002 4501 bbd9 (9002) 6097\n[  107.320585] ---[ end trace 0000000000000000 ]---\n[  107.320704] Kernel panic - not syncing: Fatal exception in interrupt\n[  107.320775] SMP: stopping secondary CPUs\n[  107.321219] Kernel Offset: 0x0 from 0xffffffff80000000\n[  107.333051] ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drivers: perf: Verifique el valor de retorno de find_first_bit(). Debemos verificar el valor de retorno de find_first_bit() antes de usar el valor de retorno como una matriz de índice ya que sucede que desborda la matriz y luego pánico: [107.318430] BUG del kernel [#1] [107.319434] CPU: 3 PID: 1238 Comm: kill Contaminado: GE 6.6.0-rc6ubuntu-defconfig #2 [ 107.319465] Nombre de hardware: riscv-virtio,qemu (DT) [ 107.319551] epc: pmu_sbi_ovf_handler+0x3a4\/0x3ae [107.319840] ra: pmu_sbi_ovf_handler+0x52\/0x3ae [107.319868] epc: ffffffff80a0a77c ra: ffffffff80a0a42a sp: 83fecda350 [ 107.319884] gp : ffffffff823961a8 tp : ffffaf8083db1dc0 t0 : ffffaf83fecda480 [ 107.319899] t1 : ffffffff80cafe62 t2 : 000000000000ff00 s0 : ffffaf83fecda520 [ 107.319921] s1 : ffffaf83fecda380 a0 : 00000018fca29df0 a1 : ffffffffffffffff [ 107.319936] a2 : 000000000107373 4 a3: 0000000000000004 a4: 0000000000000000 [107.319951] a5: 0000000000000040 a6: 000000001d1c8774 a7: 000000000504d55 [107.3199 65] s2: ffffffff82451f10 s3: ffffffff82724e70 s4: 000000000000003f [107.319980] s5: 0000000000000011 s6: ffffaf8083db27c0 s7: 00000000000000000 [107.319995] s8: 000000000000 0001 s9: 00007fffb45d6558 s10: 00007fffb45d81a0 [107.320009] s11: ffffaf7ffff60000 t3: 00000000000000004 t4: 0000000000000000 [ 107.320 023] t5: ffffaf7f80000000 t6: ffffaf8000000000 [107.320037 ] estado: 0000000200000100 badaddr: 00000000000000000 causa: 0000000000000003 [ 107.320081] [] pmu_sbi_ovf_handler+0x3a4\/0x3ae [ 107.3201 12] [] handle_percpu_devid_irq+0x9e\/0x1a0 [ 107.320131] [] generic_handle_domain_irq+0x28\/0x36 [ 107.320148] [] riscv_intc_irq+0x36\/0x4e [ 107.320166] [] handle_riscv_irq+0x54\/0x86 [ 107.320189] [] _irq+0x64\/0x96 [ 107.320271] Código: 85a6 855e b097 ff7f 80e7 9220 b709 9002 4501 bbd9 (9002) 6097 [107.320585] ---[ seguimiento final 0000000000000000 ]--- [ 107.320704] Pánico del kernel - no se sincroniza: excepción fatal en interrupción [ 107.320775] SMP: deteniendo CPU secundarias [ 107.32121 9]Compensación del kernel: 0x0 desde 0xffffffff80000000 [107.333051] ---[ fin del pánico del kernel - no se sincroniza: excepción fatal en la interrupción ]---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2c86b24095fcf72cf51bc72d12e4350163b4e11d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/45a0de41ec383c8b7c6d442734ba3852dd2fc4a7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c6e316ac05532febb0c966fa9b55f5258ed037be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52798","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.370","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: fix dfs radar event locking\n\nThe ath11k active pdevs are protected by RCU but the DFS radar event\nhandling code calling ath11k_mac_get_ar_by_pdev_id() was not marked as a\nread-side critical section.\n\nMark the code in question as an RCU read-side critical section to avoid\nany potential use-after-free issues.\n\nCompile tested only."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: wifi: ath11k: corrige el bloqueo de eventos de radar dfs. Los pdevs activos de ath11k están protegidos por RCU, pero el código de manejo de eventos de radar DFS que llama a ath11k_mac_get_ar_by_pdev_id() no se marcó como una sección crítica del lado de lectura . Marque el código en cuestión como una sección crítica del lado de lectura de RCU para evitar posibles problemas de use after free. Compilación probada únicamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1fd878e1750190a612b5de2af357cca422ec0822","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/21ebb0aba580d347e12f01ce5f6e75044427b3d5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3b6c14833165f689cc5928574ebafe52bbce5f1e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/426e718ce9ba60013364a54233feee309356cb82","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca420ac4f9451f22347bae44b18ab47ba2c267ec","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f882f51905517575c9f793a3dff567af90ef9a10","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52799","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.443","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix array-index-out-of-bounds in dbFindLeaf\n\nCurrently while searching for dmtree_t for sufficient free blocks there\nis an array out of bounds while getting element in tp->dm_stree. To add\nthe required check for out of bound we first need to determine the type\nof dmtree. Thus added an extra parameter to dbFindLeaf so that the type\nof tree can be determined and the required check can be applied."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: jfs: corrige el índice de matriz fuera de los límites en dbFindLeaf. Actualmente, mientras se busca dmtree_t para suficientes bloques libres, hay una matriz fuera de los límites al obtener el elemento en tp-&gt;dm_stree . Para agregar la verificación requerida para fuera de los límites, primero debemos determinar el tipo de dmtree. Por lo tanto, se agregó un parámetro adicional a dbFindLeaf para que se pueda determinar el tipo de árbol y se pueda aplicar la verificación requerida."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/20f9310a18e3e99fc031e036fcbed67105ae1859","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/22cad8bc1d36547cdae0eef316c47d917ce3147c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/81aa58cd8495b8c3b527f58ccbe19478d8087f61","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/86df90f3fea7c5591f05c8a0010871d435e83046","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/87c681ab49e99039ff2dd3e71852417381b13878","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/88b7894a8f8705bf4e7ea90b10229376abf14514","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a50b796d36719757526ee094c703378895ab5e67","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/da3da5e1e6f71c21d8e6149d7076d936ef5d4cb9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ecfb47f13b08b02cf28b7b50d4941eefa21954d2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52800","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.523","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: fix htt pktlog locking\n\nThe ath11k active pdevs are protected by RCU but the htt pktlog handling\ncode calling ath11k_mac_get_ar_by_pdev_id() was not marked as a\nread-side critical section.\n\nMark the code in question as an RCU read-side critical section to avoid\nany potential use-after-free issues.\n\nCompile tested only."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: wifi: ath11k: corrige el bloqueo de htt pktlog. Los pdevs activos de ath11k están protegidos por RCU, pero el código de manejo de htt pktlog que llama a ath11k_mac_get_ar_by_pdev_id() no se marcó como una sección crítica del lado de lectura. Marque el código en cuestión como una sección crítica del lado de lectura de RCU para evitar posibles problemas de use after free. Compilación probada únicamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/03ed26935bebf6b6fd8a656490bf3dcc71b72679","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3a51e6b4da71fdfa43ec006d6abc020f3e22d14e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3f77c7d605b29df277d77e9ee75d96e7ad145d2d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/423762f021825b5e57c3d6f01ff96a9ff19cdcd8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/69cede2a5a5f60e3f5602b901b52cb64edd2ea6c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e3199b3fac65c9f103055390b6fd07c5cffa5961","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52801","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.603","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\niommufd: Fix missing update of domains_itree after splitting iopt_area\n\nIn iopt_area_split(), if the original iopt_area has filled a domain and is\nlinked to domains_itree, pages_nodes have to be properly\nreinserted. Otherwise the domains_itree becomes corrupted and we will UAF."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: iommufd: corrige la actualización faltante de domains_itree después de dividir iopt_area. En iopt_area_split(), si el iopt_area original ha llenado un dominio y está vinculado a domains_itree, los pages_nodes deben reinsertarse correctamente. De lo contrario, domains_itree se corrompe y usaremos UAF."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/836db2e7e4565d8218923b3552304a1637e2f28d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e7250ab7ca4998fe026f2149805b03e09dc32498","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fcb32111f01ddf3cbd04644cde1773428e31de6a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52802","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.680","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\niio: adc: stm32-adc: harden against NULL pointer deref in stm32_adc_probe()\n\nof_match_device() may fail and returns a NULL pointer.\n\nIn practice there is no known reasonable way to trigger this, but\nin case one is added in future, harden the code by adding the check"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: iio: adc: stm32-adc: endurece contra puntero NULL deref en stm32_adc_probe() of_match_device() puede fallar y devuelve un puntero NULL. En la práctica, no se conoce una forma razonable de activar esto, pero en caso de que se agregue una en el futuro, endurezca el código agregando la verificación"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3a23b384e7e3d64d5587ad10729a34d4f761517e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5b82e4240533bcd4691e50b64ec86d0d7fbd21b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b028f89c56e964a22d3ddb8eab1a0e7e980841b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b80aaff5f7817d50798ac61ed75973f004dd5202","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52803","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.753","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nSUNRPC: Fix RPC client cleaned up the freed pipefs dentries\n\nRPC client pipefs dentries cleanup is in separated rpc_remove_pipedir()\nworkqueue,which takes care about pipefs superblock locking.\nIn some special scenarios, when kernel frees the pipefs sb of the\ncurrent client and immediately alloctes a new pipefs sb,\nrpc_remove_pipedir function would misjudge the existence of pipefs\nsb which is not the one it used to hold. As a result,\nthe rpc_remove_pipedir would clean the released freed pipefs dentries.\n\nTo fix this issue, rpc_remove_pipedir should check whether the\ncurrent pipefs sb is consistent with the original pipefs sb.\n\nThis error can be catched by KASAN:\n=========================================================\n[  250.497700] BUG: KASAN: slab-use-after-free in dget_parent+0x195\/0x200\n[  250.498315] Read of size 4 at addr ffff88800a2ab804 by task kworker\/0:18\/106503\n[  250.500549] Workqueue: events rpc_free_client_work\n[  250.501001] Call Trace:\n[  250.502880]  kasan_report+0xb6\/0xf0\n[  250.503209]  ? dget_parent+0x195\/0x200\n[  250.503561]  dget_parent+0x195\/0x200\n[  250.503897]  ? __pfx_rpc_clntdir_depopulate+0x10\/0x10\n[  250.504384]  rpc_rmdir_depopulate+0x1b\/0x90\n[  250.504781]  rpc_remove_client_dir+0xf5\/0x150\n[  250.505195]  rpc_free_client_work+0xe4\/0x230\n[  250.505598]  process_one_work+0x8ee\/0x13b0\n...\n[   22.039056] Allocated by task 244:\n[   22.039390]  kasan_save_stack+0x22\/0x50\n[   22.039758]  kasan_set_track+0x25\/0x30\n[   22.040109]  __kasan_slab_alloc+0x59\/0x70\n[   22.040487]  kmem_cache_alloc_lru+0xf0\/0x240\n[   22.040889]  __d_alloc+0x31\/0x8e0\n[   22.041207]  d_alloc+0x44\/0x1f0\n[   22.041514]  __rpc_lookup_create_exclusive+0x11c\/0x140\n[   22.041987]  rpc_mkdir_populate.constprop.0+0x5f\/0x110\n[   22.042459]  rpc_create_client_dir+0x34\/0x150\n[   22.042874]  rpc_setup_pipedir_sb+0x102\/0x1c0\n[   22.043284]  rpc_client_register+0x136\/0x4e0\n[   22.043689]  rpc_new_client+0x911\/0x1020\n[   22.044057]  rpc_create_xprt+0xcb\/0x370\n[   22.044417]  rpc_create+0x36b\/0x6c0\n...\n[   22.049524] Freed by task 0:\n[   22.049803]  kasan_save_stack+0x22\/0x50\n[   22.050165]  kasan_set_track+0x25\/0x30\n[   22.050520]  kasan_save_free_info+0x2b\/0x50\n[   22.050921]  __kasan_slab_free+0x10e\/0x1a0\n[   22.051306]  kmem_cache_free+0xa5\/0x390\n[   22.051667]  rcu_core+0x62c\/0x1930\n[   22.051995]  __do_softirq+0x165\/0x52a\n[   22.052347]\n[   22.052503] Last potentially related work creation:\n[   22.052952]  kasan_save_stack+0x22\/0x50\n[   22.053313]  __kasan_record_aux_stack+0x8e\/0xa0\n[   22.053739]  __call_rcu_common.constprop.0+0x6b\/0x8b0\n[   22.054209]  dentry_free+0xb2\/0x140\n[   22.054540]  __dentry_kill+0x3be\/0x540\n[   22.054900]  shrink_dentry_list+0x199\/0x510\n[   22.055293]  shrink_dcache_parent+0x190\/0x240\n[   22.055703]  do_one_tree+0x11\/0x40\n[   22.056028]  shrink_dcache_for_umount+0x61\/0x140\n[   22.056461]  generic_shutdown_super+0x70\/0x590\n[   22.056879]  kill_anon_super+0x3a\/0x60\n[   22.057234]  rpc_kill_sb+0x121\/0x200"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: SUNRPC: el cliente RPC limpió los pipefs dentries liberados. La limpieza de pipefs dentries del cliente RPC está en la cola de trabajo separada rpc_remove_pipedir(), que se encarga del bloqueo del superbloque de pipefs. En algunos escenarios especiales, cuando el kernel libera el pipefs sb del cliente actual e inmediatamente asigna un nuevo pipefs sb, la función rpc_remove_pipedir juzgaría mal la existencia de pipefs sb que no es el que solía contener. Como resultado, rpc_remove_pipedir limpiaría las dentrías de pipefs liberadas. Para solucionar este problema, rpc_remove_pipedir debe verificar si el pipefs sb actual es consistente con el pipefs sb original. KASAN puede detectar este error: ============================================ =============== [250.497700] BUG: KASAN: slab-use-after-free en dget_parent+0x195\/0x200 [250.498315] Lectura de tamaño 4 en la dirección ffff88800a2ab804 por tarea kworker\/0 :18\/106503 [250.500549] Cola de trabajo: eventos rpc_free_client_work [250.501001] Seguimiento de llamadas: [250.502880] kasan_report+0xb6\/0xf0 [250.503209]? dget_parent+0x195\/0x200 [ 250.503561] dget_parent+0x195\/0x200 [ 250.503897] ? __pfx_rpc_clntdir_depopulate+0x10\/0x10 [ 250.504384] rpc_rmdir_depopulate+0x1b\/0x90 [ 250.504781] rpc_remove_client_dir+0xf5\/0x150 [ 250.505195] \/0x230 [ 250.505598] Process_one_work+0x8ee\/0x13b0 ... [ 22.039056] Asignado por la tarea 244: [ 22.039390 ] kasan_save_stack+0x22\/0x50 [ 22.039758] kasan_set_track+0x25\/0x30 [ 22.040109] __kasan_slab_alloc+0x59\/0x70 [ 22.040487] kmem_cache_alloc_lru+0xf0\/0x240 [ 22.0408 89] __d_alloc+0x31\/0x8e0 [ 22.041207] d_alloc+0x44\/0x1f0 [ 22.041514] __rpc_lookup_create_exclusive +0x11c\/0x140 [ 22.041987] rpc_mkdir_populate.constprop.0+0x5f\/0x110 [ 22.042459] rpc_create_client_dir+0x34\/0x150 [ 22.042874] rpc_setup_pipedir_sb+0x102\/0x1c0 [ 22.043284] rpc_client_register+0x136\/0x4e0 [ 22.043689] rpc_new_client+0x911\/0x1020 [ 22.044057 ] rpc_create_xprt+0xcb\/0x370 [ 22.044417] rpc_create+0x36b\/0x6c0 ... [ 22.049524] Liberado por la tarea 0: [ 22.049803] kasan_save_stack+0x22\/0x50 [ 22.050165] 25\/0x30 [ 22.050520] kasan_save_free_info+0x2b\/0x50 [ 22.050921] __kasan_slab_free+0x10e\/0x1a0 [ 22.051306] kmem_cache_free+0xa5\/0x390 [ 22.051667] rcu_core+0x62c\/0x1930 [ 22.051995] __do_softirq+0x165\/0x52a [ 22.052347] [ 22.052503] Última creación de trabajo potencialmente relacionado: [ 22.052952] kasan_save_stack+0x22\/ 0x50 [ 22.053313] __kasan_record_aux_stack+0x8e\/0xa0 [ 22.053739] __call_rcu_common.constprop.0+0x6b\/0x8b0 [ 22.054209] dentry_free+0xb2\/0x140 [ __dentry_kill+ 0x3be\/0x540 [22.054900] Shrink_dentry_list+0x199\/0x510 [22.055293] Shrink_dcache_parent+ 0x190\/0x240 [ 22.055703] do_one_tree+0x11\/0x40 [ 22.056028] shrink_dcache_for_umount+0x61\/0x140 [ 22.056461] generic_shutdown_super+0x70\/0x590 [ 22.056879] 3a\/0x60 [22.057234] rpc_kill_sb+0x121\/0x200"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/194454afa6aa9d6ed74f0c57127bc8beb27c20df","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1cdb52ffd6600a37bd355d8dce58ecd03e55e618","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7749fd2dbef72a52b5c9ffdbf877691950ed4680","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bfca5fb4e97c46503ddfc582335917b0cc228264","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cc2e7ebbeb1d0601f7f3c8d93b78fcc03a95e44a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dedf2a0eb9448ae73b270743e6ea9b108189df46","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52804","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.820","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nfs\/jfs: Add validity check for db_maxag and db_agpref\n\nBoth db_maxag and db_agpref are used as the index of the\ndb_agfree array, but there is currently no validity check for\ndb_maxag and db_agpref, which can lead to errors.\n\nThe following is related bug reported by Syzbot:\n\nUBSAN: array-index-out-of-bounds in fs\/jfs\/jfs_dmap.c:639:20\nindex 7936 is out of range for type 'atomic_t[128]'\n\nAdd checking that the values of db_maxag and db_agpref are valid\nindexes for the db_agfree array."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: fs\/jfs: agregue verificación de validez para db_maxag y db_agpref. Tanto db_maxag como db_agpref se utilizan como índice de la matriz db_agfree, pero actualmente no hay verificación de validez para db_maxag y db_agpref, lo cual puede dar lugar a errores. El siguiente es un error relacionado reportado por Syzbot: UBSAN: array-index-out-of-bounds in fs\/jfs\/jfs_dmap.c:639:20 el índice 7936 está fuera de rango para el tipo 'atomic_t[128]' Agregue verificando que el Los valores de db_maxag y db_agpref son índices válidos para la matriz db_agfree."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1f74d336990f37703a8eee77153463d65b67f70e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2323de34a3ae61a9f9b544c18583f71cea86721f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/32bd8f1cbcf8b663e29dd1f908ba3a129541a11b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5013f8269887642cca784adc8db9b5f0b771533f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/64933ab7b04881c6c18b21ff206c12278341c72e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a0649e2dd4a3595b5595a29d0064d047c2fae2fb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c6c8863fb3f57700ab583d875adda04caaf2278a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ce15b0f1a431168f07b1cc6c9f71206a2db5c809","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dca403bb035a565bb98ecc1dda5d30f676feda40","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52805","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.890","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix array-index-out-of-bounds in diAlloc\n\nCurrently there is not check against the agno of the iag while\nallocating new inodes to avoid fragmentation problem. Added the check\nwhich is required."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: jfs: corrige el índice de matriz fuera de los límites en diAlloc. Actualmente no se verifica el agno del iag al asignar nuevos inodos para evitar problemas de fragmentación. Se agregó la comprobación que se requiere."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/05d9ea1ceb62a55af6727a69269a4fd310edf483","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1708d0a9917fea579cc9da3d87b154285abd2cd8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1ba7df5457dc1c1071c5f92ac11323533a6430e1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2308d0fb0dc32446b4e6ca37cd09c30374bb64e9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/64f062baf202b82f54987a3f614a6c8f3e466641","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/665b44e55c2767a4f899c3b18f49e9e1c9983777","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7467ca10a5ff09b0e87edf6c4d2a4bfdee69cf2c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8c68af2af697ba2ba3b138be0c6d72e2ce3a3d6d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cf7e3e84df36a9953796c737f080712f631d7083","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52806","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:18.963","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: hda: Fix possible null-ptr-deref when assigning a stream\n\nWhile AudioDSP drivers assign streams exclusively of HOST or LINK type,\nnothing blocks a user to attempt to assign a COUPLED stream. As\nsupplied substream instance may be a stub, what is the case when\ncode-loading, such scenario ends with null-ptr-deref."},{"lang":"es","value":"En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: ALSA: hda: Corrige posible null-ptr-deref al asignar un flujo. Si bien los controladores AudioDSP asignan flujos exclusivamente de tipo HOST o LINK, nada impide que un usuario intente asignar un flujo ACOPLADO. Como la instancia de subsecuencia proporcionada puede ser un código auxiliar, cuál es el caso cuando se carga el código, dicho escenario termina con null-ptr-deref."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2527775616f3638f4fd54649eba8c7b84d5e4250","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/25354bae4fc310c3928e8a42fda2d486f67745d7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/43b91df291c8802268ab3cfd8fccfdf135800ed4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4a320da7f7cbdab2098b103c47f45d5061f42edd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/631a96e9eb4228ff75fce7e72d133ca81194797e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/758c7733cb821041f5fd403b7b97c0b95d319323","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7de25112de8222fd20564769e6c99dc9f9738a0b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f93dc90c2e8ed664985e366aa6459ac83cdab236","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fe7c1a0c2b25c82807cb46fc3aadbf2664a682b0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52807","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.033","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hns3: fix out-of-bounds access may occur when coalesce info is read via debugfs\n\nThe hns3 driver define an array of string to show the coalesce\ninfo, but if the kernel adds a new mode or a new state,\nout-of-bounds access may occur when coalesce info is read via\ndebugfs, this patch fix the problem."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: hns3: se puede corregir el acceso fuera de los límites cuando se lee la información fusionada a través de debugfs. El controlador hns3 define una matriz de cadenas para mostrar la información fusionada, pero si el kernel agrega un nuevo modo o un nuevo estado, puede ocurrir acceso fuera de los límites cuando se lee información fusionada a través de debugfs, este parche soluciona el problema."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/07f5b8c47152cadbd9102e053dcb60685820aa09","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/53aba458f23846112c0d44239580ff59bc5c36c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/be1f703f39efa27b7371b9a4cd983317f1366792","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f79d985c69060047426be68b7e4c1663d5d731b4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52808","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.113","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: hisi_sas: Set debugfs_dir pointer to NULL after removing debugfs\n\nIf init debugfs failed during device registration due to memory allocation\nfailure, debugfs_remove_recursive() is called, after which debugfs_dir is\nnot set to NULL. debugfs_remove_recursive() will be called again during\ndevice removal. As a result, illegal pointer is accessed.\n\n[ 1665.467244] hisi_sas_v3_hw 0000:b4:02.0: failed to init debugfs!\n...\n[ 1669.836708] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000a0\n[ 1669.872669] pc : down_write+0x24\/0x70\n[ 1669.876315] lr : down_write+0x1c\/0x70\n[ 1669.879961] sp : ffff000036f53a30\n[ 1669.883260] x29: ffff000036f53a30 x28: ffffa027c31549f8\n[ 1669.888547] x27: ffffa027c3140000 x26: 0000000000000000\n[ 1669.893834] x25: ffffa027bf37c270 x24: ffffa027bf37c270\n[ 1669.899122] x23: ffff0000095406b8 x22: ffff0000095406a8\n[ 1669.904408] x21: 0000000000000000 x20: ffffa027bf37c310\n[ 1669.909695] x19: 00000000000000a0 x18: ffff8027dcd86f10\n[ 1669.914982] x17: 0000000000000000 x16: 0000000000000000\n[ 1669.920268] x15: 0000000000000000 x14: ffffa0274014f870\n[ 1669.925555] x13: 0000000000000040 x12: 0000000000000228\n[ 1669.930842] x11: 0000000000000020 x10: 0000000000000bb0\n[ 1669.936129] x9 : ffff000036f537f0 x8 : ffff80273088ca10\n[ 1669.941416] x7 : 000000000000001d x6 : 00000000ffffffff\n[ 1669.946702] x5 : ffff000008a36310 x4 : ffff80273088be00\n[ 1669.951989] x3 : ffff000009513e90 x2 : 0000000000000000\n[ 1669.957276] x1 : 00000000000000a0 x0 : ffffffff00000001\n[ 1669.962563] Call trace:\n[ 1669.965000]  down_write+0x24\/0x70\n[ 1669.968301]  debugfs_remove_recursive+0x5c\/0x1b0\n[ 1669.972905]  hisi_sas_debugfs_exit+0x24\/0x30 [hisi_sas_main]\n[ 1669.978541]  hisi_sas_v3_remove+0x130\/0x150 [hisi_sas_v3_hw]\n[ 1669.984175]  pci_device_remove+0x48\/0xd8\n[ 1669.988082]  device_release_driver_internal+0x1b4\/0x250\n[ 1669.993282]  device_release_driver+0x28\/0x38\n[ 1669.997534]  pci_stop_bus_device+0x84\/0xb8\n[ 1670.001611]  pci_stop_and_remove_bus_device_locked+0x24\/0x40\n[ 1670.007244]  remove_store+0xfc\/0x140\n[ 1670.010802]  dev_attr_store+0x44\/0x60\n[ 1670.014448]  sysfs_kf_write+0x58\/0x80\n[ 1670.018095]  kernfs_fop_write+0xe8\/0x1f0\n[ 1670.022000]  __vfs_write+0x60\/0x190\n[ 1670.025472]  vfs_write+0xac\/0x1c0\n[ 1670.028771]  ksys_write+0x6c\/0xd8\n[ 1670.032071]  __arm64_sys_write+0x24\/0x30\n[ 1670.035977]  el0_svc_common+0x78\/0x130\n[ 1670.039710]  el0_svc_handler+0x38\/0x78\n[ 1670.043442]  el0_svc+0x8\/0xc\n\nTo fix this, set debugfs_dir to NULL after debugfs_remove_recursive()."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: scsi: hisi_sas: establezca el puntero debugfs_dir en NULL después de eliminar debugfs. Si init debugfs falló durante el registro del dispositivo debido a un fallo en la asignación de memoria, se llama a debugfs_remove_recursive(), después de lo cual debugfs_dir no se configura en NULO. Se volverá a llamar a debugfs_remove_recursive() durante la eliminación del dispositivo. Como resultado, se accede a un puntero ilegal. [1665.467244] hisi_sas_v3_hw 0000:b4:02.0: ¡no se pudo iniciar debugfs! ... [1669.836708] No se puede manejar la desreferencia del puntero NULL del kernel en la dirección virtual 00000000000000a0 [1669.872669] pc: down_write+0x24\/0x70 [1669.876315] lr: down_write+0x1c\/0x70 [1669.879961] sp: ffff000036f53a30 [ 1669.883260] x29: ffff000036f53a30 x28 : ffffa027c31549f8 [ 1669.888547] x27: ffffa027c3140000 x26: 0000000000000000 [ 1669.893834] x25: ffffa027bf37c270 x24: ffffa027bf37c270 [ 166 9.899122] x23: ffff0000095406b8 x22: ffff0000095406a8 [ 1669.904408] x21: 00000000000000000 x20: ffffa027bf37c310 [ 1669.909695] x19: 000000000a0 x18: ffff8027dcd86f10 [1669.914982] x17: 0000000000000000 x16: 0000000000000000 [ 1669.920268] x15: 0000000000000000 x14: ffffa0274014f870 [ 1669.925555] x13: 000000000 0000040 x12: 0000000000000228 [1669.930842] x11: 0000000000000020 x10: 0000000000000bb0 [1669.936129] x9: ffff000036f537f0 x8: 73088ca10 [1669.941416] x7: 000000000000001d x6: 00000000ffffffff [ 1669.946702] x5 : ffff000008a36310 x4 : ffff80273088be00 [ 1669.951989 ] x3 : ffff000009513e90 x2 : 0000000000000000 [ 1669.95 7276] x1: 00000000000000a0 x0: ffffffff00000001 [1669.962563] Seguimiento de llamadas: [1669.965000] down_write+0x24\/0x70 [1669.968301] debugfs_remove_recursive+0x5c\/0x1b0 [ 1669.972905] hisi_sas_debugfs_exit+0x24\/0x30 [hisi_sas_main] [ 1669.978541] hisi_sas_v3_remove+0x130\/0x150 [hisi_sas_v3_hw] [ 1669.984175] pci_device_remove+0x48\/0 xd8 [ 1669.988082] device_release_driver_internal+0x1b4\/0x250 [ 1669.993282] device_release_driver+0x28\/0x38 [ 1669.997534] pci_stop_bus_device +0x84\/0xb8 [ 1670.001611] pci_stop_and_remove_bus_device_locked+0x24\/0x40 [ 1670.007244] remove_store+0xfc\/0x140 [ 1670.010802] dev_attr_store+0x44\/0x60 [ 1670.01444 8] sysfs_kf_write+0x58\/0x80 [ 1670.018095] kernfs_fop_write+0xe8\/0x1f0 [ 1670.022000] __vfs_write+0x60 \/0x190 [ 1670.025472] vfs_write+0xac\/0x1c0 [ 1670.028771] ksys_write+0x6c\/0xd8 [ 1670.032071] __arm64_sys_write+0x24\/0x30 [ 1670.035977] +0x78\/0x130 [ 1670.039710] el0_svc_handler+0x38\/0x78 [ 1670.043442] el0_svc+0x8\/0xc Para solucionar este problema, establezca debugfs_dir en NULL después de debugfs_remove_recursive()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/33331b265aac9441ac0c1a5442e3f05d038240ec","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6de426f9276c448e2db7238911c97fb157cb23be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/75a2656260fe8c7eeabda6ff4600b29e183f48db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4465009e7d60c6111946db4c8f1e50d401ed7be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f0bfc8a5561fb0b2c48183dcbfe00bdd6d973bd3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52809","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.197","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: libfc: Fix potential NULL pointer dereference in fc_lport_ptp_setup()\n\nfc_lport_ptp_setup() did not check the return value of fc_rport_create()\nwhich can return NULL and would cause a NULL pointer dereference. Address\nthis issue by checking return value of fc_rport_create() and log error\nmessage on fc_rport_create() failed."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: scsi: libfc: corrigió la posible desreferencia del puntero NULL en fc_lport_ptp_setup() fc_lport_ptp_setup() no verificó el valor de retorno de fc_rport_create() que puede devolver NULL y causaría una desreferencia del puntero NULL. Solucione este problema verificando el valor de retorno de fc_rport_create() y el mensaje de error de registro en fc_rport_create() falló."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/442fd24d7b6b29e4a9cd9225afba4142d5f522ba","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4df105f0ce9f6f30cda4e99f577150d23f0c9c5f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/56d78b5495ebecbb9395101f3be177cd0a52450b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6b9ecf4e1032e645873933e5b43cbb84cac19106","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/77072ec41d6ab3718c3fc639bc149b8037caedfa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/930f0aaba4820d6362de4e6ed569eaf444f1ea4e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b549acf999824d4f751ca57965700372f2f3ad00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bb83f79f90e92f46466adcfd4fd264a7ae0f0f01","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f6fe7261b92b21109678747f36df9fdab1e30c34","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52810","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.270","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nfs\/jfs: Add check for negative db_l2nbperpage\n\nl2nbperpage is log2(number of blks per page), and the minimum legal\nvalue should be 0, not negative.\n\nIn the case of l2nbperpage being negative, an error will occur\nwhen subsequently used as shift exponent.\n\nSyzbot reported this bug:\n\nUBSAN: shift-out-of-bounds in fs\/jfs\/jfs_dmap.c:799:12\nshift exponent -16777216 is negative"},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: fs\/jfs: agregue verificación para db_l2nbperpage negativo, l2nbperpage es log2 (número de bloques por página) y el valor mínimo legal debe ser 0, no negativo. En el caso de que l2nbperpage sea negativo, se producirá un error cuando se utilice posteriormente como exponente de desplazamiento. Syzbot informó este error: UBSAN: desplazamiento fuera de los límites en fs\/jfs\/jfs_dmap.c:799:12 el exponente de desplazamiento -16777216 es negativo"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0cb567e727339a192f9fd0db00781d73a91d15a6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1a7c53fdea1d189087544d9a606d249e93c4934b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/491085258185ffc4fb91555b0dba895fe7656a45","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/524b4f203afcf87accfe387e846f33f916f0c907","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/525b861a008143048535011f3816d407940f4bfa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5f148b16972e5f4592629b244d5109b15135f53f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f2964df6bfce9d92d81ca552010b8677af8d9dc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a81a56b4cbe3142cc99f6b98e8f9b3a631c768e1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cc61fcf7d1c99f148fe8ddfb5c6ed0bb75861f01","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52811","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.347","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ibmvfc: Remove BUG_ON in the case of an empty event pool\n\nIn practice the driver should never send more commands than are allocated\nto a queue's event pool. In the unlikely event that this happens, the code\nasserts a BUG_ON, and in the case that the kernel is not configured to\ncrash on panic returns a junk event pointer from the empty event list\ncausing things to spiral from there. This BUG_ON is a historical artifact\nof the ibmvfc driver first being upstreamed, and it is well known now that\nthe use of BUG_ON is bad practice except in the most unrecoverable\nscenario. There is nothing about this scenario that prevents the driver\nfrom recovering and carrying on.\n\nRemove the BUG_ON in question from ibmvfc_get_event() and return a NULL\npointer in the case of an empty event pool. Update all call sites to\nibmvfc_get_event() to check for a NULL pointer and perfrom the appropriate\nfailure or recovery action."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: scsi: ibmvfc: Eliminar BUG_ON en el caso de un grupo de eventos vacío. En la práctica, el controlador nunca debe enviar más comandos de los asignados al grupo de eventos de una cola. En el improbable caso de que esto suceda, el código afirma un BUG_ON, y en el caso de que el kernel no esté configurado para fallar en caso de pánico, devuelve un puntero de evento basura de la lista de eventos vacía, lo que hace que las cosas vayan en espiral a partir de ahí. Este BUG_ON es un artefacto histórico del controlador ibmvfc que se actualizó por primera vez, y ahora es bien sabido que el uso de BUG_ON es una mala práctica, excepto en el escenario más irrecuperable. No hay nada en este escenario que impida al conductor recuperarse y continuar. Elimine el BUG_ON en cuestión de ibmvfc_get_event() y devuelva un puntero NULL en el caso de un grupo de eventos vacío. Actualice todos los sitios de llamadas a ibmvfc_get_event() para comprobar si hay un puntero NULL y realizar la acción de recuperación o error adecuada."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/88984ec4792766df5a9de7a2ff2b5f281f94c7d4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8bbe784c2ff28d56ca0c548aaf3e584edc77052d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b39f2d10b86d0af353ea339e5815820026bca48f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d2af4ef80601224b90630c1ddc7cd2c7c8ab4dd8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e1d1f79b1929dce470a5dc9281c574cd58e8c6c0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52812","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.410","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd: check num of link levels when update pcie param\n\nIn SR-IOV environment, the value of pcie_table->num_of_link_levels will\nbe 0, and num_of_levels - 1 will cause array index out of bounds"},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amd: comprueba el número de niveles de enlace cuando se actualiza el parámetro pcie. En el entorno SR-IOV, el valor de pcie_table-&gt;num_of_link_levels será 0, y num_of_levels - 1 provocará un índice de matriz fuera de los límites."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/09f617219fe9ccd8d7b65dc3e879b5889f663b5a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/406e8845356d18bdf3d3a23b347faf67706472ec","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5b4574b663d0a1a0a62d5232429b7db9ae6d0670","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52813","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.477","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: pcrypt - Fix hungtask for PADATA_RESET\n\nWe found a hungtask bug in test_aead_vec_cfg as follows:\n\nINFO: task cryptomgr_test:391009 blocked for more than 120 seconds.\n\"echo 0 > \/proc\/sys\/kernel\/hung_task_timeout_secs\" disables this message.\nCall trace:\n __switch_to+0x98\/0xe0\n __schedule+0x6c4\/0xf40\n schedule+0xd8\/0x1b4\n schedule_timeout+0x474\/0x560\n wait_for_common+0x368\/0x4e0\n wait_for_completion+0x20\/0x30\n wait_for_completion+0x20\/0x30\n test_aead_vec_cfg+0xab4\/0xd50\n test_aead+0x144\/0x1f0\n alg_test_aead+0xd8\/0x1e0\n alg_test+0x634\/0x890\n cryptomgr_test+0x40\/0x70\n kthread+0x1e0\/0x220\n ret_from_fork+0x10\/0x18\n Kernel panic - not syncing: hung_task: blocked tasks\n\nFor padata_do_parallel, when the return err is 0 or -EBUSY, it will call\nwait_for_completion(&wait->completion) in test_aead_vec_cfg. In normal\ncase, aead_request_complete() will be called in pcrypt_aead_serial and the\nreturn err is 0 for padata_do_parallel. But, when pinst->flags is\nPADATA_RESET, the return err is -EBUSY for padata_do_parallel, and it\nwon't call aead_request_complete(). Therefore, test_aead_vec_cfg will\nhung at wait_for_completion(&wait->completion), which will cause\nhungtask.\n\nThe problem comes as following:\n(padata_do_parallel)                 |\n    rcu_read_lock_bh();              |\n    err = -EINVAL;                   |   (padata_replace)\n                                     |     pinst->flags |= PADATA_RESET;\n    err = -EBUSY                     |\n    if (pinst->flags & PADATA_RESET) |\n        rcu_read_unlock_bh()         |\n        return err\n\nIn order to resolve the problem, we replace the return err -EBUSY with\n-EAGAIN, which means parallel_data is changing, and the caller should call\nit again.\n\nv3:\nremove retry and just change the return err.\nv2:\nintroduce padata_try_do_parallel() in pcrypt_aead_encrypt and\npcrypt_aead_decrypt to solve the hungtask."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: crypto: pcrypt - Reparar hungtask para PADATA_RESET. Encontramos un error de hungtask en test_aead_vec_cfg de la siguiente manera: INFORMACIÓN: tarea cryptomgr_test:391009 bloqueada durante más de 120 segundos. \"echo 0 &gt; \/proc\/sys\/kernel\/hung_task_timeout_secs\" desactiva este mensaje. Seguimiento de llamadas: __switch_to+0x98\/0xe0 __schedule+0x6c4\/0xf40 Schedule+0xd8\/0x1b4 Schedule_timeout+0x474\/0x560 wait_for_common+0x368\/0x4e0 wait_for_completion+0x20\/0x30 wait_for_completion+0x20\/0x30 test_aead_ve c_cfg+0xab4\/0xd50 test_aead+0x144\/0x1f0 alg_test_aead+ 0xd8\/0x1e0 alg_test+0x634\/0x890 cryptomgr_test+0x40\/0x70 kthread+0x1e0\/0x220 ret_from_fork+0x10\/0x18 kernel panic - no syncing: hung_task: tareas bloqueadas para el error for_completion (&amp;esperar-&gt;finalización) en test_aead_vec_cfg. En caso normal, se llamará aead_request_complete() en pcrypt_aead_serial y el error de retorno es 0 para padata_do_parallel. Pero, cuando pinst-&gt;flags es PADATA_RESET, el error de retorno es -EBUSY para padata_do_parallel y no llamará a aead_request_complete(). Por lo tanto, test_aead_vec_cfg se colgará en wait_for_completion(&amp;wait-&gt;completion), lo que provocará que se cuelgue la tarea. El problema viene de la siguiente manera: (padata_do_parallel) | rcu_read_lock_bh(); | err = -EINVAL; | (padata_replace) | pinst-&gt;flags |= PADATA_RESET; err = -EBUSY | si (pinst-&gt;flags &amp; PADATA_RESET) | rcu_read_unlock_bh() | return err Para resolver el problema, reemplazamos el retorno err -EBUSY con -EAGAIN, lo que significa que los datos_paralelos están cambiando y la persona que llama debe llamarlo nuevamente. v3: elimine el reintento y simplemente cambie el error de devolución. v2: introduce padata_try_do_parallel() en pcrypt_aead_encrypt y pcrypt_aead_decrypt para resolver la tarea colgada."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/039fec48e062504f14845124a1a25eb199b2ddc0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/372636debe852913529b1716f44addd94fff2d28","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/546c1796ad1ed0d87dab3c4b5156d75819be2316","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8f4f68e788c3a7a696546291258bfa5fdb215523","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c55fc098fd9d2dca475b82d00ffbcaf97879d77e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c9c1334697301c10e6918d747ed38abfbc0c96e7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e134f3aba98e6c801a693f540912c2d493718ddf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e97bf4ada7dddacd184c3e196bd063b0dc71b41d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fb2d3a50a8f29a3c66682bb426144f40e32ab818","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52814","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.547","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu: Fix potential null pointer derefernce\n\nThe amdgpu_ras_get_context may return NULL if device\nnot support ras feature, so add check before using."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amdgpu: soluciona una posible desreferencia del puntero null. Amdgpu_ras_get_context puede devolver NULL si el dispositivo no admite la función ras, así que agregue la verificación antes de usarlo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/80285ae1ec8717b597b20de38866c29d84d321a1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9b70fc7d70e8ef7c4a65034c9487f58609e708a1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0702ee4d811708251cdf54d4a1d3e888d365111","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b93a25de28af153312f0fc979b0663fc4bd3442b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c11cf5e117f50f5a767054600885acd981449afe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/da46e63482fdc5e35c008865c22ac64027f6f0c2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52815","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.620","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu\/vkms: fix a possible null pointer dereference\n\nIn amdgpu_vkms_conn_get_modes(), the return value of drm_cvt_mode()\nis assigned to mode, which will lead to a NULL pointer dereference\non failure of drm_cvt_mode(). Add a check to avoid null pointer\ndereference."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amdgpu\/vkms: soluciona una posible desreferencia del puntero null. En amdgpu_vkms_conn_get_modes(), el valor de retorno de drm_cvt_mode() se asigna al modo, lo que provocará una desreferencia del puntero NULL en falla de drm_cvt_mode(). Agregue una marca para evitar la desreferencia del puntero null."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/33fb1a555354bd593f785935ddcb5d9dd4d3847f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/70f831f21155c692bb336c434936fd6f24f3f81a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8c6c85a073768df68c1a3fea143d013a38c66d34","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cd90511557fdfb394bb4ac4c3b539b007383914c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eaa03ea366c85ae3cb69c8d4bbc67c8bc2167a27","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52816","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.690","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdkfd: Fix shift out-of-bounds issue\n\n[  567.613292] shift exponent 255 is too large for 64-bit type 'long unsigned int'\n[  567.614498] CPU: 5 PID: 238 Comm: kworker\/5:1 Tainted: G           OE      6.2.0-34-generic #34~22.04.1-Ubuntu\n[  567.614502] Hardware name: AMD Splinter\/Splinter-RPL, BIOS WS43927N_871 09\/25\/2023\n[  567.614504] Workqueue: events send_exception_work_handler [amdgpu]\n[  567.614748] Call Trace:\n[  567.614750]  <TASK>\n[  567.614753]  dump_stack_lvl+0x48\/0x70\n[  567.614761]  dump_stack+0x10\/0x20\n[  567.614763]  __ubsan_handle_shift_out_of_bounds+0x156\/0x310\n[  567.614769]  ? srso_alias_return_thunk+0x5\/0x7f\n[  567.614773]  ? update_sd_lb_stats.constprop.0+0xf2\/0x3c0\n[  567.614780]  svm_range_split_by_granularity.cold+0x2b\/0x34 [amdgpu]\n[  567.615047]  ? srso_alias_return_thunk+0x5\/0x7f\n[  567.615052]  svm_migrate_to_ram+0x185\/0x4d0 [amdgpu]\n[  567.615286]  do_swap_page+0x7b6\/0xa30\n[  567.615291]  ? srso_alias_return_thunk+0x5\/0x7f\n[  567.615294]  ? __free_pages+0x119\/0x130\n[  567.615299]  handle_pte_fault+0x227\/0x280\n[  567.615303]  __handle_mm_fault+0x3c0\/0x720\n[  567.615311]  handle_mm_fault+0x119\/0x330\n[  567.615314]  ? lock_mm_and_find_vma+0x44\/0x250\n[  567.615318]  do_user_addr_fault+0x1a9\/0x640\n[  567.615323]  exc_page_fault+0x81\/0x1b0\n[  567.615328]  asm_exc_page_fault+0x27\/0x30\n[  567.615332] RIP: 0010:__get_user_8+0x1c\/0x30"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amdkfd: solucionó el problema de desplazamiento fuera de límites [567.613292] el exponente de desplazamiento 255 es demasiado grande para el tipo de 64 bits 'long unsigned int' [567.614498] CPU: 5 PID : 238 Comm: kworker\/5:1 Tainted: G OE 6.2.0-34-generic #34~22.04.1-Ubuntu [ 567.614502] Nombre de hardware: AMD Splinter\/Splinter-RPL, BIOS WS43927N_871 25\/09\/2023 [ 567.614504 ] Cola de trabajo: eventos send_exception_work_handler [amdgpu] [ 567.614748] Seguimiento de llamadas: [ 567.614750]  [ 567.614753] dump_stack_lvl+0x48\/0x70 [ 567.614761] dump_stack+0x10\/0x20 [ 567.6147 63] __ubsan_handle_shift_out_of_bounds+0x156\/0x310 [567.614769]? srso_alias_return_thunk+0x5\/0x7f [567.614773]? update_sd_lb_stats.constprop.0+0xf2\/0x3c0 [567.614780] svm_range_split_by_granularity.cold+0x2b\/0x34 [amdgpu] [567.615047]? srso_alias_return_thunk+0x5\/0x7f [ 567.615052] svm_migrate_to_ram+0x185\/0x4d0 [amdgpu] [ 567.615286] do_swap_page+0x7b6\/0xa30 [ 567.615291] ? srso_alias_return_thunk+0x5\/0x7f [567.615294]? __free_pages+0x119\/0x130 [ 567.615299] handle_pte_fault+0x227\/0x280 [ 567.615303] __handle_mm_fault+0x3c0\/0x720 [ 567.615311] handle_mm_fault+0x119\/0x330 [ 567.61 5314] ? lock_mm_and_find_vma+0x44\/0x250 [ 567.615318] do_user_addr_fault+0x1a9\/0x640 [ 567.615323] exc_page_fault+0x81\/0x1b0 [ 567.615328] asm_exc_page_fault+0x27\/0x30 [ 567.615332] RIP: 0010:__get_user_8+0x1c\/0x30"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2806f880379232e789957c2078d612669eb7a69c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/282c1d793076c2edac6c3db51b7e8ed2b41d60a5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3f7a400d5e80f99581e3e8a9843e1f6118bf454f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/56649c43d40ce0147465a2d5756d300e87f9ee1c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d33a35b13cbfec3238043f196fa87a6384f9d087","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52817","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.763","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu: Fix a null pointer access when the smc_rreg pointer is NULL\n\nIn certain types of chips, such as VEGA20, reading the amdgpu_regs_smc file could result in an abnormal null pointer access when the smc_rreg pointer is NULL. Below are the steps to reproduce this issue and the corresponding exception log:\n\n1. Navigate to the directory: \/sys\/kernel\/debug\/dri\/0\n2. Execute command: cat amdgpu_regs_smc\n3. Exception Log::\n[4005007.702554] BUG: kernel NULL pointer dereference, address: 0000000000000000\n[4005007.702562] #PF: supervisor instruction fetch in kernel mode\n[4005007.702567] #PF: error_code(0x0010) - not-present page\n[4005007.702570] PGD 0 P4D 0\n[4005007.702576] Oops: 0010 [#1] SMP NOPTI\n[4005007.702581] CPU: 4 PID: 62563 Comm: cat Tainted: G           OE     5.15.0-43-generic #46-Ubunt       u\n[4005007.702590] RIP: 0010:0x0\n[4005007.702598] Code: Unable to access opcode bytes at RIP 0xffffffffffffffd6.\n[4005007.702600] RSP: 0018:ffffa82b46d27da0 EFLAGS: 00010206\n[4005007.702605] RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffa82b46d27e68\n[4005007.702609] RDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff9940656e0000\n[4005007.702612] RBP: ffffa82b46d27dd8 R08: 0000000000000000 R09: ffff994060c07980\n[4005007.702615] R10: 0000000000020000 R11: 0000000000000000 R12: 00007f5e06753000\n[4005007.702618] R13: ffff9940656e0000 R14: ffffa82b46d27e68 R15: 00007f5e06753000\n[4005007.702622] FS:  00007f5e0755b740(0000) GS:ffff99479d300000(0000) knlGS:0000000000000000\n[4005007.702626] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[4005007.702629] CR2: ffffffffffffffd6 CR3: 00000003253fc000 CR4: 00000000003506e0\n[4005007.702633] Call Trace:\n[4005007.702636]  <TASK>\n[4005007.702640]  amdgpu_debugfs_regs_smc_read+0xb0\/0x120 [amdgpu]\n[4005007.703002]  full_proxy_read+0x5c\/0x80\n[4005007.703011]  vfs_read+0x9f\/0x1a0\n[4005007.703019]  ksys_read+0x67\/0xe0\n[4005007.703023]  __x64_sys_read+0x19\/0x20\n[4005007.703028]  do_syscall_64+0x5c\/0xc0\n[4005007.703034]  ? do_user_addr_fault+0x1e3\/0x670\n[4005007.703040]  ? exit_to_user_mode_prepare+0x37\/0xb0\n[4005007.703047]  ? irqentry_exit_to_user_mode+0x9\/0x20\n[4005007.703052]  ? irqentry_exit+0x19\/0x30\n[4005007.703057]  ? exc_page_fault+0x89\/0x160\n[4005007.703062]  ? asm_exc_page_fault+0x8\/0x30\n[4005007.703068]  entry_SYSCALL_64_after_hwframe+0x44\/0xae\n[4005007.703075] RIP: 0033:0x7f5e07672992\n[4005007.703079] Code: c0 e9 b2 fe ff ff 50 48 8d 3d fa b2 0c 00 e8 c5 1d 02 00 0f 1f 44 00 00 f3 0f        1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 e       c 28 48 89 54 24\n[4005007.703083] RSP: 002b:00007ffe03097898 EFLAGS: 00000246 ORIG_RAX: 0000000000000000\n[4005007.703088] RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007f5e07672992\n[4005007.703091] RDX: 0000000000020000 RSI: 00007f5e06753000 RDI: 0000000000000003\n[4005007.703094] RBP: 00007f5e06753000 R08: 00007f5e06752010 R09: 00007f5e06752010\n[4005007.703096] R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000022000\n[4005007.703099] R13: 0000000000000003 R14: 0000000000020000 R15: 0000000000020000\n[4005007.703105]  <\/TASK>\n[4005007.703107] Modules linked in: nf_tables libcrc32c nfnetlink algif_hash af_alg binfmt_misc nls_       iso8859_1 ipmi_ssif ast intel_rapl_msr intel_rapl_common drm_vram_helper drm_ttm_helper amd64_edac t       tm edac_mce_amd kvm_amd ccp mac_hid k10temp kvm acpi_ipmi ipmi_si rapl sch_fq_codel ipmi_devintf ipm       i_msghandler msr parport_pc ppdev lp parport mtd pstore_blk efi_pstore ramoops pstore_zone reed_solo       mon ip_tables x_tables autofs4 ib_uverbs ib_core amdgpu(OE) amddrm_ttm_helper(OE) amdttm(OE) iommu_v       2 amd_sched(OE) amdkcl(OE) drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops cec rc_core        drm igb ahci xhci_pci libahci i2c_piix4 i2c_algo_bit xhci_pci_renesas dca\n[4005007.703184] CR2: 0000000000000000\n[4005007.703188] ---[ en\n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amdgpu: corrige un acceso de puntero null cuando el puntero smc_rreg es NULL. En ciertos tipos de chips, como VEGA20, la lectura del archivo amdgpu_regs_smc podría resultar en un acceso anormal de puntero null cuando el puntero smc_rreg es NULL. A continuación se detallan los pasos para reproducir este problema y el registro de excepciones correspondiente: 1. Navegue hasta el directorio: \/sys\/kernel\/debug\/dri\/0 2. Ejecute el comando: cat amdgpu_regs_smc 3. Registro de excepciones:: [4005007.702554] BUG: kernel Desreferencia de puntero NULL, dirección: 0000000000000000 [4005007.702562] #PF: búsqueda de instrucciones del supervisor en modo kernel [4005007.702567] #PF: código_error(0x0010) - página no presente [4005007.702570] PGD 0 P4D 0 [4005007. 702576] Ups: 0010 [#1 ] SMP NOPTI [4005007.702581] CPU: 4 PID: 62563 Comm: Cat Tainted: G Oe 5.15.0-43-Generic #46-Ubunt U [4005007.702590] RIP: 0010: 0x0 [4005007.702598] Código: Incedente de acceso a acceso a acceso a acceso a acceso a acceso a acceso a acceso a acceso a acceso a acceso a la operación. QEPD 0xffffffffffffffd6. [4005007.702600] RSP: 0018:ffffa82b46d27da0 EFLAGS: 00010206 [4005007.702605] RAX: 00000000000000000 RBX: 0000000000000000 RCX: e68 [4005007.702609] RDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff9940656e0000 [4005007.702612] RBP: ffffa82b46d27dd8 R08: 0000000 R09: ffff994060c07980 [4005007.702615] R10: 0000000000020000 R11: 0000000000000000 R12: 00007f5e06753000 [4005007.702618] R13: ffff9940656e0000 R14: ffffa82b46d27e68 R15: 007f5e06753000 [4005007.702622] FS: 00007f5e0755b740(0000) GS:ffff99479d300000(0000) knlGS:0000000000000000 [4005007.702626] CS: 0010 DS: 0000ES: 0000 CR0: 0000000080050033 [4005007.702629] CR2: ffffffffffffffd6 CR3: 00000003253fc000 CR4: 00000000003506e0 [4005007.702633] Seguimiento de llamadas: [4005007.7 02636]  [4005007.702640] amdgpu_debugfs_regs_smc_read+0xb0\/0x120 [amdgpu] [4005007.703002] full_proxy_read+0x5c\/0x80 [4005007.703011] vfs_read+0x9f\/0x1a0 [4005007.703019] ksys_read+0x67\/0xe0 [4005007.703023] __x64_sys_read+0x19\/0x20 [4005007.703028] do_syscall_64+0x5c\/0xc0 [40 05007.703034] ? do_user_addr_fault+0x1e3\/0x670 [4005007.703040] ? exit_to_user_mode_prepare+0x37\/0xb0 [4005007.703047] ? irqentry_exit_to_user_mode+0x9\/0x20 [4005007.703052] ? irqentry_exit+0x19\/0x30 [4005007.703057] ? exc_page_fault+0x89\/0x160 [4005007.703062] ? asm_exc_page_fault+0x8\/0x30 [4005007.703068] Entry_SYSCALL_64_after_hwframe+0x44\/0xae [4005007.703075] RIP: 0033:0x7f5e07672992 [4005007.703079] Código: c0 e9 b2 fe ff ff 50 48 8d 3d fa b2 0c 00 e8 c5 1d 02 00 0f 1f 44 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 &lt;48&gt; 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 ec 28 48 89 54 24 [4005007.70 3083]RSP: 002b:00007ffe03097898 EFLAGS: 00000246 ORIG_RAX: 0000000000000000 [4005007.703088] RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007f5e07672992 [4005007.703091] RDX: 0000000000020000 RSI: 00007f5e06753000 RDI: 0000000000000003 [4005007.703094] RBP: 00007f5e06753000 R08: 00007f5e06752010 R09: 007f5e06752010 [4005007.703096] R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000022000 [4005007.703099] R13: 000000000000003 R14: 0000000000020000 R15: 0000000000020000 [40050 07.703105]  [4005007.703107] Módulos vinculados en: nf_tables libcrc32c nfnetlink algif_hash af_alg binfmt_misc nls_ iso8859_1 ipmi_ssif ast intel_rapl_msr intel_rapl_common drm_vram_helper drm_ttm_helper amd64_edac t tm edac_mce_amd kvm_amd ccp mac_hid k10temp kvm acpi_ipmi ipmi_si rapl sch_fq_codel ipmi_devintf ipm i_msghandler msr parport_pc ppdev lp parport mtd pstore_blk efi_pstore ramoops pstore_zone reed_solo mon ip_tables x_tables autofs4 ib_uverbs ib_core amdgpu(OE) _helper(OE) amdttm(OE) iommu_v 2 amd_sched(OE) amdkcl(OE) drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops cec rc_core drm igb ahci xhci_pci libahci i2c_piix4 i2c_algo_bit xhci_pci_renesas dca [4005007.703184] CR2: 0000000000000000 [4005007.703188] ---[ es ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/174f62a0aa15c211e60208b41ee9e7cdfb73d455","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/437e0fa907ba39b4d7eda863c03ea9cf48bd93a9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5104fdf50d326db2c1a994f8b35dcd46e63ae4ad","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6c1b3d89a2dda79881726bb6e37af19c0936d736","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/820daf9ffe2b0afb804567b10983fb38bc5ae288","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ba3c0796d292de84f2932cc5bbb0f771fc720996","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bf2d51eedf03bd61e3556e35d74d49e2e6112398","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f475d5502f33a6c5b149b0afe96316ad1962a64a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52818","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.840","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd: Fix UBSAN array-index-out-of-bounds for SMU7\n\nFor pptable structs that use flexible array sizes, use flexible arrays."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amd: corrige el índice de matriz UBSAN fuera de límites para SMU7. Para estructuras pptable que usan tamaños de matriz flexibles, use matrices flexibles."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6dffdddfca818c02a42b6caa1d9845995f0a1f94","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/760efbca74a405dc439a013a5efaa9fadc95a8c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8af28ae3acb736ada4ce3457662fa446cc913bb4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/92a775e7c9707aed28782bafe636bf87675f5a97","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/acdb6830de02cf2873aeaccdf2d9bca4aee50e47","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c847379a5d00078ad6fcb1c24230e72c5609342f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cfd8cd907fd94538561479a43aea455f5cf16928","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e52e324a21341c97350d5f11de14721c1c609498","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fc9ac0e8e0bcb3740c6eaad3a1a50c20016d422b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52819","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.910","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd: Fix UBSAN array-index-out-of-bounds for Polaris and Tonga\n\nFor pptable structs that use flexible array sizes, use flexible arrays."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amd: corrige el índice de matriz UBSAN fuera de límites para Polaris y Tonga. Para estructuras pptable que usan tamaños de matriz flexibles, use matrices flexibles."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0f0e59075b5c22f1e871fbd508d6e4f495048356","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/60a00dfc7c5deafd1dd393beaf53224f7256dad6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7c68283f3166221af3df5791f0e13d3137a72216","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8c1dbddbfcb051e82cea0c197c620f9dcdc38e92","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a237675aa1e62bbfaa341c535331c8656a508fa1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a63fd579e7b1c3a9ebd6e6c494d49b1b6cf5515e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b3b8b7c040cf069da7afe11c5bd73b870b8f3d18","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0725232da777840703f5f1e22f2e3081d712aa4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d50a56749e5afdc63491b88f5153c1aae00d4679","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52820","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:19.980","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm_lease.c: copy user-array safely\n\nCurrently, there is no overflow-check with memdup_user().\n\nUse the new function memdup_array_user() instead of memdup_user() for\nduplicating the user-space array safely."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm_lease.c: copia la matriz de usuarios de forma segura. Actualmente, no hay verificación de desbordamiento con memdup_user(). Utilice la nueva función memdup_array_user() en lugar de memdup_user() para duplicar la matriz de espacio de usuario de forma segura."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0f5f56745188b06f13509e5054231cb7a4cb047d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/301e597e7b81efa307dd0969ff8f2af9d7b9064e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ea42bc330723644a0bd01d7124a601ab60b27747","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f37d63e219c39199a59b8b8a211412ff27192830","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52821","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.047","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/panel: fix a possible null pointer dereference\n\nIn versatile_panel_get_modes(), the return value of drm_mode_duplicate()\nis assigned to mode, which will lead to a NULL pointer dereference\non failure of drm_mode_duplicate(). Add a check to avoid npd."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/panel: corrige una posible desreferencia del puntero null. En versatile_panel_get_modes(), el valor de retorno de drm_mode_duplicate() se asigna al modo, lo que conducirá a una desreferencia del puntero NULL en caso de falla de drm_mode_duplicate(). Agregue una marca para evitar npd."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2381f6b628b3214f07375e0adf5ce17093c31190","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4fa930ba046d20fc1899770396ee11e905fa96e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/79813cd59398015867d51e6d7dcc14d287d4c402","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a9dd36fcb4f3906982b82593393578db4479992","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/924e5814d1f84e6fa5cb19c6eceb69f066225229","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c7dc0aca5962fb37dbea9769dd26ec37813faae1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52822","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.120","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: vmwgfx_surface.c: copy user-array safely\n\nCurrently, there is no overflow-check with memdup_user().\n\nUse the new function memdup_array_user() instead of memdup_user() for\nduplicating the user-space array safely."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm: vmwgfx_surface.c: copia la matriz de usuarios de forma segura. Actualmente, no hay verificación de desbordamiento con memdup_user(). Utilice la nueva función memdup_array_user() en lugar de memdup_user() para duplicar la matriz de espacio de usuario de forma segura."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/06ab64a0d836ac430c5f94669710a78aa43942cb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1eacb4c96e73225a2f6f276bade006abbe4d8341","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/21e29f1437b7c36c76efa908589578eaf0f50900","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/412ce89669341dfd8ed98a4746ad3dbe9653a7b8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/689b33b94f096e717cd8f140a8b5502e7e4fe759","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52823","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.187","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nkernel: kexec: copy user-array safely\n\nCurrently, there is no overflow-check with memdup_user().\n\nUse the new function memdup_array_user() instead of memdup_user() for\nduplicating the user-space array safely."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: kernel: kexec: copiar la matriz de usuarios de forma segura. Actualmente, no hay verificación de desbordamiento con memdup_user(). Utilice la nueva función memdup_array_user() en lugar de memdup_user() para duplicar la matriz de espacio de usuario de forma segura."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4fc857cc5cb9b7ce6940898857d773564973a584","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/569c8d82f95eb5993c84fb61a649a9c4ddd208b3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8332523b13dbfcce60f631dfb34ac90df021b4bd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0ed017a2b9735753eb95798d9f60176480424ca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d4f2c09d4672f0e997ba4b1b589cc376be7ec938","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52824","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.253","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nkernel: watch_queue: copy user-array safely\n\nCurrently, there is no overflow-check with memdup_user().\n\nUse the new function memdup_array_user() instead of memdup_user() for\nduplicating the user-space array safely."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0f403ebad98e6151aaa9c96c9aae5549aa4d87cd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/22260dabcfe30ab70440d91aa1e4a703d13925c4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6995df256e4f5841fb45cf40d04f94b62b8067e1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c7acf02df1673a4ea7d6401ac4bc773ffe6a88f6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca0776571d3163bd03b3e8c9e3da936abfaecbf6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52825","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.320","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdkfd: Fix a race condition of vram buffer unref in svm code\n\nprange->svm_bo unref can happen in both mmu callback and a callback after\nmigrate to system ram. Both are async call in different tasks. Sync svm_bo\nunref operation to avoid random \"use-after-free\"."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/amdkfd: se corrige una condición de ejecución de vram buffer unref en el código svm prange-&gt;svm_bo unref puede ocurrir tanto en la devolución de llamada mmu como en una devolución de llamada después de migrar a la memoria RAM del sistema. Ambas son llamadas asíncronas en diferentes tareas. Sincronice la operación svm_bo unref para evitar un \"use after free\" aleatorio."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/50f35a907c4f9ed431fd3dbb8b871ef1cbb0718e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/709c348261618da7ed89d6c303e2ceb9e453ba74","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7d43cdd22cd81a2b079e864c4321b9aba4c6af34","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c772eacbd6d0845fc922af8716bb9d29ae27b8cf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fc0210720127cc6302e6d6f3de48f49c3fcf5659","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52826","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.390","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/panel\/panel-tpo-tpg110: fix a possible null pointer dereference\n\nIn tpg110_get_modes(), the return value of drm_mode_duplicate() is\nassigned to mode, which will lead to a NULL pointer dereference on\nfailure of drm_mode_duplicate(). Add a check to avoid npd."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/panel\/panel-tpo-tpg110: corrige una posible desreferencia del puntero null. En tpg110_get_modes(), el valor de retorno de drm_mode_duplicate() se asigna al modo, lo que conducirá a un Desreferencia del puntero NULL en caso de fallo de drm_mode_duplicate(). Agregue una marca para evitar npd."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/84c923d898905187ebfd4c0ef38cd1450af7e0ea","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9268bfd76bebc85ff221691b61498cc16d75451c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9acc2bc00135e9ecd13a70ce1140e2673e504cdc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0bc9ab0a161a9745273f5bf723733a8e6c57aca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eaede6900c0961b072669d6bd97fe8f90ed1900f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f22def5970c423ea7f87d5247bd0ef91416b0658","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52827","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.463","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Undergoing Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath12k: fix possible out-of-bound read in ath12k_htt_pull_ppdu_stats()\n\nlen is extracted from HTT message and could be an unexpected value in\ncase errors happen, so add validation before using to avoid possible\nout-of-bound read in the following message iteration and parsing.\n\nThe same issue also applies to ppdu_info->ppdu_stats.common.num_users,\nso validate it before using too.\n\nThese are found during code review.\n\nCompile test only."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: wifi: ath12k: corrige una posible lectura fuera de los límites en ath12k_htt_pull_ppdu_stats(). len se extrae del mensaje HTT y podría ser un valor inesperado en caso de que ocurran errores, así que agregue validación antes de usarlo para evitar una posible lectura fuera de los límites en la siguiente iteración y análisis del mensaje. El mismo problema también se aplica a ppdu_info-&gt;ppdu_stats.common.num_users, así que valídelo antes de usarlo también. Estos se encuentran durante la revisión del código. Compilar prueba únicamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1bc44a505a229bb1dd4957e11aa594edeea3690e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/79527c21a3ce04cffc35ea54f74ee087e532be57","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c9e44111da221246efb2e623ae1be40a5cf6542c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52828","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.533","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Detect IP == ksym.end as part of BPF program\n\nNow that bpf_throw kfunc is the first such call instruction that has\nnoreturn semantics within the verifier, this also kicks in dead code\nelimination in unprecedented ways. For one, any instruction following\na bpf_throw call will never be marked as seen. Moreover, if a callchain\nends up throwing, any instructions after the call instruction to the\neventually throwing subprog in callers will also never be marked as\nseen.\n\nThe tempting way to fix this would be to emit extra 'int3' instructions\nwhich bump the jited_len of a program, and ensure that during runtime\nwhen a program throws, we can discover its boundaries even if the call\ninstruction to bpf_throw (or to subprogs that always throw) is emitted\nas the final instruction in the program.\n\nAn example of such a program would be this:\n\ndo_something():\n\t...\n\tr0 = 0\n\texit\n\nfoo():\n\tr1 = 0\n\tcall bpf_throw\n\tr0 = 0\n\texit\n\nbar(cond):\n\tif r1 != 0 goto pc+2\n\tcall do_something\n\texit\n\tcall foo\n\tr0 = 0  \/\/ Never seen by verifier\n\texit\t\/\/\n\nmain(ctx):\n\tr1 = ...\n\tcall bar\n\tr0 = 0\n\texit\n\nHere, if we do end up throwing, the stacktrace would be the following:\n\nbpf_throw\nfoo\nbar\nmain\n\nIn bar, the final instruction emitted will be the call to foo, as such,\nthe return address will be the subsequent instruction (which the JIT\nemits as int3 on x86). This will end up lying outside the jited_len of\nthe program, thus, when unwinding, we will fail to discover the return\naddress as belonging to any program and end up in a panic due to the\nunreliable stack unwinding of BPF programs that we never expect.\n\nTo remedy this case, make bpf_prog_ksym_find treat IP == ksym.end as\npart of the BPF program, so that is_bpf_text_address returns true when\nsuch a case occurs, and we are able to unwind reliably when the final\ninstruction ends up being a call instruction."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: Detectar IP == ksym.end como parte del programa BPF. Ahora que bpf_throw kfunc es la primera instrucción de llamada que no tiene semántica de retorno dentro del verificador, esto también activa el código muerto eliminación de formas sin precedentes. Por un lado, cualquier instrucción que siga a una llamada a bpf_throw nunca se marcará como vista. Además, si una cadena de llamadas termina lanzándose, cualquier instrucción posterior a la instrucción de llamada al subprog que finalmente se lance en las personas que llaman tampoco se marcará como vista. La forma tentadora de solucionar este problema sería emitir instrucciones 'int3' adicionales que superen el jited_len de un programa y garantizar que, durante el tiempo de ejecución, cuando se inicia un programa, podamos descubrir sus límites incluso si la instrucción de llamada a bpf_throw (o a subprogs que siempre tirar) se emite como instrucción final en el programa. Un ejemplo de un programa de este tipo sería este: do_something(): ... r0 = 0 salir foo(): r1 = 0 llamar a bpf_throw r0 = 0 salir de la barra (cond): si r1 != 0 ir a pc+2 llamar a hacer_algo exit call foo r0 = 0 \/\/ Nunca visto por el verificador exit \/\/ main(ctx): r1 = ... call bar r0 = 0 exit Aquí, si terminamos lanzando, el seguimiento de pila sería el siguiente: bpf_throw foo bar main En bar, la instrucción final emitida será la llamada a foo, como tal, la dirección de retorno será la instrucción posterior (que el JIT emite como int3 en x86). Esto terminará quedando fuera del jited_len del programa, por lo tanto, al desenrollarlo, no podremos descubrir que la dirección del remitente pertenece a ningún programa y terminaremos en pánico debido al desenrollado poco confiable de la pila de programas BPF que nunca esperamos. Para remediar este caso, haga que bpf_prog_ksym_find trate IP == ksym.end como parte del programa BPF, de modo que is_bpf_text_address devuelva verdadero cuando ocurra tal caso, y podamos desenredarlo de manera confiable cuando la instrucción final termine siendo una instrucción de llamada."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/327b92e8cb527ae097961ffd1610c720481947f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6058e4829696412457729a00734969acc6fd1d18","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/66d9111f3517f85ef2af0337ece02683ce0faf21","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/821a7e4143af115b840ec199eb179537e18af922","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aa42a7cb92647786719fe9608685da345883878f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cf353904a82873e952633fcac4385c2fcd3a46e1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52829","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.600","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath12k: fix possible out-of-bound write in ath12k_wmi_ext_hal_reg_caps()\n\nreg_cap.phy_id is extracted from WMI event and could be an unexpected value\nin case some errors happen. As a result out-of-bound write may occur to\nsoc->hal_reg_cap. Fix it by validating reg_cap.phy_id before using it.\n\nThis is found during code review.\n\nCompile tested only."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: wifi: ath12k: corrige una posible escritura fuera de los límites en ath12k_wmi_ext_hal_reg_caps() reg_cap.phy_id se extrae del evento WMI y podría ser un valor inesperado en caso de que ocurran algunos errores. Como resultado, puede ocurrir una escritura fuera de los límites en soc-&gt;hal_reg_cap. Solucionarlo validando reg_cap.phy_id antes de usarlo. Esto se encuentra durante la revisión del código. Compilación probada únicamente."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4dd0547e8b45faf6f95373be5436b66cde326c0e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b302dce3d9edea5b93d1902a541684a967f3c63c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dfe13eaab043130f90dd3d57c7d88577c04adc97","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52830","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.670","lastModified":"2024-05-22T12:15:09.470","vulnStatus":"Rejected","descriptions":[{"lang":"en","value":"Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority."}],"metrics":{},"references":[]}},{"cve":{"id":"CVE-2023-52831","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.743","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncpu\/hotplug: Don't offline the last non-isolated CPU\n\nIf a system has isolated CPUs via the \"isolcpus=\" command line parameter,\nthen an attempt to offline the last housekeeping CPU will result in a\nWARN_ON() when rebuilding the scheduler domains and a subsequent panic due\nto and unhandled empty CPU mas in partition_sched_domains_locked().\n\ncpuset_hotplug_workfn()\n  rebuild_sched_domains_locked()\n    ndoms = generate_sched_domains(&doms, &attr);\n      cpumask_and(doms[0], top_cpuset.effective_cpus, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\nThus results in an empty CPU mask which triggers the warning and then the\nsubsequent crash:\n\nWARNING: CPU: 4 PID: 80 at kernel\/sched\/topology.c:2366 build_sched_domains+0x120c\/0x1408\nCall trace:\n build_sched_domains+0x120c\/0x1408\n partition_sched_domains_locked+0x234\/0x880\n rebuild_sched_domains_locked+0x37c\/0x798\n rebuild_sched_domains+0x30\/0x58\n cpuset_hotplug_workfn+0x2a8\/0x930\n\nUnable to handle kernel paging request at virtual address fffe80027ab37080\n partition_sched_domains_locked+0x318\/0x880\n rebuild_sched_domains_locked+0x37c\/0x798\n\nAside of the resulting crash, it does not make any sense to offline the last\nlast housekeeping CPU.\n\nPrevent this by masking out the non-housekeeping CPUs when selecting a\ntarget CPU for initiating the CPU unplug operation via the work queue."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: cpu\/hotplug: no desconectar la última CPU no aislada. Si un sistema tiene CPU aisladas mediante el parámetro de línea de comando \"isolcpus=\", entonces se intenta desconectar la última limpieza La CPU dará como resultado un WARN_ON() al reconstruir los dominios del programador y un pánico posterior debido a una masa de CPU vacía no controlada en particion_sched_domains_locked(). cpuset_hotplug_workfn() build_sched_domains_locked() ndoms = generate_sched_domains(&amp;doms, &amp;attr); cpumask_and(doms[0], top_cpuset. Effective_cpus, housekeeping_cpumask(HK_FLAG_DOMAIN)); Por lo tanto, se genera una máscara de CPU vacía que activa la advertencia y luego el bloqueo posterior: ADVERTENCIA: CPU: 4 PID: 80 en kernel\/sched\/topology.c:2366 build_sched_domains+0x120c\/0x1408 Seguimiento de llamadas: build_sched_domains+0x120c\/0x1408 partition_sched_domains_locked+ 0x234\/0x880 build_sched_domains_locked+0x37c\/0x798 build_sched_domains+0x30\/0x58 cpuset_hotplug_workfn+0x2a8\/0x930 No se puede manejar la solicitud de paginación del kernel en la dirección virtual fffe80027ab37080 particion_sched_domains_locked+0x318\/0x880 _sched_domains_locked+0x37c\/0x798 Aparte del bloqueo resultante, no tiene ningún sentido para desconectar la última CPU de mantenimiento. Evite esto enmascarando las CPU que no son de mantenimiento al seleccionar una CPU de destino para iniciar la operación de desconexión de la CPU a través de la cola de trabajo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3073f6df783d9d75f7f69f73e16c7ef85d6cfb63","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/335a47ed71e332c82339d1aec0c7f6caccfcda13","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3410b702354702b500bde10e3cc1f9db8731d908","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/38685e2a0476127db766f81b1c06019ddc4c9ffa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52832","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.813","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: don't return unset power in ieee80211_get_tx_power()\n\nWe can get a UBSAN warning if ieee80211_get_tx_power() returns the\nINT_MIN value mac80211 internally uses for \"unset power level\".\n\n UBSAN: signed-integer-overflow in net\/wireless\/nl80211.c:3816:5\n -2147483648 * 100 cannot be represented in type 'int'\n CPU: 0 PID: 20433 Comm: insmod Tainted: G        WC OE\n Call Trace:\n  dump_stack+0x74\/0x92\n  ubsan_epilogue+0x9\/0x50\n  handle_overflow+0x8d\/0xd0\n  __ubsan_handle_mul_overflow+0xe\/0x10\n  nl80211_send_iface+0x688\/0x6b0 [cfg80211]\n  [...]\n  cfg80211_register_wdev+0x78\/0xb0 [cfg80211]\n  cfg80211_netdev_notifier_call+0x200\/0x620 [cfg80211]\n  [...]\n  ieee80211_if_add+0x60e\/0x8f0 [mac80211]\n  ieee80211_register_hw+0xda5\/0x1170 [mac80211]\n\nIn this case, simply return an error instead, to indicate\nthat no data is available."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: wifi: mac80211: no devolver energía no configurada en ieee80211_get_tx_power(). Podemos obtener una advertencia de UBSAN si ieee80211_get_tx_power() devuelve el valor INT_MIN que mac80211 usa internamente para \"nivel de energía no configurada\". UBSAN: desbordamiento de entero con signo en net\/wireless\/nl80211.c:3816:5 -2147483648 * 100 no se puede representar en el tipo 'int' CPU: 0 PID: 20433 Comm: insmod Contaminado: G WC OE Call Trace: dump_stack+ 0x74\/0x92 ubsan_epilogue+0x9\/0x50 handle_overflow+0x8d\/0xd0 __ubsan_handle_mul_overflow+0xe\/0x10 nl80211_send_iface+0x688\/0x6b0 [cfg80211] [...] cfg80211_register_wdev+0x78\/0xb0 cfg80211] cfg80211_netdev_notifier_call+0x200\/0x620 [cfg80211] [.. .] ieee80211_if_add+0x60e\/0x8f0 [mac80211] ieee80211_register_hw+0xda5\/0x1170 [mac80211] En este caso, simplemente devuelva un error para indicar que no hay datos disponibles."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1571120c44dbe5757aee1612c5b6097cdc42710f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/21a0f310a9f3bfd2b4cf4f382430e638607db846","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/298e767362cade639b7121ecb3cc5345b6529f62","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2be24c47ac19bf639c48c082486c08888bd603c6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5a94cffe90e20e8fade0b9abd4370bd671fe87c7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/717de20abdcd1d4993fa450e28b8086a352620ea","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/adc2474d823fe81d8da759207f4f1d3691aa775a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e160ab85166e77347d0cbe5149045cb25e83937f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/efeae5f4972f75d50002bc50eb112ab9e7069b18","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52833","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.883","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: btusb: Add date->evt_skb is NULL check\n\nfix crash because of null pointers\n\n[ 6104.969662] BUG: kernel NULL pointer dereference, address: 00000000000000c8\n[ 6104.969667] #PF: supervisor read access in kernel mode\n[ 6104.969668] #PF: error_code(0x0000) - not-present page\n[ 6104.969670] PGD 0 P4D 0\n[ 6104.969673] Oops: 0000 [#1] SMP NOPTI\n[ 6104.969684] RIP: 0010:btusb_mtk_hci_wmt_sync+0x144\/0x220 [btusb]\n[ 6104.969688] RSP: 0018:ffffb8d681533d48 EFLAGS: 00010246\n[ 6104.969689] RAX: 0000000000000000 RBX: ffff8ad560bb2000 RCX: 0000000000000006\n[ 6104.969691] RDX: 0000000000000000 RSI: ffffb8d681533d08 RDI: 0000000000000000\n[ 6104.969692] RBP: ffffb8d681533d70 R08: 0000000000000001 R09: 0000000000000001\n[ 6104.969694] R10: 0000000000000001 R11: 00000000fa83b2da R12: ffff8ad461d1d7c0\n[ 6104.969695] R13: 0000000000000000 R14: ffff8ad459618c18 R15: ffffb8d681533d90\n[ 6104.969697] FS:  00007f5a1cab9d40(0000) GS:ffff8ad578200000(0000) knlGS:00000\n[ 6104.969699] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 6104.969700] CR2: 00000000000000c8 CR3: 000000018620c001 CR4: 0000000000760ef0\n[ 6104.969701] PKRU: 55555554\n[ 6104.969702] Call Trace:\n[ 6104.969708]  btusb_mtk_shutdown+0x44\/0x80 [btusb]\n[ 6104.969732]  hci_dev_do_close+0x470\/0x5c0 [bluetooth]\n[ 6104.969748]  hci_rfkill_set_block+0x56\/0xa0 [bluetooth]\n[ 6104.969753]  rfkill_set_block+0x92\/0x160\n[ 6104.969755]  rfkill_fop_write+0x136\/0x1e0\n[ 6104.969759]  __vfs_write+0x18\/0x40\n[ 6104.969761]  vfs_write+0xdf\/0x1c0\n[ 6104.969763]  ksys_write+0xb1\/0xe0\n[ 6104.969765]  __x64_sys_write+0x1a\/0x20\n[ 6104.969769]  do_syscall_64+0x51\/0x180\n[ 6104.969771]  entry_SYSCALL_64_after_hwframe+0x44\/0xa9\n[ 6104.969773] RIP: 0033:0x7f5a21f18fef\n[ 6104.9] RSP: 002b:00007ffeefe39010 EFLAGS: 00000293 ORIG_RAX: 0000000000000001\n[ 6104.969780] RAX: ffffffffffffffda RBX: 000055c10a7560a0 RCX: 00007f5a21f18fef\n[ 6104.969781] RDX: 0000000000000008 RSI: 00007ffeefe39060 RDI: 0000000000000012\n[ 6104.969782] RBP: 00007ffeefe39060 R08: 0000000000000000 R09: 0000000000000017\n[ 6104.969784] R10: 00007ffeefe38d97 R11: 0000000000000293 R12: 0000000000000002\n[ 6104.969785] R13: 00007ffeefe39220 R14: 00007ffeefe391a0 R15: 000055c10a72acf0"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: Bluetooth: btusb: Agregar fecha-&gt;evt_skb es un fallo de corrección de verificación NULL debido a punteros nulos [6104.969662] BUG: desreferencia del puntero NULL del kernel, dirección: 00000000000000c8 [6104.969667] #PF: supervisor acceso de lectura en modo kernel [6104.969668] #PF: error_code(0x0000) - página no presente [6104.969670] PGD 0 P4D 0 [6104.969673] Ups: 0000 [#1] SMP NOPTI [6104.969684] RIP: k_hci_wmt_sync+0x144\/ 0x220 [btusb] [ 6104.969688] RSP: 0018:ffffb8d681533d48 EFLAGS: 00010246 [ 6104.969689] RAX: 00000000000000000 RBX: ffff8ad560bb2000 RCX: 0000000006 [ 6104.969691] RDX: 00000000000000000 RSI: ffffb8d681533d08 RDI: 0000000000000000 [ 6104.969692] RBP: ffffb8d681533d70 R08: 000000000001 R09: 0000000000000001 [ 6104.969694] R10: 0000000000000001 R11: 00000000fa83b2da R12: ffff8ad461d1d7c0 [ 6104.969695] R13: 000000000000000 0 R14: ffff8ad459618c18 R15: ffffb8d681533d90 [ 6104.969697] FS: 00007f5a1cab9d40(0000) GS:ffff8ad578200000(0000) knlGS:00000 [ 6104.969699] CS: 0010DS : 0000 ES: 0000 CR0: 0000000080050033 [ 6104.969700] CR2: 00000000000000c8 CR3: 000000018620c001 CR4: 0000000000760ef0 [ 6104.969701] : 55555554 [6104.969702] Seguimiento de llamadas: [6104.969708] btusb_mtk_shutdown+0x44\/0x80 [btusb] [6104.969732] hci_dev_do_close+0x470\/ 0x5c0 [bluetooth] [ 6104.969748] hci_rfkill_set_block+0x56\/0xa0 [bluetooth] [ 6104.969753] rfkill_set_block+0x92\/0x160 [ 6104.969755] rfkill_fop_write+0x136\/0x1e0 [ 6104.9 69759] __vfs_write+0x18\/0x40 [ 6104.969761] vfs_write+0xdf\/0x1c0 [ 6104.969763] ksys_write+0xb1\/0xe0 [ 6104.969765] __x64_sys_write+0x1a\/0x20 [ 6104.969769] do_syscall_64+0x51\/0x180 [ 6104.969771] Entry_SYSCALL_64_after_hwframe+0x44\/0xa9 [ 6104.969773] RIP: 0033:0x7f5a21f18fef [ 6104.9] RSP: 002b:00007ffeefe39010 EFLAGS: 00000293 ORIG_RAX: 0000000000000001 [ 6104.969780] RAX: ffffffffffffffda RBX: 000055c10a7560a0 RCX: 00007f5a21f18fef [ 6104.969781] RDX: 0000000000000008 RSI: 0007ffeefe39060 RDI: 0000000000000012 [ 6104.969782] RBP: 00007ffeefe39060 R08: 00000000000000000 R09: 0000000000000017 [ 6104.969784] 00007ffeefe38d97 R11: 0000000000000293 R12: 0000000000000002 [ 6104.969785] R13: 00007ffeefe39220 R14: 00007ffeefe391a0 R15: 000055c10a72acf0"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0048ddf045bddc4dacb3e783fd869a2f8fb5be30","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/13b1ebad4c175e6a9b0748acbf133c21a15d282a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/624820f7c8826dd010e8b1963303c145f99816e9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9f8e4d1a4ca1179aaeb43f91f3e2a386e7e616b3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a556f2ef556a04790f67f2fa272f1a77336d15a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f9de14bde56dcbb0765284c6dfc35842b021733c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52834","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:20.950","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\natl1c: Work around the DMA RX overflow issue\n\nThis is based on alx driver commit 881d0327db37 (\"net: alx: Work around\nthe DMA RX overflow issue\").\n\nThe alx and atl1c drivers had RX overflow error which was why a custom\nallocator was created to avoid certain addresses. The simpler workaround\nthen created for alx driver, but not for atl1c due to lack of tester.\n\nInstead of using a custom allocator, check the allocated skb address and\nuse skb_reserve() to move away from problematic 0x...fc0 address.\n\nTested on AR8131 on Acer 4540."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: atl1c:workaround al problema de desbordamiento de DMA RX. Esto se basa en la confirmación del controlador alx 881d0327db37 (\"net: alx: solución alternativa al problema de desbordamiento de DMA RX\"). Los controladores alx y atl1c tenían un error de desbordamiento de RX, por lo que se creó un asignador personalizado para evitar ciertas direcciones. Luego se creó la solución más simple para el controlador alx, pero no para atl1c debido a la falta de un probador. En lugar de utilizar un asignador personalizado, verifique la dirección skb asignada y use skb_reserve() para alejarse de la dirección problemática 0x...fc0. Probado en AR8131 en Acer 4540."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/32f08b7b430ee01ec47d730f961a3306c1c7b6fb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/54a6152da4993ec8e4b53dc3cf577f5a2c829afa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/57e44ff9c2c9747b2b1a53556810b0e5192655d6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/86565682e9053e5deb128193ea9e88531bbae9cf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c29a89b23f67ee592f4dee61f9d7efbf86d60315","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52835","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.023","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nperf\/core: Bail out early if the request AUX area is out of bound\n\nWhen perf-record with a large AUX area, e.g 4GB, it fails with:\n\n    #perf record -C 0 -m ,4G -e arm_spe_0\/\/ -- sleep 1\n    failed to mmap with 12 (Cannot allocate memory)\n\nand it reveals a WARNING with __alloc_pages():\n\n\t------------[ cut here ]------------\n\tWARNING: CPU: 44 PID: 17573 at mm\/page_alloc.c:5568 __alloc_pages+0x1ec\/0x248\n\tCall trace:\n\t __alloc_pages+0x1ec\/0x248\n\t __kmalloc_large_node+0xc0\/0x1f8\n\t __kmalloc_node+0x134\/0x1e8\n\t rb_alloc_aux+0xe0\/0x298\n\t perf_mmap+0x440\/0x660\n\t mmap_region+0x308\/0x8a8\n\t do_mmap+0x3c0\/0x528\n\t vm_mmap_pgoff+0xf4\/0x1b8\n\t ksys_mmap_pgoff+0x18c\/0x218\n\t __arm64_sys_mmap+0x38\/0x58\n\t invoke_syscall+0x50\/0x128\n\t el0_svc_common.constprop.0+0x58\/0x188\n\t do_el0_svc+0x34\/0x50\n\t el0_svc+0x34\/0x108\n\t el0t_64_sync_handler+0xb8\/0xc0\n\t el0t_64_sync+0x1a4\/0x1a8\n\n'rb->aux_pages' allocated by kcalloc() is a pointer array which is used to\nmaintains AUX trace pages. The allocated page for this array is physically\ncontiguous (and virtually contiguous) with an order of 0..MAX_ORDER. If the\nsize of pointer array crosses the limitation set by MAX_ORDER, it reveals a\nWARNING.\n\nSo bail out early with -ENOMEM if the request AUX area is out of bound,\ne.g.:\n\n    #perf record -C 0 -m ,4G -e arm_spe_0\/\/ -- sleep 1\n    failed to mmap with 12 (Cannot allocate memory)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1a2a4202c60fcdffbf04f259002ce9bff39edece","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2424410f94a94d91230ced094062d859714c984a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2e905e608e38cf7f8dcddcf8a6036e91a78444cb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/54aee5f15b83437f23b2b2469bcf21bdd9823916","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/788c0b3442ead737008934947730a6d1ff703734","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8c504f615d7ed60ae035c51d0c789137ced6797f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9ce4e87a8efd37c85766ec08b15e885cab08553a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fd0df3f8719201dbe61a4d39083d5aecd705399a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52836","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.090","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nlocking\/ww_mutex\/test: Fix potential workqueue corruption\n\nIn some cases running with the test-ww_mutex code, I was seeing\nodd behavior where sometimes it seemed flush_workqueue was\nreturning before all the work threads were finished.\n\nOften this would cause strange crashes as the mutexes would be\nfreed while they were being used.\n\nLooking at the code, there is a lifetime problem as the\ncontrolling thread that spawns the work allocates the\n\"struct stress\" structures that are passed to the workqueue\nthreads. Then when the workqueue threads are finished,\nthey free the stress struct that was passed to them.\n\nUnfortunately the workqueue work_struct node is in the stress\nstruct. Which means the work_struct is freed before the work\nthread returns and while flush_workqueue is waiting.\n\nIt seems like a better idea to have the controlling thread\nboth allocate and free the stress structures, so that we can\nbe sure we don't corrupt the workqueue by freeing the structure\nprematurely.\n\nSo this patch reworks the test to do so, and with this change\nI no longer see the early flush_workqueue returns."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: lock\/ww_mutex\/test: soluciona una posible corrupción de la cola de trabajo. En algunos casos, al ejecutar el código test-ww_mutex, veía un comportamiento extraño en el que a veces parecía que flush_workqueue regresaba antes que todos los subprocesos de trabajo. hemos terminado. A menudo, esto causaría fallas extrañas ya que los mutex se liberarían mientras se estaban usando. Al observar el código, hay un problema de duración, ya que el subproceso de control que genera el trabajo asigna las estructuras de \"estrés de estructura\" que se pasan a los subprocesos de la cola de trabajo. Luego, cuando los subprocesos de la cola de trabajo finalizan, liberan la estructura de tensión que se les pasó. Desafortunadamente, el nodo work_struct de la cola de trabajo está en la estructura de estrés. Lo que significa que work_struct se libera antes de que regrese el hilo de trabajo y mientras descarga_workqueue está esperando. Parece una mejor idea que el subproceso de control asigne y libere las estructuras de tensión, de modo que podamos estar seguros de no corromper la cola de trabajo al liberar la estructura prematuramente. Entonces, este parche reelabora la prueba para hacerlo, y con este cambio ya no veo los primeros retornos de Flush_workqueue."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/304a2c4aad0fff887ce493e4197bf9cbaf394479","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9ed2d68b3925145f5f51c46559484881d6082f75","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bccdd808902f8c677317cec47c306e42b93b849e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c56df79d68677cf062da1b6e3b33e74299a92dfc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d4d37c9e6a4dbcca958dabd99216550525c7e389","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d8267cabbe1bed15ccf8b0e684c528bf8eeef715","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dcd85e3c929368076a7592b27f541e0da8b427f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e36407713163363e65566e7af0abe207d5f59a0c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e89d0ed45a419c485bae999426ecf92697cbdda3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52837","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.170","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: fix uaf in nbd_open\n\nCommit 4af5f2e03013 (\"nbd: use blk_mq_alloc_disk and\nblk_cleanup_disk\") cleans up disk by blk_cleanup_disk() and it won't set\ndisk->private_data as NULL as before. UAF may be triggered in nbd_open()\nif someone tries to open nbd device right after nbd_put() since nbd has\nbeen free in nbd_dev_remove().\n\nFix this by implementing ->free_disk and free private data in it."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: nbd: corrija uaf en nbd_open Commit 4af5f2e03013 (\"nbd: use blk_mq_alloc_disk y blk_cleanup_disk\") limpia el disco mediante blk_cleanup_disk() y no configurará disk-&gt;private_data como NULL como antes. UAF puede activarse en nbd_open() si alguien intenta abrir el dispositivo nbd justo después de nbd_put() ya que nbd ha estado libre en nbd_dev_remove(). Solucione este problema implementando -&gt;free_disk y datos privados gratuitos en él."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/327462725b0f759f093788dfbcb2f1fd132f956b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4e9b3ec84dc97909876641dad14e0a2300d6c2a3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/56bd7901b5e9dbc9112036ea615ebcba1565fafe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/879947f4180bc6e83af64eb0515e0cf57fce15db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52838","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.240","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: imsttfb: fix a resource leak in probe\n\nI've re-written the error handling but the bug is that if init_imstt()\nfails we need to call iounmap(par->cmap_regs)."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: fbdev: imsttfb: corrige una fuga de recursos en la sonda. He reescrito el manejo de errores, pero el error es que si init_imstt() falla, debemos llamar a iounmap(par-&gt; cmap_regs)."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/18d26f9baca7d0d309303e3074a2252b8310884a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/382e1931e0c9cd58a5a8519cdc6cd9dc4d82b485","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6c66d737b2726ac7784269ddf32a31634f8f269d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7bc7b82fb2191b0d50a80ee4e27030918767dd1d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8e4b510fe91782522b7ca0ca881b663b5d35e513","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a4dfebec32ec6d420a5506dd56a7834c91be28e4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aba6ab57a910ad4b940c2024d15f2cdbf5b7f76b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b346a531159d08c564a312a9eaeea691704f3c00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52839","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.310","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers: perf: Do not broadcast to other cpus when starting a counter\n\nThis command:\n\n$ perf record -e cycles:k -e instructions:k -c 10000 -m 64M dd if=\/dev\/zero of=\/dev\/null count=1000\n\ngives rise to this kernel warning:\n\n[  444.364395] WARNING: CPU: 0 PID: 104 at kernel\/smp.c:775 smp_call_function_many_cond+0x42c\/0x436\n[  444.364515] Modules linked in:\n[  444.364657] CPU: 0 PID: 104 Comm: perf-exec Not tainted 6.6.0-rc6-00051-g391df82e8ec3-dirty #73\n[  444.364771] Hardware name: riscv-virtio,qemu (DT)\n[  444.364868] epc : smp_call_function_many_cond+0x42c\/0x436\n[  444.364917]  ra : on_each_cpu_cond_mask+0x20\/0x32\n[  444.364948] epc : ffffffff8009f9e0 ra : ffffffff8009fa5a sp : ff20000000003800\n[  444.364966]  gp : ffffffff81500aa0 tp : ff60000002b83000 t0 : ff200000000038c0\n[  444.364982]  t1 : ffffffff815021f0 t2 : 000000000000001f s0 : ff200000000038b0\n[  444.364998]  s1 : ff60000002c54d98 a0 : ff60000002a73940 a1 : 0000000000000000\n[  444.365013]  a2 : 0000000000000000 a3 : 0000000000000003 a4 : 0000000000000100\n[  444.365029]  a5 : 0000000000010100 a6 : 0000000000f00000 a7 : 0000000000000000\n[  444.365044]  s2 : 0000000000000000 s3 : ffffffffffffffff s4 : ff60000002c54d98\n[  444.365060]  s5 : ffffffff81539610 s6 : ffffffff80c20c48 s7 : 0000000000000000\n[  444.365075]  s8 : 0000000000000000 s9 : 0000000000000001 s10: 0000000000000001\n[  444.365090]  s11: ffffffff80099394 t3 : 0000000000000003 t4 : 00000000eac0c6e6\n[  444.365104]  t5 : 0000000400000000 t6 : ff60000002e010d0\n[  444.365120] status: 0000000200000100 badaddr: 0000000000000000 cause: 0000000000000003\n[  444.365226] [<ffffffff8009f9e0>] smp_call_function_many_cond+0x42c\/0x436\n[  444.365295] [<ffffffff8009fa5a>] on_each_cpu_cond_mask+0x20\/0x32\n[  444.365311] [<ffffffff806e90dc>] pmu_sbi_ctr_start+0x7a\/0xaa\n[  444.365327] [<ffffffff806e880c>] riscv_pmu_start+0x48\/0x66\n[  444.365339] [<ffffffff8012111a>] perf_adjust_freq_unthr_context+0x196\/0x1ac\n[  444.365356] [<ffffffff801237aa>] perf_event_task_tick+0x78\/0x8c\n[  444.365368] [<ffffffff8003faf4>] scheduler_tick+0xe6\/0x25e\n[  444.365383] [<ffffffff8008a042>] update_process_times+0x80\/0x96\n[  444.365398] [<ffffffff800991ec>] tick_sched_handle+0x26\/0x52\n[  444.365410] [<ffffffff800993e4>] tick_sched_timer+0x50\/0x98\n[  444.365422] [<ffffffff8008a6aa>] __hrtimer_run_queues+0x126\/0x18a\n[  444.365433] [<ffffffff8008b350>] hrtimer_interrupt+0xce\/0x1da\n[  444.365444] [<ffffffff806cdc60>] riscv_timer_interrupt+0x30\/0x3a\n[  444.365457] [<ffffffff8006afa6>] handle_percpu_devid_irq+0x80\/0x114\n[  444.365470] [<ffffffff80065b82>] generic_handle_domain_irq+0x1c\/0x2a\n[  444.365483] [<ffffffff8045faec>] riscv_intc_irq+0x2e\/0x46\n[  444.365497] [<ffffffff808a9c62>] handle_riscv_irq+0x4a\/0x74\n[  444.365521] [<ffffffff808aa760>] do_irq+0x7c\/0x7e\n[  444.365796] ---[ end trace 0000000000000000 ]---\n\nThat's because the fix in commit 3fec323339a4 (\"drivers: perf: Fix panic\nin riscv SBI mmap support\") was wrong since there is no need to broadcast\nto other cpus when starting a counter, that's only needed in mmap when\nthe counters could have already been started on other cpus, so simply\nremove this broadcast."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: controladores: perf: no transmitir a otras CPU al iniciar un contador. Este comando: $ perf record -e ciclos:k -e instrucciones:k -c 10000 -m 64M dd if =\/dev\/zero of=\/dev\/null count=1000 da lugar a esta advertencia del kernel: [444.364395] ADVERTENCIA: CPU: 0 PID: 104 en kernel\/smp.c:775 smp_call_function_many_cond+0x42c\/0x436 [444.364515] Módulos vinculados en: [ 444.364657] CPU: 0 PID: 104 Comm: perf-exec No contaminado 6.6.0-rc6-00051-g391df82e8ec3-dirty #73 [ 444.364771] Nombre de hardware: riscv-virtio,qemu (DT) [ 444.364868] epc : smp_call_function_many_cond+0x42c\/0x436 [ 444.364917] ra : on_each_cpu_cond_mask+0x20\/0x32 [ 444.364948] epc : ffffffff8009f9e0 ra : ffffffff8009fa5a sp : ff20000000003800 [ 444.364966] gp : ffffffff81500aa0 tp : ff60000002b83000 t0 : ff200000000038c0 [ 444.364982] t1 : ffffffff815021f0 t2 : 000000000000001f s0 : ff200000000038b0 [444.364998] s1: ff60000002c54d98 a0: ff60000002a73940 a1: 0000000000000000 [444.365013] a2: 0000000000000000 a3 : 0000000000000003 a4 : 0000000000000100 [ 444.365029 ] a5 : 000000000010100 a6 : 0000000000f00000 a7 : 0000000000000000 [ 444.365044] s2: 0000000000000000 s3: ffffffffffffffff s4: ff60000002c54d98 [ 444.365060] s5: ffffffff81539610 s6: ffffffff80c20c48 s7: 0000000000000000 [444.365075] s8: 0000000000000000 s9: 0000000000000001 s10: 0000000000000001 [444.365090] s11: ffffffff80099394 t3: 0000000000000003 t4: 00000000eac0c6e6 [444.365104] t5: 0000000400000000 t6: ff60000002e010d0 [444.365120] estado: 0000000200000100 badaddr: 0000000000000000 causa: 0000000000000003 [444.365226] [] smp_call_function_many_cond+0x42c\/0x436 [444.365295] [] on_each_cpu_cond_mask+0x20\/0x32 [ 444.365311] [] pmu_sbi_ctr_start+0x7a\/0xaa [ 444.365327] [&lt; ffffffff806e880c&gt;] riscv_pmu_start+0x48\/0x66 [ 444.365339] [] perf_adjust_freq_unthr_context+0x196\/0x1ac [ 444.365356] [] _task_tick+0x78\/0x8c [ 444.365368] [] scheduler_tick+0xe6\/0x25e [ 444.365383] [] update_process_times+0x80\/0x96 [ 444.365398] [] tick_sched_handle+0x26\/0x52 [ 444.365410] [] [ 444.365422] [] __hrtimer_run_queues+0x126\/0x18a [ 444.365433] [] hrtimer_interrupt+0xce\/0x1da [ 444.365444] [] riscv_timer_interrupt+0x30\/0x3a [ 444.365457] [] cpu_devid_irq+0x80\/0x114 [ 444.365470] [] generic_handle_domain_irq+0x1c\/ 0x2a [ 444.365483] [] riscv_intc_irq+0x2e\/0x46 [ 444.365497] [] handle_riscv_irq+0x4a\/0x74 [ 444.365521 [] do_irq+0x7c\/0x7e [ 444.365796] ---[ final de seguimiento 0000000000000000 ]--- Esto se debe a que la solución en la confirmación 3fec323339a4 (\"drivers: perf: Fix panic in riscv SBI mmap support\") era incorrecta ya que no hay necesidad de transmitir a otras CPU al iniciar un contador, eso solo es necesario en mmap cuando el Es posible que los contadores ya se hayan iniciado en otras CPU, así que simplemente elimine esta transmisión."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/61e3d993c8bd3e80f8f1363ed5e04f88ab531b72","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/85be1a73fd298ed3fd060dfce97caef5f9928c57","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52840","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.377","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nInput: synaptics-rmi4 - fix use after free in rmi_unregister_function()\n\nThe put_device() calls rmi_release_function() which frees \"fn\" so the\ndereference on the next line \"fn->num_of_irqs\" is a use after free.\nMove the put_device() to the end to fix this."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: Entrada: synaptics-rmi4 - corrige el use after free en rmi_unregister_function(). El put_device() llama a rmi_release_function() que libera \"fn\", por lo que se elimina la referencia en la siguiente línea \"fn-&gt; num_of_irqs\" es un uso después de ser gratuito. Mueva put_device() hasta el final para solucionar este problema."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2f236d8638f5b43e0c72919a6a27fe286c32053f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/303766bb92c5c225cf40f9bbbe7e29749406e2f2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/50d12253666195a14c6cd2b81c376e2dbeedbdff","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6c71e065befb2fae8f1461559b940c04e1071bd5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7082b1fb5321037bc11ba1cf2d7ed23c6b2b521f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c8e639f5743cf4b01f8c65e0df075fe4d782b585","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cc56c4d17721dcb10ad4e9c9266e449be1462683","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb988e46da2e4eae89f5337e047ce372fe33d5b1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52841","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.440","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: vidtv: mux: Add check and kfree for kstrdup\n\nAdd check for the return value of kstrdup() and return the error\nif it fails in order to avoid NULL pointer dereference.\nMoreover, use kfree() in the later error handling in order to avoid\nmemory leak."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: media: vidtv: mux: Add check and kfree for kstrdup. Agregue check para el valor de retorno de kstrdup() y devuelva el error si falla para evitar la desreferencia al puntero NULL. Además, utilice kfree() en el manejo de errores posterior para evitar pérdidas de memoria."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1fd6eb12642e0c32692924ff359c07de4b781d78","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/64863ba8e6b7651d994c6e6d506cc8aa2ac45edb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/980be4c3b0d51c0f873fd750117774561c66cf68","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a254ee1ddc592ae1efcce96b8c014e1bd2d5a2b4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aae7598aff291d4d140be1355aa20930af948785","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cb13001411999adb158b39e76d94705eb2da100d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52842","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.510","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio\/vsock: Fix uninit-value in virtio_transport_recv_pkt()\n\nKMSAN reported the following uninit-value access issue:\n\n=====================================================\nBUG: KMSAN: uninit-value in virtio_transport_recv_pkt+0x1dfb\/0x26a0 net\/vmw_vsock\/virtio_transport_common.c:1421\n virtio_transport_recv_pkt+0x1dfb\/0x26a0 net\/vmw_vsock\/virtio_transport_common.c:1421\n vsock_loopback_work+0x3bb\/0x5a0 net\/vmw_vsock\/vsock_loopback.c:120\n process_one_work kernel\/workqueue.c:2630 [inline]\n process_scheduled_works+0xff6\/0x1e60 kernel\/workqueue.c:2703\n worker_thread+0xeca\/0x14d0 kernel\/workqueue.c:2784\n kthread+0x3cc\/0x520 kernel\/kthread.c:388\n ret_from_fork+0x66\/0x80 arch\/x86\/kernel\/process.c:147\n ret_from_fork_asm+0x11\/0x20 arch\/x86\/entry\/entry_64.S:304\n\nUninit was stored to memory at:\n virtio_transport_space_update net\/vmw_vsock\/virtio_transport_common.c:1274 [inline]\n virtio_transport_recv_pkt+0x1ee8\/0x26a0 net\/vmw_vsock\/virtio_transport_common.c:1415\n vsock_loopback_work+0x3bb\/0x5a0 net\/vmw_vsock\/vsock_loopback.c:120\n process_one_work kernel\/workqueue.c:2630 [inline]\n process_scheduled_works+0xff6\/0x1e60 kernel\/workqueue.c:2703\n worker_thread+0xeca\/0x14d0 kernel\/workqueue.c:2784\n kthread+0x3cc\/0x520 kernel\/kthread.c:388\n ret_from_fork+0x66\/0x80 arch\/x86\/kernel\/process.c:147\n ret_from_fork_asm+0x11\/0x20 arch\/x86\/entry\/entry_64.S:304\n\nUninit was created at:\n slab_post_alloc_hook+0x105\/0xad0 mm\/slab.h:767\n slab_alloc_node mm\/slub.c:3478 [inline]\n kmem_cache_alloc_node+0x5a2\/0xaf0 mm\/slub.c:3523\n kmalloc_reserve+0x13c\/0x4a0 net\/core\/skbuff.c:559\n __alloc_skb+0x2fd\/0x770 net\/core\/skbuff.c:650\n alloc_skb include\/linux\/skbuff.h:1286 [inline]\n virtio_vsock_alloc_skb include\/linux\/virtio_vsock.h:66 [inline]\n virtio_transport_alloc_skb+0x90\/0x11e0 net\/vmw_vsock\/virtio_transport_common.c:58\n virtio_transport_reset_no_sock net\/vmw_vsock\/virtio_transport_common.c:957 [inline]\n virtio_transport_recv_pkt+0x1279\/0x26a0 net\/vmw_vsock\/virtio_transport_common.c:1387\n vsock_loopback_work+0x3bb\/0x5a0 net\/vmw_vsock\/vsock_loopback.c:120\n process_one_work kernel\/workqueue.c:2630 [inline]\n process_scheduled_works+0xff6\/0x1e60 kernel\/workqueue.c:2703\n worker_thread+0xeca\/0x14d0 kernel\/workqueue.c:2784\n kthread+0x3cc\/0x520 kernel\/kthread.c:388\n ret_from_fork+0x66\/0x80 arch\/x86\/kernel\/process.c:147\n ret_from_fork_asm+0x11\/0x20 arch\/x86\/entry\/entry_64.S:304\n\nCPU: 1 PID: 10664 Comm: kworker\/1:5 Not tainted 6.6.0-rc3-00146-g9f3ebbef746f #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-1.fc38 04\/01\/2014\nWorkqueue: vsock-loopback vsock_loopback_work\n=====================================================\n\nThe following simple reproducer can cause the issue described above:\n\nint main(void)\n{\n  int sock;\n  struct sockaddr_vm addr = {\n    .svm_family = AF_VSOCK,\n    .svm_cid = VMADDR_CID_ANY,\n    .svm_port = 1234,\n  };\n\n  sock = socket(AF_VSOCK, SOCK_STREAM, 0);\n  connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  return 0;\n}\n\nThis issue occurs because the `buf_alloc` and `fwd_cnt` fields of the\n`struct virtio_vsock_hdr` are not initialized when a new skb is allocated\nin `virtio_transport_init_hdr()`. This patch resolves the issue by\ninitializing these fields during allocation."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: virtio\/vsock: corrige el valor uninit en virtio_transport_recv_pkt(). KMSAN informó el siguiente problema de acceso al valor uninit: ================ ===================================== ERROR: KMSAN: valor uninit en virtio_transport_recv_pkt+0x1dfb\/0x26a0 net\/vmw_vsock\/virtio_transport_common.c:1421 virtio_transport_recv_pkt+0x1dfb\/0x26a0 net\/vmw_vsock\/virtio_transport_common.c:1421 vsock_loopback_work+0x3bb\/0x5a0 net\/vmw_vsock\/vsock_loopback.c:120 Process_one_work workqueue.c:2630 [en línea] process_scheduled_works+ 0xff6\/0x1e60 kernel\/workqueue.c:2703 worker_thread+0xeca\/0x14d0 kernel\/workqueue.c:2784 kthread+0x3cc\/0x520 kernel\/kthread.c:388 ret_from_fork+0x66\/0x80 arch\/x86\/kernel\/process.c:147 ret_from_fork_asm+0x11\/0x20 arch\/x86\/entry\/entry_64.S:304 Uninit se almacenó en la memoria en: virtio_transport_space_update net\/vmw_vsock\/virtio_transport_common.c:1274 [en línea] virtio_transport_recv_pkt+0x1ee8\/0x26a0 net\/vmw_vsock\/virt io_transport_common.c:1415 vsock_loopback_work+0x3bb\/0x5a0 net\/vmw_vsock\/vsock_loopback.c:120 Process_one_work kernel\/workqueue.c:2630 [en línea] Process_scheduled_works+0xff6\/0x1e60 kernel\/workqueue.c:2703 trabajador_thread+0xeca\/0x14d0 kernel\/workqueue.c:2784 hilo +0x3cc\/0x520 kernel\/kthread.c:388 ret_from_fork+0x66\/0x80 arch\/x86\/kernel\/process.c:147 ret_from_fork_asm+0x11\/0x20 arch\/x86\/entry\/entry_64.S:304 Uninit se creó en: slab_post_alloc_hook+ 0x105\/0xad0 mm\/slab.h: 767 slab_alloc_node mm\/slub.c: 3478 [inline] kmem_cache_alloc_node+0x5a2\/0xaf0 mm\/slub.c: 3523 kmalloc_reserve+0x13c\/0x4a0 net\/skbuff. fd \/0x770 net\/core\/skbuff.c:650 alloc_skb include\/linux\/skbuff.h:1286 [en línea] virtio_vsock_alloc_skb include\/linux\/virtio_vsock.h:66 [en línea] virtio_transport_alloc_skb+0x90\/0x11e0 net\/vmw_vsock\/virtio_transport_common.c: 58 virtio_transport_reset_no_sock net\/vmw_vsock\/virtio_transport_common.c:957 [en línea] virtio_transport_recv_pkt+0x1279\/0x26a0 net\/vmw_vsock\/virtio_transport_common.c:1387 vsock_loopback_work+0x3bb\/0x5a0 net\/vmw_vsock\/v sock_loopback.c:120 proceso_one_work kernel\/workqueue.c:2630 [en línea] Process_scheduled_works+0xff6\/0x1e60 kernel\/workqueue.c:2703 trabajador_thread+0xeca\/0x14d0 kernel\/workqueue.c:2784 kthread+0x3cc\/0x520 kernel\/kthread.c:388 ret_from_fork+0x66\/0x80 arch\/x86\/kernel\/ Process.c:147 ret_from_fork_asm+0x11\/0x20 arch\/x86\/entry\/entry_64.S:304 CPU: 1 PID: 10664 Comm: kworker\/1:5 No contaminado 6.6.0-rc3-00146-g9f3ebbef746f #3 Nombre de hardware: PC estándar QEMU (i440FX + PIIX, 1996), BIOS 1.16.2-1.fc38 01\/04\/2014 Cola de trabajo: vsock-loopback vsock_loopback_work ===================== ================================= El siguiente reproductor simple puede causar el problema descrito anteriormente: int main(void) { calcetín interno; struct sockaddr_vm addr = { .svm_family = AF_VSOCK, .svm_cid = VMADDR_CID_ANY, .svm_port = 1234, }; sock = socket(AF_VSOCK, SOCK_STREAM, 0); connect(socket, (struct sockaddr *)&amp;addr, sizeof(addr)); return 0; } Este problema ocurre porque los campos `buf_alloc` y `fwd_cnt` de `struct virtio_vsock_hdr` no se inicializan cuando se asigna un nuevo skb en `virtio_transport_init_hdr()`. Este parche resuelve el problema inicializando estos campos durante la asignación."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0b8906fb48b99e993d6e8a12539f618f4854dd26","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/34c4effacfc329aeca5635a69fd9e0f6c90b4101","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cd12535b97dd7d18cf655ec78ce1cf1f29a576be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52843","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.583","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nllc: verify mac len before reading mac header\n\nLLC reads the mac header with eth_hdr without verifying that the skb\nhas an Ethernet header.\n\nSyzbot was able to enter llc_rcv on a tun device. Tun can insert\npackets without mac len and with user configurable skb->protocol\n(passing a tun_pi header when not configuring IFF_NO_PI).\n\n    BUG: KMSAN: uninit-value in llc_station_ac_send_test_r net\/llc\/llc_station.c:81 [inline]\n    BUG: KMSAN: uninit-value in llc_station_rcv+0x6fb\/0x1290 net\/llc\/llc_station.c:111\n    llc_station_ac_send_test_r net\/llc\/llc_station.c:81 [inline]\n    llc_station_rcv+0x6fb\/0x1290 net\/llc\/llc_station.c:111\n    llc_rcv+0xc5d\/0x14a0 net\/llc\/llc_input.c:218\n    __netif_receive_skb_one_core net\/core\/dev.c:5523 [inline]\n    __netif_receive_skb+0x1a6\/0x5a0 net\/core\/dev.c:5637\n    netif_receive_skb_internal net\/core\/dev.c:5723 [inline]\n    netif_receive_skb+0x58\/0x660 net\/core\/dev.c:5782\n    tun_rx_batched+0x3ee\/0x980 drivers\/net\/tun.c:1555\n    tun_get_user+0x54c5\/0x69c0 drivers\/net\/tun.c:2002\n\nAdd a mac_len test before all three eth_hdr(skb) calls under net\/llc.\n\nThere are further uses in include\/net\/llc_pdu.h. All these are\nprotected by a test skb->protocol == ETH_P_802_2. Which does not\nprotect against this tun scenario.\n\nBut the mac_len test added in this patch in llc_fixup_skb will\nindirectly protect those too. That is called from llc_rcv before any\nother LLC code.\n\nIt is tempting to just add a blanket mac_len check in llc_rcv, but\nnot sure whether that could break valid LLC paths that do not assume\nan Ethernet header. 802.2 LLC may be used on top of non-802.3\nprotocols in principle. The below referenced commit shows that used\nto, on top of Token Ring.\n\nAt least one of the three eth_hdr uses goes back to before the start\nof git history. But the one that syzbot exercises is introduced in\nthis commit. That commit is old enough (2008), that effectively all\nstable kernels should receive this."},{"lang":"es","value":"En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: llc: verificar mac len antes de leer el encabezado de mac. LLC lee el encabezado de mac con eth_hdr sin verificar que el skb tenga un encabezado de Ethernet. Syzbot pudo ingresar llc_rcv en un dispositivo tun. Tun puede insertar paquetes sin mac len y con el protocolo skb-&gt; configurable por el usuario (pasando un encabezado tun_pi cuando no se configura IFF_NO_PI). ERROR: KMSAN: valor uninit en llc_station_ac_send_test_r net\/llc\/llc_station.c:81 [en línea] BUG: KMSAN: valor uninit en llc_station_rcv+0x6fb\/0x1290 net\/llc\/llc_station.c:111 llc_station_ac_send_test_r net\/llc\/llc_station. c:81 [en línea] llc_station_rcv+0x6fb\/0x1290 net\/llc\/llc_station.c:111 llc_rcv+0xc5d\/0x14a0 net\/llc\/llc_input.c:218 __netif_receive_skb_one_core net\/core\/dev.c:5523 __netif_receive_skb+ 0x1a6 \/0x5a0 net\/core\/dev.c:5637 netif_receive_skb_internal net\/core\/dev.c:5723 [en línea] netif_receive_skb+0x58\/0x660 net\/core\/dev.c:5782 tun_rx_batched+0x3ee\/0x980 drivers\/net\/tun.c :1555 tun_get_user+0x54c5\/0x69c0 drivers\/net\/tun.c:2002 Agregue una prueba mac_len antes de las tres llamadas eth_hdr(skb) en net\/llc. Hay más usos en include\/net\/llc_pdu.h. Todos estos están protegidos por un protocolo de prueba skb-&gt;== ETH_P_802_2. Lo cual no protege contra este escenario tun. Pero la prueba mac_len agregada en este parche en llc_fixup_skb también los protegerá indirectamente. Esto se llama desde llc_rcv antes que cualquier otro código LLC. Es tentador simplemente agregar una verificación general de mac_len en llc_rcv, pero no estoy seguro de si eso podría interrumpir las rutas LLC válidas que no asumen un encabezado Ethernet. En principio, 802.2 LLC se puede utilizar además de protocolos que no sean 802.3. La confirmación a la que se hace referencia a continuación muestra que solía hacerlo, además de Token Ring. Al menos uno de los tres usos de eth_hdr se remonta a antes del inicio del historial de git. Pero el que ejercita syzbot se introduce en este compromiso. Ese compromiso es lo suficientemente antiguo (2008), por lo que efectivamente todos los núcleos estables deberían recibirlo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0a720d0259ad3521ec6c9e4199f9f6fc75bac77a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/352887b3edd007cf9b0abc30fe9d98622acd859b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3a2653828ffc6101aef80bf58d5b77484239f779","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7b3ba18703a63f6fd487183b9262b08e5632da1b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/900a4418e3f66a32db6baaf23f92b99c20ae6535","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9a3f9054a5227d7567cba1fb821df48ccecad10c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cbdcdf42d15dac74c7287679fb2a9d955f8feb1f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f980e9a57dfb9530f1f4ee41a2420f2a256d7b29","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ff5cb6a4f0c6d7fbdc84858323fb4b7af32cfd79","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52844","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.653","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: vidtv: psi: Add check for kstrdup\n\nAdd check for the return value of kstrdup() and return the error\nif it fails in order to avoid NULL pointer dereference."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: media: vidtv: psi: Agregar verificación para kstrdup. Agregue verificación para el valor de retorno de kstrdup() y devuelva el error si falla para evitar la desreferencia al puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3387490c89b10aeb4e71d78b65dbc9ba4b2385b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5c26aae3723965c291c65dd2ecad6a3240d422b0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5cfcc8de7d733a1137b86954cc28ce99972311ad","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/76a2c5df6ca8bd8ada45e953b8c72b746f42918d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a51335704a3f90eaf23a6864faefca34b382490a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d17269fb9161995303985ab2fe6f16cfb72152f9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52845","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.723","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: Change nla_policy for bearer-related names to NLA_NUL_STRING\n\nsyzbot reported the following uninit-value access issue [1]:\n\n=====================================================\nBUG: KMSAN: uninit-value in strlen lib\/string.c:418 [inline]\nBUG: KMSAN: uninit-value in strstr+0xb8\/0x2f0 lib\/string.c:756\n strlen lib\/string.c:418 [inline]\n strstr+0xb8\/0x2f0 lib\/string.c:756\n tipc_nl_node_reset_link_stats+0x3ea\/0xb50 net\/tipc\/node.c:2595\n genl_family_rcv_msg_doit net\/netlink\/genetlink.c:971 [inline]\n genl_family_rcv_msg net\/netlink\/genetlink.c:1051 [inline]\n genl_rcv_msg+0x11ec\/0x1290 net\/netlink\/genetlink.c:1066\n netlink_rcv_skb+0x371\/0x650 net\/netlink\/af_netlink.c:2545\n genl_rcv+0x40\/0x60 net\/netlink\/genetlink.c:1075\n netlink_unicast_kernel net\/netlink\/af_netlink.c:1342 [inline]\n netlink_unicast+0xf47\/0x1250 net\/netlink\/af_netlink.c:1368\n netlink_sendmsg+0x1238\/0x13d0 net\/netlink\/af_netlink.c:1910\n sock_sendmsg_nosec net\/socket.c:730 [inline]\n sock_sendmsg net\/socket.c:753 [inline]\n ____sys_sendmsg+0x9c2\/0xd60 net\/socket.c:2541\n ___sys_sendmsg+0x28d\/0x3c0 net\/socket.c:2595\n __sys_sendmsg net\/socket.c:2624 [inline]\n __do_sys_sendmsg net\/socket.c:2633 [inline]\n __se_sys_sendmsg net\/socket.c:2631 [inline]\n __x64_sys_sendmsg+0x307\/0x490 net\/socket.c:2631\n do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n do_syscall_64+0x41\/0xc0 arch\/x86\/entry\/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63\/0xcd\n\nUninit was created at:\n slab_post_alloc_hook+0x12f\/0xb70 mm\/slab.h:767\n slab_alloc_node mm\/slub.c:3478 [inline]\n kmem_cache_alloc_node+0x577\/0xa80 mm\/slub.c:3523\n kmalloc_reserve+0x13d\/0x4a0 net\/core\/skbuff.c:559\n __alloc_skb+0x318\/0x740 net\/core\/skbuff.c:650\n alloc_skb include\/linux\/skbuff.h:1286 [inline]\n netlink_alloc_large_skb net\/netlink\/af_netlink.c:1214 [inline]\n netlink_sendmsg+0xb34\/0x13d0 net\/netlink\/af_netlink.c:1885\n sock_sendmsg_nosec net\/socket.c:730 [inline]\n sock_sendmsg net\/socket.c:753 [inline]\n ____sys_sendmsg+0x9c2\/0xd60 net\/socket.c:2541\n ___sys_sendmsg+0x28d\/0x3c0 net\/socket.c:2595\n __sys_sendmsg net\/socket.c:2624 [inline]\n __do_sys_sendmsg net\/socket.c:2633 [inline]\n __se_sys_sendmsg net\/socket.c:2631 [inline]\n __x64_sys_sendmsg+0x307\/0x490 net\/socket.c:2631\n do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n do_syscall_64+0x41\/0xc0 arch\/x86\/entry\/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63\/0xcd\n\nTIPC bearer-related names including link names must be null-terminated\nstrings. If a link name which is not null-terminated is passed through\nnetlink, strstr() and similar functions can cause buffer overrun. This\ncauses the above issue.\n\nThis patch changes the nla_policy for bearer-related names from NLA_STRING\nto NLA_NUL_STRING. This resolves the issue by ensuring that only\nnull-terminated strings are accepted as bearer-related names.\n\nsyzbot reported similar uninit-value issue related to bearer names [2]. The\nroot cause of this issue is that a non-null-terminated bearer name was\npassed. This patch also resolved this issue."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: tipc: Cambiar nla_policy para nombres relacionados con el portador a NLA_NUL_STRING syzbot informó el siguiente problema de acceso de valor uninit [1]: ============== ======================================= BUG: KMSAN: valor uninit en strlen lib\/ string.c:418 [en línea] BUG: KMSAN: valor uninit en strstr+0xb8\/0x2f0 lib\/string.c:756 strlen lib\/string.c:418 [en línea] strstr+0xb8\/0x2f0 lib\/string.c: 756 tipc_nl_node_reset_link_stats+0x3ea\/0xb50 net\/tipc\/node.c:2595 genl_family_rcv_msg_doit net\/netlink\/genetlink.c:971 [en línea] genl_family_rcv_msg net\/netlink\/genetlink.c:1051 [en línea] 0x1290 red\/enlace de red\/ genetlink.c:1066 netlink_rcv_skb+0x371\/0x650 net\/netlink\/af_netlink.c:2545 genl_rcv+0x40\/0x60 net\/netlink\/genetlink.c:1075 netlink_unicast_kernel net\/netlink\/af_netlink.c:1342 [en línea] netlink_unicast+0xf47\/ 0x1250 net\/netlink\/af_netlink.c:1368 netlink_sendmsg+0x1238\/0x13d0 net\/netlink\/af_netlink.c:1910 sock_sendmsg_nosec net\/socket.c:730 [en línea] sock_sendmsg net\/socket.c:753 [en línea] 2\/ 0xd60 net\/socket.c:2541 ___sys_sendmsg+0x28d\/0x3c0 net\/socket.c:2595 __sys_sendmsg net\/socket.c:2624 [en línea] __do_sys_sendmsg net\/socket.c:2633 [en línea] __se_sys_sendmsg red\/socket. c:2631 [en línea] __x64_sys_sendmsg+0x307\/0x490 net\/socket.c:2631 do_syscall_x64 arch\/x86\/entry\/common.c:50 [en línea] do_syscall_64+0x41\/0xc0 arch\/x86\/entry\/common.c:80 Entry_SYSCALL_64_after_hwframe+0 x63\/ 0xcd Uninit se creó en: slab_post_alloc_hook+0x12f\/0xb70 mm\/slab.h:767 slab_alloc_node mm\/slub.c:3478 [en línea] kmem_cache_alloc_node+0x577\/0xa80 mm\/slub.c:3523 kmalloc_reserve+0x13d\/0x4a0 net\/ núcleo\/ skbuff.c:559 __alloc_skb+0x318\/0x740 net\/core\/skbuff.c:650 alloc_skb include\/linux\/skbuff.h:1286 [en línea] netlink_alloc_large_skb net\/netlink\/af_netlink.c:1214 [en línea] netlink_sendmsg+0xb34\/0x13d0 net\/netlink\/af_netlink.c:1885 sock_sendmsg_nosec net\/socket.c:730 [en línea] sock_sendmsg net\/socket.c:753 [en línea] ____sys_sendmsg+0x9c2\/0xd60 net\/socket.c:2541 ___sys_sendmsg+0x28d\/0x3c0 net\/ socket.c:2595 __sys_sendmsg net\/socket.c:2624 [en línea] __do_sys_sendmsg net\/socket.c:2633 [en línea] __se_sys_sendmsg net\/socket.c:2631 [en línea] __x64_sys_sendmsg+0x307\/0x490 :2631 do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline] do_syscall_64+0x41\/0xc0 arch\/x86\/entry\/common.c:80 Entry_SYSCALL_64_after_hwframe+0x63\/0xcd Los nombres relacionados con el portador TIPC, incluidos los nombres de enlaces, deben ser cadenas terminadas en nulo . Si un nombre de enlace que no termina en nulo se pasa a través de netlink, strstr() y funciones similares pueden provocar una saturación del búfer. Esto causa el problema anterior. Este parche cambia la nla_policy para nombres relacionados con el portador de NLA_STRING a NLA_NUL_STRING. Esto resuelve el problema garantizando que sólo se acepten cadenas terminadas en nulo como nombres relacionados con el portador. syzbot informó un problema similar de valor uninitario relacionado con los nombres de los portadores [2]. La causa principal de este problema es que se pasó un nombre de portador no terminado en nulo. Este parche también resolvió este problema."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/19b3f72a41a8751e26bffc093bb7e1cef29ad579","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2199260c42e6fbc5af8adae3bf78e623407c91b0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2426425d686b43adbc4f2f4a367b494f06f159d6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3907b89cd17fcc23e9a80789c36856f00ece0ba8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4c731e98fe4d678e87ba3e4d45d3cf0a5a193dc4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/560992f41c0cea44b7603bc9e6c73bffbf6b5709","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6744008c354bca2e4686a5b6056ee6b535d9f67d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/abc1582119e8c4af14cedb0db6541fd603f45a04","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b33d130f07f1decd756b849ab03c23d11d4dd294","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52846","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.800","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nhsr: Prevent use after free in prp_create_tagged_frame()\n\nThe prp_fill_rct() function can fail.  In that situation, it frees the\nskb and returns NULL.  Meanwhile on the success path, it returns the\noriginal skb.  So it's straight forward to fix bug by using the returned\nvalue."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: hsr: impedir el uso después de liberar en prp_create_tagged_frame(). La función prp_fill_rct() puede fallar. En esa situación, libera el skb y devuelve NULL. Mientras tanto, en el camino hacia el éxito, devuelve el skb original. Por lo tanto, es sencillo corregir el error utilizando el valor devuelto."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1787b9f0729d318d67cf7c5a95f0c3dba9a7cc18","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6086258bd5ea7b5c706ff62da42b8e271b2401db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/876f8ab52363f649bcc74072157dfd7adfbabc0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a1a485e45d24b1cd8fe834fd6f1b06e2903827da","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d103fb6726904e353b4773188ee3d3acb4078363","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ddf4e04e946aaa6c458b8b6829617cc44af2bffd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52847","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.873","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: bttv: fix use after free error due to btv->timeout timer\n\nThere may be some a race condition between timer function\nbttv_irq_timeout and bttv_remove. The timer is setup in\nprobe and there is no timer_delete operation in remove\nfunction. When it hit kfree btv, the function might still be\ninvoked, which will cause use after free bug.\n\nThis bug is found by static analysis, it may be false positive.\n\nFix it by adding del_timer_sync invoking to the remove function.\n\ncpu0                cpu1\n                  bttv_probe\n                    ->timer_setup\n                      ->bttv_set_dma\n                        ->mod_timer;\nbttv_remove\n  ->kfree(btv);\n                  ->bttv_irq_timeout\n                    ->USE btv"},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: medio: bttv: corrección de uso después de error gratuito debido a btv-&gt;timeout timer. Puede haber alguna condición de ejecución entre la función del temporizador bttv_irq_timeout y bttv_remove. El temporizador está configurado en la sonda y no hay ninguna operación timer_delete en la función de eliminación. Cuando llega a kfree btv, es posible que la función aún se invoque, lo que provocará un error de use after free. Este error se encuentra mediante análisis estático y puede ser un falso positivo. Solucionelo agregando del_timer_sync invocando a la función de eliminación. cpu0 cpu1 bttv_probe -&gt;timer_setup -&gt;bttv_set_dma -&gt;mod_timer; bttv_remove -&gt;kfree(btv); -&gt;bttv_irq_timeout -&gt;USE btv"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1871014d6ef4812ad11ef7d838d73ce09d632267","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/20568d06f6069cb835e05eed432edf962645d226","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2f3d9198cdae1cb079ec8652f4defacd481eab2b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/51c94256a83fe4e17406c66ff3e1ad7d242d8574","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/847599fffa528b2cdec4e21b6bf7586dad982132","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b35fdade92c5058a5e727e233fe263b828de2c9a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bbc3b8dd2cb7817e703f112d988e4f4728f0f2a9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bd5b50b329e850d467e7bcc07b2b6bde3752fbda","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52848","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:21.947","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to drop meta_inode's page cache in f2fs_put_super()\n\nsyzbot reports a kernel bug as below:\n\nF2FS-fs (loop1): detect filesystem reference count leak during umount, type: 10, count: 1\nkernel BUG at fs\/f2fs\/super.c:1639!\nCPU: 0 PID: 15451 Comm: syz-executor.1 Not tainted 6.5.0-syzkaller-09338-ge0152e7481c6 #0\nRIP: 0010:f2fs_put_super+0xce1\/0xed0 fs\/f2fs\/super.c:1639\nCall Trace:\n generic_shutdown_super+0x161\/0x3c0 fs\/super.c:693\n kill_block_super+0x3b\/0x70 fs\/super.c:1646\n kill_f2fs_super+0x2b7\/0x3d0 fs\/f2fs\/super.c:4879\n deactivate_locked_super+0x9a\/0x170 fs\/super.c:481\n deactivate_super+0xde\/0x100 fs\/super.c:514\n cleanup_mnt+0x222\/0x3d0 fs\/namespace.c:1254\n task_work_run+0x14d\/0x240 kernel\/task_work.c:179\n resume_user_mode_work include\/linux\/resume_user_mode.h:49 [inline]\n exit_to_user_mode_loop kernel\/entry\/common.c:171 [inline]\n exit_to_user_mode_prepare+0x210\/0x240 kernel\/entry\/common.c:204\n __syscall_exit_to_user_mode_work kernel\/entry\/common.c:285 [inline]\n syscall_exit_to_user_mode+0x1d\/0x60 kernel\/entry\/common.c:296\n do_syscall_64+0x44\/0xb0 arch\/x86\/entry\/common.c:86\n entry_SYSCALL_64_after_hwframe+0x63\/0xcd\n\nIn f2fs_put_super(), it tries to do sanity check on dirty and IO\nreference count of f2fs, once there is any reference count leak,\nit will trigger panic.\n\nThe root case is, during f2fs_put_super(), if there is any IO error\nin f2fs_wait_on_all_pages(), we missed to truncate meta_inode's page\ncache later, result in panic, fix this case."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: f2fs: corrección para eliminar el caché de la página de meta_inode en f2fs_put_super() syzbot informa un error en el kernel como se muestra a continuación: F2FS-fs (loop1): detecta pérdida del recuento de referencias del sistema de archivos durante el desmontaje, escriba: 10 , recuento: ¡1 BUG del kernel en fs\/f2fs\/super.c:1639! CPU: 0 PID: 15451 Comm: syz-executor.1 No contaminado 6.5.0-syzkaller-09338-ge0152e7481c6 #0 RIP: 0010:f2fs_put_super+0xce1\/0xed0 fs\/f2fs\/super.c:1639 Seguimiento de llamadas: generic_shutdown_super+0x161 \/0x3c0 fs\/super.c:693 kill_block_super+0x3b\/0x70 fs\/super.c:1646 kill_f2fs_super+0x2b7\/0x3d0 fs\/f2fs\/super.c:4879 deactivate_locked_super+0x9a\/0x170 fs\/super.c:481 deactivate_super+0xde \/0x100 fs\/super.c:514 cleanup_mnt+0x222\/0x3d0 fs\/namespace.c:1254 task_work_run+0x14d\/0x240 kernel\/task_work.c:179 resume_user_mode_work include\/linux\/resume_user_mode.h:49 [en línea] exit_to_user_mode_loop kernel\/entry \/common.c:171 [en línea] exit_to_user_mode_prepare+0x210\/0x240 kernel\/entry\/common.c:204 __syscall_exit_to_user_mode_work kernel\/entry\/common.c:285 [en línea] syscall_exit_to_user_mode+0x1d\/0x60 kernel\/entry\/common.c:296 do_syscall_64+0x44\/0xb0 arch\/x86\/entry\/common.c:86 Entry_SYSCALL_64_after_hwframe+0x63\/0xcd En f2fs_put_super(), intenta realizar una verificación de cordura en el recuento de referencias sucias y de IO de f2fs, una vez que hay alguna fuga en el recuento de referencias, provocará pánico. El caso raíz es que, durante f2fs_put_super(), si hay algún error de IO en f2fs_wait_on_all_pages(), no pudimos truncar el caché de la página de meta_inode más tarde, lo que generó pánico, solucionemos este caso."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/10b2a6c0dade67b5a2b2d17fb75c457ea1985fad","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a4639380bbe66172df329f8b54aa7d2e943f0f64","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb42e1862aa7934c2c21890097ce4993c5e0d192","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52849","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.023","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncxl\/mem: Fix shutdown order\n\nIra reports that removing cxl_mock_mem causes a crash with the following\ntrace:\n\n BUG: kernel NULL pointer dereference, address: 0000000000000044\n [..]\n RIP: 0010:cxl_region_decode_reset+0x7f\/0x180 [cxl_core]\n [..]\n Call Trace:\n  <TASK>\n  cxl_region_detach+0xe8\/0x210 [cxl_core]\n  cxl_decoder_kill_region+0x27\/0x40 [cxl_core]\n  cxld_unregister+0x29\/0x40 [cxl_core]\n  devres_release_all+0xb8\/0x110\n  device_unbind_cleanup+0xe\/0x70\n  device_release_driver_internal+0x1d2\/0x210\n  bus_remove_device+0xd7\/0x150\n  device_del+0x155\/0x3e0\n  device_unregister+0x13\/0x60\n  devm_release_action+0x4d\/0x90\n  ? __pfx_unregister_port+0x10\/0x10 [cxl_core]\n  delete_endpoint+0x121\/0x130 [cxl_core]\n  devres_release_all+0xb8\/0x110\n  device_unbind_cleanup+0xe\/0x70\n  device_release_driver_internal+0x1d2\/0x210\n  bus_remove_device+0xd7\/0x150\n  device_del+0x155\/0x3e0\n  ? lock_release+0x142\/0x290\n  cdev_device_del+0x15\/0x50\n  cxl_memdev_unregister+0x54\/0x70 [cxl_core]\n\nThis crash is due to the clearing out the cxl_memdev's driver context\n(@cxlds) before the subsystem is done with it. This is ultimately due to\nthe region(s), that this memdev is a member, being torn down and expecting\nto be able to de-reference @cxlds, like here:\n\nstatic int cxl_region_decode_reset(struct cxl_region *cxlr, int count)\n...\n                if (cxlds->rcd)\n                        goto endpoint_reset;\n...\n\nFix it by keeping the driver context valid until memdev-device\nunregistration, and subsequently the entire stack of related\ndependencies, unwinds."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: cxl\/mem: arreglo del orden de apagado. Ira informa que la eliminación de cxl_mock_mem causa un bloqueo con el siguiente rastro: ERROR: desreferencia del puntero NULL del kernel, dirección: 0000000000000044 [..] RIP: 0010: cxl_region_decode_reset+0x7f\/0x180 [cxl_core] [..] Seguimiento de llamadas:  cxl_region_detach+0xe8\/0x210 [cxl_core] cxl_decoder_kill_region+0x27\/0x40 [cxl_core] cxld_unregister+0x29\/0x40 [cxl_core] 0x110 device_unbind_cleanup+0xe\/0x70 device_release_driver_internal+0x1d2\/0x210 bus_remove_device+0xd7\/0x150 dispositivo_del+0x155\/0x3e0 device_unregister+0x13\/0x60 devm_release_action+0x4d\/0x90 ? __pfx_unregister_port+0x10\/0x10 [cxl_core] delete_endpoint+0x121\/0x130 [cxl_core] devres_release_all+0xb8\/0x110 device_unbind_cleanup+0xe\/0x70 dispositivo_release_driver_internal+0x1d2\/0x210 bus_remove_device+0xd7\/0x15 0 dispositivo_del+0x155\/0x3e0? lock_release+0x142\/0x290 cdev_device_del+0x15\/0x50 cxl_memdev_unregister+0x54\/0x70 [cxl_core] Este bloqueo se debe a que se borró el contexto del controlador de cxl_memdev (@cxlds) antes de que el subsistema termine con él. En última instancia, esto se debe a que las regiones de las que este memdev es miembro están siendo derribadas y esperan poder eliminar la referencia a @cxlds, como aquí: static int cxl_region_decode_reset(struct cxl_region *cxlr, int count) .. si (cxlds-&gt;rcd) pasa a endpoint_reset; ... Solucionelo manteniendo válido el contexto del controlador hasta que se cancele el registro del dispositivo memdev y, posteriormente, toda la pila de dependencias relacionadas."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0ca074f7d788627a4e0b047ca5fbdb5fc567220c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/20bd0198bebdd706bd4614b3933ef70d7c19618f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7c7371b41a14e86f53e7dbe5baa7b1d3e0ab324b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/88d3917f82ed4215a2154432c26de1480a61b209","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cad22a757029c3a1985c221a2d4a6491ad4035ae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52850","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.097","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: hantro: Check whether reset op is defined before use\n\nThe i.MX8MM\/N\/P does not define the .reset op since reset of the VPU is\ndone by genpd. Check whether the .reset op is defined before calling it\nto avoid NULL pointer dereference.\n\nNote that the Fixes tag is set to the commit which removed the reset op\nfrom i.MX8M Hantro G2 implementation, this is because before this commit\nall the implementations did define the .reset op."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: medios: hantro: compruebe si la operación de reinicio está definida antes de su uso. El i.MX8MM\/N\/P no define la operación .reset ya que genpd realiza el reinicio de la VPU. Compruebe si la operación .reset está definida antes de llamarla para evitar la desreferencia del puntero NULL. Tenga en cuenta que la etiqueta Fixes está configurada en la confirmación que eliminó la operación de reinicio de la implementación de i.MX8M Hantro G2, esto se debe a que antes de esta confirmación todas las implementaciones definían la operación .reset."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/24c06295f28335ced3aad53dd4b0a0bae7b9b100","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/64f55cebb4339ae771e9e7f3f42bee2489e2fa00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/66b4c5f980d741f3a47e4b65eeaf2797f2d59294","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/88d4b23a629ebd34f682f770cb6c2116c851f7b8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52851","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.160","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nIB\/mlx5: Fix init stage error handling to avoid double free of same QP and UAF\n\nIn the unlikely event that workqueue allocation fails and returns NULL in\nmlx5_mkey_cache_init(), delete the call to\nmlx5r_umr_resource_cleanup() (which frees the QP) in\nmlx5_ib_stage_post_ib_reg_umr_init().  This will avoid attempted double\nfree of the same QP when __mlx5_ib_add() does its cleanup.\n\nResolves a splat:\n\n   Syzkaller reported a UAF in ib_destroy_qp_user\n\n   workqueue: Failed to create a rescuer kthread for wq \"mkey_cache\": -EINTR\n   infiniband mlx5_0: mlx5_mkey_cache_init:981:(pid 1642):\n   failed to create work queue\n   infiniband mlx5_0: mlx5_ib_stage_post_ib_reg_umr_init:4075:(pid 1642):\n   mr cache init failed -12\n   ==================================================================\n   BUG: KASAN: slab-use-after-free in ib_destroy_qp_user (drivers\/infiniband\/core\/verbs.c:2073)\n   Read of size 8 at addr ffff88810da310a8 by task repro_upstream\/1642\n\n   Call Trace:\n   <TASK>\n   kasan_report (mm\/kasan\/report.c:590)\n   ib_destroy_qp_user (drivers\/infiniband\/core\/verbs.c:2073)\n   mlx5r_umr_resource_cleanup (drivers\/infiniband\/hw\/mlx5\/umr.c:198)\n   __mlx5_ib_add (drivers\/infiniband\/hw\/mlx5\/main.c:4178)\n   mlx5r_probe (drivers\/infiniband\/hw\/mlx5\/main.c:4402)\n   ...\n   <\/TASK>\n\n   Allocated by task 1642:\n   __kmalloc (.\/include\/linux\/kasan.h:198 mm\/slab_common.c:1026\n   mm\/slab_common.c:1039)\n   create_qp (.\/include\/linux\/slab.h:603 .\/include\/linux\/slab.h:720\n   .\/include\/rdma\/ib_verbs.h:2795 drivers\/infiniband\/core\/verbs.c:1209)\n   ib_create_qp_kernel (drivers\/infiniband\/core\/verbs.c:1347)\n   mlx5r_umr_resource_init (drivers\/infiniband\/hw\/mlx5\/umr.c:164)\n   mlx5_ib_stage_post_ib_reg_umr_init (drivers\/infiniband\/hw\/mlx5\/main.c:4070)\n   __mlx5_ib_add (drivers\/infiniband\/hw\/mlx5\/main.c:4168)\n   mlx5r_probe (drivers\/infiniband\/hw\/mlx5\/main.c:4402)\n   ...\n\n   Freed by task 1642:\n   __kmem_cache_free (mm\/slub.c:1826 mm\/slub.c:3809 mm\/slub.c:3822)\n   ib_destroy_qp_user (drivers\/infiniband\/core\/verbs.c:2112)\n   mlx5r_umr_resource_cleanup (drivers\/infiniband\/hw\/mlx5\/umr.c:198)\n   mlx5_ib_stage_post_ib_reg_umr_init (drivers\/infiniband\/hw\/mlx5\/main.c:4076\n   drivers\/infiniband\/hw\/mlx5\/main.c:4065)\n   __mlx5_ib_add (drivers\/infiniband\/hw\/mlx5\/main.c:4168)\n   mlx5r_probe (drivers\/infiniband\/hw\/mlx5\/main.c:4402)\n   ..."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: IB\/mlx5: corrige el manejo de errores de la etapa inicial para evitar la doble liberación del mismo QP y UAF. En el improbable caso de que la asignación de la cola de trabajo falle y devuelva NULL en mlx5_mkey_cache_init(), elimine la llamada a mlx5r_umr_resource_cleanup() (que libera el QP) en mlx5_ib_stage_post_ib_reg_umr_init(). Esto evitará intentos de double free del mismo QP cuando __mlx5_ib_add() realice su limpieza. Resuelve un problema: Syzkaller informó un UAF en ib_destroy_qp_user workqueue: No se pudo crear un kthread de rescate para wq \"mkey_cache\": -EINTR infiniband mlx5_0: mlx5_mkey_cache_init:981:(pid 1642): no se pudo crear la cola de trabajo infiniband mlx5_0: mlx5_ib_stage_post_ib_reg_umr_ inicio: 4075: (pid 1642): el inicio de caché de mr falló -12 ========================================= =========================== BUG: KASAN: uso de losa después de la liberación en ib_destroy_qp_user (drivers\/infiniband\/core\/verbs.c :2073) Lectura de tamaño 8 en la dirección ffff88810da310a8 mediante la tarea repro_upstream\/1642 Rastreo de llamadas:  kasan_report (mm\/kasan\/report.c:590) ib_destroy_qp_user (drivers\/infiniband\/core\/verbs.c:2073) mlx5r_umr_resource_cleanup (drivers \/infiniband\/hw\/mlx5\/umr.c:198) __mlx5_ib_add (drivers\/infiniband\/hw\/mlx5\/main.c:4178) mlx5r_probe (drivers\/infiniband\/hw\/mlx5\/main.c:4402) ...  Asignado por la tarea 1642: __kmalloc (.\/include\/linux\/kasan.h:198 mm\/slab_common.c:1026 mm\/slab_common.c:1039) create_qp (.\/include\/linux\/slab.h:603 .\/ include\/linux\/slab.h:720 .\/include\/rdma\/ib_verbs.h:2795 drivers\/infiniband\/core\/verbs.c:1209) ib_create_qp_kernel (drivers\/infiniband\/core\/verbs.c:1347) mlx5r_umr_resource_init (drivers\/ infiniband\/hw\/mlx5\/umr.c:164) mlx5_ib_stage_post_ib_reg_umr_init (drivers\/infiniband\/hw\/mlx5\/main.c:4070) __mlx5_ib_add (drivers\/infiniband\/hw\/mlx5\/main.c:4168) mlx5r_probe (drivers\/infiniband\/ hw\/mlx5\/main.c:4402) ... Liberado por la tarea 1642: __kmem_cache_free (mm\/slub.c:1826 mm\/slub.c:3809 mm\/slub.c:3822) ib_destroy_qp_user (drivers\/infiniband\/core\/ verbs.c:2112) mlx5r_umr_resource_cleanup (drivers\/infiniband\/hw\/mlx5\/umr.c:198) mlx5_ib_stage_post_ib_reg_umr_init (drivers\/infiniband\/hw\/mlx5\/main.c:4076 drivers\/infiniband\/hw\/mlx5\/main.c:4065 ) __mlx5_ib_add (controladores\/infiniband\/hw\/mlx5\/main.c:4168) mlx5r_probe (controladores\/infiniband\/hw\/mlx5\/main.c:4402) ..."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2ef422f063b74adcc4a4a9004b0a87bb55e0a836","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/437f033e30c897bb3723eac9e9003cd9f88d00a3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4f4a7a7d1404297f2a92df0046f7e64dc5c52dd9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6387f269d84e6e149499408c4d1fc805017729b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52852","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.227","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: compress: fix to avoid use-after-free on dic\n\nCall trace:\n __memcpy+0x128\/0x250\n f2fs_read_multi_pages+0x940\/0xf7c\n f2fs_mpage_readpages+0x5a8\/0x624\n f2fs_readahead+0x5c\/0x110\n page_cache_ra_unbounded+0x1b8\/0x590\n do_sync_mmap_readahead+0x1dc\/0x2e4\n filemap_fault+0x254\/0xa8c\n f2fs_filemap_fault+0x2c\/0x104\n __do_fault+0x7c\/0x238\n do_handle_mm_fault+0x11bc\/0x2d14\n do_mem_abort+0x3a8\/0x1004\n el0_da+0x3c\/0xa0\n el0t_64_sync_handler+0xc4\/0xec\n el0t_64_sync+0x1b4\/0x1b8\n\nIn f2fs_read_multi_pages(), once f2fs_decompress_cluster() was called if\nwe hit cached page in compress_inode's cache, dic may be released, it needs\nbreak the loop rather than continuing it, in order to avoid accessing\ninvalid dic pointer."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: f2fs: compress: corrección para evitar el use after free en dic. Rastreo de llamadas: __memcpy+0x128\/0x250 f2fs_read_multi_pages+0x940\/0xf7c f2fs_mpage_readpages+0x5a8\/0x624 f2fs_readahead+0x5c\/0x110 page_cache_ra_ ilimitado +0x1b8\/0x590 do_sync_mmap_readahead+0x1dc\/0x2e4 filemap_fault+0x254\/0xa8c f2fs_filemap_fault+0x2c\/0x104 __do_fault+0x7c\/0x238 do_handle_mm_fault+0x11bc\/0x2d14 do_mem_abort+0x3a8 \/0x1004 el0_da+0x3c\/0xa0 el0t_64_sync_handler+0xc4\/0xec el0t_64_sync+0x1b4\/0x1b8 En f2fs_read_multi_pages(), una vez que se llamó a f2fs_decompress_cluster() si llegamos a la página almacenada en caché en el caché de compress_inode, es posible que se libere dic, es necesario romper el ciclo en lugar de continuarlo, para evitar acceder a un puntero dic no válido."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/8c4504cc0c64862740a6acb301e0cfa59580dbc5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/932ddb5c29e884cc6fac20417ece72ba4a35c401","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9375ea7f269093d7c884857ae1f47633a91f429c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9d065aa52b6ee1b06f9c4eca881c9b4425a12ba2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0327c84e91a0f4f0abced8cb83ec86a7083f086","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52853","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.303","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nhid: cp2112: Fix duplicate workqueue initialization\n\nPreviously the cp2112 driver called INIT_DELAYED_WORK within\ncp2112_gpio_irq_startup, resulting in duplicate initilizations of the\nworkqueue on subsequent IRQ startups following an initial request. This\nresulted in a warning in set_work_data in workqueue.c, as well as a rare\nNULL dereference within process_one_work in workqueue.c.\n\nInitialize the workqueue within _probe instead."},{"lang":"es","value":"En el kernel de Linux, se resolvió la siguiente vulnerabilidad: hid: cp2112: corrige la inicialización duplicada de la cola de trabajo. Anteriormente, el controlador cp2112 llamaba INIT_DELAYED_WORK dentro de cp2112_gpio_irq_startup, lo que generaba inicializaciones duplicadas de la cola de trabajo en inicios IRQ posteriores después de una solicitud inicial. Esto resultó en una advertencia en set_work_data en workqueue.c, así como en una rara desreferencia NULL dentro de process_one_work en workqueue.c. En su lugar, inicialice la cola de trabajo dentro de _probe."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/012d0c66f9392a99232ac28217229f32dd3a70cf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3d959406c8fff2334d83d0c352d54fd6f5b2e7cd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/727203e6e7e7020e1246fc1628cbdb8d90177819","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bafb12b629b7c3ad59812dd1ac1b0618062e0e38","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df0daac2709473531d6a3472997cc65301ac06d6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e3c2d2d144c082dd71596953193adf9891491f42","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb1121fac7986b30915ba20c5a04cc01fdcf160c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fb5718bc67337dde1528661f419ffcf275757592","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52854","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.377","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npadata: Fix refcnt handling in padata_free_shell()\n\nIn a high-load arm64 environment, the pcrypt_aead01 test in LTP can lead\nto system UAF (Use-After-Free) issues. Due to the lengthy analysis of\nthe pcrypt_aead01 function call, I'll describe the problem scenario\nusing a simplified model:\n\nSuppose there's a user of padata named `user_function` that adheres to\nthe padata requirement of calling `padata_free_shell` after `serial()`\nhas been invoked, as demonstrated in the following code:\n\n```c\nstruct request {\n    struct padata_priv padata;\n    struct completion *done;\n};\n\nvoid parallel(struct padata_priv *padata) {\n    do_something();\n}\n\nvoid serial(struct padata_priv *padata) {\n    struct request *request = container_of(padata,\n    \t\t\t\tstruct request,\n\t\t\t\tpadata);\n    complete(request->done);\n}\n\nvoid user_function() {\n    DECLARE_COMPLETION(done)\n    padata->parallel = parallel;\n    padata->serial = serial;\n    padata_do_parallel();\n    wait_for_completion(&done);\n    padata_free_shell();\n}\n```\n\nIn the corresponding padata.c file, there's the following code:\n\n```c\nstatic void padata_serial_worker(struct work_struct *serial_work) {\n    ...\n    cnt = 0;\n\n    while (!list_empty(&local_list)) {\n        ...\n        padata->serial(padata);\n        cnt++;\n    }\n\n    local_bh_enable();\n\n    if (refcount_sub_and_test(cnt, &pd->refcnt))\n        padata_free_pd(pd);\n}\n```\n\nBecause of the high system load and the accumulation of unexecuted\nsoftirq at this moment, `local_bh_enable()` in padata takes longer\nto execute than usual. Subsequently, when accessing `pd->refcnt`,\n`pd` has already been released by `padata_free_shell()`, resulting\nin a UAF issue with `pd->refcnt`.\n\nThe fix is straightforward: add `refcount_dec_and_test` before calling\n`padata_free_pd` in `padata_free_shell`."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: padata: corrige el manejo de refcnt en padata_free_shell(). En un entorno arm64 de alta carga, la prueba pcrypt_aead01 en LTP puede provocar problemas de UAF (Use-After-Free) del sistema. Debido al extenso análisis de la llamada a la función pcrypt_aead01, describiré el escenario del problema usando un modelo simplificado: supongamos que hay un usuario de padata llamado `user_function` que cumple con el requisito de padata de llamar a `padata_free_shell` después de `serial()`. ha sido invocado, como se demuestra en el siguiente código: ```c struct request { struct padata_priv padata; finalización de la estructura *hecho; }; void paralelo(struct padata_priv *padata) { hacer_algo(); } void serial(struct padata_priv *padata) { solicitud de estructura *request = container_of(padata, solicitud de estructura, padata); completar(solicitud-&gt;hecho); } void user_function() { DECLARE_COMPLETION(hecho) padata-&gt;parallel = parallel; padata-&gt;serial = serial; padata_do_parallel(); wait_for_completion(&amp;hecho); padata_free_shell(); } ``` En el archivo padata.c correspondiente, hay el siguiente código: ```c static void padata_serial_worker(struct work_struct *serial_work) { ... cnt = 0; while (!list_empty(&amp;local_list)) { ... padata-&gt;serial(padata); cnt++; } local_bh_enable(); if (refcount_sub_and_test(cnt, &amp;pd-&gt;refcnt)) padata_free_pd(pd); } ``` Debido a la alta carga del sistema y la acumulación de software no ejecutado en este momento, `local_bh_enable()` en padata tarda más de lo habitual en ejecutarse. Posteriormente, al acceder a `pd-&gt;refcnt`, `pd` ya ha sido liberado por `padata_free_shell()`, lo que genera un problema de UAF con `pd-&gt;refcnt`. La solución es sencilla: agregue `refcount_dec_and_test` antes de llamar a `padata_free_pd` en `padata_free_shell`."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0dd34a7ad395dbcf6ae60e48e9786050e25b9bc5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1734a79e951914f1db2c65e635012a35db1c674b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1e901bcb8af19416b65f5063a4af7996e5a51d7f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/41aad9d6953984d134fc50f631f24ef476875d4d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7ddc21e317b360c3444de3023bcc83b85fabae2f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c7c26d0ef5d20f00dbb2ae3befcabbe0efa77275","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52855","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.453","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc2: fix possible NULL pointer dereference caused by driver concurrency\n\nIn _dwc2_hcd_urb_enqueue(), \"urb->hcpriv = NULL\" is executed without\nholding the lock \"hsotg->lock\". In _dwc2_hcd_urb_dequeue():\n\n    spin_lock_irqsave(&hsotg->lock, flags);\n    ...\n\tif (!urb->hcpriv) {\n\t\tdev_dbg(hsotg->dev, \"## urb->hcpriv is NULL ##\\n\");\n\t\tgoto out;\n\t}\n    rc = dwc2_hcd_urb_dequeue(hsotg, urb->hcpriv); \/\/ Use urb->hcpriv\n    ...\nout:\n    spin_unlock_irqrestore(&hsotg->lock, flags);\n\nWhen _dwc2_hcd_urb_enqueue() and _dwc2_hcd_urb_dequeue() are\nconcurrently executed, the NULL check of \"urb->hcpriv\" can be executed\nbefore \"urb->hcpriv = NULL\". After urb->hcpriv is NULL, it can be used\nin the function call to dwc2_hcd_urb_dequeue(), which can cause a NULL\npointer dereference.\n\nThis possible bug is found by an experimental static analysis tool\ndeveloped by myself. This tool analyzes the locking APIs to extract\nfunction pairs that can be concurrently executed, and then analyzes the\ninstructions in the paired functions to identify possible concurrency\nbugs including data races and atomicity violations. The above possible\nbug is reported, when my tool analyzes the source code of Linux 6.5.\n\nTo fix this possible bug, \"urb->hcpriv = NULL\" should be executed with\nholding the lock \"hsotg->lock\". After using this patch, my tool never\nreports the possible bug, with the kernelconfiguration allyesconfig for\nx86_64. Because I have no associated hardware, I cannot test the patch\nin runtime testing, and just verify it according to the code logic."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: dwc2: corrige posible desreferencia de puntero NULL causada por concurrencia de controladores. En _dwc2_hcd_urb_enqueue(), \"urb-&gt;hcpriv = NULL\" se ejecuta sin mantener presionado el bloqueo \"hsotg-&gt;lock\" . En _dwc2_hcd_urb_dequeue(): spin_lock_irqsave(&amp;hsotg-&gt;lock, flags); ... if (!urb-&gt;hcpriv) { dev_dbg(hsotg-&gt;dev, \"## urb-&gt;hcpriv es NULL ##\\n\"); salir; } rc = dwc2_hcd_urb_dequeue(hsotg, urb-&gt;hcpriv); \/\/ Usa urb-&gt;hcpriv ... out: spin_unlock_irqrestore(&amp;hsotg-&gt;lock, flags); Cuando _dwc2_hcd_urb_enqueue() y _dwc2_hcd_urb_dequeue() se ejecutan simultáneamente, la verificación NULL de \"urb-&gt;hcpriv\" se puede ejecutar antes de \"urb-&gt;hcpriv = NULL\". Después de que urb-&gt;hcpriv sea NULL, se puede usar en la llamada de función a dwc2_hcd_urb_dequeue(), lo que puede provocar una desreferencia del puntero NULL. Este posible error se encuentra mediante una herramienta experimental de análisis estático desarrollada por mí. Esta herramienta analiza las API de bloqueo para extraer pares de funciones que se pueden ejecutar simultáneamente y luego analiza las instrucciones en las funciones emparejadas para identificar posibles errores de concurrencia, incluidas ejecucións de datos y violaciones de atomicidad. El posible error anterior se informa cuando mi herramienta analiza el código fuente de Linux 6.5. Para corregir este posible error, se debe ejecutar \"urb-&gt;hcpriv = NULL\" manteniendo presionado el bloqueo \"hsotg-&gt;lock\". Después de usar este parche, mi herramienta nunca informa el posible error, con la configuración del kernel allyesconfig para x86_64. Como no tengo hardware asociado, no puedo probar el parche en tiempo de ejecución y simplemente verificarlo de acuerdo con la lógica del código."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/14c9ec34e8118fbffd7f5431814d767726323e72","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3e851a77a13ce944d703721793f49ee82622986d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/64c47749fc7507ed732e155c958253968c1d275e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6b21a22728852d020a6658d39cd7bb7e14b07790","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7bee9598afb38004841a41dd8fe68c1faff4e90","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bdb3dd4096302d6b87441fdc528439f171b04be6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ef307bc6ef04e8c1ea843231db58e3afaafa9fa6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fcaafb574fc88a52dce817f039f7ff2f9da38001","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fed492aa6493a91a77ebd51da6fb939c98d94a0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52856","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.727","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/bridge: lt8912b: Fix crash on bridge detach\n\nThe lt8912b driver, in its bridge detach function, calls\ndrm_connector_unregister() and drm_connector_cleanup().\n\ndrm_connector_unregister() should be called only for connectors\nexplicitly registered with drm_connector_register(), which is not the\ncase in lt8912b.\n\nThe driver's drm_connector_funcs.destroy hook is set to\ndrm_connector_cleanup().\n\nThus the driver should not call either drm_connector_unregister() nor\ndrm_connector_cleanup() in its lt8912_bridge_detach(), as they cause a\ncrash on bridge detach:\n\nUnable to handle kernel NULL pointer dereference at virtual address 0000000000000000\nMem abort info:\n  ESR = 0x0000000096000006\n  EC = 0x25: DABT (current EL), IL = 32 bits\n  SET = 0, FnV = 0\n  EA = 0, S1PTW = 0\n  FSC = 0x06: level 2 translation fault\nData abort info:\n  ISV = 0, ISS = 0x00000006, ISS2 = 0x00000000\n  CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n  GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\nuser pgtable: 4k pages, 48-bit VAs, pgdp=00000000858f3000\n[0000000000000000] pgd=0800000085918003, p4d=0800000085918003, pud=0800000085431003, pmd=0000000000000000\nInternal error: Oops: 0000000096000006 [#1] PREEMPT SMP\nModules linked in: tidss(-) display_connector lontium_lt8912b tc358768 panel_lvds panel_simple drm_dma_helper drm_kms_helper drm drm_panel_orientation_quirks\nCPU: 3 PID: 462 Comm: rmmod Tainted: G        W          6.5.0-rc2+ #2\nHardware name: Toradex Verdin AM62 on Verdin Development Board (DT)\npstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : drm_connector_cleanup+0x78\/0x2d4 [drm]\nlr : lt8912_bridge_detach+0x54\/0x6c [lontium_lt8912b]\nsp : ffff800082ed3a90\nx29: ffff800082ed3a90 x28: ffff0000040c1940 x27: 0000000000000000\nx26: 0000000000000000 x25: dead000000000122 x24: dead000000000122\nx23: dead000000000100 x22: ffff000003fb6388 x21: 0000000000000000\nx20: 0000000000000000 x19: ffff000003fb6260 x18: fffffffffffe56e8\nx17: 0000000000000000 x16: 0010000000000000 x15: 0000000000000038\nx14: 0000000000000000 x13: ffff800081914b48 x12: 000000000000040e\nx11: 000000000000015a x10: ffff80008196ebb8 x9 : ffff800081914b48\nx8 : 00000000ffffefff x7 : ffff0000040c1940 x6 : ffff80007aa649d0\nx5 : 0000000000000000 x4 : 0000000000000001 x3 : ffff80008159e008\nx2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000\nCall trace:\n drm_connector_cleanup+0x78\/0x2d4 [drm]\n lt8912_bridge_detach+0x54\/0x6c [lontium_lt8912b]\n drm_bridge_detach+0x44\/0x84 [drm]\n drm_encoder_cleanup+0x40\/0xb8 [drm]\n drmm_encoder_alloc_release+0x1c\/0x30 [drm]\n drm_managed_release+0xac\/0x148 [drm]\n drm_dev_put.part.0+0x88\/0xb8 [drm]\n devm_drm_dev_init_release+0x14\/0x24 [drm]\n devm_action_release+0x14\/0x20\n release_nodes+0x5c\/0x90\n devres_release_all+0x8c\/0xe0\n device_unbind_cleanup+0x18\/0x68\n device_release_driver_internal+0x208\/0x23c\n driver_detach+0x4c\/0x94\n bus_remove_driver+0x70\/0xf4\n driver_unregister+0x30\/0x60\n platform_driver_unregister+0x14\/0x20\n tidss_platform_driver_exit+0x18\/0xb2c [tidss]\n __arm64_sys_delete_module+0x1a0\/0x2b4\n invoke_syscall+0x48\/0x110\n el0_svc_common.constprop.0+0x60\/0x10c\n do_el0_svc_compat+0x1c\/0x40\n el0_svc_compat+0x40\/0xac\n el0t_32_sync_handler+0xb0\/0x138\n el0t_32_sync+0x194\/0x198\nCode: 9104a276 f2fbd5b7 aa0203e1 91008af8 (f85c0420)"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm\/bridge: lt8912b: soluciona el fallo al desconectar el puente. El controlador lt8912b, en su función de desconectar el puente, llama a drm_connector_unregister() y drm_connector_cleanup(). drm_connector_unregister() debe llamarse solo para conectores registrados explícitamente con drm_connector_register(), lo cual no es el caso en lt8912b. El gancho drm_connector_funcs.destroy del controlador está configurado en drm_connector_cleanup(). Por lo tanto, el controlador no debe llamar ni a drm_connector_unregister() ni a drm_connector_cleanup() en su lt8912_bridge_detach(), ya que causan un bloqueo al desconectar el puente: No se puede manejar la desreferencia del puntero NULL del núcleo en la dirección virtual 00000000000000000 Información de cancelación de memoria: ESR = 0x0000000096000006 EC = 0x25 : DABT (EL actual), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x06: fallo de traducción de nivel 2 Información de cancelación de datos: ISV = 0, ISS = 0x00000006, ISS2 = 0x00000000 CM = 0, WnR = 0, TnD = 0, TagAccess = 0 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 tabla de páginas de usuario: páginas de 4k, VA de 48 bits, pgdp=00000000858f3000 [0000000000000000000000000859180] 03, p4d =0800000085918003, pud=0800000085431003, pmd=0000000000000000 Error interno: Ups: 0000000096000006 [#1] Módulos SMP PREEMPT vinculados en: tidss(-) display_connector lontium_lt8912b tc35876 8 panel_lvds panel_simple drm_dma_helper drm_kms_helper drm drm_panel_orientation_quirks CPU: 3 PID: 462 Comunicaciones: rmmod Contaminado: GW 6.5.0-rc2+ #2 Nombre del hardware: Toradex Verdin AM62 en la placa de desarrollo Verdin (DT) pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc: drm_connector_cleanup+0x78\/0x2d4 [ drm] lr: lt8912_bridge_detach+0x54\/0x6c [lontium_lt8912b] sp: ffff800082ed3a90 x29: ffff800082ed3a90 x28: ffff0000040c1940 x27: 0000000000000000 x26: 00000000000 x25: dead000000000122 x24: dead000000000122 x23: dead000000000100 x22: ffff000003fb6388 x21: 0000000000000000 x20: 00000000000000000 x 19: ffff000003fb6260 x18: fffffffffffe56e8 x17: 0000000000000000 x16: 0010000000000000 x15: 0000000000000038 x14: 00000000000000000 x13: ffff800081914b48 x12: 0000000040e x11: 000000000000015a x10: ffff80008196ebb8 x9: ffff800081914b48 x8: 00000000fffffff x7: ffff0000040c1940 x6: ffff80007aa649d0 0000000000000000 x4: 0000000000000001 x3: ffff80008159e008 x2: 0000000000000000 x1 : 0000000000000000 x0 : 00000000000000000 Rastreo de llamadas: drm_connector_cleanup+0x78\/0x2d4 [drm] lt8912_bridge_detach+0x54\/0x6c [lontium_lt8912b] drm_bridge_detach+0x44\/0x84 [drm_encoder] _cleanup+0x40\/0xb8 [drm] drmm_encoder_alloc_release+0x1c\/0x30 [drm] drm_managed_release+ 0xac\/0x148 [drm] drm_dev_put.part.0+0x88\/0xb8 [drm] devm_drm_dev_init_release+0x14\/0x24 [drm] devm_action_release+0x14\/0x20 release_nodes+0x5c\/0x90 devres_release_all+0x8c\/0xe0 device_unbind_cleanup +0x18\/0x68 device_release_driver_internal+0x208\/ 0x23c driver_detach+0x4c\/0x94 bus_remove_driver+0x70\/0xf4 driver_unregister+0x30\/0x60 platform_driver_unregister+0x14\/0x20 tidss_platform_driver_exit+0x18\/0xb2c [tidss] __arm64_sys_delete_module+0x1a0\/0 x2b4 invoke_syscall+0x48\/0x110 el0_svc_common.constprop.0+0x60\/0x10c do_el0_svc_compat+ 0x1c\/0x40 el0_svc_compat+0x40\/0xac el0t_32_sync_handler+0xb0\/0x138 el0t_32_sync+0x194\/0x198 Código: 9104a276 f2fbd5b7 aa0203e1 91008af8 (f85c0420)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/42071feab712ba2a139b8928f7e0f8d3a6fc719e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/44283993144a03af9df31934d6c32bbd42d1a347","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7bf0cb8f40280a85034990dfe42be8ca8f80f37a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b65e3249f3ca96e3c736af889461d80d675feab6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fcd9895e365474709844eeb31cfe53d912c3596e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52857","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.803","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/mediatek: Fix coverity issue with unintentional integer overflow\n\n1. Instead of multiplying 2 variable of different types. Change to\nassign a value of one variable and then multiply the other variable.\n\n2. Add a int variable for multiplier calculation instead of calculating\ndifferent types multiplier with dma_addr_t variable directly."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0d8a1df39d3fc34560e2cc663b5c340d06a25396","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/96312a251d4dcee5d36e32edba3002bfde0ddd9c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0b0d811eac6b4c52cb9ad632fa6384cf48869e7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52858","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.867","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mediatek: clk-mt7629: Add check for mtk_alloc_clk_data\n\nAdd the check for the return value of mtk_alloc_clk_data() in order to\navoid NULL pointer dereference."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: mediatek: clk-mt7629: Agregar verificación para mtk_alloc_clk_data. Agregue la verificación para el valor de retorno de mtk_alloc_clk_data() para evitar la desreferencia al puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1d89430fc3158f872d492f1b88d07262f48290c0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2befa515c1bb6cdd33c262b909d93d1973a219aa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4f861b63945e076f9f003a5fad958174096df1ee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5fbea47eebff5daeca7d918c99289bcd3ae4dc8d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a836efc21ef04608333d6d05753e558ebd1f85d0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e8ae4b49dd9cfde69d8de8c0c0cd7cf1b004482e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e964d21dc034b650d719c4ea39564bec72b42f94","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52859","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:22.933","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nperf: hisi: Fix use-after-free when register pmu fails\n\nWhen we fail to register the uncore pmu, the pmu context may not been\nallocated. The error handing will call cpuhp_state_remove_instance()\nto call uncore pmu offline callback, which migrate the pmu context.\nSince that's liable to lead to some kind of use-after-free.\n\nUse cpuhp_state_remove_instance_nocalls() instead of\ncpuhp_state_remove_instance() so that the notifiers don't execute after\nthe PMU device has been failed to register."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: perf: hisi: corrige el use after free cuando falla el registro de pmu. Cuando no logramos registrar el pmu sin núcleo, es posible que no se haya asignado el contexto de pmu. El manejo del error llamará a cpuhp_state_remove_instance() para llamar a la devolución de llamada fuera de línea de uncore pmu, que migra el contexto de pmu. Dado que eso puede conducir a algún tipo de use after free. Utilice cpuhp_state_remove_instance_nocalls() en lugar de cpuhp_state_remove_instance() para que los notificadores no se ejecuten después de que el dispositivo PMU no haya podido registrarse."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0e1e88bba286621b886218363de07b319d6208b2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3405f364f82d4f5407a8b4c519dc15d24b847fda","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/75bab28ffd05ec8879c197890b1bd1dfec8d3f63","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b660420f449d094b1fabfa504889810b3a63cdd5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b805cafc604bfdb671fae7347a57f51154afa735","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52860","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.003","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers\/perf: hisi: use cpuhp_state_remove_instance_nocalls() for hisi_hns3_pmu uninit process\n\nWhen tearing down a 'hisi_hns3' PMU, we mistakenly run the CPU hotplug\ncallbacks after the device has been unregistered, leading to fireworks\nwhen we try to execute empty function callbacks within the driver:\n\n  | Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000\n  | CPU: 0 PID: 15 Comm: cpuhp\/0 Tainted: G        W  O      5.12.0-rc4+ #1\n  | Hardware name:  , BIOS KpxxxFPGA 1P B600 V143 04\/22\/2021\n  | pstate: 80400009 (Nzcv daif +PAN -UAO -TCO BTYPE=--)\n  | pc : perf_pmu_migrate_context+0x98\/0x38c\n  | lr : perf_pmu_migrate_context+0x94\/0x38c\n  |\n  | Call trace:\n  |  perf_pmu_migrate_context+0x98\/0x38c\n  |  hisi_hns3_pmu_offline_cpu+0x104\/0x12c [hisi_hns3_pmu]\n\nUse cpuhp_state_remove_instance_nocalls() instead of\ncpuhp_state_remove_instance() so that the notifiers don't execute after\nthe PMU device has been unregistered.\n\n[will: Rewrote commit message]"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drivers\/perf: hisi: use cpuhp_state_remove_instance_nocalls() para el proceso uninit hisi_hns3_pmu. Al derribar una PMU 'hisi_hns3', ejecutamos por error las devoluciones de llamadas de conexión en caliente de la CPU después de que el dispositivo haya sido anulado del registro, lo que lleva a a fuegos artificiales cuando intentamos ejecutar devoluciones de llamadas de funciones vacías dentro del controlador: | No se puede manejar la desreferencia del puntero NULL del kernel en la dirección virtual 0000000000000000 | CPU: 0 PID: 15 Comunicaciones: cpuhp\/0 Contaminado: GWO 5.12.0-rc4+ #1 | Nombre del hardware: , BIOS KpxxxFPGA 1P B600 V143 22\/04\/2021 | pstate: 80400009 (Nzcv daif +PAN -UAO -TCO BTYPE=--) | ordenador personal: perf_pmu_migrate_context+0x98\/0x38c | lr: perf_pmu_migrate_context+0x94\/0x38c | | Rastreo de llamadas: | perf_pmu_migrate_context+0x98\/0x38c | hisi_hns3_pmu_offline_cpu+0x104\/0x12c [hisi_hns3_pmu] Utilice cpuhp_state_remove_instance_nocalls() en lugar de cpuhp_state_remove_instance() para que los notificadores no se ejecuten después de que el dispositivo PMU haya sido anulado del registro. [will: reescribirá el mensaje de confirmación]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3f5827371763f2d9c70719c270055a81d030f3d0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4589403a343bb0c72a6faf5898386ff964d4e01a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/50b560783f7f71790bcf70e9e9855155fb0af8c1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d04ff5437a45f275db5530efb49b68d0ec851f6f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52861","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.073","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: bridge: it66121: Fix invalid connector dereference\n\nFix the NULL pointer dereference when no monitor is connected, and the\nsound card is opened from userspace.\n\nInstead return an empty buffer (of zeroes) as the EDID information to\nthe sound framework if there is no connector attached."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm: bridge: it66121: Corrige la desreferencia del conector no válido. Corrige la desreferencia del puntero NULL cuando no hay ningún monitor conectado y la tarjeta de sonido se abre desde el espacio de usuario. En su lugar, devuelva un búfer vacío (de ceros) como información EDID al sistema de sonido si no hay ningún conector conectado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1374561a7cbc9a000b77bb0473bb2c19daf18d86","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1669d7b21a664aa531856ce85b01359a376baebc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2c80c4f0d2845645f41cbb7c9304c8efbdbd4331","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d0375f6858c4ff7244b62b02eb5e93428e1916cd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52862","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.150","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amd\/display: Fix null pointer dereference in error message\n\nThis patch fixes a null pointer dereference in the error message that is\nprinted when the Display Core (DC) fails to initialize. The original\nmessage includes the DC version number, which is undefined if the DC is\nnot initialized."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: drm\/amd\/display: corrige la desreferencia del puntero null en el mensaje de error. Este parche corrige una desreferencia del puntero null en el mensaje de error que se imprime cuando el Display Core (DC) no se inicializa. El mensaje original incluye el número de versión del DC, que no está definido si el DC no está inicializado."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0c3601a2fbfb265ce283651480e30c8e60459112","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8b72c5d4a5d25e76b16283397c40b8b3c0d70019","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/97ef07182ac46b069bb5e7d46cb903a764d67898","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52863","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.233","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (axi-fan-control) Fix possible NULL pointer dereference\n\naxi_fan_control_irq_handler(), dependent on the private\naxi_fan_control_data structure, might be called before the hwmon\ndevice is registered. That will cause an \"Unable to handle kernel\nNULL pointer dereference\" error."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: hwmon: (axi-fan-control) Se corrigió la posible desreferencia del puntero NULL. Se podría llamar a axi_fan_control_irq_handler(), dependiente de la estructura privada axi_fan_control_data, antes de que se registre el dispositivo hwmon. Esto provocará el error \"No se puede manejar la desreferencia del puntero NULL del kernel\"."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2a5b3370a1d9750eca325292e291c8c7cb8cf2e0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/33de53a2706066d526173dc743faf43d92c62105","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7d870088db4863c514a7f8751cd593751983029a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b3e7eb23a6e97642ff3190431c06475d9ca1e062","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c49f14cc1bb12c625a1c572e8a95b6adefd4d8eb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f62b8969847850ba7596cb145cc47c65ea57dae0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52864","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.317","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nplatform\/x86: wmi: Fix opening of char device\n\nSince commit fa1f68db6ca7 (\"drivers: misc: pass miscdevice pointer via\nfile private data\"), the miscdevice stores a pointer to itself inside\nfilp->private_data, which means that private_data will not be NULL when\nwmi_char_open() is called. This might cause memory corruption should\nwmi_char_open() be unable to find its driver, something which can\nhappen when the associated WMI device is deleted in wmi_free_devices().\n\nFix the problem by using the miscdevice pointer to retrieve the WMI\ndevice data associated with a char device using container_of(). This\nalso avoids wmi_char_open() picking a wrong WMI device bound to a\ndriver with the same name as the original driver."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: plataforma\/x86: wmi: corrige la apertura del dispositivo char. Desde la confirmación fa1f68db6ca7 (\"drivers: misc: pasar el puntero del dispositivo misc a través de datos privados del archivo\"), el dispositivo misc almacena un puntero a sí mismo en su interior. filp-&gt;private_data, lo que significa que private_data no será NULL cuando se llame a wmi_char_open(). Esto podría causar daños en la memoria si wmi_char_open() no puede encontrar su controlador, algo que puede suceder cuando el dispositivo WMI asociado se elimina en wmi_free_devices(). Solucione el problema utilizando el puntero miscdevice para recuperar los datos del dispositivo WMI asociados con un dispositivo char usando container_of(). Esto también evita que wmi_char_open() seleccione un dispositivo WMI incorrecto vinculado a un controlador con el mismo nombre que el controlador original."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/36d85fa7ae0d6be651c1a745191fa7ef055db43e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/44a96796d25809502c75771d40ee693c2e44724e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9fb0eed09e1470cd4021ff52b2b9dfcbcee4c203","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cf098e937dd125c0317a0d6f261ac2a950a233d6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d426a2955e45a95b2282764105fcfb110a540453","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e0bf076b734a2fab92d8fddc2b8b03462eee7097","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eba9ac7abab91c8f6d351460239108bef5e7a0b6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fb7b06b59c6887659c6ed0ecd3110835eecbb6a3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52865","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.403","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mediatek: clk-mt6797: Add check for mtk_alloc_clk_data\n\nAdd the check for the return value of mtk_alloc_clk_data() in order to\navoid NULL pointer dereference."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: mediatek: clk-mt6797: Agregar verificación para mtk_alloc_clk_data Agregue la verificación para el valor de retorno de mtk_alloc_clk_data() para evitar la desreferencia al puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/122ac6496e4975ddd7ec1edba4f6fc1e15e39478","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2705c5b97f504e831ae1935c05f0e44f80dfa6b3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/357df1c2f6ace96defd557fad709ed1f9f70e16c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3aefc6fcfbada57fac27f470602d5565e5b76cb4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4c79cbfb8e9e2311be77182893fda5ea4068c836","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/606f6366a35a3329545e38129804d65ef26ed7d2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/81b16286110728674dcf81137be0687c5055e7bf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/be3f12f16038a558f08fa93cc32fa715746a5235","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c26feedbc561f2a3cee1a4f717e61bdbdfb4fa92","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52866","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.480","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nHID: uclogic: Fix user-memory-access bug in uclogic_params_ugee_v2_init_event_hooks()\n\nWhen CONFIG_HID_UCLOGIC=y and CONFIG_KUNIT_ALL_TESTS=y, launch kernel and\nthen the below user-memory-access bug occurs.\n\nIn hid_test_uclogic_params_cleanup_event_hooks(),it call\nuclogic_params_ugee_v2_init_event_hooks() with the first arg=NULL, so\nwhen it calls uclogic_params_ugee_v2_has_battery(), the hid_get_drvdata()\nwill access hdev->dev with hdev=NULL, which will cause below\nuser-memory-access.\n\nSo add a fake_device with quirks member and call hid_set_drvdata()\nto assign hdev->dev->driver_data which avoids the null-ptr-def bug\nfor drvdata->quirks in uclogic_params_ugee_v2_has_battery(). After applying\nthis patch, the below user-memory-access bug never occurs.\n\n general protection fault, probably for non-canonical address 0xdffffc0000000329: 0000 [#1] PREEMPT SMP KASAN\n KASAN: probably user-memory-access in range [0x0000000000001948-0x000000000000194f]\n CPU: 5 PID: 2189 Comm: kunit_try_catch Tainted: G    B   W        N 6.6.0-rc2+ #30\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04\/01\/2014\n RIP: 0010:uclogic_params_ugee_v2_init_event_hooks+0x87\/0x600\n Code: f3 f3 65 48 8b 14 25 28 00 00 00 48 89 54 24 60 31 d2 48 89 fa c7 44 24 30 00 00 00 00 48 c7 44 24 28 02 f8 02 01 48 c1 ea 03 <80> 3c 02 00 0f 85 2c 04 00 00 48 8b 9d 48 19 00 00 48 b8 00 00 00\n RSP: 0000:ffff88810679fc88 EFLAGS: 00010202\n RAX: dffffc0000000000 RBX: 0000000000000004 RCX: 0000000000000000\n RDX: 0000000000000329 RSI: ffff88810679fd88 RDI: 0000000000001948\n RBP: 0000000000000000 R08: 0000000000000000 R09: ffffed1020f639f0\n R10: ffff888107b1cf87 R11: 0000000000000400 R12: 1ffff11020cf3f92\n R13: ffff88810679fd88 R14: ffff888100b97b08 R15: ffff8881030bb080\n FS:  0000000000000000(0000) GS:ffff888119e80000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 0000000005286001 CR4: 0000000000770ee0\n DR0: ffffffff8fdd6cf4 DR1: ffffffff8fdd6cf5 DR2: ffffffff8fdd6cf6\n DR3: ffffffff8fdd6cf7 DR6: 00000000fffe0ff0 DR7: 0000000000000600\n PKRU: 55555554\n Call Trace:\n  <TASK>\n  ? die_addr+0x3d\/0xa0\n  ? exc_general_protection+0x144\/0x220\n  ? asm_exc_general_protection+0x22\/0x30\n  ? uclogic_params_ugee_v2_init_event_hooks+0x87\/0x600\n  ? sched_clock_cpu+0x69\/0x550\n  ? uclogic_parse_ugee_v2_desc_gen_params+0x70\/0x70\n  ? load_balance+0x2950\/0x2950\n  ? rcu_trc_cmpxchg_need_qs+0x67\/0xa0\n  hid_test_uclogic_params_cleanup_event_hooks+0x9e\/0x1a0\n  ? uclogic_params_ugee_v2_init_event_hooks+0x600\/0x600\n  ? __switch_to+0x5cf\/0xe60\n  ? migrate_enable+0x260\/0x260\n  ? __kthread_parkme+0x83\/0x150\n  ? kunit_try_run_case_cleanup+0xe0\/0xe0\n  kunit_generic_run_threadfn_adapter+0x4a\/0x90\n  ? kunit_try_catch_throw+0x80\/0x80\n  kthread+0x2b5\/0x380\n  ? kthread_complete_and_exit+0x20\/0x20\n  ret_from_fork+0x2d\/0x70\n  ? kthread_complete_and_exit+0x20\/0x20\n  ret_from_fork_asm+0x11\/0x20\n  <\/TASK>\n Modules linked in:\n Dumping ftrace buffer:\n    (ftrace buffer empty)\n ---[ end trace 0000000000000000 ]---\n RIP: 0010:uclogic_params_ugee_v2_init_event_hooks+0x87\/0x600\n Code: f3 f3 65 48 8b 14 25 28 00 00 00 48 89 54 24 60 31 d2 48 89 fa c7 44 24 30 00 00 00 00 48 c7 44 24 28 02 f8 02 01 48 c1 ea 03 <80> 3c 02 00 0f 85 2c 04 00 00 48 8b 9d 48 19 00 00 48 b8 00 00 00\n RSP: 0000:ffff88810679fc88 EFLAGS: 00010202\n RAX: dffffc0000000000 RBX: 0000000000000004 RCX: 0000000000000000\n RDX: 0000000000000329 RSI: ffff88810679fd88 RDI: 0000000000001948\n RBP: 0000000000000000 R08: 0000000000000000 R09: ffffed1020f639f0\n R10: ffff888107b1cf87 R11: 0000000000000400 R12: 1ffff11020cf3f92\n R13: ffff88810679fd88 R14: ffff888100b97b08 R15: ffff8881030bb080\n FS:  0000000000000000(0000) GS:ffff888119e80000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 0000000005286001 CR4: 0000000000770ee0\n DR0: ffffffff8fdd6cf4 DR1: \n---truncated---"},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: HID: uclogic: corrige el error de acceso a la memoria del usuario en uclogic_params_ugee_v2_init_event_hooks(). Cuando CONFIG_HID_UCLOGIC=y y CONFIG_KUNIT_ALL_TESTS=y, inicia el kernel y luego ocurre el siguiente error de acceso a la memoria del usuario. En hid_test_uclogic_params_cleanup_event_hooks(), llama a uclogic_params_ugee_v2_init_event_hooks() con el primer argumento = NULL, por lo que cuando llama a uclogic_params_ugee_v2_has_battery(), hid_get_drvdata() accederá a hdev-&gt;dev con hdev=NULL, lo que provocará el siguiente acceso a la memoria del usuario. Así que agregue un miembro fake_device con peculiaridades y llame a hid_set_drvdata() para asignar hdev-&gt;dev-&gt;driver_data, lo que evita el error null-ptr-def para drvdata-&gt;quirks en uclogic_params_ugee_v2_has_battery(). Después de aplicar este parche, el siguiente error de acceso a la memoria del usuario nunca ocurre. falla de protección general, probablemente para dirección no canónica 0xdffffc0000000329: 0000 [#1] PREEMPT SMP KASAN KASAN: probablemente acceso a memoria de usuario en el rango [0x0000000000001948-0x000000000000194f] CPU: 5 PID: 2189 Comm: kunit_try_catch Tainted: GBWN 6.6.0 -rc2+ #30 Nombre del hardware: PC estándar QEMU (i440FX + PIIX, 1996), BIOS 1.15.0-1 01\/04\/2014 RIP: 0010:uclogic_params_ugee_v2_init_event_hooks+0x87\/0x600 Código: f3 f3 65 48 8b 14 25 28 00 0 00 48 89 54 24 60 31 d2 48 89 fa c7 44 24 30 00 00 00 00 48 c7 44 24 28 02 f8 02 01 48 c1 ea 03 &lt;80&gt; 3c 02 00 0f 85 2c 04 00 00 48 8b 9d 48 19 00 00 48 b8 00 00 00 RSP: 0000:ffff88810679fc88 EFLAGS: 00010202 RAX: dffffc0000000000 RBX: 00000000000000004 RCX: 0000000000000000 RDX: 000000 0000000329 RSI: ffff88810679fd88 RDI: 0000000000001948 RBP: 0000000000000000 R08: 0000000000000000 R09: ffffed1020f639f0 R10: ffff888107b1cf8 7 R11: 0000000000000400 R12: 1ffff11020cf3f92 R13: ffff88810679fd88 R14: ffff888100b97b08 R15: ffff8881030bb080 FS: 0000000000000000(0000) GS:ffff888119e80000(0000) knlGS:00000000000000 00 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 0000000005286001 CR4: 0000000000770ee0 DR0: ffffffff8fdd6cf4 DR1: ffffffff8fdd6cf5 DR2: ffffffff8fdd6cf6 DR3: ffffffff8fdd6cf7 DR6: 00000000fffe0ff0 DR7: 00000000000000600 PKRU: 55555554 Seguimiento de llamadas: ? die_addr+0x3d\/0xa0? exc_general_protection+0x144\/0x220? asm_exc_general_protection+0x22\/0x30? uclogic_params_ugee_v2_init_event_hooks+0x87\/0x600? sched_clock_cpu+0x69\/0x550? uclogic_parse_ugee_v2_desc_gen_params+0x70\/0x70 ? load_balance+0x2950\/0x2950? rcu_trc_cmpxchg_need_qs+0x67\/0xa0 hid_test_uclogic_params_cleanup_event_hooks+0x9e\/0x1a0 ? uclogic_params_ugee_v2_init_event_hooks+0x600\/0x600? __switch_to+0x5cf\/0xe60 ? migrar_enable+0x260\/0x260? __kthread_parkme+0x83\/0x150 ? kunit_try_run_case_cleanup+0xe0\/0xe0 kunit_generic_run_threadfn_adapter+0x4a\/0x90 ? kunit_try_catch_throw+0x80\/0x80 kthread+0x2b5\/0x380 ? kthread_complete_and_exit+0x20\/0x20 ret_from_fork+0x2d\/0x70 ? kthread_complete_and_exit+0x20\/0x20 ret_from_fork_asm+0x11\/0x20  Módulos vinculados en: Dumping ftrace buffer: (ftrace buffer vacío) ---[ end trace 0000000000000000 ]--- RIP: uclogic_params_ugee_v2_init_event_hooks+0x 87\/0x600 Código: f3 f3 65 48 8b 14 25 28 00 00 00 48 89 54 24 60 31 d2 48 89 fa c7 44 24 30 00 00 00 00 48 c7 44 24 28 02 f8 02 01 48 c1 ea 03 &lt;80&gt; 3c 2 00 0f 85 2c 04 00 00 48 8b 9d 48 19 00 00 48 b8 00 00 00 RSP: 0000:ffff88810679fc88 EFLAGS: 00010202 RAX: dffffc0000000000 RBX: 0000000000000004 RCX: 0000000000000000 RDX: 0000000000000329 RSI: ffff88810679fd88 RDI: 0000000000001948 RBP: 00000000000000000 R08: 0000000000000000 R09: 1020f639f0 R10: ffff888107b1cf87 R11: 0000000000000400 R12: 1ffff11020cf3f92 R13: ffff88810679fd88 R14: ffff888100b97b08 R15: ffff8881030bb080 FS: 0000000000(0000) GS:ffff888119e80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 0000000005286001 CR4: 0000000000770ee0 DR0: ffffffff8fdd6cf4 DR1: ---truncado---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/64da1f6147dac7f8499d4937a0d7ea990bf569e8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6c8f953728d75104d994893f58801c457274335a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/91cfe0bbaa1c434d4271eb6e1d7aaa1fe8d121f6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52867","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.597","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/radeon: possible buffer overflow\n\nBuffer 'afmt_status' of size 6 could overflow, since index 'afmt_idx' is\nchecked after access."},{"lang":"es","value":" En el kernel de Linux se ha resuelto la siguiente vulnerabilidad: drm\/radeon: posible desbordamiento del búfer. El búfer 'afmt_status' de tamaño 6 podría desbordarse, ya que el índice 'afmt_idx' se comprueba después del acceso."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/112d4b02d94bf9fa4f1d3376587878400dd74783","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/19534a7a225f1bf2da70a9a90d41d0215f8f6b45","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/341e79f8aec6af6b0061b8171d77b085835c6a58","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/347f025a02b3a5d715a0b471fc3b1439c338ad94","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7b063c93bece827fde237fae1c101bceeee4e896","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/caaa74541459c4c9e2c10046cf66ad2890483d0f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d9b4fa249deaae1145d6fc2b64dae718e5c7a855","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dd05484f99d16715a88eedfca363828ef9a4c2d4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ddc42881f170f1f518496f5a70447501335fc783","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52868","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.673","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nthermal: core: prevent potential string overflow\n\nThe dev->id value comes from ida_alloc() so it's a number between zero\nand INT_MAX.  If it's too high then these sprintf()s will overflow."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: térmica: núcleo: evita un posible desbordamiento de cadenas. El valor dev-&gt;id proviene de ida_alloc(), por lo que es un número entre cero e INT_MAX. Si es demasiado alto, estos sprintf()s se desbordarán."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0f6b3be28c4d62ef6498133959c72266629bea97","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3091ab943dfc7b2578599b0fe203350286fab5bb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3a8f4e58e1ee707b4f46a1000b40b86ea3dd509c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3f795fb35c2d8a637efe76b4518216c9319b998c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6ad1bf47fbe5750c4d5d8e41337665e193e2c521","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/77ff34a56b695e228e6daf30ee30be747973d6e8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b55f0a9f865be75ca1019aad331f3225f7b50ce8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c99626092efca3061b387043d4a7399bf75fbdd5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/edbd6bbe40ac524a8f2273ffacc53edf14f3c686","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52869","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.750","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npstore\/platform: Add check for kstrdup\n\nAdd check for the return value of kstrdup() and return the error\nif it fails in order to avoid NULL pointer dereference."},{"lang":"es","value":" En el kernel de Linux, se resolvió la siguiente vulnerabilidad: pstore\/platform: Agregar verificación para kstrdup. Agregue verificación para el valor de retorno de kstrdup() y devuelva el error si falla para evitar la desreferencia del puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1c426da79f9fc7b761021b5eb44185ba119cd44a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/379b120e4f27fd1cf636a5f85570c4d240a3f688","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/63f637309baadf81a095f2653e3b807d4b5814b9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a19d48f7c5d57c0f0405a7d4334d1d38fe9d3c1c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad5cb6deb41417ef41b9d6ff54f789212108606f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bb166bdae1a7d7db30e9be7e6ccaba606debc05f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52870","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.833","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mediatek: clk-mt6765: Add check for mtk_alloc_clk_data\n\nAdd the check for the return value of mtk_alloc_clk_data() in order to\navoid NULL pointer dereference."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: mediatek: clk-mt6765: Agregar verificación para mtk_alloc_clk_data. Agregue la verificación para el valor de retorno de mtk_alloc_clk_data() para evitar la desreferencia al puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/10cc81124407d862f0f747db4baa9c006510b480","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2617aa8ceaf30e41d3eb7f5fef3445542bef193a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/533ca5153ad6c7b7d47ae0114b14d0333964b946","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b5ff3e89b4e7f46ad2aa0de7e08d18e6f87d71bc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b82681042724924ae3ba0f2f2eeec217fa31e830","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dd1f30d68fa98eb672c0a259297b761656a9025f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52871","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.907","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nsoc: qcom: llcc: Handle a second device without data corruption\n\nUsually there is only one llcc device. But if there were a second, even\na failed probe call would modify the global drv_data pointer. So check\nif drv_data is valid before overwriting it."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: soc: qcom: llcc: Manejar un segundo dispositivo sin corrupción de datos. Generalmente solo hay un dispositivo llcc. Pero si hubiera un segundo, incluso una llamada de sonda fallida modificaría el puntero global drv_data. Así que verifique si drv_data es válido antes de sobrescribirlo."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1143bfb9b055897975aeaea254da148e19524493","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3565684309e54fa998ea27f37028d67cc3e1dff2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5e5b85ea0f4bc484bfe4cc73ead51fa48d2366a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/995ee1e84e8db7fa5dcdde7dfe0bd7bb6f9bbb8c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cc1a1dcb411fe224f48553cfdcdfe6e61395b69c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f0ef883cae309bc5e8cdfcdbc1b4822732ce20a8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f1a1bc8775b26345aba2be278118999e7f661d3d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52872","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:23.990","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntty: n_gsm: fix race condition in status line change on dead connections\n\ngsm_cleanup_mux() cleans up the gsm by closing all DLCIs, stopping all\ntimers, removing the virtual tty devices and clearing the data queues.\nThis procedure, however, may cause subsequent changes of the virtual modem\nstatus lines of a DLCI. More data is being added the outgoing data queue\nand the deleted kick timer is restarted to handle this. At this point many\nresources have already been removed by the cleanup procedure. Thus, a\nkernel panic occurs.\n\nFix this by proving in gsm_modem_update() that the cleanup procedure has\nnot been started and the mux is still alive.\n\nNote that writing to a virtual tty is already protected by checks against\nthe DLCI specific connection state."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tty: n_gsm: corrige la condición de ejecución en la línea de estado, cambia en conexiones inactivas gsm_cleanup_mux() limpia el gsm cerrando todos los DLCI, deteniendo todos los temporizadores, eliminando los dispositivos tty virtuales y limpiando el colas de datos. Sin embargo, este procedimiento puede provocar cambios posteriores en las líneas de estado del módem virtual de un DLCI. Se agregan más datos a la cola de datos salientes y el temporizador de eliminación eliminado se reinicia para manejar esto. En este punto, el procedimiento de limpieza ya ha eliminado muchos recursos. Por tanto, se produce un pánico en el núcleo. Solucione este problema demostrando en gsm_modem_update() que el procedimiento de limpieza no se ha iniciado y que el mux sigue activo. Tenga en cuenta que la escritura en un tty virtual ya está protegida mediante comprobaciones del estado de conexión específico de DLCI."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/19d34b73234af542cc8a218cf398dee73cdb1890","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3a75b205de43365f80a33b98ec9289785da56243","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/81a4dd5e6c78f5d8952fa8c9d36565db1fe01444","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ce4df90333c4fe65acb8b5089fdfe9b955ce976a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df6cfab66ff2a44bd23ad5dd5309cb3421bb6593","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52873","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:24.080","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mediatek: clk-mt6779: Add check for mtk_alloc_clk_data\n\nAdd the check for the return value of mtk_alloc_clk_data() in order to\navoid NULL pointer dereference."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: mediatek: clk-mt6779: Agregar verificación para mtk_alloc_clk_data. Agregue la verificación para el valor de retorno de mtk_alloc_clk_data() para evitar la desreferencia al puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1f57f78fbacf630430bf954e5a84caafdfea30c0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3994387ba3564976731179c4d4a6d7850ddda71a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a90239551abc181687f8c0ba60b276f7d75c141e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ca6d565a2319d69d9766e6ecbb5af827fc4afb2b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df1c4a9efa3f5b6fb5e0ae63890230dbe2190b7e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f6a7c51cf07a399ec067d39f0a22f1817c5c7d2b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fbe466f06d4ea18745da0d57540539b7b36936ae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52874","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:24.157","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nx86\/tdx: Zero out the missing RSI in TDX_HYPERCALL macro\n\nIn the TDX_HYPERCALL asm, after the TDCALL instruction returns from the\nuntrusted VMM, the registers that the TDX guest shares to the VMM need\nto be cleared to avoid speculative execution of VMM-provided values.\n\nRSI is specified in the bitmap of those registers, but it is missing\nwhen zeroing out those registers in the current TDX_HYPERCALL.\n\nIt was there when it was originally added in commit 752d13305c78\n(\"x86\/tdx: Expand __tdx_hypercall() to handle more arguments\"), but was\nlater removed in commit 1e70c680375a (\"x86\/tdx: Do not corrupt\nframe-pointer in __tdx_hypercall()\"), which was correct because %rsi is\nlater restored in the \"pop %rsi\".  However a later commit 7a3a401874be\n(\"x86\/tdx: Drop flags from __tdx_hypercall()\") removed that \"pop %rsi\"\nbut forgot to add the \"xor %rsi, %rsi\" back.\n\nFix by adding it back."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: x86\/tdx: Ponga a cero el RSI que falta en la macro TDX_HYPERCALL. En el conjunto TDX_HYPERCALL, después de que la instrucción TDCALL regresa del VMM que no es de confianza, los registros que el invitado TDX comparte con el VMM necesitan debe borrarse para evitar la ejecución especulativa de los valores proporcionados por VMM. RSI se especifica en el mapa de bits de esos registros, pero falta al poner a cero esos registros en el TDX_HYPERCALL actual. Estaba allí cuando se agregó originalmente en la confirmación 752d13305c78 (\"x86\/tdx: Expand__tdx_hypercall() to handle more arguments\"), pero luego se eliminó en la confirmación 1e70c680375a (\"x86\/tdx: Do not corrupt frame-pointer in __tdx_hypercall( )\"), lo cual era correcto porque %rsi se restaura posteriormente en el \"pop %rsi\". Sin embargo, una confirmación posterior 7a3a401874be (\"x86\/tdx: Drop flags from __tdx_hypercall()\") eliminó ese \"pop %rsi\" pero olvidó volver a agregar \"xor %rsi, %rsi\". Solucionadlo volviéndolo a agregar."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2191950d35d8f81620ea8d4e04d983f664fe3a8a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5d092b66119d774853cc9308522620299048a662","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/de4c5bacca4f50233f1f791bec9eeb4dee1b14cd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52875","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:24.227","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mediatek: clk-mt2701: Add check for mtk_alloc_clk_data\n\nAdd the check for the return value of mtk_alloc_clk_data() in order to\navoid NULL pointer dereference."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: mediatek: clk-mt2701: Agregar verificación para mtk_alloc_clk_data. Agregue la verificación para el valor de retorno de mtk_alloc_clk_data() para evitar la desreferencia al puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/001e5def774fa1a8f2b29567c0b0cd3e3a859a96","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0d6e24b422a2166a9297a8286ff2e6ab9a5e8cd3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1953e62366da5460dc712e045f94fb0d8918999d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1bf9c204aef4cc55ce46a7ff2d4dc7e5f86551a7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2a18dd653284550900b02107c3c7b3ac5e0eb802","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6fccee2af400edaed9cf349d506c5971d4762739","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d1175cf4bd2b4c5f7c43f677ea1ce9ad2c18d055","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d1461f0c9ca0827c03730fe9652ebbf6316a2a95","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e61934720af4a58ffd43a63ffdd6f3a0bd7d7b47","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52876","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:24.297","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mediatek: clk-mt7629-eth: Add check for mtk_alloc_clk_data\n\nAdd the check for the return value of mtk_alloc_clk_data() in order to\navoid NULL pointer dereference."},{"lang":"es","value":" En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: clk: mediatek: clk-mt7629-eth: Agregar verificación para mtk_alloc_clk_data. Agregue la verificación para el valor de retorno de mtk_alloc_clk_data() para evitar la desreferencia al puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0884393c63cc9a1772f7121a6645ba7bd76feeb9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1639072f6260babd017556e9f236ca2ad589d1e7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/96e9544a0c4faca616b3f9f4034dcd83a14e7f22","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a540ca0aeae83c2f3964bcb4e383f64ce2ec1783","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b20cfe007a46f8c165d42a05c50a8d3d893e6592","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c4070ada5d5155c8d4d17ea64bd246949889f25b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cfa68e0ac5dcde43577adadf6f0f26f3b365ad68","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52877","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:24.377","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: tcpm: Fix NULL pointer dereference in tcpm_pd_svdm()\n\nIt is possible that typec_register_partner() returns ERR_PTR on failure.\nWhen port->partner is an error, a NULL pointer dereference may occur as\nshown below.\n\n[91222.095236][  T319] typec port0: failed to register partner (-17)\n...\n[91225.061491][  T319] Unable to handle kernel NULL pointer dereference\nat virtual address 000000000000039f\n[91225.274642][  T319] pc : tcpm_pd_data_request+0x310\/0x13fc\n[91225.274646][  T319] lr : tcpm_pd_data_request+0x298\/0x13fc\n[91225.308067][  T319] Call trace:\n[91225.308070][  T319]  tcpm_pd_data_request+0x310\/0x13fc\n[91225.308073][  T319]  tcpm_pd_rx_handler+0x100\/0x9e8\n[91225.355900][  T319]  kthread_worker_fn+0x178\/0x58c\n[91225.355902][  T319]  kthread+0x150\/0x200\n[91225.355905][  T319]  ret_from_fork+0x10\/0x30\n\nAdd a check for port->partner to avoid dereferencing a NULL pointer."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: typec: tcpm: corrige la desreferencia del puntero NULL en tcpm_pd_svdm(). Es posible que typec_register_partner() devuelva ERR_PTR en caso de fallo. Cuando port-&gt;partner es un error, puede ocurrir una desreferencia de puntero NULL como se muestra a continuación. [91222.095236][T319] typec port0: no se pudo registrar el socio (-17)... [91225.061491][T319] No se puede manejar la desreferencia del puntero NULL del kernel en la dirección virtual 000000000000039f [91225.274642][T319] pc: tcpm_pd_data_request+0x310 \/0x13fc [91225.274646][ T319] lr: tcpm_pd_data_request+0x298\/0x13fc [91225.308067][ T319] Rastreo de llamadas: [91225.308070][ T319] tcpm_pd_data_request+0x310\/0x13fc 3][T319] tcpm_pd_rx_handler+0x100\/0x9e8 [91225.355900][T319] kthread_worker_fn+0x178\/0x58c [91225.355902][ T319] kthread+0x150\/0x200 [91225.355905][ T319] ret_from_fork+0x10\/0x30 Agregue una verificación de port-&gt;partner para evitar desreferenciar un puntero NULL."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4987daf86c152ff882d51572d154ad12e4ff3a4b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9ee038590d808a95d16adf92818dcd4752273c08","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b37a168c0137156042a0ca9626651b5a789e822b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e5f53a68a596e04df3fde3099273435a30b6fdac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e7a802447c491903aa7cb45967aa2a934a4e63fc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52878","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:24.450","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncan: dev: can_put_echo_skb(): don't crash kernel if can_priv::echo_skb is accessed out of bounds\n\nIf the \"struct can_priv::echoo_skb\" is accessed out of bounds, this\nwould cause a kernel crash. Instead, issue a meaningful warning\nmessage and return with an error."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: can: dev: can_put_echo_skb(): no bloquee el kernel si se accede a can_priv::echo_skb fuera de los límites. Si se accede a \"struct can_priv::echoo_skb\" fuera de los límites, esto provocaría un fallo del kernel. En su lugar, emita un mensaje de advertencia significativo y regrese con un error."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0d30931f1fa0fb893fb7d5dc32b6b7edfb775be4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/53c468008a7c9ca3f5fc985951f35ec2acae85bc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6411959c10fe917288cbb1038886999148560057","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/826120c9ba68f2d0dbae58e99013929c883d1444","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8ab67da060157362b2e0926692c659808784708f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2023-52879","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-21T16:15:24.530","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Have trace_event_file have ref counters\n\nThe following can crash the kernel:\n\n # cd \/sys\/kernel\/tracing\n # echo 'p:sched schedule' > kprobe_events\n # exec 5>>events\/kprobes\/sched\/enable\n # > kprobe_events\n # exec 5>&-\n\nThe above commands:\n\n 1. Change directory to the tracefs directory\n 2. Create a kprobe event (doesn't matter what one)\n 3. Open bash file descriptor 5 on the enable file of the kprobe event\n 4. Delete the kprobe event (removes the files too)\n 5. Close the bash file descriptor 5\n\nThe above causes a crash!\n\n BUG: kernel NULL pointer dereference, address: 0000000000000028\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP PTI\n CPU: 6 PID: 877 Comm: bash Not tainted 6.5.0-rc4-test-00008-g2c6b6b1029d4-dirty #186\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04\/01\/2014\n RIP: 0010:tracing_release_file_tr+0xc\/0x50\n\nWhat happens here is that the kprobe event creates a trace_event_file\n\"file\" descriptor that represents the file in tracefs to the event. It\nmaintains state of the event (is it enabled for the given instance?).\nOpening the \"enable\" file gets a reference to the event \"file\" descriptor\nvia the open file descriptor. When the kprobe event is deleted, the file is\nalso deleted from the tracefs system which also frees the event \"file\"\ndescriptor.\n\nBut as the tracefs file is still opened by user space, it will not be\ntotally removed until the final dput() is called on it. But this is not\ntrue with the event \"file\" descriptor that is already freed. If the user\ndoes a write to or simply closes the file descriptor it will reference the\nevent \"file\" descriptor that was just freed, causing a use-after-free bug.\n\nTo solve this, add a ref count to the event \"file\" descriptor as well as a\nnew flag called \"FREED\". The \"file\" will not be freed until the last\nreference is released. But the FREE flag will be set when the event is\nremoved to prevent any more modifications to that event from happening,\neven if there's still a reference to the event \"file\" descriptor."},{"lang":"es","value":"En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: rastreo: Tener trace_event_file tiene contadores de referencia. Lo siguiente puede bloquear el kernel: # cd \/sys\/kernel\/tracing # echo 'p:sched Schedule' &gt; kprobe_events # exec 5&gt;&gt;events \/kprobes\/sched\/enable # &gt; kprobe_events # exec 5&gt;&amp;- Los comandos anteriores: 1. Cambie el directorio al directorio tracefs 2. Cree un evento kprobe (no importa cuál) 3. Abra el descriptor de archivo bash 5 en el habilitar el archivo del evento kprobe 4. Eliminar el evento kprobe (también elimina los archivos) 5. Cerrar el descriptor del archivo bash 5 ¡Lo anterior provoca un bloqueo! BUG: desreferencia del puntero NULL del kernel, dirección: 0000000000000028 #PF: acceso de lectura del supervisor en modo kernel #PF: código_error(0x0000) - página no presente PGD 0 P4D 0 Ups: 0000 [#1] PREEMPT SMP PTI CPU: 6 PID: 877 Comm: bash Not tainted 6.5.0-rc4-test-00008-g2c6b6b1029d4-dirty #186 Nombre del hardware: PC estándar QEMU (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04\/01 \/2014 RIP: 0010:tracing_release_file_tr+0xc\/0x50. Lo que sucede aquí es que el evento kprobe crea un descriptor de \"archivo\" trace_event_file que representa el archivo en tracefs hasta el evento. Mantiene el estado del evento (¿está habilitado para la instancia dada?). Al abrir el archivo \"habilitar\" se obtiene una referencia al descriptor de \"archivo\" del evento a través del descriptor de archivo abierto. Cuando se elimina el evento kprobe, el archivo también se elimina del sistema tracefs, lo que también libera el descriptor de \"archivo\" del evento. Pero como el espacio del usuario todavía abre el archivo tracefs, no se eliminará por completo hasta que se llame al dput() final. Pero esto no es cierto con el descriptor de \"archivo\" de evento que ya está liberado. Si el usuario escribe o simplemente cierra el descriptor de archivo, hará referencia al descriptor de \"archivo\" del evento que acaba de liberarse, lo que provocará un error de uso después de la liberación. Para resolver esto, agregue un recuento de referencias al descriptor de \"archivo\" del evento, así como una nueva bandera llamada \"FREED\". El \"archivo\" no se liberará hasta que se publique la última referencia. Pero el indicador FREE se establecerá cuando se elimine el evento para evitar que se realicen más modificaciones en ese evento, incluso si todavía hay una referencia al descriptor de \"archivo\" del evento."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2c9de867ca285c397cd71af703763fe416265706","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2fa74d29fc1899c237d51bf9a6e132ea5c488976","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9034c87d61be8cff989017740a91701ac8195a1d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/961c4511c7578d6b8f39118be919016ec3db1c1e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a98172e36e5f1b3d29ad71fade2d611cfcc2fe6f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bb32500fb9b78215e4ef6ee8b4345c5f5d7eafb4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cbc7c29dff0fa18162f2a3889d82eeefd67305e0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-1721","sourceIdentifier":"security@hypr.com","published":"2024-05-21T16:15:24.607","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"Improper Verification of Cryptographic Signature vulnerability in HYPR Passwordless on Windows allows Malicious Software Update.This issue affects HYPR Passwordless: before 9.1."},{"lang":"es","value":" La verificación incorrecta de la vulnerabilidad de la firma criptográfica en HYPR Passwordless en Windows permite una actualización de software malicioso. Este problema afecta a HYPR Passwordless: versiones anteriores a 9.1."}],"metrics":{},"weaknesses":[{"source":"security@hypr.com","type":"Secondary","description":[{"lang":"en","value":"CWE-347"}]}],"references":[{"url":"https:\/\/www.hypr.com\/trust-center\/security-advisories","source":"security@hypr.com"}]}},{"cve":{"id":"CVE-2024-21902","sourceIdentifier":"security@qnapsecurity.com.tw","published":"2024-05-21T16:15:24.743","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An incorrect permission assignment for critical resource vulnerability has been reported to affect several QNAP operating system versions. If exploited, the vulnerability could allow authenticated users to read or modify the resource via a network.\n\nWe have already fixed the vulnerability in the following version:\nQTS 5.1.7.2770 build 20240520 and later\nQuTS hero h5.1.7.2770 build 20240520 and later"},{"lang":"es","value":" Se ha informado que una asignación incorrecta de permisos para una vulnerabilidad de recursos críticos afecta a varias versiones del sistema operativo QNAP. Si se explota, la vulnerabilidad podría permitir a los usuarios autenticados leer o modificar el recurso a través de una red. Ya hemos solucionado la vulnerabilidad en la siguiente versión: QTS 5.1.7.2770 build 20240520 y posteriores QuTS hero h5.1.7.2770 build 20240520 y posteriores"}],"metrics":{"cvssMetricV31":[{"source":"security@qnapsecurity.com.tw","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"weaknesses":[{"source":"security@qnapsecurity.com.tw","type":"Primary","description":[{"lang":"en","value":"CWE-200"},{"lang":"en","value":"CWE-732"}]}],"references":[{"url":"https:\/\/www.qnap.com\/en\/security-advisory\/qsa-24-23","source":"security@qnapsecurity.com.tw"}]}},{"cve":{"id":"CVE-2024-27127","sourceIdentifier":"security@qnapsecurity.com.tw","published":"2024-05-21T16:15:24.997","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A double free vulnerability has been reported to affect several QNAP operating system versions. If exploited, the vulnerability could allow authenticated users to execute arbitrary code via a network.\n\nWe have already fixed the vulnerability in the following version:\nQTS 5.1.7.2770 build 20240520 and later\nQuTS hero h5.1.7.2770 build 20240520 and later"},{"lang":"es","value":" Se ha informado que una vulnerabilidad double free afecta a varias versiones del sistema operativo QNAP. Si se explota, la vulnerabilidad podría permitir a los usuarios autenticados ejecutar código arbitrario a través de una red. Ya hemos solucionado la vulnerabilidad en la siguiente versión: QTS 5.1.7.2770 build 20240520 y posteriores QuTS hero h5.1.7.2770 build 20240520 y posteriores"}],"metrics":{"cvssMetricV31":[{"source":"security@qnapsecurity.com.tw","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:C\/C:N\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":7.2,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":2.7}]},"weaknesses":[{"source":"security@qnapsecurity.com.tw","type":"Secondary","description":[{"lang":"en","value":"CWE-415"}]}],"references":[{"url":"https:\/\/www.qnap.com\/en\/security-advisory\/qsa-24-23","source":"security@qnapsecurity.com.tw"}]}},{"cve":{"id":"CVE-2024-27128","sourceIdentifier":"security@qnapsecurity.com.tw","published":"2024-05-21T16:15:25.230","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A buffer copy without checking size of input vulnerability has been reported to affect several QNAP operating system versions. If exploited, the vulnerability could allow authenticated users to execute code via a network.\n\nWe have already fixed the vulnerability in the following version:\nQTS 5.1.7.2770 build 20240520 and later\nQuTS hero h5.1.7.2770 build 20240520 and later"},{"lang":"es","value":" Se ha informado de una vulnerabilidad de una copia del búfer sin verificar el tamaño de entrada afecta a varias versiones del sistema operativo QNAP. Si se explota, la vulnerabilidad podría permitir a los usuarios autenticados ejecutar código a través de una red. Ya hemos solucionado la vulnerabilidad en la siguiente versión: QTS 5.1.7.2770 build 20240520 y posteriores QuTS hero h5.1.7.2770 build 20240520 y posteriores"}],"metrics":{"cvssMetricV31":[{"source":"security@qnapsecurity.com.tw","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:N\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"weaknesses":[{"source":"security@qnapsecurity.com.tw","type":"Primary","description":[{"lang":"en","value":"CWE-120"},{"lang":"en","value":"CWE-121"}]}],"references":[{"url":"https:\/\/www.qnap.com\/en\/security-advisory\/qsa-24-23","source":"security@qnapsecurity.com.tw"}]}},{"cve":{"id":"CVE-2024-27129","sourceIdentifier":"security@qnapsecurity.com.tw","published":"2024-05-21T16:15:25.457","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A buffer copy without checking size of input vulnerability has been reported to affect several QNAP operating system versions. If exploited, the vulnerability could allow authenticated users to execute code via a network.\n\nWe have already fixed the vulnerability in the following version:\nQTS 5.1.7.2770 build 20240520 and later\nQuTS hero h5.1.7.2770 build 20240520 and later"},{"lang":"es","value":" Se ha informado que una vulnerabilidad de una copia del búfer sin verificar el tamaño de entrada afecta a varias versiones del sistema operativo QNAP. Si se explota, la vulnerabilidad podría permitir a los usuarios autenticados ejecutar código a través de una red. Ya hemos solucionado la vulnerabilidad en la siguiente versión: QTS 5.1.7.2770 build 20240520 y posteriores QuTS hero h5.1.7.2770 build 20240520 y posteriores"}],"metrics":{"cvssMetricV31":[{"source":"security@qnapsecurity.com.tw","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:N\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"weaknesses":[{"source":"security@qnapsecurity.com.tw","type":"Primary","description":[{"lang":"en","value":"CWE-120"},{"lang":"en","value":"CWE-121"}]}],"references":[{"url":"https:\/\/www.qnap.com\/en\/security-advisory\/qsa-24-23","source":"security@qnapsecurity.com.tw"}]}},{"cve":{"id":"CVE-2024-27130","sourceIdentifier":"security@qnapsecurity.com.tw","published":"2024-05-21T16:15:25.737","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"A buffer copy without checking size of input vulnerability has been reported to affect several QNAP operating system versions. If exploited, the vulnerability could allow users to execute code via a network.\n\nWe have already fixed the vulnerability in the following version:\nQTS 5.1.7.2770 build 20240520 and later\nQuTS hero h5.1.7.2770 build 20240520 and later"},{"lang":"es","value":" Se ha informado que una vulnerabilidad de una copia del búfer sin verificar el tamaño de entrada afecta a varias versiones del sistema operativo QNAP. Si se explota, la vulnerabilidad podría permitir a los usuarios ejecutar código a través de una red. Ya hemos solucionado la vulnerabilidad en la siguiente versión: QTS 5.1.7.2770 build 20240520 y posteriores QuTS hero h5.1.7.2770 build 20240520 y posteriores"}],"metrics":{"cvssMetricV31":[{"source":"security@qnapsecurity.com.tw","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:C\/C:N\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":7.2,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":2.7}]},"weaknesses":[{"source":"security@qnapsecurity.com.tw","type":"Primary","description":[{"lang":"en","value":"CWE-120"},{"lang":"en","value":"CWE-121"}]}],"references":[{"url":"https:\/\/www.qnap.com\/en\/security-advisory\/qsa-24-23","source":"security@qnapsecurity.com.tw"}]}},{"cve":{"id":"CVE-2024-31840","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T16:15:25.943","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue was discovered in Italtel Embrace 1.6.4. The web application inserts cleartext passwords in the HTML source code. An authenticated user is able to edit the configuration of the email server. Once the user access the edit function, the web application fills the edit form with the current credentials for the email account, including the cleartext password."},{"lang":"es","value":"Se descubrió un problema en Italtel Embrace 1.6.4. La aplicación web inserta contraseñas de texto plano en el código fuente HTML. Un usuario autenticado puede editar la configuración del servidor de correo electrónico. Una vez que el usuario accede a la función de edición, la aplicación web completa el formulario de edición con las credenciales actuales de la cuenta de correo electrónico, incluida la contraseña en texto plano."}],"metrics":{},"references":[{"url":"https:\/\/www.gruppotim.it\/it\/footer\/red-team.html","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-31844","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T16:15:26.027","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue was discovered in Italtel Embrace 1.6.4. The server does not properly handle application errors. In some cases, this leads to a disclosure of information about the server. An unauthenticated user is able craft specific requests in order to make the application generate an error. Inside an error message, some information about the server is revealed, such as the absolute path of the source code of the application. This kind of information can help an attacker to perform other attacks against the system. This can be exploited without authentication."},{"lang":"es","value":" Se descubrió un problema en Italtel Embrace 1.6.4. El servidor no maneja adecuadamente los errores de la aplicación. En algunos casos, esto conduce a la divulgación de información sobre el servidor. Un usuario no autenticado puede crear solicitudes específicas para que la aplicación genere un error. Dentro de un mensaje de error se revela cierta información sobre el servidor, como la ruta absoluta del código fuente de la aplicación. Este tipo de información puede ayudar a un atacante a realizar otros ataques contra el sistema. Esto se puede explotar sin autenticación."}],"metrics":{},"references":[{"url":"https:\/\/www.gruppotim.it\/it\/footer\/red-team.html","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-31845","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T16:15:26.103","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue was discovered in Italtel Embrace 1.6.4. The product does not neutralize or incorrectly neutralizes output that is written to logs. The web application writes logs using a GET query string parameter. This parameter can be modified by an attacker, so that every action he performs is attributed to a different user. This can be exploited without authentication."},{"lang":"es","value":"Se descubrió un problema en Italtel Embrace 1.6.4. El producto no neutraliza o neutraliza incorrectamente la salida escrita en los registros. La aplicación web escribe registros utilizando un parámetro de cadena de consulta GET. Este parámetro puede ser modificado por un atacante, de modo que cada acción que realice se atribuya a un usuario diferente. Esto se puede explotar sin autenticación."}],"metrics":{},"references":[{"url":"https:\/\/www.gruppotim.it\/it\/footer\/red-team.html","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-31847","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T16:15:26.210","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"An issue was discovered in Italtel Embrace 1.6.4. A stored cross-site scripting (XSS) vulnerability allows authenticated and unauthenticated remote attackers to inject arbitrary web script or HTML into a GET parameter. This reflects\/stores the user input without sanitization."},{"lang":"es","value":" Se descubrió un problema en Italtel Embrace 1.6.4. Una vulnerabilidad de Cross Site Scripting (XSS) almacenado permite a atacantes remotos autenticados y no autenticados inyectar scripts web o HTML de su elección en un parámetro GET. Esto refleja\/almacena la entrada del usuario sin sanitización."}],"metrics":{},"references":[{"url":"https:\/\/www.gruppotim.it\/it\/footer\/red-team.html","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-36039","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T16:15:26.293","lastModified":"2024-05-21T16:53:56.550","vulnStatus":"Awaiting Analysis","descriptions":[{"lang":"en","value":"PyMySQL through 1.1.0 allows SQL injection if used with untrusted JSON input because keys are not escaped by escape_dict."},{"lang":"es","value":" PyMySQL hasta 1.1.0 permite la inyección de SQL si se usa con entradas JSON que no son de confianza porque escape_dict no escapa las claves."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/PyMySQL\/PyMySQL\/releases\/tag\/v1.1.1","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-36052","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T17:15:09.250","lastModified":"2024-05-21T17:15:09.250","vulnStatus":"Received","descriptions":[{"lang":"en","value":"RARLAB WinRAR before 7.00, on Windows, allows attackers to spoof the screen output via ANSI escape sequences, a different issue than CVE-2024-33899."}],"metrics":{},"references":[{"url":"https:\/\/sdushantha.medium.com\/ansi-escape-injection-vulnerability-in-winrar-a2cbfac4b983","source":"cve@mitre.org"},{"url":"https:\/\/www.rarlab.com\/rarnew.htm","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-22273","sourceIdentifier":"security@vmware.com","published":"2024-05-21T18:15:08.993","lastModified":"2024-05-21T18:15:08.993","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The storage controllers on VMware ESXi, Workstation, and Fusion have out-of-bounds read\/write vulnerability. A malicious actor with access to a virtual machine with storage controllers enabled may exploit this issue to create a denial of service condition or execute code on the hypervisor from a virtual machine in conjunction with other issues."}],"metrics":{"cvssMetricV31":[{"source":"security@vmware.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:H\/PR:N\/UI:N\/S:C\/C:H\/I:H\/A:H","attackVector":"LOCAL","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":8.1,"baseSeverity":"HIGH"},"exploitabilityScore":1.4,"impactScore":6.0}]},"references":[{"url":"https:\/\/support.broadcom.com\/web\/ecx\/support-content-notification\/-\/external\/content\/SecurityAdvisories\/0\/24308","source":"security@vmware.com"}]}},{"cve":{"id":"CVE-2024-22274","sourceIdentifier":"security@vmware.com","published":"2024-05-21T18:15:09.190","lastModified":"2024-05-21T18:15:09.190","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The vCenter Server contains an authenticated remote code execution vulnerability. A malicious actor with administrative privileges on the vCenter appliance shell may exploit this issue to run arbitrary commands on the underlying operating system."}],"metrics":{"cvssMetricV31":[{"source":"security@vmware.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:H\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":7.2,"baseSeverity":"HIGH"},"exploitabilityScore":1.2,"impactScore":5.9}]},"references":[{"url":"https:\/\/support.broadcom.com\/web\/ecx\/support-content-notification\/-\/external\/content\/SecurityAdvisories\/0\/24308","source":"security@vmware.com"}]}},{"cve":{"id":"CVE-2024-22275","sourceIdentifier":"security@vmware.com","published":"2024-05-21T18:15:09.383","lastModified":"2024-05-21T18:15:09.383","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The vCenter Server contains a partial file read vulnerability. A malicious actor with administrative privileges on the vCenter appliance shell may exploit this issue to partially read arbitrary files containing sensitive data."}],"metrics":{"cvssMetricV31":[{"source":"security@vmware.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:H\/UI:N\/S:U\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":4.9,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.2,"impactScore":3.6}]},"references":[{"url":"https:\/\/support.broadcom.com\/web\/ecx\/support-content-notification\/-\/external\/content\/SecurityAdvisories\/0\/24308","source":"security@vmware.com"}]}},{"cve":{"id":"CVE-2024-31757","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T18:15:09.563","lastModified":"2024-05-21T18:15:09.563","vulnStatus":"Received","descriptions":[{"lang":"en","value":"An issue in TeraByte Unlimited Image for Windows v.3.64.0.0 and before and fixed in v.4.0.0.0 allows a local attacker to escalate privileges via the TBOFLHelper64.sys and TBOFLHelper.sys component."}],"metrics":{},"references":[{"url":"https:\/\/www.terabyteunlimited.com\/image-for-windows\/","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-34240","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T18:15:09.650","lastModified":"2024-05-21T18:15:09.650","vulnStatus":"Received","descriptions":[{"lang":"en","value":"QDOCS Smart School 7.0.0 is vulnerable to Cross Site Scripting (XSS) resulting in arbitrary code execution in admin functions related to adding or updating records."}],"metrics":{},"references":[{"url":"https:\/\/grumpz.net\/cve-2024-34240-latest-stored-xss-0day-vulnerability-unveiled","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-35056","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T18:15:09.737","lastModified":"2024-05-21T18:15:09.737","vulnStatus":"Received","descriptions":[{"lang":"en","value":"NASA AIT-Core v2.5.2 was discovered to contain multiple SQL injection vulnerabilities via the query_packets and insert functions."}],"metrics":{},"references":[{"url":"https:\/\/www.linkedin.com\/pulse\/remote-code-execution-via-man-in-the-middle-more-ujkze","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-35057","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T18:15:09.820","lastModified":"2024-05-21T18:15:09.820","vulnStatus":"Received","descriptions":[{"lang":"en","value":"An issue in NASA AIT-Core v2.5.2 allows attackers to execute arbitrary code via a crafted packet."}],"metrics":{},"references":[{"url":"https:\/\/www.linkedin.com\/pulse\/remote-code-execution-via-man-in-the-middle-more-ujkze","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-35058","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T18:15:09.903","lastModified":"2024-05-21T18:15:09.903","vulnStatus":"Received","descriptions":[{"lang":"en","value":"An issue in the API wait function of NASA AIT-Core v2.5.2 allows attackers to execute arbitrary code via supplying a crafted string."}],"metrics":{},"references":[{"url":"https:\/\/www.linkedin.com\/pulse\/remote-code-execution-via-man-in-the-middle-more-ujkze","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-4154","sourceIdentifier":"security@huntr.dev","published":"2024-05-21T18:15:09.987","lastModified":"2024-05-21T18:15:09.987","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In lunary-ai\/lunary version 1.2.2, an incorrect synchronization vulnerability allows unprivileged users to rename projects they do not have access to. Specifically, an unprivileged user can send a PATCH request to the project's endpoint with a new name for a project, despite not having the necessary permissions or being assigned to the project. This issue allows for unauthorized modification of project names, potentially leading to confusion or unauthorized access to project resources."}],"metrics":{"cvssMetricV30":[{"source":"security@huntr.dev","type":"Secondary","cvssData":{"version":"3.0","vectorString":"CVSS:3.0\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:L\/I:H\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"HIGH","availabilityImpact":"NONE","baseScore":7.1,"baseSeverity":"HIGH"},"exploitabilityScore":2.8,"impactScore":4.2}]},"weaknesses":[{"source":"security@huntr.dev","type":"Primary","description":[{"lang":"en","value":"CWE-821"}]}],"references":[{"url":"https:\/\/huntr.com\/bounties\/e56509af-f7af-4e1e-a04b-9cb53545f30f","source":"security@huntr.dev"}]}},{"cve":{"id":"CVE-2024-25724","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T19:15:09.557","lastModified":"2024-05-21T19:15:09.557","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In RTI Connext Professional 5.3.1 through 6.1.0 before 6.1.1, a buffer overflow in XML parsing from Routing Service, Recording Service, Queuing Service, and Cloud Discovery Service allows attackers to execute code with the affected service's privileges, compromise the service's integrity, leak sensitive information, or crash the service. These attacks could be done via a remote malicious RTPS message; a compromised call with malicious parameters to the RTI_RoutingService_new, rti::recording::Service, RTI_QueuingService_new, or RTI_CDS_Service_new public APIs; or a compromised local file system containing a malicious XML file."}],"metrics":{"cvssMetricV31":[{"source":"cve@mitre.org","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:L\/PR:L\/UI:N\/S:U\/C:L\/I:H\/A:H","attackVector":"LOCAL","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":7.3,"baseSeverity":"HIGH"},"exploitabilityScore":1.8,"impactScore":5.5}]},"references":[{"url":"https:\/\/community.rti.com\/static\/documentation\/connext-dds\/current\/doc\/vulnerabilities\/index.html#cve-2024-25724","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-31989","sourceIdentifier":"security-advisories@github.com","published":"2024-05-21T19:15:09.770","lastModified":"2024-05-21T19:15:09.770","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. It has been discovered that an unprivileged pod in a different namespace on the same cluster could connect to the Redis server on port 6379. Despite having installed the latest version of the VPC CNI plugin on the EKS cluster, it requires manual enablement through configuration to enforce network policies. This raises concerns that many clients might unknowingly have open access to their Redis servers. This vulnerability could lead to Privilege Escalation to the level of cluster controller, or to information leakage, affecting anyone who does not have strict access controls on their Redis instance. This issue has been patched in version(s) 2.8.19, 2.9.15 and 2.10.10."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:A\/AC:L\/PR:L\/UI:N\/S:C\/C:H\/I:H\/A:H","attackVector":"ADJACENT_NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.0,"baseSeverity":"CRITICAL"},"exploitabilityScore":2.3,"impactScore":6.0}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-327"}]}],"references":[{"url":"https:\/\/github.com\/argoproj\/argo-cd\/commit\/2de0ceade243039c120c28374016c04ff9590d1d","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/argoproj\/argo-cd\/commit\/35a7d6c7fa1534aceba763d6a68697f36c12e678","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/argoproj\/argo-cd\/commit\/4e2fe302c3352a0012ecbe7f03476b0e07f7fc6c","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/argoproj\/argo-cd\/commit\/53570cbd143bced49d4376d6e31bd9c7bd2659ff","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/argoproj\/argo-cd\/commit\/6ef7b62a0f67e74b4aac2aee31c98ae49dd95d12","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/argoproj\/argo-cd\/commit\/9552034a80070a93a161bfa330359585f3b85f07","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/argoproj\/argo-cd\/commit\/bdd889d43969ba738ddd15e1f674d27964048994","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/argoproj\/argo-cd\/commit\/f1a449e83ee73f8f14d441563b6a31b504f8d8b0","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/argoproj\/argo-cd\/security\/advisories\/GHSA-9766-5277-j5hr","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-33525","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T19:15:10.010","lastModified":"2024-05-21T19:15:10.010","vulnStatus":"Received","descriptions":[{"lang":"en","value":"A Stored Cross-site Scripting (XSS) vulnerability in the \"Import of organizational units and title of organizational unit\" feature in ILIAS 7.20 to 7.30 and ILIAS 8.4 to 8.10 as well as ILIAS 9.0 allows remote authenticated attackers with administrative privileges to inject arbitrary web script or HTML via XML file upload."}],"metrics":{},"references":[{"url":"https:\/\/docu.ilias.de\/ilias.php?baseClass=illmpresentationgui&cmd=layout&ref_id=1719&obj_id=159938","source":"cve@mitre.org"},{"url":"https:\/\/docu.ilias.de\/ilias.php?baseClass=illmpresentationgui&cmd=layout&ref_id=1719&obj_id=170029","source":"cve@mitre.org"},{"url":"https:\/\/docu.ilias.de\/ilias.php?baseClass=illmpresentationgui&cmd=layout&ref_id=1719&obj_id=170040","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-35059","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T19:15:10.240","lastModified":"2024-05-21T19:15:10.240","vulnStatus":"Received","descriptions":[{"lang":"en","value":"An issue in the Pickle Python library of NASA AIT-Core v2.5.2 allows attackers to execute arbitrary commands."}],"metrics":{},"references":[{"url":"https:\/\/www.linkedin.com\/pulse\/remote-code-execution-via-man-in-the-middle-more-ujkze","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-35060","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T19:15:10.313","lastModified":"2024-05-21T19:15:10.313","vulnStatus":"Received","descriptions":[{"lang":"en","value":"An issue in the YAML Python library of NASA AIT-Core v2.5.2 allows attackers to execute arbitrary commands via supplying a crafted YAML file."}],"metrics":{},"references":[{"url":"https:\/\/www.linkedin.com\/pulse\/remote-code-execution-via-man-in-the-middle-more-ujkze","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-35061","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T19:15:10.390","lastModified":"2024-05-21T19:15:10.390","vulnStatus":"Received","descriptions":[{"lang":"en","value":"NASA AIT-Core v2.5.2 was discovered to use unencrypted channels to exchange data over the network, allowing attackers to execute a man-in-the-middle attack."}],"metrics":{},"references":[{"url":"https:\/\/www.linkedin.com\/pulse\/remote-code-execution-via-man-in-the-middle-more-ujkze","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-31756","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T20:15:08.733","lastModified":"2024-05-21T20:15:08.733","vulnStatus":"Received","descriptions":[{"lang":"en","value":"An issue in MarvinTest Solutions Hardware Access Driver v.5.0.3.0 and before and fixed in v.5.0.4.0 allows a local attacker to escalate privileges via the Hw65.sys component."}],"metrics":{},"references":[{"url":"https:\/\/northwave-cybersecurity.com\/vulnerability-notice-hardware-access-driver-marvintest-solutions","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-34274","sourceIdentifier":"cve@mitre.org","published":"2024-05-21T20:15:08.870","lastModified":"2024-05-21T20:15:08.870","vulnStatus":"Received","descriptions":[{"lang":"en","value":"OpenBD 20210306203917-6cbe797 is vulnerable to Deserialization of Untrusted Data. The cookies bdglobals and bdclient_spot of the OpenBD software uses serialized data, which can be used to execute arbitrary code on the system. NOTE: This vulnerability only affects products that are no longer supported by the maintainer."}],"metrics":{},"references":[{"url":"https:\/\/github.com\/OpenBD\/openbd-core\/issues\/89","source":"cve@mitre.org"}]}},{"cve":{"id":"CVE-2024-35220","sourceIdentifier":"security-advisories@github.com","published":"2024-05-21T21:15:08.117","lastModified":"2024-05-21T21:15:08.117","vulnStatus":"Received","descriptions":[{"lang":"en","value":"@fastify\/session is a session plugin for fastify. Requires the @fastify\/cookie plugin. When restoring the cookie from the session store, the `expires` field is overriden if the `maxAge` field was set.\nThis means a cookie is never correctly detected as expired and thus expired sessions are not destroyed. This vulnerability has been patched 10.8.0."}],"metrics":{"cvssMetricV31":[{"source":"security-advisories@github.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:C\/C:H\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":7.4,"baseSeverity":"HIGH"},"exploitabilityScore":2.8,"impactScore":4.0}]},"weaknesses":[{"source":"security-advisories@github.com","type":"Secondary","description":[{"lang":"en","value":"CWE-613"}]}],"references":[{"url":"https:\/\/github.com\/fastify\/session\/commit\/0495ce5b534c4550f25228821db8098293439f2f","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/fastify\/session\/issues\/251","source":"security-advisories@github.com"},{"url":"https:\/\/github.com\/fastify\/session\/security\/advisories\/GHSA-pj27-2xvp-4qxg","source":"security-advisories@github.com"}]}},{"cve":{"id":"CVE-2024-5040","sourceIdentifier":"ics-cert@hq.dhs.gov","published":"2024-05-21T21:15:08.370","lastModified":"2024-05-21T21:15:08.370","vulnStatus":"Received","descriptions":[{"lang":"en","value":"There are multiple ways in \nLCDS LAquis SCADA for an attacker to access locations outside of their own directory."}],"metrics":{"cvssMetricV31":[{"source":"ics-cert@hq.dhs.gov","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:L\/PR:N\/UI:R\/S:U\/C:H\/I:H\/A:H","attackVector":"LOCAL","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":7.8,"baseSeverity":"HIGH"},"exploitabilityScore":1.8,"impactScore":5.9}]},"weaknesses":[{"source":"ics-cert@hq.dhs.gov","type":"Primary","description":[{"lang":"en","value":"CWE-22"}]}],"references":[{"url":"https:\/\/www.cisa.gov\/news-events\/ics-advisories\/icsa-24-142-01","source":"ics-cert@hq.dhs.gov"}]}},{"cve":{"id":"CVE-2024-21683","sourceIdentifier":"security@atlassian.com","published":"2024-05-21T23:15:07.923","lastModified":"2024-05-21T23:15:07.923","vulnStatus":"Received","descriptions":[{"lang":"en","value":"This High severity RCE (Remote Code Execution) vulnerability was introduced in version 5.2 of Confluence Data Center and Server.\n\nThis RCE (Remote Code Execution) vulnerability, with a CVSS Score of 8.3, allows an authenticated attacker to execute arbitrary code which has high impact to confidentiality, high impact to integrity, high impact to availability, and requires no user interaction. \n\nAtlassian recommends that Confluence Data Center and Server customers upgrade to latest version. If you are unable to do so, upgrade your instance to one of the specified supported fixed versions. See the release notes https:\/\/confluence.atlassian.com\/doc\/confluence-release-notes-327.html\n\nYou can download the latest version of Confluence Data Center and Server from the download center https:\/\/www.atlassian.com\/software\/confluence\/download-archives.\n\nThis vulnerability was found internally."}],"metrics":{},"references":[{"url":"https:\/\/confluence.atlassian.com\/pages\/viewpage.action?pageId=1387867145","source":"security@atlassian.com"},{"url":"https:\/\/jira.atlassian.com\/browse\/CONFSERVER-95832","source":"security@atlassian.com"}]}},{"cve":{"id":"CVE-2024-3518","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T00:15:08.437","lastModified":"2024-05-22T00:15:08.437","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Media Library Assistant plugin for WordPress is vulnerable to SQL Injection via the plugin's shortcode(s) in all versions up to, and including, 3.15 due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query. This makes it possible for authenticated attackers, with contributor access or higher, to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":8.8,"baseSeverity":"HIGH"},"exploitabilityScore":2.8,"impactScore":5.9}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/media-library-assistant\/trunk\/includes\/class-mla-shortcode-custom-list.php#L1971","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset?sfp_email=&sfph_mail=&reponame=&new=3069819%40media-library-assistant%2Ftrunk&old=3060779%40media-library-assistant%2Ftrunk&sfp_email=&sfph_mail=#file3","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/a7af1a03-8382-4593-a41f-8cdb1bb9e53b?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-3519","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T00:15:08.667","lastModified":"2024-05-22T00:15:08.667","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Media Library Assistant plugin for WordPress is vulnerable to Reflected Cross-Site Scripting via the lang parameter in all versions up to, and including, 3.15 due to insufficient input sanitization and output escaping. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in pages that execute if they can successfully trick a user into performing an action such as clicking on a link."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.1,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset?sfp_email=&sfph_mail=&reponame=&new=3069819%40media-library-assistant%2Ftrunk&old=3060779%40media-library-assistant%2Ftrunk&sfp_email=&sfph_mail=#file3","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/7e1cdaf3-76fe-4b73-b30b-4554f0d34d11?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-5190","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T03:15:08.273","lastModified":"2024-05-22T03:15:08.273","vulnStatus":"Rejected","descriptions":[{"lang":"en","value":"Rejected reason: ** REJECT ** DO NOT USE THIS CANDIDATE NUMBER. Reason: This candidate was issued in error. Notes: All references and descriptions in this candidate have been removed to prevent accidental usage."}],"metrics":{},"references":[]}},{"cve":{"id":"CVE-2024-0451","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T04:15:09.130","lastModified":"2024-05-22T04:15:09.130","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The AI ChatBot plugin for WordPress is vulnerable to unauthorized access of data due to a missing capability check on the openai_file_list_callback function in all versions up to, and including, 5.3.4. This makes it possible for authenticated attackers, with subscriber-level access and above, to list files existing in a linked OpenAI account."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":5.0,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":1.4}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/chatbot\/trunk\/includes\/openai\/qcld-bot-openai.php#L175","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3089461\/chatbot\/trunk\/includes\/openai\/qcld-bot-openai.php","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/1c0572a5-6cc9-43ab-a4a3-c8d3b93c8fcf?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-0452","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T04:15:09.510","lastModified":"2024-05-22T04:15:09.510","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The AI ChatBot plugin for WordPress is vulnerable to unauthorized modification of data due to a missing capability check on the openai_file_upload_callback function in all versions up to, and including, 5.3.4. This makes it possible for authenticated attackers, with subscriber-level access and above, to upload files to a linked OpenAI account."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:N\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":5.0,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":1.4}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/chatbot\/trunk\/includes\/openai\/qcld-bot-openai.php#L208","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3089461\/chatbot\/trunk\/includes\/openai\/qcld-bot-openai.php","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/34b6475c-b5dd-42a1-98d1-9b5ae9ff4ad5?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-0453","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T04:15:09.757","lastModified":"2024-05-22T04:15:09.757","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The AI ChatBot plugin for WordPress is vulnerable to unauthorized modification of data due to a missing capability check on the openai_file_delete_callback function in all versions up to, and including, 5.3.4. This makes it possible for authenticated attackers, with subscriber-level access and above, to delete files from a linked OpenAI account."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:N\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":5.0,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":1.4}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/chatbot\/trunk\/includes\/openai\/qcld-bot-openai.php#L133","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3089461\/chatbot\/trunk\/includes\/openai\/qcld-bot-openai.php","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/7e0ef4a5-42d7-4cea-b19f-51917e3ee55f?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-30419","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-22T05:15:52.137","lastModified":"2024-05-22T05:15:52.137","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Cross-site scripting vulnerability exists in a-blog cms Ver.3.1.x series versions prior to Ver.3.1.12, Ver.3.0.x series versions prior to Ver.3.0.32, Ver.2.11.x series versions prior to Ver.2.11.61, Ver.2.10.x series versions prior to Ver.2.10.53, and Ver.2.9 and earlier versions. If this vulnerability is exploited, a user with a contributor or higher privilege who can log in to the product may execute an arbitrary script on the web browser of the user who accessed the website using the product."}],"metrics":{},"references":[{"url":"https:\/\/developer.a-blogcms.jp\/blog\/news\/JVN-70977403.html","source":"vultures@jpcert.or.jp"},{"url":"https:\/\/jvn.jp\/en\/jp\/JVN70977403\/","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-30420","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-22T05:15:52.983","lastModified":"2024-05-22T05:15:52.983","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Server-side request forgery (SSRF) vulnerability exists in a-blog cms Ver.3.1.x series versions prior to Ver.3.1.12 and Ver.3.0.x series versions prior to Ver.3.0.32. If this vulnerability is exploited, a user with an administrator or higher privilege who can log in to the product may obtain arbitrary files on the server and information on the internal server that is not disclosed to the public."}],"metrics":{},"references":[{"url":"https:\/\/developer.a-blogcms.jp\/blog\/news\/JVN-70977403.html","source":"vultures@jpcert.or.jp"},{"url":"https:\/\/jvn.jp\/en\/jp\/JVN70977403\/","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-31394","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-22T05:15:53.053","lastModified":"2024-05-22T05:15:53.053","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Directory traversal vulnerability exists in a-blog cms Ver.3.1.x series versions prior to Ver.3.1.12, Ver.3.0.x series versions prior to Ver.3.0.32, Ver.2.11.x series versions prior to Ver.2.11.61, Ver.2.10.x series versions prior to Ver.2.10.53, and Ver.2.9 and earlier versions. If this vulnerability is exploited, a user with an editor or higher privilege who can log in to the product may obtain arbitrary files on the server."}],"metrics":{},"references":[{"url":"https:\/\/developer.a-blogcms.jp\/blog\/news\/JVN-70977403.html","source":"vultures@jpcert.or.jp"},{"url":"https:\/\/jvn.jp\/en\/jp\/JVN70977403\/","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-31395","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-22T05:15:53.120","lastModified":"2024-05-22T05:15:53.120","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Cross-site scripting vulnerability exists in a-blog cms Ver.3.1.x series versions prior to Ver.3.1.12, Ver.3.0.x series versions prior to Ver.3.0.32, Ver.2.11.x series versions prior to Ver.2.11.61, Ver.2.10.x series versions prior to Ver.2.10.53, and Ver.2.9 and earlier versions. If this vulnerability is exploited, a user with an editor or higher privilege who can log in to the product may execute an arbitrary script on the web browser of the user who accessed the schedule management page."}],"metrics":{},"references":[{"url":"https:\/\/developer.a-blogcms.jp\/blog\/news\/JVN-70977403.html","source":"vultures@jpcert.or.jp"},{"url":"https:\/\/jvn.jp\/en\/jp\/JVN70977403\/","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-31396","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-22T05:15:53.183","lastModified":"2024-05-22T05:15:53.183","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Code injection vulnerability exists in a-blog cms Ver.3.1.x series versions prior to Ver.3.1.12 and Ver.3.0.x series versions prior to Ver.3.0.32. If this vulnerability is exploited, a user with an administrator or higher privilege who can log in to the product may execute an arbitrary command on the server."}],"metrics":{},"references":[{"url":"https:\/\/developer.a-blogcms.jp\/blog\/news\/JVN-70977403.html","source":"vultures@jpcert.or.jp"},{"url":"https:\/\/jvn.jp\/en\/jp\/JVN70977403\/","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-4980","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T05:15:53.253","lastModified":"2024-05-22T05:15:53.253","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The WPKoi Templates for Elementor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via 'id', 'mixColor', 'backgroundColor', 'saveInCookies', and 'autoMatchOsTheme' parameters in all versions up to, and including, 2.5.9 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with Contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/wpkoi-templates-for-elementor\/trunk\/elements\/elements\/advanced-heading\/advanced-heading.php#L626","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/wpkoi-templates-for-elementor\/trunk\/elements\/elements\/darkmode\/darkmode.php#L291","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/wpkoi-templates-for-elementor\/trunk\/elements\/elements\/qr-code\/qr-code.php#L110","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088306\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/6054a885-e67a-4731-93ea-64d7f90d9ea8?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2020-35165","sourceIdentifier":"security_alert@emc.com","published":"2024-05-22T06:15:09.317","lastModified":"2024-05-22T06:15:09.317","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Dell BSAFE Crypto-C Micro Edition, versions before 4.1.5, and Dell BSAFE Micro Edition Suite, versions before 4.6, contain an Observable Timing Discrepancy Vulnerability."}],"metrics":{"cvssMetricV31":[{"source":"security_alert@emc.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:L\/AC:H\/PR:N\/UI:N\/S:U\/C:H\/I:N\/A:N","attackVector":"LOCAL","attackComplexity":"HIGH","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":5.1,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.4,"impactScore":3.6}]},"weaknesses":[{"source":"security_alert@emc.com","type":"Secondary","description":[{"lang":"en","value":"CWE-208"}]}],"references":[{"url":"https:\/\/www.dell.com\/support\/kbdoc\/en-us\/000181115\/dsa-2020-286-dell-bsafe-crypto-c-micro-edition-4-1-5-and-dell-bsafe-micro-edition-suite-4-6-multiple-security-vulnerabilities","source":"security_alert@emc.com"}]}},{"cve":{"id":"CVE-2024-31340","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-22T06:15:12.350","lastModified":"2024-05-22T06:15:12.350","vulnStatus":"Received","descriptions":[{"lang":"en","value":"TP-Link Tether versions prior to 4.5.13 and TP-Link Tapo versions prior to 3.3.6 do not properly validate certificates, which may allow a remote unauthenticated attacker to eavesdrop on an encrypted communication via a man-in-the-middle attack."}],"metrics":{},"references":[{"url":"https:\/\/jvn.jp\/en\/jp\/JVN29471697\/","source":"vultures@jpcert.or.jp"},{"url":"https:\/\/play.google.com\/store\/apps\/details?id=com.tplink.iot","source":"vultures@jpcert.or.jp"},{"url":"https:\/\/play.google.com\/store\/apps\/details?id=com.tplink.tether","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-35162","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-22T06:15:12.570","lastModified":"2024-05-22T06:15:12.570","vulnStatus":"Received","descriptions":[{"lang":"en","value":"Path traversal vulnerability exists in Download Plugins and Themes from Dashboard versions prior to 1.8.6. If this vulnerability is exploited, a remote authenticated attacker with \"switch_themes\" privilege may obtain arbitrary files on the server."}],"metrics":{},"references":[{"url":"https:\/\/jvn.jp\/en\/jp\/JVN85380030\/","source":"vultures@jpcert.or.jp"},{"url":"https:\/\/wordpress.org\/plugins\/download-plugins-dashboard\/","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-3066","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T06:15:12.843","lastModified":"2024-05-22T06:15:12.843","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Elegant Addons for elementor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's widgets in all versions up to, and including, 1.0.8 due to insufficient input sanitization and output escaping on user supplied tag attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/elegant-addons-for-elementor\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/affa8b39-94b8-474d-9310-a93ebdb7c1b8?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-3611","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T06:15:13.547","lastModified":"2024-05-22T06:15:13.547","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Toolbar Extras for Elementor & More – WordPress Admin Bar Enhanced plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'tbex-version' shortcode in all versions up to, and including, 1.4.9 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/toolbar-extras\/#developers","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/50631f6c-de8b-408e-ab1f-ef74d3180e7f?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4443","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T06:15:14.110","lastModified":"2024-05-22T06:15:14.110","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Business Directory Plugin – Easy Listing Directories for WordPress plugin for WordPress is vulnerable to time-based SQL Injection via the ‘listingfields’ parameter in all versions up to, and including, 6.4.2 due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query.  This makes it possible for unauthenticated attackers to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.8,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.9}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/business-directory-plugin\/trunk\/includes\/fields\/class-fieldtypes-select.php#L110","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3089626\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/982fb304-08d6-4195-97a3-f18e94295492?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4971","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T06:15:14.637","lastModified":"2024-05-22T06:15:14.637","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The LearnPress – WordPress LMS Plugin plugin for WordPress is vulnerable to Reflected Cross-Site Scripting via the ‘id’ parameter in all versions up to, and including, 4.2.6.6 due to insufficient input sanitization and output escaping. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in pages that execute if they can successfully trick a user into performing an action such as clicking on a link."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/learnpress\/#developers","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/10b08a05-3561-4d05-985b-6a2339a547a7?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-5092","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T06:15:15.173","lastModified":"2024-05-22T06:15:15.173","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Elegant Addons for elementor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's Switcher, Slider, and Iconbox widgets in all versions up to, and including, 1.0.8 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/elegant-addons-for-elementor\/trunk\/widgets\/eae-iconbox.php#L1667","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/elegant-addons-for-elementor\/trunk\/widgets\/eae-slider.php#L1091","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/elegant-addons-for-elementor\/trunk\/widgets\/eae-switcher.php#L516","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/7ab3e286-05db-430e-bbe7-bfaa31134c3c?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2021-47433","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:08.347","lastModified":"2024-05-22T07:15:08.347","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix abort logic in btrfs_replace_file_extents\n\nError injection testing uncovered a case where we'd end up with a\ncorrupt file system with a missing extent in the middle of a file.  This\noccurs because the if statement to decide if we should abort is wrong.\n\nThe only way we would abort in this case is if we got a ret !=\n-EOPNOTSUPP and we called from the file clone code.  However the\nprealloc code uses this path too.  Instead we need to abort if there is\nan error, and the only error we _don't_ abort on is -EOPNOTSUPP and only\nif we came from the clone file code."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0e309e1152fc34ef75991d9d69b165dbf75bf26c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0e32a2b85c7d92ece86c17dfef390c5ed79c6378","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4afb912f439c4bc4e6a4f3e7547f2e69e354108f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47434","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:08.707","lastModified":"2024-05-22T07:15:08.707","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nxhci: Fix command ring pointer corruption while aborting a command\n\nThe command ring pointer is located at [6:63] bits of the command\nring control register (CRCR). All the control bits like command stop,\nabort are located at [0:3] bits. While aborting a command, we read the\nCRCR and set the abort bit and write to the CRCR. The read will always\ngive command ring pointer as all zeros. So we essentially write only\nthe control bits. Since we split the 64 bit write into two 32 bit writes,\nthere is a possibility of xHC command ring stopped before the upper\ndword (all zeros) is written. If that happens, xHC updates the upper\ndword of its internal command ring pointer with all zeros. Next time,\nwhen the command ring is restarted, we see xHC memory access failures.\nFix this issue by only writing to the lower dword of CRCR where all\ncontrol bits are located."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/01c2dcb67e71c351006dd17cbba86c26b7f61eaf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/22bcb65ea41072ab5d03c0c6290e04e0df6d09a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/62c182b5e763e5f4062e72678e72ce3e02dd4d1b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/dec944bb7079b37968cf69c8a438f91f15c4cc61","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e54abefe703ab7c4e5983e889babd1447738ca42","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ff0e50d3564f33b7f4b35cadeabd951d66cfc570","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47435","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:08.790","lastModified":"2024-05-22T07:15:08.790","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndm: fix mempool NULL pointer race when completing IO\n\ndm_io_dec_pending() calls end_io_acct() first and will then dec md\nin-flight pending count. But if a task is swapping DM table at same\ntime this can result in a crash due to mempool->elements being NULL:\n\ntask1                             task2\ndo_resume\n ->do_suspend\n  ->dm_wait_for_completion\n                                  bio_endio\n\t\t\t\t   ->clone_endio\n\t\t\t\t    ->dm_io_dec_pending\n\t\t\t\t     ->end_io_acct\n\t\t\t\t      ->wakeup task1\n ->dm_swap_table\n  ->__bind\n   ->__bind_mempools\n    ->bioset_exit\n     ->mempool_exit\n                                     ->free_io\n\n[ 67.330330] Unable to handle kernel NULL pointer dereference at\nvirtual address 0000000000000000\n......\n[ 67.330494] pstate: 80400085 (Nzcv daIf +PAN -UAO)\n[ 67.330510] pc : mempool_free+0x70\/0xa0\n[ 67.330515] lr : mempool_free+0x4c\/0xa0\n[ 67.330520] sp : ffffff8008013b20\n[ 67.330524] x29: ffffff8008013b20 x28: 0000000000000004\n[ 67.330530] x27: ffffffa8c2ff40a0 x26: 00000000ffff1cc8\n[ 67.330535] x25: 0000000000000000 x24: ffffffdada34c800\n[ 67.330541] x23: 0000000000000000 x22: ffffffdada34c800\n[ 67.330547] x21: 00000000ffff1cc8 x20: ffffffd9a1304d80\n[ 67.330552] x19: ffffffdada34c970 x18: 000000b312625d9c\n[ 67.330558] x17: 00000000002dcfbf x16: 00000000000006dd\n[ 67.330563] x15: 000000000093b41e x14: 0000000000000010\n[ 67.330569] x13: 0000000000007f7a x12: 0000000034155555\n[ 67.330574] x11: 0000000000000001 x10: 0000000000000001\n[ 67.330579] x9 : 0000000000000000 x8 : 0000000000000000\n[ 67.330585] x7 : 0000000000000000 x6 : ffffff80148b5c1a\n[ 67.330590] x5 : ffffff8008013ae0 x4 : 0000000000000001\n[ 67.330596] x3 : ffffff80080139c8 x2 : ffffff801083bab8\n[ 67.330601] x1 : 0000000000000000 x0 : ffffffdada34c970\n[ 67.330609] Call trace:\n[ 67.330616] mempool_free+0x70\/0xa0\n[ 67.330627] bio_put+0xf8\/0x110\n[ 67.330638] dec_pending+0x13c\/0x230\n[ 67.330644] clone_endio+0x90\/0x180\n[ 67.330649] bio_endio+0x198\/0x1b8\n[ 67.330655] dec_pending+0x190\/0x230\n[ 67.330660] clone_endio+0x90\/0x180\n[ 67.330665] bio_endio+0x198\/0x1b8\n[ 67.330673] blk_update_request+0x214\/0x428\n[ 67.330683] scsi_end_request+0x2c\/0x300\n[ 67.330688] scsi_io_completion+0xa0\/0x710\n[ 67.330695] scsi_finish_command+0xd8\/0x110\n[ 67.330700] scsi_softirq_done+0x114\/0x148\n[ 67.330708] blk_done_softirq+0x74\/0xd0\n[ 67.330716] __do_softirq+0x18c\/0x374\n[ 67.330724] irq_exit+0xb4\/0xb8\n[ 67.330732] __handle_domain_irq+0x84\/0xc0\n[ 67.330737] gic_handle_irq+0x148\/0x1b0\n[ 67.330744] el1_irq+0xe8\/0x190\n[ 67.330753] lpm_cpuidle_enter+0x4f8\/0x538\n[ 67.330759] cpuidle_enter_state+0x1fc\/0x398\n[ 67.330764] cpuidle_enter+0x18\/0x20\n[ 67.330772] do_idle+0x1b4\/0x290\n[ 67.330778] cpu_startup_entry+0x20\/0x28\n[ 67.330786] secondary_start_kernel+0x160\/0x170\n\nFix this by:\n1) Establishing pointers to 'struct dm_io' members in\ndm_io_dec_pending() so that they may be passed into end_io_acct()\n_after_ free_io() is called.\n2) Moving end_io_acct() after free_io()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6e506f07c5b561d673dd0b0d8f7f420cc48024fb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9e07272cca2ed76f7f6073f4444b1143828c8d87","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9fb7cd5c7fef0f1c982e3cd27745a0dec260eaed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ad1393b92e5059218d055bfec8f4946d85ad04c4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d208b89401e073de986dc891037c5a668f5d5d95","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d29c78d3f9c5d2604548c1065bf1ec212728ea61","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d35aef9c60d310eff3eaddacce301efe877e2b7c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47436","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:08.883","lastModified":"2024-05-22T07:15:08.883","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusb: musb: dsps: Fix the probe error path\n\nCommit 7c75bde329d7 (\"usb: musb: musb_dsps: request_irq() after\ninitializing musb\") has inverted the calls to\ndsps_setup_optional_vbus_irq() and dsps_create_musb_pdev() without\nupdating correctly the error path. dsps_create_musb_pdev() allocates and\nregisters a new platform device which must be unregistered and freed\nwith platform_device_unregister(), and this is missing upon\ndsps_setup_optional_vbus_irq() error.\n\nWhile on the master branch it seems not to trigger any issue, I observed\na kernel crash because of a NULL pointer dereference with a v5.10.70\nstable kernel where the patch mentioned above was backported. With this\nkernel version, -EPROBE_DEFER is returned the first time\ndsps_setup_optional_vbus_irq() is called which triggers the probe to\nerror out without unregistering the platform device. Unfortunately, on\nthe Beagle Bone Black Wireless, the platform device still living in the\nsystem is being used by the USB Ethernet gadget driver, which during the\nboot phase triggers the crash.\n\nMy limited knowledge of the musb world prevents me to revert this commit\nwhich was sent to silence a robot warning which, as far as I understand,\ndoes not make sense. The goal of this patch was to prevent an IRQ to\nfire before the platform device being registered. I think this cannot\never happen due to the fact that enabling the interrupts is done by the\n->enable() callback of the platform musb device, and this platform\ndevice must be already registered in order for the core or any other\nuser to use this callback.\n\nHence, I decided to fix the error path, which might prevent future\nerrors on mainline kernels while also fixing older ones."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5ed60a430fb5f3d93e7fef66264daef466b4d10c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9ab5d539bc975b8dcde86eca1b58d836b657732e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9d89e287116796bf987cc48f5c8632ef3048f8eb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c2115b2b16421d93d4993f3fe4c520e91d6fe801","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e923bce31ffefe4f60edfc6b84f62d4a858f3676","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ff9249aab39820be11b6975a10d94253b7d426fc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47437","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:08.997","lastModified":"2024-05-22T07:15:08.997","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\niio: adis16475: fix deadlock on frequency set\n\nWith commit 39c024b51b560\n(\"iio: adis16475: improve sync scale mode handling\"), two deadlocks were\nintroduced:\n 1) The call to 'adis_write_reg_16()' was not changed to it's unlocked\n    version.\n 2) The lock was not being released on the success path of the function.\n\nThis change fixes both these issues."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/04e03b907022ebd876f422f17efcc2c6cc934dc6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9da1b86865ab4376408c58cd9fec332c8bdb5c73","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47438","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.080","lastModified":"2024-05-22T07:15:09.080","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/mlx5e: Fix memory leak in mlx5_core_destroy_cq() error path\n\nPrior to this patch in case mlx5_core_destroy_cq() failed it returns\nwithout completing all destroy operations and that leads to memory leak.\nInstead, complete the destroy flow before return error.\n\nAlso move mlx5_debug_cq_remove() to the beginning of mlx5_core_destroy_cq()\nto be symmetrical with mlx5_core_create_cq().\n\nkmemleak complains on:\n\nunreferenced object 0xc000000038625100 (size 64):\n  comm \"ethtool\", pid 28301, jiffies 4298062946 (age 785.380s)\n  hex dump (first 32 bytes):\n    60 01 48 94 00 00 00 c0 b8 05 34 c3 00 00 00 c0  `.H.......4.....\n    02 00 00 00 00 00 00 00 00 db 7d c1 00 00 00 c0  ..........}.....\n  backtrace:\n    [<000000009e8643cb>] add_res_tree+0xd0\/0x270 [mlx5_core]\n    [<00000000e7cb8e6c>] mlx5_debug_cq_add+0x5c\/0xc0 [mlx5_core]\n    [<000000002a12918f>] mlx5_core_create_cq+0x1d0\/0x2d0 [mlx5_core]\n    [<00000000cef0a696>] mlx5e_create_cq+0x210\/0x3f0 [mlx5_core]\n    [<000000009c642c26>] mlx5e_open_cq+0xb4\/0x130 [mlx5_core]\n    [<0000000058dfa578>] mlx5e_ptp_open+0x7f4\/0xe10 [mlx5_core]\n    [<0000000081839561>] mlx5e_open_channels+0x9cc\/0x13e0 [mlx5_core]\n    [<0000000009cf05d4>] mlx5e_switch_priv_channels+0xa4\/0x230\n[mlx5_core]\n    [<0000000042bbedd8>] mlx5e_safe_switch_params+0x14c\/0x300\n[mlx5_core]\n    [<0000000004bc9db8>] set_pflag_tx_port_ts+0x9c\/0x160 [mlx5_core]\n    [<00000000a0553443>] mlx5e_set_priv_flags+0xd0\/0x1b0 [mlx5_core]\n    [<00000000a8f3d84b>] ethnl_set_privflags+0x234\/0x2d0\n    [<00000000fd27f27c>] genl_family_rcv_msg_doit+0x108\/0x1d0\n    [<00000000f495e2bb>] genl_family_rcv_msg+0xe4\/0x1f0\n    [<00000000646c5c2c>] genl_rcv_msg+0x78\/0x120\n    [<00000000d53e384e>] netlink_rcv_skb+0x74\/0x1a0"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4f7bddf8c5c01cac74373443b13a68e1c6723a94","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/94b960b9deffc02fc0747afc01f72cc62ab099e3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ed8aafea4fec9c654e63445236e0b505e27ed3a7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47439","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.163","lastModified":"2024-05-22T07:15:09.163","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: microchip: Added the condition for scheduling ksz_mib_read_work\n\nWhen the ksz module is installed and removed using rmmod, kernel crashes\nwith null pointer dereferrence error. During rmmod, ksz_switch_remove\nfunction tries to cancel the mib_read_workqueue using\ncancel_delayed_work_sync routine and unregister switch from dsa.\n\nDuring dsa_unregister_switch it calls ksz_mac_link_down, which in turn\nreschedules the workqueue since mib_interval is non-zero.\nDue to which queue executed after mib_interval and it tries to access\ndp->slave. But the slave is unregistered in the ksz_switch_remove\nfunction. Hence kernel crashes.\n\nTo avoid this crash, before canceling the workqueue, resetted the\nmib_interval to 0.\n\nv1 -> v2:\n-Removed the if condition in ksz_mib_read_work"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/383239a33cf29ebee9ce0d4e0e5c900b77a16148","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ef1100ef20f29aec4e62abeccdb5bdbebba1e378","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f2e1de075018cf71bcd7d628e9f759cb8540b0c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47440","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.250","lastModified":"2024-05-22T07:15:09.250","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: encx24j600: check error in devm_regmap_init_encx24j600\n\ndevm_regmap_init may return error which caused by like out of memory,\nthis will results in null pointer dereference later when reading\nor writing register:\n\ngeneral protection fault in encx24j600_spi_probe\nKASAN: null-ptr-deref in range [0x0000000000000090-0x0000000000000097]\nCPU: 0 PID: 286 Comm: spi-encx24j600- Not tainted 5.15.0-rc2-00142-g9978db750e31-dirty #11 9c53a778c1306b1b02359f3c2bbedc0222cba652\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04\/01\/2014\nRIP: 0010:regcache_cache_bypass drivers\/base\/regmap\/regcache.c:540\nCode: 54 41 89 f4 55 53 48 89 fb 48 83 ec 08 e8 26 94 a8 fe 48 8d bb a0 00 00 00 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 4a 03 00 00 4c 8d ab b0 00 00 00 48 8b ab a0 00\nRSP: 0018:ffffc900010476b8 EFLAGS: 00010207\nRAX: dffffc0000000000 RBX: fffffffffffffff4 RCX: 0000000000000000\nRDX: 0000000000000012 RSI: ffff888002de0000 RDI: 0000000000000094\nRBP: ffff888013c9a000 R08: 0000000000000000 R09: fffffbfff3f9cc6a\nR10: ffffc900010476e8 R11: fffffbfff3f9cc69 R12: 0000000000000001\nR13: 000000000000000a R14: ffff888013c9af54 R15: ffff888013c9ad08\nFS:  00007ffa984ab580(0000) GS:ffff88801fe00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000055a6384136c8 CR3: 000000003bbe6003 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n encx24j600_spi_probe drivers\/net\/ethernet\/microchip\/encx24j600.c:459\n spi_probe drivers\/spi\/spi.c:397\n really_probe drivers\/base\/dd.c:517\n __driver_probe_device drivers\/base\/dd.c:751\n driver_probe_device drivers\/base\/dd.c:782\n __device_attach_driver drivers\/base\/dd.c:899\n bus_for_each_drv drivers\/base\/bus.c:427\n __device_attach drivers\/base\/dd.c:971\n bus_probe_device drivers\/base\/bus.c:487\n device_add drivers\/base\/core.c:3364\n __spi_add_device drivers\/spi\/spi.c:599\n spi_add_device drivers\/spi\/spi.c:641\n spi_new_device drivers\/spi\/spi.c:717\n new_device_store+0x18c\/0x1f1 [spi_stub 4e02719357f1ff33f5a43d00630982840568e85e]\n dev_attr_store drivers\/base\/core.c:2074\n sysfs_kf_write fs\/sysfs\/file.c:139\n kernfs_fop_write_iter fs\/kernfs\/file.c:300\n new_sync_write fs\/read_write.c:508 (discriminator 4)\n vfs_write fs\/read_write.c:594\n ksys_write fs\/read_write.c:648\n do_syscall_64 arch\/x86\/entry\/common.c:50\n entry_SYSCALL_64_after_hwframe arch\/x86\/entry\/entry_64.S:113\n\nAdd error check in devm_regmap_init_encx24j600 to avoid this situation."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/322c0e53496309e634d9db7349678eaad1d25b55","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4c2eb80fc90b05559ce6ed1b8dfb2348420b5644","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5e5494e6fc8a29c927e0478bec4a078a40da8901","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/66358471fa75a713fd76bc8a4bd74cb14cd50a4f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e19c10d6e07c59c96e90fe053a72683ad8b0397e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f03dca0c9e2297c84a018e306f8a9cd534ee4287","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f043fac1133a6c5ef960a8422c0f6dd711dee462","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fddc7f678d7fb93caa0d7bc512f968ff1e2bddbc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47441","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.340","lastModified":"2024-05-22T07:15:09.340","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: thermal: Fix out-of-bounds memory accesses\n\nCurrently, mlxsw allows cooling states to be set above the maximum\ncooling state supported by the driver:\n\n # cat \/sys\/class\/thermal\/thermal_zone2\/cdev0\/type\n mlxsw_fan\n # cat \/sys\/class\/thermal\/thermal_zone2\/cdev0\/max_state\n 10\n # echo 18 > \/sys\/class\/thermal\/thermal_zone2\/cdev0\/cur_state\n # echo $?\n 0\n\nThis results in out-of-bounds memory accesses when thermal state\ntransition statistics are enabled (CONFIG_THERMAL_STATISTICS=y), as the\ntransition table is accessed with a too large index (state) [1].\n\nAccording to the thermal maintainer, it is the responsibility of the\ndriver to reject such operations [2].\n\nTherefore, return an error when the state to be set exceeds the maximum\ncooling state supported by the driver.\n\nTo avoid dead code, as suggested by the thermal maintainer [3],\npartially revert commit a421ce088ac8 (\"mlxsw: core: Extend cooling\ndevice with cooling levels\") that tried to interpret these invalid\ncooling states (above the maximum) in a special way. The cooling levels\narray is not removed in order to prevent the fans going below 20% PWM,\nwhich would cause them to get stuck at 0% PWM.\n\n[1]\nBUG: KASAN: slab-out-of-bounds in thermal_cooling_device_stats_update+0x271\/0x290\nRead of size 4 at addr ffff8881052f7bf8 by task kworker\/0:0\/5\n\nCPU: 0 PID: 5 Comm: kworker\/0:0 Not tainted 5.15.0-rc3-custom-45935-gce1adf704b14 #122\nHardware name: Mellanox Technologies Ltd. \"MSN2410-CB2FO\"\/\"SA000874\", BIOS 4.6.5 03\/08\/2016\nWorkqueue: events_freezable_power_ thermal_zone_device_check\nCall Trace:\n dump_stack_lvl+0x8b\/0xb3\n print_address_description.constprop.0+0x1f\/0x140\n kasan_report.cold+0x7f\/0x11b\n thermal_cooling_device_stats_update+0x271\/0x290\n __thermal_cdev_update+0x15e\/0x4e0\n thermal_cdev_update+0x9f\/0xe0\n step_wise_throttle+0x770\/0xee0\n thermal_zone_device_update+0x3f6\/0xdf0\n process_one_work+0xa42\/0x1770\n worker_thread+0x62f\/0x13e0\n kthread+0x3ee\/0x4e0\n ret_from_fork+0x1f\/0x30\n\nAllocated by task 1:\n kasan_save_stack+0x1b\/0x40\n __kasan_kmalloc+0x7c\/0x90\n thermal_cooling_device_setup_sysfs+0x153\/0x2c0\n __thermal_cooling_device_register.part.0+0x25b\/0x9c0\n thermal_cooling_device_register+0xb3\/0x100\n mlxsw_thermal_init+0x5c5\/0x7e0\n __mlxsw_core_bus_device_register+0xcb3\/0x19c0\n mlxsw_core_bus_device_register+0x56\/0xb0\n mlxsw_pci_probe+0x54f\/0x710\n local_pci_probe+0xc6\/0x170\n pci_device_probe+0x2b2\/0x4d0\n really_probe+0x293\/0xd10\n __driver_probe_device+0x2af\/0x440\n driver_probe_device+0x51\/0x1e0\n __driver_attach+0x21b\/0x530\n bus_for_each_dev+0x14c\/0x1d0\n bus_add_driver+0x3ac\/0x650\n driver_register+0x241\/0x3d0\n mlxsw_sp_module_init+0xa2\/0x174\n do_one_initcall+0xee\/0x5f0\n kernel_init_freeable+0x45a\/0x4de\n kernel_init+0x1f\/0x210\n ret_from_fork+0x1f\/0x30\n\nThe buggy address belongs to the object at ffff8881052f7800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 1016 bytes inside of\n 1024-byte region [ffff8881052f7800, ffff8881052f7c00)\nThe buggy address belongs to the page:\npage:0000000052355272 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1052f0\nhead:0000000052355272 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0x200000000010200(slab|head|node=0|zone=2)\nraw: 0200000000010200 ffffea0005034800 0000000300000003 ffff888100041dc0\nraw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff8881052f7a80: 00 00 00 00 00 00 04 fc fc fc fc fc fc fc fc fc\n ffff8881052f7b00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff8881052f7b80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n                                                                ^\n ffff8881052f7c00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff8881052f7c80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n\n[2] https:\/\/lore.kernel.org\/linux-pm\/9aca37cb-1629-5c67-\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/332fdf951df8b870e3da86b122ae304e2aabe88c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ae0993739e14a102d506aa09e11b0065f3144f10","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df8e58716afb3bee2b59de66b1ba1033f2e26303","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e59d839743b50cb1d3f42a786bea48cc5621d254","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47442","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.430","lastModified":"2024-05-22T07:15:09.430","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nNFC: digital: fix possible memory leak in digital_in_send_sdd_req()\n\n'skb' is allocated in digital_in_send_sdd_req(), but not free when\ndigital_in_send_cmd() failed, which will cause memory leak. Fix it\nby freeing 'skb' if digital_in_send_cmd() return failed."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/071bdef36391958c89af5fa2172f691b31baa212","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/291c932fc3692e4d211a445ba8aa35663831bac7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2bde4aca56db9fe25405d39ddb062531493a65db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/50cb95487c265187289810addec5093d4fed8329","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6432d7f1d1c3aa74cfe8f5e3afdf81b786c32e86","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/74569c78aa84f8c958f1334b465bc530906ec99a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/88c890b0b9a1fb9fcd01c61ada515e8b636c34f9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fcce6e5255474ca33c27dda0cdf9bf5087278873","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47443","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.570","lastModified":"2024-05-22T07:15:09.570","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nNFC: digital: fix possible memory leak in digital_tg_listen_mdaa()\n\n'params' is allocated in digital_tg_listen_mdaa(), but not free when\ndigital_send_cmd() failed, which will cause memory leak. Fix it by\nfreeing 'params' if digital_send_cmd() return failed."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3f2960b39f22e26cf8addae93c3f5884d1c183c9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/429054ec51e648d241a7e0b465cf44f6633334c5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/564249219e5b5673a8416b5181875d828c3f1e8c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/58e7dcc9ca29c14e44267a4d0ea61e3229124907","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7ab488d7228a9dceb2456867f1f0919decf6efed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9881b0c860649f27ef2565deef011e516390f416","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a67d47e32c91e2b10402cb8c081774cbf08edb2e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7b023e6ff567e991c31cd425b0e1d16779c938b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47444","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.660","lastModified":"2024-05-22T07:15:09.660","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/edid: In connector_bad_edid() cap num_of_ext by num_blocks read\n\nIn commit e11f5bd8228f (\"drm: Add support for DP 1.4 Compliance edid\ncorruption test\") the function connector_bad_edid() started assuming\nthat the memory for the EDID passed to it was big enough to hold\n`edid[0x7e] + 1` blocks of data (1 extra for the base block). It\ncompletely ignored the fact that the function was passed `num_blocks`\nwhich indicated how much memory had been allocated for the EDID.\n\nLet's fix this by adding a bounds check.\n\nThis is important for handling the case where there's an error in the\nfirst block of the EDID. In that case we will call\nconnector_bad_edid() without having re-allocated memory based on\n`edid[0x7e]`."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/09f3946bb452918dbfb1982add56f9ffaae393dc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/97794170b696856483f74b47bfb6049780d2d3a0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7b45024f66f9ec769e8dbb1a51ae83cd05929c7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47445","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.733","lastModified":"2024-05-22T07:15:09.733","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/msm: Fix null pointer dereference on pointer edp\n\nThe initialization of pointer dev dereferences pointer edp before\nedp is null checked, so there is a potential null pointer deference\nissue. Fix this by only dereferencing edp after edp has been null\nchecked.\n\nAddresses-Coverity: (\"Dereference before null check\")"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0cd063aa0a09822cc1620fc59a67fe2f9f6338ac","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2133c4fc8e1348dcb752f267a143fe2254613b34","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/46c8ddede0273d1d132beefa9de8b820326982be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7f642b93710b6b1119bdff90be01e6b5a2a5d669","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/91a340768b012f5b910a203a805b97a345b3db37","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bacac7d26849c8e903ceb7466d9ce8dc3c2797eb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f175b9a83e5c252d7c74acddc792840016caae0a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f302be08e3de94db8863a0b2958b2bb3e8e998e6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47446","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.820","lastModified":"2024-05-22T07:15:09.820","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/msm\/a4xx: fix error handling in a4xx_gpu_init()\n\nThis code returns 1 on error instead of a negative error.  It leads to\nan Oops in the caller.  A second problem is that the check for\n\"if (ret != -ENODATA)\" cannot be true because \"ret\" is set to 1."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3962d626eb3e3b23ebb2e2a61537fa764acbfe11","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/980d74e7d03ccf2eaa11d133416946bd880c7c08","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47447","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.897","lastModified":"2024-05-22T07:15:09.897","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/msm\/a3xx: fix error handling in a3xx_gpu_init()\n\nThese error paths returned 1 on failure, instead of a negative error\ncode.  This would lead to an Oops in the caller.  A second problem is\nthat the check for \"if (ret != -ENODATA)\" did not work because \"ret\" was\nset to 1."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3eda901995371d390ef82d0b6462f4ea8efbcfdf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d59e44e7821a8f2bb6f2e846b9167397a5f01608","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47448","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:09.970","lastModified":"2024-05-22T07:15:09.970","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: fix possible stall on recvmsg()\n\nrecvmsg() can enter an infinite loop if the caller provides the\nMSG_WAITALL, the data present in the receive queue is not sufficient to\nfulfill the request, and no more data is received by the peer.\n\nWhen the above happens, mptcp_wait_data() will always return with\nno wait, as the MPTCP_DATA_READY flag checked by such function is\nset and never cleared in such code path.\n\nLeveraging the above syzbot was able to trigger an RCU stall:\n\nrcu: INFO: rcu_preempt self-detected stall on CPU\nrcu:    0-...!: (10499 ticks this GP) idle=0af\/1\/0x4000000000000000 softirq=10678\/10678 fqs=1\n        (t=10500 jiffies g=13089 q=109)\nrcu: rcu_preempt kthread starved for 10497 jiffies! g13089 f0x0 RCU_GP_WAIT_FQS(5) ->state=0x0 ->cpu=1\nrcu:    Unless rcu_preempt kthread gets sufficient CPU time, OOM is now expected behavior.\nrcu: RCU grace-period kthread stack dump:\ntask:rcu_preempt     state:R  running task     stack:28696 pid:   14 ppid:     2 flags:0x00004000\nCall Trace:\n context_switch kernel\/sched\/core.c:4955 [inline]\n __schedule+0x940\/0x26f0 kernel\/sched\/core.c:6236\n schedule+0xd3\/0x270 kernel\/sched\/core.c:6315\n schedule_timeout+0x14a\/0x2a0 kernel\/time\/timer.c:1881\n rcu_gp_fqs_loop+0x186\/0x810 kernel\/rcu\/tree.c:1955\n rcu_gp_kthread+0x1de\/0x320 kernel\/rcu\/tree.c:2128\n kthread+0x405\/0x4f0 kernel\/kthread.c:327\n ret_from_fork+0x1f\/0x30 arch\/x86\/entry\/entry_64.S:295\nrcu: Stack dump where RCU GP kthread last ran:\nSending NMI from CPU 0 to CPUs 1:\nNMI backtrace for cpu 1\nCPU: 1 PID: 8510 Comm: syz-executor827 Not tainted 5.15.0-rc2-next-20210920-syzkaller #0\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01\/2011\nRIP: 0010:bytes_is_nonzero mm\/kasan\/generic.c:84 [inline]\nRIP: 0010:memory_is_nonzero mm\/kasan\/generic.c:102 [inline]\nRIP: 0010:memory_is_poisoned_n mm\/kasan\/generic.c:128 [inline]\nRIP: 0010:memory_is_poisoned mm\/kasan\/generic.c:159 [inline]\nRIP: 0010:check_region_inline mm\/kasan\/generic.c:180 [inline]\nRIP: 0010:kasan_check_range+0xc8\/0x180 mm\/kasan\/generic.c:189\nCode: 38 00 74 ed 48 8d 50 08 eb 09 48 83 c0 01 48 39 d0 74 7a 80 38 00 74 f2 48 89 c2 b8 01 00 00 00 48 85 d2 75 56 5b 5d 41 5c c3 <48> 85 d2 74 5e 48 01 ea eb 09 48 83 c0 01 48 39 d0 74 50 80 38 00\nRSP: 0018:ffffc9000cd676c8 EFLAGS: 00000283\nRAX: ffffed100e9a110e RBX: ffffed100e9a110f RCX: ffffffff88ea062a\nRDX: 0000000000000001 RSI: 0000000000000008 RDI: ffff888074d08870\nRBP: ffffed100e9a110e R08: 0000000000000001 R09: ffff888074d08877\nR10: ffffed100e9a110e R11: 0000000000000000 R12: ffff888074d08000\nR13: ffff888074d08000 R14: ffff888074d08088 R15: ffff888074d08000\nFS:  0000555556d8e300(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000\nS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000180 CR3: 0000000068909000 CR4: 00000000001506e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n instrument_atomic_read_write include\/linux\/instrumented.h:101 [inline]\n test_and_clear_bit include\/asm-generic\/bitops\/instrumented-atomic.h:83 [inline]\n mptcp_release_cb+0x14a\/0x210 net\/mptcp\/protocol.c:3016\n release_sock+0xb4\/0x1b0 net\/core\/sock.c:3204\n mptcp_wait_data net\/mptcp\/protocol.c:1770 [inline]\n mptcp_recvmsg+0xfd1\/0x27b0 net\/mptcp\/protocol.c:2080\n inet6_recvmsg+0x11b\/0x5e0 net\/ipv6\/af_inet6.c:659\n sock_recvmsg_nosec net\/socket.c:944 [inline]\n ____sys_recvmsg+0x527\/0x600 net\/socket.c:2626\n ___sys_recvmsg+0x127\/0x200 net\/socket.c:2670\n do_recvmmsg+0x24d\/0x6d0 net\/socket.c:2764\n __sys_recvmmsg net\/socket.c:2843 [inline]\n __do_sys_recvmmsg net\/socket.c:2866 [inline]\n __se_sys_recvmmsg net\/socket.c:2859 [inline]\n __x64_sys_recvmmsg+0x20b\/0x260 net\/socket.c:2859\n do_syscall_x64 arch\/x86\/entry\/common.c:50 [inline]\n do_syscall_64+0x35\/0xb0 arch\/x86\/entry\/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44\/0xae\nRIP: 0033:0x7fc200d2\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1a4554e94f0deff9fc1dc5addf93fa579cc29711","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/612f71d7328c14369924384ad2170aae2a6abd92","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47449","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.050","lastModified":"2024-05-22T07:15:10.050","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nice: fix locking for Tx timestamp tracking flush\n\nCommit 4dd0d5c33c3e (\"ice: add lock around Tx timestamp tracker flush\")\nadded a lock around the Tx timestamp tracker flow which is used to\ncleanup any left over SKBs and prepare for device removal.\n\nThis lock is problematic because it is being held around a call to\nice_clear_phy_tstamp. The clear function takes a mutex to send a PHY\nwrite command to firmware. This could lead to a deadlock if the mutex\nactually sleeps, and causes the following warning on a kernel with\npreemption debugging enabled:\n\n[  715.419426] BUG: sleeping function called from invalid context at kernel\/locking\/mutex.c:573\n[  715.427900] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 3100, name: rmmod\n[  715.435652] INFO: lockdep is turned off.\n[  715.439591] Preemption disabled at:\n[  715.439594] [<0000000000000000>] 0x0\n[  715.446678] CPU: 52 PID: 3100 Comm: rmmod Tainted: G        W  OE     5.15.0-rc4+ #42 bdd7ec3018e725f159ca0d372ce8c2c0e784891c\n[  715.458058] Hardware name: Intel Corporation S2600STQ\/S2600STQ, BIOS SE5C620.86B.02.01.0010.010620200716 01\/06\/2020\n[  715.468483] Call Trace:\n[  715.470940]  dump_stack_lvl+0x6a\/0x9a\n[  715.474613]  ___might_sleep.cold+0x224\/0x26a\n[  715.478895]  __mutex_lock+0xb3\/0x1440\n[  715.482569]  ? stack_depot_save+0x378\/0x500\n[  715.486763]  ? ice_sq_send_cmd+0x78\/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.494979]  ? kfree+0xc1\/0x520\n[  715.498128]  ? mutex_lock_io_nested+0x12a0\/0x12a0\n[  715.502837]  ? kasan_set_free_info+0x20\/0x30\n[  715.507110]  ? __kasan_slab_free+0x10b\/0x140\n[  715.511385]  ? slab_free_freelist_hook+0xc7\/0x220\n[  715.516092]  ? kfree+0xc1\/0x520\n[  715.519235]  ? ice_deinit_lag+0x16c\/0x220 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.527359]  ? ice_remove+0x1cf\/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.535133]  ? pci_device_remove+0xab\/0x1d0\n[  715.539318]  ? __device_release_driver+0x35b\/0x690\n[  715.544110]  ? driver_detach+0x214\/0x2f0\n[  715.548035]  ? bus_remove_driver+0x11d\/0x2f0\n[  715.552309]  ? pci_unregister_driver+0x26\/0x250\n[  715.556840]  ? ice_module_exit+0xc\/0x2f [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.564799]  ? __do_sys_delete_module.constprop.0+0x2d8\/0x4e0\n[  715.570554]  ? do_syscall_64+0x3b\/0x90\n[  715.574303]  ? entry_SYSCALL_64_after_hwframe+0x44\/0xae\n[  715.579529]  ? start_flush_work+0x542\/0x8f0\n[  715.583719]  ? ice_sq_send_cmd+0x78\/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.591923]  ice_sq_send_cmd+0x78\/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.599960]  ? wait_for_completion_io+0x250\/0x250\n[  715.604662]  ? lock_acquire+0x196\/0x200\n[  715.608504]  ? do_raw_spin_trylock+0xa5\/0x160\n[  715.612864]  ice_sbq_rw_reg+0x1e6\/0x2f0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.620813]  ? ice_reset+0x130\/0x130 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.628497]  ? __debug_check_no_obj_freed+0x1e8\/0x3c0\n[  715.633550]  ? trace_hardirqs_on+0x1c\/0x130\n[  715.637748]  ice_write_phy_reg_e810+0x70\/0xf0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.646220]  ? do_raw_spin_trylock+0xa5\/0x160\n[  715.650581]  ? ice_ptp_release+0x910\/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.658797]  ? ice_ptp_release+0x255\/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.667013]  ice_clear_phy_tstamp+0x2c\/0x110 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.675403]  ice_ptp_release+0x408\/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.683440]  ice_remove+0x560\/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.691037]  ? _raw_spin_unlock_irqrestore+0x46\/0x73\n[  715.696005]  pci_device_remove+0xab\/0x1d0\n[  715.700018]  __device_release_driver+0x35b\/0x690\n[  715.704637]  driver_detach+0x214\/0x2f0\n[  715.708389]  bus_remove_driver+0x11d\/0x2f0\n[  715.712489]  pci_unregister_driver+0x26\/0x250\n[  71\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4d4a223a86afe658cd878800f09458e8bb54415d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/61616be899975404df44c20ab902464b60882cd7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47450","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.143","lastModified":"2024-05-22T07:15:10.143","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: arm64: Fix host stage-2 PGD refcount\n\nThe KVM page-table library refcounts the pages of concatenated stage-2\nPGDs individually. However, when running KVM in protected mode, the\nhost's stage-2 PGD is currently managed by EL2 as a single high-order\ncompound page, which can cause the refcount of the tail pages to reach 0\nwhen they shouldn't, hence corrupting the page-table.\n\nFix this by introducing a new hyp_split_page() helper in the EL2 page\nallocator (matching the kernel's split_page() function), and make use of\nit from host_s2_zalloc_pages_exact()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1d58a17ef54599506d44c45ac95be27273a4d2b1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b372264c66ef78f2cab44e877fbd765ad6d24c39","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47451","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.220","lastModified":"2024-05-22T07:15:10.220","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: xt_IDLETIMER: fix panic that occurs when timer_type has garbage value\n\nCurrently, when the rule related to IDLETIMER is added, idletimer_tg timer\nstructure is initialized by kmalloc on executing idletimer_tg_create\nfunction. However, in this process timer->timer_type is not defined to\na specific value. Thus, timer->timer_type has garbage value and it occurs\nkernel panic. So, this commit fixes the panic by initializing\ntimer->timer_type using kzalloc instead of kmalloc.\n\nTest commands:\n    # iptables -A OUTPUT -j IDLETIMER --timeout 1 --label test\n    $ cat \/sys\/class\/xt_idletimer\/timers\/test\n      Killed\n\nSplat looks like:\n    BUG: KASAN: user-memory-access in alarm_expires_remaining+0x49\/0x70\n    Read of size 8 at addr 0000002e8c7bc4c8 by task cat\/917\n    CPU: 12 PID: 917 Comm: cat Not tainted 5.14.0+ #3 79940a339f71eb14fc81aee1757a20d5bf13eb0e\n    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-1ubuntu1.1 04\/01\/2014\n    Call Trace:\n     dump_stack_lvl+0x6e\/0x9c\n     kasan_report.cold+0x112\/0x117\n     ? alarm_expires_remaining+0x49\/0x70\n     __asan_load8+0x86\/0xb0\n     alarm_expires_remaining+0x49\/0x70\n     idletimer_tg_show+0xe5\/0x19b [xt_IDLETIMER 11219304af9316a21bee5ba9d58f76a6b9bccc6d]\n     dev_attr_show+0x3c\/0x60\n     sysfs_kf_seq_show+0x11d\/0x1f0\n     ? device_remove_bin_file+0x20\/0x20\n     kernfs_seq_show+0xa4\/0xb0\n     seq_read_iter+0x29c\/0x750\n     kernfs_fop_read_iter+0x25a\/0x2c0\n     ? __fsnotify_parent+0x3d1\/0x570\n     ? iov_iter_init+0x70\/0x90\n     new_sync_read+0x2a7\/0x3d0\n     ? __x64_sys_llseek+0x230\/0x230\n     ? rw_verify_area+0x81\/0x150\n     vfs_read+0x17b\/0x240\n     ksys_read+0xd9\/0x180\n     ? vfs_write+0x460\/0x460\n     ? do_syscall_64+0x16\/0xc0\n     ? lockdep_hardirqs_on+0x79\/0x120\n     __x64_sys_read+0x43\/0x50\n     do_syscall_64+0x3b\/0xc0\n     entry_SYSCALL_64_after_hwframe+0x44\/0xae\n    RIP: 0033:0x7f0cdc819142\n    Code: c0 e9 c2 fe ff ff 50 48 8d 3d 3a ca 0a 00 e8 f5 19 02 00 0f 1f 44 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 ec 28 48 89 54 24\n    RSP: 002b:00007fff28eee5b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000\n    RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007f0cdc819142\n    RDX: 0000000000020000 RSI: 00007f0cdc032000 RDI: 0000000000000003\n    RBP: 00007f0cdc032000 R08: 00007f0cdc031010 R09: 0000000000000000\n    R10: 0000000000000022 R11: 0000000000000246 R12: 00005607e9ee31f0\n    R13: 0000000000000003 R14: 0000000000020000 R15: 0000000000020000"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2a670c323055282c9b72794a491d53cef86bbeaf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/902c0b1887522a099aa4e1e6b4b476c2fe5dd13e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cae7cab804c943d723d52724a3aeb07a3f4a2650","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47452","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.300","lastModified":"2024-05-22T07:15:10.300","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: skip netdev events generated on netns removal\n\nsyzbot reported following (harmless) WARN:\n\n WARNING: CPU: 1 PID: 2648 at net\/netfilter\/core.c:468\n  nft_netdev_unregister_hooks net\/netfilter\/nf_tables_api.c:230 [inline]\n  nf_tables_unregister_hook include\/net\/netfilter\/nf_tables.h:1090 [inline]\n  __nft_release_basechain+0x138\/0x640 net\/netfilter\/nf_tables_api.c:9524\n  nft_netdev_event net\/netfilter\/nft_chain_filter.c:351 [inline]\n  nf_tables_netdev_event+0x521\/0x8a0 net\/netfilter\/nft_chain_filter.c:382\n\nreproducer:\nunshare -n bash -c 'ip link add br0 type bridge; nft add table netdev t ; \\\n nft add chain netdev t ingress \\{ type filter hook ingress device \"br0\" \\\n priority 0\\; policy drop\\; \\}'\n\nProblem is that when netns device exit hooks create the UNREGISTER\nevent, the .pre_exit hook for nf_tables core has already removed the\nbase hook.  Notifier attempts to do this again.\n\nThe need to do base hook unregister unconditionally was needed in the past,\nbecause notifier was last stage where reg->dev dereference was safe.\n\nNow that nf_tables does the hook removal in .pre_exit, this isn't\nneeded anymore."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/68a3765c659f809dcaac20030853a054646eb739","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/90c7c58aa2bd02c65a4c63b7dfe0b16eab12cf9f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47453","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.380","lastModified":"2024-05-22T07:15:10.380","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nice: Avoid crash from unnecessary IDA free\n\nIn the remove path, there is an attempt to free the aux_idx IDA whether\nit was allocated or not.  This can potentially cause a crash when\nunloading the driver on systems that do not initialize support for RDMA.\nBut, this free cannot be gated by the status bit for RDMA, since it is\nallocated if the driver detects support for RDMA at probe time, but the\ndriver can enter into a state where RDMA is not supported after the IDA\nhas been allocated at probe time and this would lead to a memory leak.\n\nInitialize aux_idx to an invalid value and check for a valid value when\nunloading to determine if an IDA free is necessary."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/73e30a62b19b9fbb4e6a3465c59da186630d5f2e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/777682e59840e24e6c5672197e6ffbcf4bff823b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47454","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.453","lastModified":"2024-05-22T07:15:10.453","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc\/smp: do not decrement idle task preempt count in CPU offline\n\nWith PREEMPT_COUNT=y, when a CPU is offlined and then onlined again, we\nget:\n\nBUG: scheduling while atomic: swapper\/1\/0\/0x00000000\nno locks held by swapper\/1\/0.\nCPU: 1 PID: 0 Comm: swapper\/1 Not tainted 5.15.0-rc2+ #100\nCall Trace:\n dump_stack_lvl+0xac\/0x108\n __schedule_bug+0xac\/0xe0\n __schedule+0xcf8\/0x10d0\n schedule_idle+0x3c\/0x70\n do_idle+0x2d8\/0x4a0\n cpu_startup_entry+0x38\/0x40\n start_secondary+0x2ec\/0x3a0\n start_secondary_prolog+0x10\/0x14\n\nThis is because powerpc's arch_cpu_idle_dead() decrements the idle task's\npreempt count, for reasons explained in commit a7c2bb8279d2 (\"powerpc:\nRe-enable preemption before cpu_die()\"), specifically \"start_secondary()\nexpects a preempt_count() of 0.\"\n\nHowever, since commit 2c669ef6979c (\"powerpc\/preempt: Don't touch the idle\ntask's preempt_count during hotplug\") and commit f1a0a376ca0c (\"sched\/core:\nInitialize the idle task with preemption disabled\"), that justification no\nlonger holds.\n\nThe idle task isn't supposed to re-enable preemption, so remove the\nvestigial preempt_enable() from the CPU offline path.\n\nTested with pseries and powernv in qemu, and pseries on PowerVM."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3ea0b497a7a2fff6a4b7090310c9f52c91975934","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/53770a411559cf7bc0906d1df319cc533d2f4f58","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/787252a10d9422f3058df9a4821f389e5326c440","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47455","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.530","lastModified":"2024-05-22T07:15:10.530","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nptp: Fix possible memory leak in ptp_clock_register()\n\nI got memory leak as follows when doing fault injection test:\n\nunreferenced object 0xffff88800906c618 (size 8):\n  comm \"i2c-idt82p33931\", pid 4421, jiffies 4294948083 (age 13.188s)\n  hex dump (first 8 bytes):\n    70 74 70 30 00 00 00 00                          ptp0....\n  backtrace:\n    [<00000000312ed458>] __kmalloc_track_caller+0x19f\/0x3a0\n    [<0000000079f6e2ff>] kvasprintf+0xb5\/0x150\n    [<0000000026aae54f>] kvasprintf_const+0x60\/0x190\n    [<00000000f323a5f7>] kobject_set_name_vargs+0x56\/0x150\n    [<000000004e35abdd>] dev_set_name+0xc0\/0x100\n    [<00000000f20cfe25>] ptp_clock_register+0x9f4\/0xd30 [ptp]\n    [<000000008bb9f0de>] idt82p33_probe.cold+0x8b6\/0x1561 [ptp_idt82p33]\n\nWhen posix_clock_register() returns an error, the name allocated\nin dev_set_name() will be leaked, the put_device() should be used\nto give up the device reference, then the name will be freed in\nkobject_cleanup() and other memory will be freed in ptp_clock_release()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4225fea1cb28370086e17e82c0f69bec2779dca0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/95c0a0c5ec8839f8f21672be786e87a100319ca8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47456","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.627","lastModified":"2024-05-22T07:15:10.627","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncan: peak_pci: peak_pci_remove(): fix UAF\n\nWhen remove the module peek_pci, referencing 'chan' again after\nreleasing 'dev' will cause UAF.\n\nFix this by releasing 'dev' later.\n\nThe following log reveals it:\n\n[   35.961814 ] BUG: KASAN: use-after-free in peak_pci_remove+0x16f\/0x270 [peak_pci]\n[   35.963414 ] Read of size 8 at addr ffff888136998ee8 by task modprobe\/5537\n[   35.965513 ] Call Trace:\n[   35.965718 ]  dump_stack_lvl+0xa8\/0xd1\n[   35.966028 ]  print_address_description+0x87\/0x3b0\n[   35.966420 ]  kasan_report+0x172\/0x1c0\n[   35.966725 ]  ? peak_pci_remove+0x16f\/0x270 [peak_pci]\n[   35.967137 ]  ? trace_irq_enable_rcuidle+0x10\/0x170\n[   35.967529 ]  ? peak_pci_remove+0x16f\/0x270 [peak_pci]\n[   35.967945 ]  __asan_report_load8_noabort+0x14\/0x20\n[   35.968346 ]  peak_pci_remove+0x16f\/0x270 [peak_pci]\n[   35.968752 ]  pci_device_remove+0xa9\/0x250"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0e5afdc2315b0737edcf55bede4ee1640d2d464d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1248582e47a9f7ce0ecd156c39fc61f8b6aa3699","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1c616528ba4aeb1125a06b407572ab7b56acae38","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/28f28e4bc3a5e0051faa963f10b778ab38c1db69","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/34914971bb3244db4ce2be44e9438a9b30c56250","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/447d44cd2f67a20b596ede3ca3cd67086dfd9ca9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/949fe9b35570361bc6ee2652f89a0561b26eec98","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/adbda14730aacce41c0d3596415aa39ad63eafd9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47457","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.710","lastModified":"2024-05-22T07:15:10.710","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncan: isotp: isotp_sendmsg(): add result check for wait_event_interruptible()\n\nUsing wait_event_interruptible() to wait for complete transmission,\nbut do not check the result of wait_event_interruptible() which can be\ninterrupted. It will result in TX buffer has multiple accessors and\nthe later process interferes with the previous process.\n\nFollowing is one of the problems reported by syzbot.\n\n=============================================================\nWARNING: CPU: 0 PID: 0 at net\/can\/isotp.c:840 isotp_tx_timer_handler+0x2e0\/0x4c0\nCPU: 0 PID: 0 Comm: swapper\/0 Not tainted 5.13.0-rc7+ #68\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1 04\/01\/2014\nRIP: 0010:isotp_tx_timer_handler+0x2e0\/0x4c0\nCall Trace:\n <IRQ>\n ? isotp_setsockopt+0x390\/0x390\n __hrtimer_run_queues+0xb8\/0x610\n hrtimer_run_softirq+0x91\/0xd0\n ? rcu_read_lock_sched_held+0x4d\/0x80\n __do_softirq+0xe8\/0x553\n irq_exit_rcu+0xf8\/0x100\n sysvec_apic_timer_interrupt+0x9e\/0xc0\n <\/IRQ>\n asm_sysvec_apic_timer_interrupt+0x12\/0x20\n\nAdd result check for wait_event_interruptible() in isotp_sendmsg()\nto avoid multiple accessers for tx buffer."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/053bc12df0d6097c1126d0e14fa778a0a8faeb64","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9acf636215a6ce9362fe618e7da4913b8bfe84c8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a76abedd2be3926d6deba236a935c7f98abf9110","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47458","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.780","lastModified":"2024-05-22T07:15:10.780","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: mount fails with buffer overflow in strlen\n\nStarting with kernel 5.11 built with CONFIG_FORTIFY_SOURCE mouting an\nocfs2 filesystem with either o2cb or pcmk cluster stack fails with the\ntrace below.  Problem seems to be that strings for cluster stack and\ncluster name are not guaranteed to be null terminated in the disk\nrepresentation, while strlcpy assumes that the source string is always\nnull terminated.  This causes a read outside of the source string\ntriggering the buffer overflow detection.\n\n  detected buffer overflow in strlen\n  ------------[ cut here ]------------\n  kernel BUG at lib\/string.c:1149!\n  invalid opcode: 0000 [#1] SMP PTI\n  CPU: 1 PID: 910 Comm: mount.ocfs2 Not tainted 5.14.0-1-amd64 #1\n    Debian 5.14.6-2\n  RIP: 0010:fortify_panic+0xf\/0x11\n  ...\n  Call Trace:\n   ocfs2_initialize_super.isra.0.cold+0xc\/0x18 [ocfs2]\n   ocfs2_fill_super+0x359\/0x19b0 [ocfs2]\n   mount_bdev+0x185\/0x1b0\n   legacy_get_tree+0x27\/0x40\n   vfs_get_tree+0x25\/0xb0\n   path_mount+0x454\/0xa20\n   __x64_sys_mount+0x103\/0x140\n   do_syscall_64+0x3b\/0xc0\n   entry_SYSCALL_64_after_hwframe+0x44\/0xae"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0e677ea5b7396f715a76b6b0ef441430e4c4b57f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/232ed9752510de4436468b653d145565669c8498","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4b74ddcc22ee6455946e80a9c4808801f8f8561e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7623b1035ca2d17bde0f6a086ad6844a34648df1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/93be0eeea14cf39235e585c8f56df3b3859deaad","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ac011cb3ff7a76b3e0e6e77158ee4ba2f929e1fb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b15fa9224e6e1239414525d8d556d824701849fc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d3a83576378b4c904f711598dde2c5e881c4295c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47459","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.863","lastModified":"2024-05-22T07:15:10.863","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncan: j1939: j1939_netdev_start(): fix UAF for rx_kref of j1939_priv\n\nIt will trigger UAF for rx_kref of j1939_priv as following.\n\n        cpu0                                    cpu1\nj1939_sk_bind(socket0, ndev0, ...)\nj1939_netdev_start\n                                        j1939_sk_bind(socket1, ndev0, ...)\n                                        j1939_netdev_start\nj1939_priv_set\n                                        j1939_priv_get_by_ndev_locked\nj1939_jsk_add\n.....\nj1939_netdev_stop\nkref_put_lock(&priv->rx_kref, ...)\n                                        kref_get(&priv->rx_kref, ...)\n                                        REFCOUNT_WARN(\"addition on 0;...\")\n\n====================================================\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 1 PID: 20874 at lib\/refcount.c:25 refcount_warn_saturate+0x169\/0x1e0\nRIP: 0010:refcount_warn_saturate+0x169\/0x1e0\nCall Trace:\n j1939_netdev_start+0x68b\/0x920\n j1939_sk_bind+0x426\/0xeb0\n ? security_socket_bind+0x83\/0xb0\n\nThe rx_kref's kref_get() and kref_put() should use j1939_netdev_lock to\nprotect."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6e8811707e2df0c6ba920f0cad3a3bca7b42132f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/864e77771a24c877aaf53aee019f78619cbcd668","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a0e47d2833b4f65e6c799f28c6b636d36b8b936d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d9d52a3ebd284882f5562c88e55991add5d01586","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47460","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:10.940","lastModified":"2024-05-22T07:15:10.940","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix data corruption after conversion from inline format\n\nCommit 6dbf7bb55598 (\"fs: Don't invalidate page buffers in\nblock_write_full_page()\") uncovered a latent bug in ocfs2 conversion\nfrom inline inode format to a normal inode format.\n\nThe code in ocfs2_convert_inline_data_to_extents() attempts to zero out\nthe whole cluster allocated for file data by grabbing, zeroing, and\ndirtying all pages covering this cluster.  However these pages are\nbeyond i_size, thus writeback code generally ignores these dirty pages\nand no blocks were ever actually zeroed on the disk.\n\nThis oversight was fixed by commit 693c241a5f6a (\"ocfs2: No need to zero\npages past i_size.\") for standard ocfs2 write path, inline conversion\npath was apparently forgotten; the commit log also has a reasoning why\nthe zeroing actually is not needed.\n\nAfter commit 6dbf7bb55598, things became worse as writeback code stopped\ninvalidating buffers on pages beyond i_size and thus these pages end up\nwith clean PageDirty bit but with buffers attached to these pages being\nstill dirty.  So when a file is converted from inline format, then\nwriteback triggers, and then the file is grown so that these pages\nbecome valid, the invalid dirtiness state is preserved,\nmark_buffer_dirty() does nothing on these pages (buffers are already\ndirty) but page is never written back because it is clean.  So data\nwritten to these pages is lost once pages are reclaimed.\n\nSimple reproducer for the problem is:\n\n  xfs_io -f -c \"pwrite 0 2000\" -c \"pwrite 2000 2000\" -c \"fsync\" \\\n    -c \"pwrite 4000 2000\" ocfs2_file\n\nAfter unmounting and mounting the fs again, you can observe that end of\n'ocfs2_file' has lost its contents.\n\nFix the problem by not doing the pointless zeroing during conversion\nfrom inline format similarly as in the standard write path.\n\n[akpm@linux-foundation.org: fix whitespace, per Joseph]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5314454ea3ff6fc746eaf71b9a7ceebed52888fa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/560edd14de2bf9dbc0129681eeb4d5ef87cc105f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8e6bfb4f70168ddfd32fb6dc028ad52faaf1f32e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a3a089c241cd49b33a8cdd7fcb37cc87a086912a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b05caf023b14cbed9223bb5b48ecc7bffe38f632","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f1b98569e81c37d7e0deada7172f8f60860c1360","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fa9b6b6c953e3f6441ed6cf83b4c771dac2dae08","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47461","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.040","lastModified":"2024-05-22T07:15:11.040","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nuserfaultfd: fix a race between writeprotect and exit_mmap()\n\nA race is possible when a process exits, its VMAs are removed by\nexit_mmap() and at the same time userfaultfd_writeprotect() is called.\n\nThe race was detected by KASAN on a development kernel, but it appears\nto be possible on vanilla kernels as well.\n\nUse mmget_not_zero() to prevent the race as done in other userfaultfd\noperations."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/149958ecd0627a9f1e9c678c25c665400054cd6a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3cda4bfffd4f755645577aaa9e96a606657b4525","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cb185d5f1ebf900f4ae3bf84cee212e6dd035aca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47462","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.117","lastModified":"2024-05-22T07:15:11.117","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmm\/mempolicy: do not allow illegal MPOL_F_NUMA_BALANCING | MPOL_LOCAL in mbind()\n\nsyzbot reported access to unitialized memory in mbind() [1]\n\nIssue came with commit bda420b98505 (\"numa balancing: migrate on fault\namong multiple bound nodes\")\n\nThis commit added a new bit in MPOL_MODE_FLAGS, but only checked valid\ncombination (MPOL_F_NUMA_BALANCING can only be used with MPOL_BIND) in\ndo_set_mempolicy()\n\nThis patch moves the check in sanitize_mpol_flags() so that it is also\nused by mbind()\n\n  [1]\n  BUG: KMSAN: uninit-value in __mpol_equal+0x567\/0x590 mm\/mempolicy.c:2260\n   __mpol_equal+0x567\/0x590 mm\/mempolicy.c:2260\n   mpol_equal include\/linux\/mempolicy.h:105 [inline]\n   vma_merge+0x4a1\/0x1e60 mm\/mmap.c:1190\n   mbind_range+0xcc8\/0x1e80 mm\/mempolicy.c:811\n   do_mbind+0xf42\/0x15f0 mm\/mempolicy.c:1333\n   kernel_mbind mm\/mempolicy.c:1483 [inline]\n   __do_sys_mbind mm\/mempolicy.c:1490 [inline]\n   __se_sys_mbind+0x437\/0xb80 mm\/mempolicy.c:1486\n   __x64_sys_mbind+0x19d\/0x200 mm\/mempolicy.c:1486\n   do_syscall_x64 arch\/x86\/entry\/common.c:51 [inline]\n   do_syscall_64+0x54\/0xd0 arch\/x86\/entry\/common.c:82\n   entry_SYSCALL_64_after_hwframe+0x44\/0xae\n\n  Uninit was created at:\n   slab_alloc_node mm\/slub.c:3221 [inline]\n   slab_alloc mm\/slub.c:3230 [inline]\n   kmem_cache_alloc+0x751\/0xff0 mm\/slub.c:3235\n   mpol_new mm\/mempolicy.c:293 [inline]\n   do_mbind+0x912\/0x15f0 mm\/mempolicy.c:1289\n   kernel_mbind mm\/mempolicy.c:1483 [inline]\n   __do_sys_mbind mm\/mempolicy.c:1490 [inline]\n   __se_sys_mbind+0x437\/0xb80 mm\/mempolicy.c:1486\n   __x64_sys_mbind+0x19d\/0x200 mm\/mempolicy.c:1486\n   do_syscall_x64 arch\/x86\/entry\/common.c:51 [inline]\n   do_syscall_64+0x54\/0xd0 arch\/x86\/entry\/common.c:82\n   entry_SYSCALL_64_after_hwframe+0x44\/0xae\n  =====================================================\n  Kernel panic - not syncing: panic_on_kmsan set ...\n  CPU: 0 PID: 15049 Comm: syz-executor.0 Tainted: G    B             5.15.0-rc2-syzkaller #0\n  Hardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01\/2011\n  Call Trace:\n   __dump_stack lib\/dump_stack.c:88 [inline]\n   dump_stack_lvl+0x1ff\/0x28e lib\/dump_stack.c:106\n   dump_stack+0x25\/0x28 lib\/dump_stack.c:113\n   panic+0x44f\/0xdeb kernel\/panic.c:232\n   kmsan_report+0x2ee\/0x300 mm\/kmsan\/report.c:186\n   __msan_warning+0xd7\/0x150 mm\/kmsan\/instrumentation.c:208\n   __mpol_equal+0x567\/0x590 mm\/mempolicy.c:2260\n   mpol_equal include\/linux\/mempolicy.h:105 [inline]\n   vma_merge+0x4a1\/0x1e60 mm\/mmap.c:1190\n   mbind_range+0xcc8\/0x1e80 mm\/mempolicy.c:811\n   do_mbind+0xf42\/0x15f0 mm\/mempolicy.c:1333\n   kernel_mbind mm\/mempolicy.c:1483 [inline]\n   __do_sys_mbind mm\/mempolicy.c:1490 [inline]\n   __se_sys_mbind+0x437\/0xb80 mm\/mempolicy.c:1486\n   __x64_sys_mbind+0x19d\/0x200 mm\/mempolicy.c:1486\n   do_syscall_x64 arch\/x86\/entry\/common.c:51 [inline]\n   do_syscall_64+0x54\/0xd0 arch\/x86\/entry\/common.c:82\n   entry_SYSCALL_64_after_hwframe+0x44\/0xae"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6d2aec9e123bb9c49cb5c7fc654f25f81e688e8c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9ee4e9ae98f1f262d6fae0d266cfdf3ba2c321d9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47463","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.193","lastModified":"2024-05-22T07:15:11.193","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmm\/secretmem: fix NULL page->mapping dereference in page_is_secretmem()\n\nCheck for a NULL page->mapping before dereferencing the mapping in\npage_is_secretmem(), as the page's mapping can be nullified while gup()\nis running, e.g.  by reclaim or truncation.\n\n  BUG: kernel NULL pointer dereference, address: 0000000000000068\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD 0 P4D 0\n  Oops: 0000 [#1] PREEMPT SMP NOPTI\n  CPU: 6 PID: 4173897 Comm: CPU 3\/KVM Tainted: G        W\n  RIP: 0010:internal_get_user_pages_fast+0x621\/0x9d0\n  Code: <48> 81 7a 68 80 08 04 bc 0f 85 21 ff ff 8 89 c7 be\n  RSP: 0018:ffffaa90087679b0 EFLAGS: 00010046\n  RAX: ffffe3f37905b900 RBX: 00007f2dd561e000 RCX: ffffe3f37905b934\n  RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffe3f37905b900\n  ...\n  CR2: 0000000000000068 CR3: 00000004c5898003 CR4: 00000000001726e0\n  Call Trace:\n   get_user_pages_fast_only+0x13\/0x20\n   hva_to_pfn+0xa9\/0x3e0\n   try_async_pf+0xa1\/0x270\n   direct_page_fault+0x113\/0xad0\n   kvm_mmu_page_fault+0x69\/0x680\n   vmx_handle_exit+0xe1\/0x5d0\n   kvm_arch_vcpu_ioctl_run+0xd81\/0x1c70\n   kvm_vcpu_ioctl+0x267\/0x670\n   __x64_sys_ioctl+0x83\/0xa0\n   do_syscall_64+0x56\/0x80\n   entry_SYSCALL_64_after_hwframe+0x44\/0xae"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/79f9bc5843142b649575f887dccdf1c07ad75c20","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b77ba1e02345bafd703f0d407bdbd88c3be1f767","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47464","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.287","lastModified":"2024-05-22T07:15:11.287","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\naudit: fix possible null-pointer dereference in audit_filter_rules\n\nFix  possible null-pointer dereference in audit_filter_rules.\n\naudit_filter_rules() error: we previously assumed 'ctx' could be null"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/16802fa4c33eb1a8efb23f1e93365190e4047d05","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4e9e46a700201b4c85081fd478c99c692a9aaa0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6e3ee990c90494561921c756481d0e2125d8b895","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d6f451f1f60c58d73038c7c3177066f8f084e2a2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47465","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.367","lastModified":"2024-05-22T07:15:11.367","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: PPC: Book3S HV: Fix stack handling in idle_kvm_start_guest()\n\nIn commit 10d91611f426 (\"powerpc\/64s: Reimplement book3s idle code in\nC\") kvm_start_guest() became idle_kvm_start_guest(). The old code\nallocated a stack frame on the emergency stack, but didn't use the\nframe to store anything, and also didn't store anything in its caller's\nframe.\n\nidle_kvm_start_guest() on the other hand is written more like a normal C\nfunction, it creates a frame on entry, and also stores CR\/LR into its\ncallers frame (per the ABI). The problem is that there is no caller\nframe on the emergency stack.\n\nThe emergency stack for a given CPU is allocated with:\n\n  paca_ptrs[i]->emergency_sp = alloc_stack(limit, i) + THREAD_SIZE;\n\nSo emergency_sp actually points to the first address above the emergency\nstack allocation for a given CPU, we must not store above it without\nfirst decrementing it to create a frame. This is different to the\nregular kernel stack, paca->kstack, which is initialised to point at an\ninitial frame that is ready to use.\n\nidle_kvm_start_guest() stores the backchain, CR and LR all of which\nwrite outside the allocation for the emergency stack. It then creates a\nstack frame and saves the non-volatile registers. Unfortunately the\nframe it creates is not large enough to fit the non-volatiles, and so\nthe saving of the non-volatile registers also writes outside the\nemergency stack allocation.\n\nThe end result is that we corrupt whatever is at 0-24 bytes, and 112-248\nbytes above the emergency stack allocation.\n\nIn practice this has gone unnoticed because the memory immediately above\nthe emergency stack happens to be used for other stack allocations,\neither another CPUs mc_emergency_sp or an IRQ stack. See the order of\ncalls to irqstack_early_init() and emergency_stack_init().\n\nThe low addresses of another stack are the top of that stack, and so are\nonly used if that stack is under extreme pressue, which essentially\nnever happens in practice - and if it did there's a high likelyhood we'd\ncrash due to that stack overflowing.\n\nStill, we shouldn't be corrupting someone else's stack, and it is purely\nluck that we aren't corrupting something else.\n\nTo fix it we save CR\/LR into the caller's frame using the existing r1 on\nentry, we then create a SWITCH_FRAME_SIZE frame (which has space for\npt_regs) on the emergency stack with the backchain pointing to the\nexisting stack, and then finally we switch to the new frame on the\nemergency stack."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6d077c37c4643394b1bae9682da48164fc147ea8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/80bbb0bc3a0288442f7fe6fc514f4ee1cb06ccb7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9b4416c5095c20e110c82ae602c254099b83b72f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fbd724c49bead048ae9fc1a5b7bff2fb3e54f855","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47466","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.450","lastModified":"2024-05-22T07:15:11.450","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmm, slub: fix potential memoryleak in kmem_cache_open()\n\nIn error path, the random_seq of slub cache might be leaked.  Fix this\nby using __kmem_cache_release() to release all the relevant resources."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/42b81946e3ac9ea0372ba16e05160dc11e02694f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4f5d1c29cfab5cb0ab885059818751bdef32e2bb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/568f906340b43120abd6fcc67c37396482f85930","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9037c57681d25e4dcc442d940d6dbe24dd31f461","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47467","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.533","lastModified":"2024-05-22T07:15:11.533","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nkunit: fix reference count leak in kfree_at_end\n\nThe reference counting issue happens in the normal path of\nkfree_at_end(). When kunit_alloc_and_get_resource() is invoked, the\nfunction forgets to handle the returned resource object, whose refcount\nincreased inside, causing a refcount leak.\n\nFix this issue by calling kunit_alloc_resource() instead of\nkunit_alloc_and_get_resource().\n\nFixed the following when applying:\nShuah Khan <skhan@linuxfoundation.org>\n\nCHECK: Alignment should match open parenthesis\n+\tkunit_alloc_resource(test, NULL, kfree_res_free, GFP_KERNEL,\n \t\t\t\t     (void *)to_free);"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/bbdd158b40b66a9403391a517f24ef6613573446","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f62314b1ced25c58b86e044fc951cd6a1ea234cf","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47468","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.603","lastModified":"2024-05-22T07:15:11.603","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nisdn: mISDN: Fix sleeping function called from invalid context\n\nThe driver can call card->isac.release() function from an atomic\ncontext.\n\nFix this by calling this function after releasing the lock.\n\nThe following log reveals it:\n\n[   44.168226 ] BUG: sleeping function called from invalid context at kernel\/workqueue.c:3018\n[   44.168941 ] in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 5475, name: modprobe\n[   44.169574 ] INFO: lockdep is turned off.\n[   44.169899 ] irq event stamp: 0\n[   44.170160 ] hardirqs last  enabled at (0): [<0000000000000000>] 0x0\n[   44.170627 ] hardirqs last disabled at (0): [<ffffffff814209ed>] copy_process+0x132d\/0x3e00\n[   44.171240 ] softirqs last  enabled at (0): [<ffffffff81420a1a>] copy_process+0x135a\/0x3e00\n[   44.171852 ] softirqs last disabled at (0): [<0000000000000000>] 0x0\n[   44.172318 ] Preemption disabled at:\n[   44.172320 ] [<ffffffffa009b0a9>] nj_release+0x69\/0x500 [netjet]\n[   44.174441 ] Call Trace:\n[   44.174630 ]  dump_stack_lvl+0xa8\/0xd1\n[   44.174912 ]  dump_stack+0x15\/0x17\n[   44.175166 ]  ___might_sleep+0x3a2\/0x510\n[   44.175459 ]  ? nj_release+0x69\/0x500 [netjet]\n[   44.175791 ]  __might_sleep+0x82\/0xe0\n[   44.176063 ]  ? start_flush_work+0x20\/0x7b0\n[   44.176375 ]  start_flush_work+0x33\/0x7b0\n[   44.176672 ]  ? trace_irq_enable_rcuidle+0x85\/0x170\n[   44.177034 ]  ? kasan_quarantine_put+0xaa\/0x1f0\n[   44.177372 ]  ? kasan_quarantine_put+0xaa\/0x1f0\n[   44.177711 ]  __flush_work+0x11a\/0x1a0\n[   44.177991 ]  ? flush_work+0x20\/0x20\n[   44.178257 ]  ? lock_release+0x13c\/0x8f0\n[   44.178550 ]  ? __kasan_check_write+0x14\/0x20\n[   44.178872 ]  ? do_raw_spin_lock+0x148\/0x360\n[   44.179187 ]  ? read_lock_is_recursive+0x20\/0x20\n[   44.179530 ]  ? __kasan_check_read+0x11\/0x20\n[   44.179846 ]  ? do_raw_spin_unlock+0x55\/0x900\n[   44.180168 ]  ? ____kasan_slab_free+0x116\/0x140\n[   44.180505 ]  ? _raw_spin_unlock_irqrestore+0x41\/0x60\n[   44.180878 ]  ? skb_queue_purge+0x1a3\/0x1c0\n[   44.181189 ]  ? kfree+0x13e\/0x290\n[   44.181438 ]  flush_work+0x17\/0x20\n[   44.181695 ]  mISDN_freedchannel+0xe8\/0x100\n[   44.182006 ]  isac_release+0x210\/0x260 [mISDNipac]\n[   44.182366 ]  nj_release+0xf6\/0x500 [netjet]\n[   44.182685 ]  nj_remove+0x48\/0x70 [netjet]\n[   44.182989 ]  pci_device_remove+0xa9\/0x250"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/37e4f57b22cc5ebb3f80cf0f74fdeb487f082367","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4054b869dc263228d30a4755800b78f0f2ba0c89","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6510e80a0b81b5d814e3aea6297ba42f5e76f73c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6f95c97e0f9d6eb39c3f2cb45e8fa4268d1b372b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9f591cbdbed3d7822b2bdba89b34a6d7b434317d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a5b34409d3fc52114c828be4adbc30744fa3258b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ef269a8808cb1759245a98a7fe16fceaebad894c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f5966ba53013149bcf94e1536644a958dd00a026","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47469","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.690","lastModified":"2024-05-22T07:15:11.690","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nspi: Fix deadlock when adding SPI controllers on SPI buses\n\nCurrently we have a global spi_add_lock which we take when adding new\ndevices so that we can check that we're not trying to reuse a chip\nselect that's already controlled.  This means that if the SPI device is\nitself a SPI controller and triggers the instantiation of further SPI\ndevices we trigger a deadlock as we try to register and instantiate\nthose devices while in the process of doing so for the parent controller\nand hence already holding the global spi_add_lock.  Since we only care\nabout concurrency within a single SPI bus move the lock to be per\ncontroller, avoiding the deadlock.\n\nThis can be easily triggered in the case of spi-mux."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/6098475d4cb48d821bdf453c61118c56e26294f0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/722ef19a161ce3fffb3d1b01ce2301c306639bdd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47470","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.763","lastModified":"2024-05-22T07:15:11.763","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmm, slub: fix potential use-after-free in slab_debugfs_fops\n\nWhen sysfs_slab_add failed, we shouldn't call debugfs_slab_add() for s\nbecause s will be freed soon.  And slab_debugfs_fops will use s later\nleading to a use-after-free."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/159d8cfbd0428d487c53be4722f33cdab0d25d83","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/67823a544414def2a36c212abadb55b23bcda00c","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47471","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.847","lastModified":"2024-05-22T07:15:11.847","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: mxsfb: Fix NULL pointer dereference crash on unload\n\nThe mxsfb->crtc.funcs may already be NULL when unloading the driver,\nin which case calling mxsfb_irq_disable() via drm_irq_uninstall() from\nmxsfb_unload() leads to NULL pointer dereference.\n\nSince all we care about is masking the IRQ and mxsfb->base is still\nvalid, just use that to clear and mask the IRQ."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3cfc183052c3dbf8eae57b6c1685dab00ed3db4a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0e6db0656ddfd8bb57303c2ef61ee1c1cc694a8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f40c2281d2c0674d32ba732fee45222d76495472","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47472","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:11.927","lastModified":"2024-05-22T07:15:11.927","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: mdiobus: Fix memory leak in __mdiobus_register\n\nOnce device_register() failed, we should call put_device() to\ndecrement reference count for cleanup. Or it will cause memory\nleak.\n\nBUG: memory leak\nunreferenced object 0xffff888114032e00 (size 256):\n  comm \"kworker\/1:3\", pid 2960, jiffies 4294943572 (age 15.920s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 08 2e 03 14 81 88 ff ff  ................\n    08 2e 03 14 81 88 ff ff 90 76 65 82 ff ff ff ff  .........ve.....\n  backtrace:\n    [<ffffffff8265cfab>] kmalloc include\/linux\/slab.h:591 [inline]\n    [<ffffffff8265cfab>] kzalloc include\/linux\/slab.h:721 [inline]\n    [<ffffffff8265cfab>] device_private_init drivers\/base\/core.c:3203 [inline]\n    [<ffffffff8265cfab>] device_add+0x89b\/0xdf0 drivers\/base\/core.c:3253\n    [<ffffffff828dd643>] __mdiobus_register+0xc3\/0x450 drivers\/net\/phy\/mdio_bus.c:537\n    [<ffffffff828cb835>] __devm_mdiobus_register+0x75\/0xf0 drivers\/net\/phy\/mdio_devres.c:87\n    [<ffffffff82b92a00>] ax88772_init_mdio drivers\/net\/usb\/asix_devices.c:676 [inline]\n    [<ffffffff82b92a00>] ax88772_bind+0x330\/0x480 drivers\/net\/usb\/asix_devices.c:786\n    [<ffffffff82baa33f>] usbnet_probe+0x3ff\/0xdf0 drivers\/net\/usb\/usbnet.c:1745\n    [<ffffffff82c36e17>] usb_probe_interface+0x177\/0x370 drivers\/usb\/core\/driver.c:396\n    [<ffffffff82661d17>] call_driver_probe drivers\/base\/dd.c:517 [inline]\n    [<ffffffff82661d17>] really_probe.part.0+0xe7\/0x380 drivers\/base\/dd.c:596\n    [<ffffffff826620bc>] really_probe drivers\/base\/dd.c:558 [inline]\n    [<ffffffff826620bc>] __driver_probe_device+0x10c\/0x1e0 drivers\/base\/dd.c:751\n    [<ffffffff826621ba>] driver_probe_device+0x2a\/0x120 drivers\/base\/dd.c:781\n    [<ffffffff82662a26>] __device_attach_driver+0xf6\/0x140 drivers\/base\/dd.c:898\n    [<ffffffff8265eca7>] bus_for_each_drv+0xb7\/0x100 drivers\/base\/bus.c:427\n    [<ffffffff826625a2>] __device_attach+0x122\/0x260 drivers\/base\/dd.c:969\n    [<ffffffff82660916>] bus_probe_device+0xc6\/0xe0 drivers\/base\/bus.c:487\n    [<ffffffff8265cd0b>] device_add+0x5fb\/0xdf0 drivers\/base\/core.c:3359\n    [<ffffffff82c343b9>] usb_set_configuration+0x9d9\/0xb90 drivers\/usb\/core\/message.c:2170\n    [<ffffffff82c4473c>] usb_generic_driver_probe+0x8c\/0xc0 drivers\/usb\/core\/generic.c:238\n\nBUG: memory leak\nunreferenced object 0xffff888116f06900 (size 32):\n  comm \"kworker\/0:2\", pid 2670, jiffies 4294944448 (age 7.160s)\n  hex dump (first 32 bytes):\n    75 73 62 2d 30 30 31 3a 30 30 33 00 00 00 00 00  usb-001:003.....\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [<ffffffff81484516>] kstrdup+0x36\/0x70 mm\/util.c:60\n    [<ffffffff814845a3>] kstrdup_const+0x53\/0x80 mm\/util.c:83\n    [<ffffffff82296ba2>] kvasprintf_const+0xc2\/0x110 lib\/kasprintf.c:48\n    [<ffffffff82358d4b>] kobject_set_name_vargs+0x3b\/0xe0 lib\/kobject.c:289\n    [<ffffffff826575f3>] dev_set_name+0x63\/0x90 drivers\/base\/core.c:3147\n    [<ffffffff828dd63b>] __mdiobus_register+0xbb\/0x450 drivers\/net\/phy\/mdio_bus.c:535\n    [<ffffffff828cb835>] __devm_mdiobus_register+0x75\/0xf0 drivers\/net\/phy\/mdio_devres.c:87\n    [<ffffffff82b92a00>] ax88772_init_mdio drivers\/net\/usb\/asix_devices.c:676 [inline]\n    [<ffffffff82b92a00>] ax88772_bind+0x330\/0x480 drivers\/net\/usb\/asix_devices.c:786\n    [<ffffffff82baa33f>] usbnet_probe+0x3ff\/0xdf0 drivers\/net\/usb\/usbnet.c:1745\n    [<ffffffff82c36e17>] usb_probe_interface+0x177\/0x370 drivers\/usb\/core\/driver.c:396\n    [<ffffffff82661d17>] call_driver_probe drivers\/base\/dd.c:517 [inline]\n    [<ffffffff82661d17>] really_probe.part.0+0xe7\/0x380 drivers\/base\/dd.c:596\n    [<ffffffff826620bc>] really_probe drivers\/base\/dd.c:558 [inline]\n    [<ffffffff826620bc>] __driver_probe_device+0x10c\/0x1e0 drivers\/base\/dd.c:751\n    [<ffffffff826621ba>] driver_probe_device+0x2a\/0x120 drivers\/base\/dd.c:781\n    [<ffffffff82662a26>] __device_attach_driver+0xf6\/0x140 drivers\/base\/dd.c:898\n    [<ffffffff8265eca7>] bus_for_each\n---truncated---"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0c4e87ba11eb331dca2315d484d08441b8c13193","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2bc10dca9432fadb09e45127e258fc7127fd346d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3a0dc2e35a5d6546b1db87fe985582dadc64fe7b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4ec0f9abc512cc02fb04daa89ccf6697e80ab417","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6a18d155d5b35ad50c8fac2be091212487ae58ec","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8121d0d4fd108280f5cd7b7fe8c6592adaa37be9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8ba94a7f7b9fc2a2b808ccceb99b77135deae21a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a9831afa2dc8a18205403907c41aa4e0950ac611","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ab609f25d19858513919369ff3d9a63c02cd9e2e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0feaa8376f52357bf2fd020d0c471713a859728","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b89f4537d7fdbd0bafb6d8a66a484e0bc99871a4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bc5f2f3431ced08300e4cb3aff35f1da14c26433","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c828115a14eacbf42042770fd68543f134e89efa","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fd2400dd4f1b8bd7a309b1b424d9e0d188151b01","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fdbffd95c4ce94d2197c504008eaac46b16bc5a4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47473","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T07:15:12.027","lastModified":"2024-05-22T07:15:12.027","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix a memory leak in an error path of qla2x00_process_els()\n\nCommit 8c0eb596baa5 (\"[SCSI] qla2xxx: Fix a memory leak in an error path of\nqla2x00_process_els()\"), intended to change:\n\n        bsg_job->request->msgcode == FC_BSG_HST_ELS_NOLOGIN\n\n\n        bsg_job->request->msgcode != FC_BSG_RPT_ELS\n\nbut changed it to:\n\n        bsg_job->request->msgcode == FC_BSG_RPT_ELS\n\ninstead.\n\nChange the == to a != to avoid leaking the fcport structure or freeing\nunallocated memory."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/7fb223d0ad801f633c78cbe42b1d1b55f5d163ad","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/96f0aebf29be25254fa585af43924e34aa21fd9a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a7fbb56e6c941d9f59437b96412a348e66388d3e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-1446","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T07:15:12.147","lastModified":"2024-05-22T07:15:12.147","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The NextScripts: Social Networks Auto-Poster plugin for WordPress is vulnerable to Cross-Site Request Forgery in all versions up to, and including, 4.4.3. This is due to missing or incorrect nonce validation on the nxssnap-reposter page. This makes it possible for unauthenticated attackers to delete arbitrary posts or pages via a forged request granted they can trick a site administrator into performing an action such as clicking on a link."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:U\/C:N\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":5.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":2.5}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset?sfp_email=&sfph_mail=&reponame=&new=3084635%40social-networks-auto-poster-facebook-twitter-g%2Ftrunk&old=3004433%40social-networks-auto-poster-facebook-twitter-g%2Ftrunk&sfp_email=&sfph_mail=#file17","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/306b23ee-7dcb-4281-a218-21168998c4b9?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-1762","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T07:15:12.617","lastModified":"2024-05-22T07:15:12.617","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The NextScripts: Social Networks Auto-Poster plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the HTTP_USER_AGENT header in all versions up to, and including, 4.4.3 due to insufficient input sanitization and output escaping. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page. This requires the victim to select view \"All Cron Events\" in order for the injection to fire."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.1,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/social-networks-auto-poster-facebook-twitter-g\/trunk\/NextScripts_SNAP.php#L74","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/social-networks-auto-poster-facebook-twitter-g\/trunk\/inc\/nxs_functions_engine.php#L117","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/social-networks-auto-poster-facebook-twitter-g\/trunk\/inc\/nxs_functions_engine.php#L125","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset?sfp_email=&sfph_mail=&reponame=&new=3084635%40social-networks-auto-poster-facebook-twitter-g%2Ftrunk&old=3004433%40social-networks-auto-poster-facebook-twitter-g%2Ftrunk&sfp_email=&sfph_mail=#file17","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/8063a545-4792-4ab7-b188-0e51a0fcfed4?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-2088","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T07:15:12.907","lastModified":"2024-05-22T07:15:12.907","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The NextScripts: Social Networks Auto-Poster plugin for WordPress is vulnerable to Sensitive Information Exposure in all versions up to, and including, 4.4.3 via the 'nxs_getExpSettings' function. This makes it possible for authenticated attackers, with subscriber access and above, to extract sensitive data including social network API keys and secrets."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:H\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":8.5,"baseSeverity":"HIGH"},"exploitabilityScore":3.1,"impactScore":4.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/social-networks-auto-poster-facebook-twitter-g\/trunk\/inc\/nxs_functions_wp.php#L620","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3084635\/social-networks-auto-poster-facebook-twitter-g\/trunk\/inc\/nxs_functions_wp.php?contextall=1","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/70724bc7-c1f4-4965-8bba-99b2ed21d34b?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-3198","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T07:15:13.167","lastModified":"2024-05-22T07:15:13.167","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The WP Font Awesome Share Icons plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's \r\n'wpfai_social' shortcode in all versions up to, and including, 1.1.1 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/wp-font-awesome-share-icons\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/cd066a04-8094-4004-8a64-317c6bd4e101?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-3663","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T07:15:13.427","lastModified":"2024-05-22T07:15:13.427","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The WP Scraper plugin for WordPress is vulnerable to unauthorized access due to a missing capability check on the wp_scraper_multi_scrape_action() function in all versions up to, and including, 5.7. This makes it possible for authenticated attackers, with subscriber-level access and above, to create arbitrary pages and posts."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:N\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":4.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":1.4}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/wp-scraper\/trunk\/wp-scraper.php#L1426","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/1a4bc52d-5771-4e7b-a394-772f2a5edbd7?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-3927","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T07:15:13.720","lastModified":"2024-05-22T07:15:13.720","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Element Pack Elementor Addons (Header Footer, Template Library, Dynamic Grid & Carousel, Remote Arrows) plugin for WordPress is vulnerable to Form Submission Admin Email Bypass  in all versions up to, and including, 5.6.3. This is due to the plugin not properly checking for all variations of an administrators emails. This makes it possible for unauthenticated attackers to bypass the restriction using a +value when submitting the contact form."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":1.4}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/bdthemes-element-pack-lite\/trunk\/modules\/contact-form\/module.php#L102","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3089154","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/3a703fc4-6c61-442e-a637-515e9f501575?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2023-6487","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T08:15:08.687","lastModified":"2024-05-22T08:15:08.687","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The LuckyWP Table of Contents plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘Header Title' field in all versions up to and including 2.1.4 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with administrator-level access, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page. This only affects multi-site installations and installations where unfiltered_html has been disabled."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:H\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":4.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.3,"impactScore":2.7}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/luckywp-table-of-contents\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/88075c15-079f-4de2-8e15-374eb7b8c77b?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-0632","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T08:15:08.890","lastModified":"2024-05-22T08:15:08.890","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Automatic Translator with Google Translate plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the custom font setting in all versions up to, and including, 1.5.4 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with administrator-level access, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page. This only affects multi-site installations and installations where unfiltered_html has been disabled."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:H\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":4.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.3,"impactScore":2.7}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/auto-translate\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/4727154c-c48f-4958-9520-cc5204927ee4?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-2119","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T08:15:09.083","lastModified":"2024-05-22T08:15:09.083","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The LuckyWP Table of Contents plugin for WordPress is vulnerable to Reflected Cross-Site Scripting via the attrs parameter in all versions up to, and including, 2.1.4 due to insufficient input sanitization and output escaping. This makes it possible for unauthenticated attackers to inject arbitrary web scripts in pages that execute if they can successfully trick a user into performing an action such as clicking on a link."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:R\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"REQUIRED","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.1,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":2.7}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/luckywp-table-of-contents\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/5ceb8f67-0c7a-4028-81b9-f2cdbcba1a80?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-2163","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T08:15:09.390","lastModified":"2024-05-22T08:15:09.390","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Ninja Beaver Add-ons for Beaver Builder plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's widgets in all versions up to, and including, 2.4.5 due to insufficient input sanitization and output escaping on user supplied attributes such as urls. This makes it possible for authenticated attackers with contributor-level and above permissions to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/ninja-beaver-lite-addons-for-beaver-builder\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/1e257954-9e44-4939-8e01-efceb3c0953a?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-2953","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T08:15:09.587","lastModified":"2024-05-22T08:15:09.587","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The LuckyWP Table of Contents plugin for WordPress is vulnerable to Stored Cross-Site Scripting via multiple parameters in versions up to, and including, 2.1.4 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers with Contributor permissions and above to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:H\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":5.5,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.3,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/luckywp-table-of-contents\/tags\/2.1.4\/plugin\/PostSettings.php#L207","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/luckywp-table-of-contents\/tags\/2.1.4\/plugin\/PostSettings.php#L209","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/luckywp-table-of-contents\/tags\/2.1.4\/plugin\/PostSettings.php#L210","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/b12c0524-d991-4f96-8646-f4203880558c?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-32988","sourceIdentifier":"vultures@jpcert.or.jp","published":"2024-05-22T08:15:10.080","lastModified":"2024-05-22T08:15:10.080","vulnStatus":"Received","descriptions":[{"lang":"en","value":"'OfferBox' App for Android versions 2.0.0 to 2.3.17 and 'OfferBox' App for iOS versions 2.1.7 to 2.6.14 use a hard-coded secret key for JWT. Secret key for JWT may be retrieved if the application binary is reverse-engineered."}],"metrics":{},"references":[{"url":"https:\/\/jvn.jp\/en\/jp\/JVN83405304\/","source":"vultures@jpcert.or.jp"}]}},{"cve":{"id":"CVE-2024-3666","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T08:15:10.170","lastModified":"2024-05-22T08:15:10.170","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Opal Estate Pro – Property Management and Submission plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the agent latitude and longitude parameters in all versions up to, and including, 1.7.6 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with contributor access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/opal-estate-pro\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/c4d5d58f-913a-4a26-8b2a-bfdd08033993?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-3671","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T08:15:10.370","lastModified":"2024-05-22T08:15:10.370","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Print-O-Matic plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'print-me' shortcode in all versions up to, and including, 2.1.10 due to insufficient input sanitization and output escaping on user supplied attributes such as 'tag'. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/print-o-matic\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/10ea8f3a-35d6-494e-90f6-9165320cf99c?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4157","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T08:15:10.557","lastModified":"2024-05-22T08:15:10.557","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Contact Form Plugin by Fluent Forms for Quiz, Survey, and Drag & Drop WP Form Builder plugin for WordPress is vulnerable to PHP Object Injection in all versions up to, and including, 5.1.15 via deserialization of untrusted input in the extractDynamicValues function. This makes it possible for authenticated attackers, with contributor-level access and above, to inject a PHP Object. If a POP chain is present via an additional plugin or theme installed on the target system, it could allow the attacker to delete arbitrary files, retrieve sensitive data, or execute code. Successful exploitation requires the attacker to have \"View Form\" and \"Manage Form\" permissions, which must be explicitly set by an administrator. However, this requirement can be bypassed when this vulnerability is chained with CVE-2024-2771."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:H\/PR:L\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"HIGH","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":7.5,"baseSeverity":"HIGH"},"exploitabilityScore":1.6,"impactScore":5.9}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3081740\/fluentform","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/8def156a-f2f2-4640-a1c9-c21c74e1f308?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-5147","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T08:15:10.743","lastModified":"2024-05-22T08:15:10.743","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The WPZOOM Addons for Elementor (Templates, Widgets) plugin for WordPress is vulnerable to Local File Inclusion in all versions up to, and including, 1.1.37 via the 'grid_style' parameter. This makes it possible for unauthenticated attackers to include and execute arbitrary files on the server, allowing the execution of any PHP code in those files. This can be used to bypass access controls, obtain sensitive data, or achieve code execution in cases where images and other “safe” file types can be uploaded and included."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.8,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.9}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/wpzoom-elementor-addons\/trunk\/includes\/wpzoom-elementor-ajax-posts-grid.php#L105","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/wpzoom-elementor-addons\/trunk\/includes\/wpzoom-elementor-ajax-posts-grid.php#L112","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3090236#file6","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/f006bb33-d017-445b-9c02-bd848c199671?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2021-47474","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:09.287","lastModified":"2024-05-22T09:15:09.287","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncomedi: vmk80xx: fix bulk-buffer overflow\n\nThe driver is using endpoint-sized buffers but must not assume that the\ntx and rx buffers are of equal size or a malicious device could overflow\nthe slab-allocated receive buffer when doing bulk transfers."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/063f576c43d589a4c153554b681d32b3f8317c7b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0866dcaa828c21bc2f94dac00e086078f11b5772","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1ae4715121a57bc6fa29fd992127b01907f2f993","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/47b4636ebdbeba2044b3db937c4d2b6a4fe3d0f2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/78cdfd62bd54af615fba9e3ca1ba35de39d3871d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7b0e356189327287d0eb98ec081bd6dd97068cd3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7cfb35db607760698d299fd1cf7402dfa8f09973","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b7fd7f3387f070215e6be341e68eb5c087eeecc0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e0e6a63fd97ad95fe05dfd77268a1952551e11a7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47475","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:09.370","lastModified":"2024-05-22T09:15:09.370","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncomedi: vmk80xx: fix transfer-buffer overflows\n\nThe driver uses endpoint-sized USB transfer buffers but up until\nrecently had no sanity checks on the sizes.\n\nCommit e1f13c879a7c (\"staging: comedi: check validity of wMaxPacketSize\nof usb endpoints found\") inadvertently fixed NULL-pointer dereferences\nwhen accessing the transfer buffers in case a malicious device has a\nzero wMaxPacketSize.\n\nMake sure to allocate buffers large enough to handle also the other\naccesses that are done without a size check (e.g. byte 18 in\nvmk80xx_cnt_insn_read() for the VMK8061_MODEL) to avoid writing beyond\nthe buffers, for example, when doing descriptor fuzzing.\n\nThe original driver was for a low-speed device with 8-byte buffers.\nSupport was later added for a device that uses bulk transfers and is\npresumably a full-speed device with a maximum 64-byte wMaxPacketSize."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/06ac746d57e6d32b062e220415c607b7e2e0fa50","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/199acd8c110e3ae62833c24f632b0bb1c9f012a9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/278484ae93297b1bb1ce755f9d3b6d95a48c7d47","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/33d7a470730dfe7c9bfc8da84575cf2cedd60d00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/40d2a7e278e2e7c0a5fd7e997e7eb63945bf93f7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5229159f1d052821007aff1a1beb7873eacf1a9f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7a2021b896de1ad559d33b5c5cdd20b982242088","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a23461c47482fc232ffc9b819539d1f837adf2b1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ec85bcff4ed09260243d8f39faba99e1041718ba","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47476","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:09.470","lastModified":"2024-05-22T09:15:09.470","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncomedi: ni_usb6501: fix NULL-deref in command paths\n\nThe driver uses endpoint-sized USB transfer buffers but had no sanity\nchecks on the sizes. This can lead to zero-size-pointer dereferences or\noverflowed transfer buffers in ni6501_port_command() and\nni6501_counter_command() if a (malicious) device has smaller max-packet\nsizes than expected (or when doing descriptor fuzz testing).\n\nAdd the missing sanity checks to probe()."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/4a9d43cb5d5f39fa39fc1da438517004cc95f7ea","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/58478143771b20ab219937b1c30a706590a59224","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/907767da8f3a925b060c740e0b5c92ea7dbec440","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/aa39738423503825625853b643b9e99d11c23816","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0156b7c9649d8f55a2ce3d3258509f1b2a181c3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bc51111bf6e8e7b6cc94b133e4c291273a16acd1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d6a727a681a39ae4f73081a9bedb45d14f95bdd1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/df7b1238f3b599a0b9284249772cdfd1ea83a632","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/ef143dc0c3defe56730ecd3a9de7b3e1d7e557c1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47477","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:09.677","lastModified":"2024-05-22T09:15:09.677","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncomedi: dt9812: fix DMA buffers on stack\n\nUSB transfer buffers are typically mapped for DMA and must not be\nallocated on the stack or transfers will fail.\n\nAllocate proper transfer buffers in the various command helpers and\nreturn an error on short transfers instead of acting on random stack\ndata.\n\nNote that this also fixes a stack info leak on systems where DMA is not\nused as 32 bytes are always sent to the device regardless of how short\nthe command is."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/20cebb8b620dc987e55ddc46801de986e081757e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/365a346cda82f51d835c49136a00a9df8a78c7f2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/39ea61037ae78f14fa121228dd962ea3280eacf3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3ac273d154d634e2034508a14db82a95d7ad12ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3efb7af8ac437085b6c776e5b54830b149d86efe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/536de747bc48262225889a533db6650731ab25d3","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/786f5b03450454557ff858a8bead5d7c0cbf78d6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8a52bc480992c7c9da3ebfea456af731f50a4b97","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a6af69768d5cb4b2528946d53be5fa19ade37723","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47478","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:09.747","lastModified":"2024-05-22T09:15:09.747","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nisofs: Fix out of bound access for corrupted isofs image\n\nWhen isofs image is suitably corrupted isofs_read_inode() can read data\nbeyond the end of buffer. Sanity-check the directory entry length before\nusing it."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/156ce5bb6cc43a80a743810199defb1dc3f55b7f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6e80e9314f8bb52d9eabe1907698718ff01120f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/86d4aedcbc69c0f84551fb70f953c24e396de2d7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9ec33a9b8790c212cc926a88c5e2105f97f3f57e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/afbd40f425227e661d991757e11cc4db024e761f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0ddff8d68f2e43857a84dce54c3deab181c8ae1","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b2fa1f52d22c5455217b294629346ad23a744945","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e7fb722586a2936b37bdff096c095c30ca06404d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e96a1866b40570b5950cda8602c2819189c62a48","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47479","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:09.817","lastModified":"2024-05-22T09:15:09.817","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nstaging: rtl8712: fix use-after-free in rtl8712_dl_fw\n\nSyzbot reported use-after-free in rtl8712_dl_fw(). The problem was in\nrace condition between r871xu_dev_remove() ->ndo_open() callback.\n\nIt's easy to see from crash log, that driver accesses released firmware\nin ->ndo_open() callback. It may happen, since driver was releasing\nfirmware _before_ unregistering netdev. Fix it by moving\nunregister_netdev() before cleaning up resources.\n\nCall Trace:\n...\n rtl871x_open_fw drivers\/staging\/rtl8712\/hal_init.c:83 [inline]\n rtl8712_dl_fw+0xd95\/0xe10 drivers\/staging\/rtl8712\/hal_init.c:170\n rtl8712_hal_init drivers\/staging\/rtl8712\/hal_init.c:330 [inline]\n rtl871x_hal_init+0xae\/0x180 drivers\/staging\/rtl8712\/hal_init.c:394\n netdev_open+0xe6\/0x6c0 drivers\/staging\/rtl8712\/os_intfs.c:380\n __dev_open+0x2bc\/0x4d0 net\/core\/dev.c:1484\n\nFreed by task 1306:\n...\n release_firmware+0x1b\/0x30 drivers\/base\/firmware_loader\/main.c:1053\n r871xu_dev_remove+0xcc\/0x2c0 drivers\/staging\/rtl8712\/usb_intf.c:599\n usb_unbind_interface+0x1d8\/0x8d0 drivers\/usb\/core\/driver.c:458"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/a65c9afe9f2f55b7a7fb4a25ab654cd4139683a4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/befd23bd3b17f1a3f9c943a8580b47444c7c63ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c052cc1a069c3e575619cf64ec427eb41176ca70","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c430094541a80575259a94ff879063ef01473506","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47480","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:09.907","lastModified":"2024-05-22T09:15:09.907","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: core: Put LLD module refcnt after SCSI device is released\n\nSCSI host release is triggered when SCSI device is freed. We have to make\nsure that the low-level device driver module won't be unloaded before SCSI\nhost instance is released because shost->hostt is required in the release\nhandler.\n\nMake sure to put LLD module refcnt after SCSI device is released.\n\nFixes a kernel panic of 'BUG: unable to handle page fault for address'\nreported by Changhui and Yi."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1105573d964f7b78734348466b01f5f6ba8a1813","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/1ce287eff9f23181d5644db787f472463a61f68b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/61a0faa89f21861d1f8d059123b5c285a5d9ffee","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7b57c38d12aed1b5d92f74748bed25e0d041729f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/8e4814a461787e15a31d322d9efbe0d4f6822428","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c2df161f69fb1c67f63adbd193368b47f511edc0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f2b85040acec9a928b4eb1b57a989324e8e38d3f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f30822c0b4c35ec86187ab055263943dc71a6836","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47481","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.070","lastModified":"2024-05-22T09:15:10.070","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA\/mlx5: Initialize the ODP xarray when creating an ODP MR\n\nNormally the zero fill would hide the missing initialization, but an\nerrant set to desc_size in reg_create() causes a crash:\n\n  BUG: unable to handle page fault for address: 0000000800000000\n  PGD 0 P4D 0\n  Oops: 0000 [#1] SMP PTI\n  CPU: 5 PID: 890 Comm: ib_write_bw Not tainted 5.15.0-rc4+ #47\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04\/01\/2014\n  RIP: 0010:mlx5_ib_dereg_mr+0x14\/0x3b0 [mlx5_ib]\n  Code: 48 63 cd 4c 89 f7 48 89 0c 24 e8 37 30 03 e1 48 8b 0c 24 eb a0 90 0f 1f 44 00 00 41 56 41 55 41 54 55 53 48 89 fb 48 83 ec 30 <48> 8b 2f 65 48 8b 04 25 28 00 00 00 48 89 44 24 28 31 c0 8b 87 c8\n  RSP: 0018:ffff88811afa3a60 EFLAGS: 00010286\n  RAX: 000000000000001c RBX: 0000000800000000 RCX: 0000000000000000\n  RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000800000000\n  RBP: 0000000800000000 R08: 0000000000000000 R09: c0000000fffff7ff\n  R10: ffff88811afa38f8 R11: ffff88811afa38f0 R12: ffffffffa02c7ac0\n  R13: 0000000000000000 R14: ffff88811afa3cd8 R15: ffff88810772fa00\n  FS:  00007f47b9080740(0000) GS:ffff88852cd40000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000800000000 CR3: 000000010761e003 CR4: 0000000000370ea0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   mlx5_ib_free_odp_mr+0x95\/0xc0 [mlx5_ib]\n   mlx5_ib_dereg_mr+0x128\/0x3b0 [mlx5_ib]\n   ib_dereg_mr_user+0x45\/0xb0 [ib_core]\n   ? xas_load+0x8\/0x80\n   destroy_hw_idr_uobject+0x1a\/0x50 [ib_uverbs]\n   uverbs_destroy_uobject+0x2f\/0x150 [ib_uverbs]\n   uobj_destroy+0x3c\/0x70 [ib_uverbs]\n   ib_uverbs_cmd_verbs+0x467\/0xb00 [ib_uverbs]\n   ? uverbs_finalize_object+0x60\/0x60 [ib_uverbs]\n   ? ttwu_queue_wakelist+0xa9\/0xe0\n   ? pty_write+0x85\/0x90\n   ? file_tty_write.isra.33+0x214\/0x330\n   ? process_echoes+0x60\/0x60\n   ib_uverbs_ioctl+0xa7\/0x110 [ib_uverbs]\n   __x64_sys_ioctl+0x10d\/0x8e0\n   ? vfs_write+0x17f\/0x260\n   do_syscall_64+0x3c\/0x80\n   entry_SYSCALL_64_after_hwframe+0x44\/0xae\n\nAdd the missing xarray initialization and remove the desc_size set."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5508546631a0f555d7088203dec2614e41b5106e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5f6995295f65d1ee6f36d466d26afd98eb797afe","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47482","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.150","lastModified":"2024-05-22T09:15:10.150","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet: batman-adv: fix error handling\n\nSyzbot reported ODEBUG warning in batadv_nc_mesh_free(). The problem was\nin wrong error handling in batadv_mesh_init().\n\nBefore this patch batadv_mesh_init() was calling batadv_mesh_free() in case\nof any batadv_*_init() calls failure. This approach may work well, when\nthere is some kind of indicator, which can tell which parts of batadv are\ninitialized; but there isn't any.\n\nAll written above lead to cleaning up uninitialized fields. Even if we hide\nODEBUG warning by initializing bat_priv->nc.work, syzbot was able to hit\nGPF in batadv_nc_purge_paths(), because hash pointer in still NULL. [1]\n\nTo fix these bugs we can unwind batadv_*_init() calls one by one.\nIt is good approach for 2 reasons: 1) It fixes bugs on error handling\npath 2) It improves the performance, since we won't call unneeded\nbatadv_*_free() functions.\n\nSo, this patch makes all batadv_*_init() clean up all allocated memory\nbefore returning with an error to no call correspoing batadv_*_free()\nand open-codes batadv_mesh_free() with proper order to avoid touching\nuninitialized fields."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/07533f1a673ce1126d0a72ef1e4b5eaaa3dd6d20","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0c6b199f09be489c48622537a550787fc80aea73","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6422e8471890273994fe8cc6d452b0dcd2c9483e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6f68cd634856f8ca93bafd623ba5357e0f648c68","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a8f7359259dd5923adc6129284fdad12fc5db347","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b0a2cd38553c77928ef1646ed1518486b1e70ae8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e50f957652190b5a88a8ebce7e5ab14ebd0d3f00","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fbf150b16a3635634b7dfb7f229d8fcd643c6c51","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47483","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.227","lastModified":"2024-05-22T09:15:10.227","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nregmap: Fix possible double-free in regcache_rbtree_exit()\n\nIn regcache_rbtree_insert_to_block(), when 'present' realloc failed,\nthe 'blk' which is supposed to assign to 'rbnode->block' will be freed,\nso 'rbnode->block' points a freed memory, in the error handling path of\nregcache_rbtree_init(), 'rbnode->block' will be freed again in\nregcache_rbtree_exit(), KASAN will report double-free as follows:\n\nBUG: KASAN: double-free or invalid-free in kfree+0xce\/0x390\nCall Trace:\n slab_free_freelist_hook+0x10d\/0x240\n kfree+0xce\/0x390\n regcache_rbtree_exit+0x15d\/0x1a0\n regcache_rbtree_init+0x224\/0x2c0\n regcache_init+0x88d\/0x1310\n __regmap_init+0x3151\/0x4a80\n __devm_regmap_init+0x7d\/0x100\n madera_spi_probe+0x10f\/0x333 [madera_spi]\n spi_probe+0x183\/0x210\n really_probe+0x285\/0xc30\n\nTo fix this, moving up the assignment of rbnode->block to immediately after\nthe reallocation has succeeded so that the data structure stays valid even\nif the second reallocation fails."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/1cead23c1c0bc766dacb900a3b0269f651ad596f","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/36e911a16b377bde0ad91a8c679069d0d310b1a6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3dae1a4eced3ee733d7222e69b8a55caf2d61091","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/50cc1462a668dc62949a1127388bc3af785ce047","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/55e6d8037805b3400096d621091dfbf713f97e83","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/758ced2c3878ff789801e6fee808e185c5cf08d6","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e72dce9afbdbfa70d9b44f5908a50ff6c4858999","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/fc081477b47dfc3a6cb50a96087fc29674013fc2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47484","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.317","lastModified":"2024-05-22T09:15:10.317","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nocteontx2-af: Fix possible null pointer dereference.\n\nThis patch fixes possible null pointer dereference in files\n\"rvu_debugfs.c\" and \"rvu_nix.c\""}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/c2d4c543f74c90f883e8ec62a31973ae8807d354","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f1e3cd1cc80204fd02b9e9843450925a2af90dc0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47485","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.503","lastModified":"2024-05-22T09:15:10.503","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nIB\/qib: Protect from buffer overflow in struct qib_user_sdma_pkt fields\n\nOverflowing either addrlimit or bytes_togo can allow userspace to trigger\na buffer overflow of kernel memory. Check for overflows in all the places\ndoing math on user controlled buffers."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0d4395477741608d123dad51def9fe50b7ebe952","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0f8cdfff06829a0b0348b6debc29ff6a61967724","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3f57c3f67fd93b4da86aeffea1ca32c484d054ad","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/60833707b968d5ae02a75edb7886dcd4a957cf0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/73d2892148aa4397a885b4f4afcfc5b27a325c42","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bda41654b6e0c125a624ca35d6d20beb8015b5d0","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c3e17e58f571f34c51aeb17274ed02c2ed5cf780","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d39bf40e55e666b5905fdbd46a0dced030ce87be","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47486","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.573","lastModified":"2024-05-22T09:15:10.573","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nriscv, bpf: Fix potential NULL dereference\n\nThe bpf_jit_binary_free() function requires a non-NULL argument. When\nthe RISC-V BPF JIT fails to converge in NR_JIT_ITERATIONS steps,\njit_data->header will be NULL, which triggers a NULL\ndereference. Avoid this by checking the argument, prior calling the\nfunction."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/27de809a3d83a6199664479ebb19712533d6fd9b","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/cac6b043cea3e120f4fccec16f7381747cbfdc0d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e1b80a5ebe5431caeb20f88c32d4a024777a2d41","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47487","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.633","lastModified":"2024-05-22T09:15:10.633","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu: fix out of bounds write\n\nSize can be any value and is user controlled resulting in overwriting the\n40 byte array wr_buf with an arbitrary length of data from buf."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5afa7898ab7a0ec9c28556a91df714bf3c2f725e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/d3ed72495a59fbfb9377450c8dfe94389a6509a7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb3b6805e3e9d98b2507201fd061a231988ce623","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47488","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.700","lastModified":"2024-05-22T09:15:10.700","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncgroup: Fix memory leak caused by missing cgroup_bpf_offline\n\nWhen enabling CONFIG_CGROUP_BPF, kmemleak can be observed by running\nthe command as below:\n\n    $mount -t cgroup -o none,name=foo cgroup cgroup\/\n    $umount cgroup\/\n\nunreferenced object 0xc3585c40 (size 64):\n  comm \"mount\", pid 425, jiffies 4294959825 (age 31.990s)\n  hex dump (first 32 bytes):\n    01 00 00 80 84 8c 28 c0 00 00 00 00 00 00 00 00  ......(.........\n    00 00 00 00 00 00 00 00 6c 43 a0 c3 00 00 00 00  ........lC......\n  backtrace:\n    [<e95a2f9e>] cgroup_bpf_inherit+0x44\/0x24c\n    [<1f03679c>] cgroup_setup_root+0x174\/0x37c\n    [<ed4b0ac5>] cgroup1_get_tree+0x2c0\/0x4a0\n    [<f85b12fd>] vfs_get_tree+0x24\/0x108\n    [<f55aec5c>] path_mount+0x384\/0x988\n    [<e2d5e9cd>] do_mount+0x64\/0x9c\n    [<208c9cfe>] sys_mount+0xfc\/0x1f4\n    [<06dd06e0>] ret_fast_syscall+0x0\/0x48\n    [<a8308cb3>] 0xbeb4daa8\n\nThis is because that since the commit 2b0d3d3e4fcf (\"percpu_ref: reduce\nmemory footprint of percpu_ref in fast path\") root_cgrp->bpf.refcnt.data\nis allocated by the function percpu_ref_init in cgroup_bpf_inherit which\nis called by cgroup_setup_root when mounting, but not freed along with\nroot_cgrp when umounting. Adding cgroup_bpf_offline which calls\npercpu_ref_kill to cgroup_kill_sb can free root_cgrp->bpf.refcnt.data in\numount path.\n\nThis patch also fixes the commit 4bfc0bb2c60e (\"bpf: decouple the lifetime\nof cgroup_bpf from cgroup itself\"). A cgroup_bpf_offline is needed to do a\ncleanup that frees the resources which are allocated by cgroup_bpf_inherit\nin cgroup_setup_root.\n\nAnd inside cgroup_bpf_offline, cgroup_get() is at the beginning and\ncgroup_put is at the end of cgroup_bpf_release which is called by\ncgroup_bpf_offline. So cgroup_bpf_offline can keep the balance of\ncgroup's refcount."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/01599bf7cc2b49c3d2be886cb438647dc25446ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/04f8ef5643bcd8bcde25dfdebef998aea480b2ba","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b529f88d93884cf8ccafda793ee3d27b82fa578d","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47489","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.770","lastModified":"2024-05-22T09:15:10.770","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/amdgpu: Fix even more out of bound writes from debugfs\n\nCVE-2021-42327 was fixed by:\n\ncommit f23750b5b3d98653b31d4469592935ef6364ad67\nAuthor: Thelford Williams <tdwilliamsiv@gmail.com>\nDate:   Wed Oct 13 16:04:13 2021 -0400\n\n    drm\/amdgpu: fix out of bounds write\n\nbut amdgpu_dm_debugfs.c contains more of the same issue so fix the\nremaining ones.\n\nv2:\n\t* Add missing fix in dp_max_bpc_write (Harry Wentland)"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/3f4e54bd312d3dafb59daf2b97ffa08abebe60f5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/9eb4bdd554fc31a5ef6bf645a20ff21618ce45a9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47490","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.837","lastModified":"2024-05-22T09:15:10.837","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndrm\/ttm: fix memleak in ttm_transfered_destroy\n\nWe need to cleanup the fences for ghost objects as well.\n\nBug: https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=214029\nBug: https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=214447"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0db55f9a1bafbe3dac750ea669de9134922389b5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/132a3d998d6753047f22152731fba2b0d6b463dd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/960b1fdfc39aba8f41e9e27b2de0c925c74182d9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bbc920fb320f1c241cc34ac85edaa0058922246a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/bd99782f3ca491879e8524c89b1c0f40071903bd","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/c21b4002214c1c7e7b627b9b53375612f7aab6db","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47491","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:10.917","lastModified":"2024-05-22T09:15:10.917","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmm: khugepaged: skip huge page collapse for special files\n\nThe read-only THP for filesystems will collapse THP for files opened\nreadonly and mapped with VM_EXEC.  The intended usecase is to avoid TLB\nmisses for large text segments.  But it doesn't restrict the file types\nso a THP could be collapsed for a non-regular file, for example, block\ndevice, if it is opened readonly and mapped with EXEC permission.  This\nmay cause bugs, like [1] and [2].\n\nThis is definitely not the intended usecase, so just collapse THP for\nregular files in order to close the attack surface.\n\n[shy828301@gmail.com: fix vm_file check [3]]"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5fcb6fce74ffa614d964667110cf1a516c48c6d9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6d67b2a73b8e3a079c355bab3c1aef7d85a044b8","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/a4aeaa06d45e90f9b279f0b09de84bd00006e733","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47492","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:11.030","lastModified":"2024-05-22T09:15:11.030","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nmm, thp: bail out early in collapse_file for writeback page\n\nCurrently collapse_file does not explicitly check PG_writeback, instead,\npage_has_private and try_to_release_page are used to filter writeback\npages.  This does not work for xfs with blocksize equal to or larger\nthan pagesize, because in such case xfs has no page->private.\n\nThis makes collapse_file bail out early for writeback page.  Otherwise,\nxfs end_page_writeback will panic as follows.\n\n  page:fffffe00201bcc80 refcount:0 mapcount:0 mapping:ffff0003f88c86a8 index:0x0 pfn:0x84ef32\n  aops:xfs_address_space_operations [xfs] ino:30000b7 dentry name:\"libtest.so\"\n  flags: 0x57fffe0000008027(locked|referenced|uptodate|active|writeback)\n  raw: 57fffe0000008027 ffff80001b48bc28 ffff80001b48bc28 ffff0003f88c86a8\n  raw: 0000000000000000 0000000000000000 00000000ffffffff ffff0000c3e9a000\n  page dumped because: VM_BUG_ON_PAGE(((unsigned int) page_ref_count(page) + 127u <= 127u))\n  page->mem_cgroup:ffff0000c3e9a000\n  ------------[ cut here ]------------\n  kernel BUG at include\/linux\/mm.h:1212!\n  Internal error: Oops - BUG: 0 [#1] SMP\n  Modules linked in:\n  BUG: Bad page state in process khugepaged  pfn:84ef32\n   xfs(E)\n  page:fffffe00201bcc80 refcount:0 mapcount:0 mapping:0 index:0x0 pfn:0x84ef32\n   libcrc32c(E) rfkill(E) aes_ce_blk(E) crypto_simd(E) ...\n  CPU: 25 PID: 0 Comm: swapper\/25 Kdump: loaded Tainted: ...\n  pstate: 60400005 (nZCv daif +PAN -UAO -TCO BTYPE=--)\n  Call trace:\n    end_page_writeback+0x1c0\/0x214\n    iomap_finish_page_writeback+0x13c\/0x204\n    iomap_finish_ioend+0xe8\/0x19c\n    iomap_writepage_end_bio+0x38\/0x50\n    bio_endio+0x168\/0x1ec\n    blk_update_request+0x278\/0x3f0\n    blk_mq_end_request+0x34\/0x15c\n    virtblk_request_done+0x38\/0x74 [virtio_blk]\n    blk_done_softirq+0xc4\/0x110\n    __do_softirq+0x128\/0x38c\n    __irq_exit_rcu+0x118\/0x150\n    irq_exit+0x1c\/0x30\n    __handle_domain_irq+0x8c\/0xf0\n    gic_handle_irq+0x84\/0x108\n    el1_irq+0xcc\/0x180\n    arch_cpu_idle+0x18\/0x40\n    default_idle_call+0x4c\/0x1a0\n    cpuidle_idle_call+0x168\/0x1e0\n    do_idle+0xb4\/0x104\n    cpu_startup_entry+0x30\/0x9c\n    secondary_start_kernel+0x104\/0x180\n  Code: d4210000 b0006161 910c8021 94013f4d (d4210000)\n  ---[ end trace 4a88c6a074082f8c ]---\n  Kernel panic - not syncing: Oops - BUG: Fatal exception in interrupt"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/5e669d8ab30ab61dec3c36e27b4711f07611e6fc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/69a7fa5cb0de06c8956b040f19a7248c8c8308ca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/74c42e1baacf206338b1dd6b6199ac964512b5bb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47493","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:11.100","lastModified":"2024-05-22T09:15:11.100","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix race between searching chunks and release journal_head from buffer_head\n\nEncountered a race between ocfs2_test_bg_bit_allocatable() and\njbd2_journal_put_journal_head() resulting in the below vmcore.\n\n  PID: 106879  TASK: ffff880244ba9c00  CPU: 2   COMMAND: \"loop3\"\n  Call trace:\n    panic\n    oops_end\n    no_context\n    __bad_area_nosemaphore\n    bad_area_nosemaphore\n    __do_page_fault\n    do_page_fault\n    page_fault\n      [exception RIP: ocfs2_block_group_find_clear_bits+316]\n    ocfs2_block_group_find_clear_bits [ocfs2]\n    ocfs2_cluster_group_search [ocfs2]\n    ocfs2_search_chain [ocfs2]\n    ocfs2_claim_suballoc_bits [ocfs2]\n    __ocfs2_claim_clusters [ocfs2]\n    ocfs2_claim_clusters [ocfs2]\n    ocfs2_local_alloc_slide_window [ocfs2]\n    ocfs2_reserve_local_alloc_bits [ocfs2]\n    ocfs2_reserve_clusters_with_limit [ocfs2]\n    ocfs2_reserve_clusters [ocfs2]\n    ocfs2_lock_refcount_allocators [ocfs2]\n    ocfs2_make_clusters_writable [ocfs2]\n    ocfs2_replace_cow [ocfs2]\n    ocfs2_refcount_cow [ocfs2]\n    ocfs2_file_write_iter [ocfs2]\n    lo_rw_aio\n    loop_queue_work\n    kthread_worker_fn\n    kthread\n    ret_from_fork\n\nWhen ocfs2_test_bg_bit_allocatable() called bh2jh(bg_bh), the\nbg_bh->b_private NULL as jbd2_journal_put_journal_head() raced and\nreleased the jounal head from the buffer head.  Needed to take bit lock\nfor the bit 'BH_JournalHead' to fix this race."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/2e382600e8856ea654677b5134ee66e03ea72bc2","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5043fbd294f5909a080ade0f04b70a4da9e122b7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/6f1b228529ae49b0f85ab89bcdb6c365df401558","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47494","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:11.270","lastModified":"2024-05-22T09:15:11.270","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ncfg80211: fix management registrations locking\n\nThe management registrations locking was broken, the list was\nlocked for each wdev, but cfg80211_mgmt_registrations_update()\niterated it without holding all the correct spinlocks, causing\nlist corruption.\n\nRather than trying to fix it with fine-grained locking, just\nmove the lock to the wiphy\/rdev (still need the list on each\nwdev), we already need to hold the wdev lock to change it, so\nthere's no contention on the lock in any case. This trivially\nfixes the bug since we hold one wdev's lock already, and now\nwill hold the lock that protects all lists."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/09b1d5dc6ce1c9151777f6c4e128a59457704c97","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/3c897f39b71fe68f90599f6a45b5f7bf5618420e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/4c22227e39c7a0b4dab55617ee8d34d171fab8d4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47495","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:11.353","lastModified":"2024-05-22T09:15:11.353","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nusbnet: sanity check for maxpacket\n\nmaxpacket of 0 makes no sense and oopses as we need to divide\nby it. Give up.\n\nV2: fixed typo in log and stylistic issues"}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/002d82227c0abe29118cf80f7e2f396b22d448ed","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/397430b50a363d8b7bdda00522123f82df6adc5e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/492140e45d2bf27c1014243f8616a9b612144e20","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/524f333e98138d909a0a0c574a9ff6737dce2767","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/693ecbe8f799405f8775719deedb1f76265d375a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/74b3b27cf9fecce00cd8918b7882fd81191d0aa4","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/7e8b6a4f18edee070213cb6a77118e8a412253c5","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b9eba0a4a527e04d712f0e0401e5391ef124b33e","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47496","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:11.447","lastModified":"2024-05-22T09:15:11.447","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnet\/tls: Fix flipped sign in tls_err_abort() calls\n\nsk->sk_err appears to expect a positive value, a convention that ktls\ndoesn't always follow and that leads to memory corruption in other code.\nFor instance,\n\n    [kworker]\n    tls_encrypt_done(..., err=<negative error from crypto request>)\n      tls_err_abort(.., err)\n        sk->sk_err = err;\n\n    [task]\n    splice_from_pipe_feed\n      ...\n        tls_sw_do_sendpage\n          if (sk->sk_err) {\n            ret = -sk->sk_err;  \/\/ ret is positive\n\n    splice_from_pipe_feed (continued)\n      ret = actor(...)  \/\/ ret is still positive and interpreted as bytes\n                        \/\/ written, resulting in underflow of buf->len and\n                        \/\/ sd->len, leading to huge buf->offset and bogus\n                        \/\/ addresses computed in later calls to actor()\n\nFix all tls_err_abort() callers to pass a negative error code\nconsistently and centralize the error-prone sign flip there, throwing in\na warning to catch future misuse and uninlining the function so it\nreally does only warn once."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/da353fac65fede6b8b4cfe207f0d9408e3121105","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e0cfd5159f314d6b304d030363650b06a2299cbb","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/e41473543f75f7dbc5d605007e6f883f1bd13b9a","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/f3dec7e7ace38224f82cf83f0049159d067c2e19","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47497","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:11.513","lastModified":"2024-05-22T09:15:11.513","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nnvmem: Fix shift-out-of-bound (UBSAN) with byte size cells\n\nIf a cell has 'nbits' equal to a multiple of BITS_PER_BYTE the logic\n\n *p &= GENMASK((cell->nbits%BITS_PER_BYTE) - 1, 0);\n\nwill become undefined behavior because nbits modulo BITS_PER_BYTE is 0, and we\nsubtract one from that making a large number that is then shifted more than the\nnumber of bits that fit into an unsigned long.\n\nUBSAN reports this problem:\n\n UBSAN: shift-out-of-bounds in drivers\/nvmem\/core.c:1386:8\n shift exponent 64 is too large for 64-bit type 'unsigned long'\n CPU: 6 PID: 7 Comm: kworker\/u16:0 Not tainted 5.15.0-rc3+ #9\n Hardware name: Google Lazor (rev3+) with KB Backlight (DT)\n Workqueue: events_unbound deferred_probe_work_func\n Call trace:\n  dump_backtrace+0x0\/0x170\n  show_stack+0x24\/0x30\n  dump_stack_lvl+0x64\/0x7c\n  dump_stack+0x18\/0x38\n  ubsan_epilogue+0x10\/0x54\n  __ubsan_handle_shift_out_of_bounds+0x180\/0x194\n  __nvmem_cell_read+0x1ec\/0x21c\n  nvmem_cell_read+0x58\/0x94\n  nvmem_cell_read_variable_common+0x4c\/0xb0\n  nvmem_cell_read_variable_le_u32+0x40\/0x100\n  a6xx_gpu_init+0x170\/0x2f4\n  adreno_bind+0x174\/0x284\n  component_bind_all+0xf0\/0x264\n  msm_drm_bind+0x1d8\/0x7a0\n  try_to_bring_up_master+0x164\/0x1ac\n  __component_add+0xbc\/0x13c\n  component_add+0x20\/0x2c\n  dp_display_probe+0x340\/0x384\n  platform_probe+0xc0\/0x100\n  really_probe+0x110\/0x304\n  __driver_probe_device+0xb8\/0x120\n  driver_probe_device+0x4c\/0xfc\n  __device_attach_driver+0xb0\/0x128\n  bus_for_each_drv+0x90\/0xdc\n  __device_attach+0xc8\/0x174\n  device_initial_probe+0x20\/0x2c\n  bus_probe_device+0x40\/0xa4\n  deferred_probe_work_func+0x7c\/0xb8\n  process_one_work+0x128\/0x21c\n  process_scheduled_works+0x40\/0x54\n  worker_thread+0x1ec\/0x2a8\n  kthread+0x138\/0x158\n  ret_from_fork+0x10\/0x20\n\nFix it by making sure there are any bits to mask out."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/0594f1d048d8dc338eb9a240021b1d00ae1eb082","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/0e822e5413da1af28cca350cb1cb42b6133bdcae","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/2df6c023050205c4d04ffc121bc549f65cb8d1df","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/57e48886401b14cd351423fabfec2cfd18df4f66","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/5d388fa01fa6eb310ac023a363a6cb216d9d8fe9","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/60df06bbdf497e37ed25ad40572c362e5b0998df","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/abcb8d33e4d2215ccde5ab5ccf9f730a59d79d97","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/eb0fc8e7170e61eaf65d28dee4a8baf4e86b19ca","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2021-47498","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T09:15:11.673","lastModified":"2024-05-22T09:15:11.673","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\ndm rq: don't queue request to blk-mq during DM suspend\n\nDM uses blk-mq's quiesce\/unquiesce to stop\/start device mapper queue.\n\nBut blk-mq's unquiesce may come from outside events, such as elevator\nswitch, updating nr_requests or others, and request may come during\nsuspend, so simply ask for blk-mq to requeue it.\n\nFixes one kernel panic issue when running updating nr_requests and\ndm-mpath suspend\/resume stress test."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/8ca9745efe3528feb06ca4e117188038eea2d351","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"},{"url":"https:\/\/git.kernel.org\/stable\/c\/b4459b11e84092658fa195a2587aff3b9637f0e7","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-2036","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T09:15:11.793","lastModified":"2024-05-22T09:15:11.793","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The ApplyOnline – Application Form Builder and Manager plugin for WordPress is vulnerable to unauthorized access of data due to a missing capability check on the aol_modal_box AJAX action in all versions up to, and including, 2.6. This makes it possible for authenticated attackers, with subscriber access or higher, to view Application submissions."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:L\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":4.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":1.4}]},"references":[{"url":"https:\/\/wordpress.org\/plugins\/apply-online\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/3eff4992-dbd4-4b9b-872e-1670ce7dab9d?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-3495","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T09:15:12.073","lastModified":"2024-05-22T09:15:12.073","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Country State City Dropdown CF7 plugin for WordPress is vulnerable to SQL Injection via the ‘cnt’ and 'sid' parameters in versions up to, and including, 2.7.2 due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query.  This makes it possible for unauthenticated attackers to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:H\/I:H\/A:H","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"HIGH","integrityImpact":"HIGH","availabilityImpact":"HIGH","baseScore":9.8,"baseSeverity":"CRITICAL"},"exploitabilityScore":3.9,"impactScore":5.9}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/country-state-city-auto-dropdown\/trunk\/includes\/ajax-actions.php#L22","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/country-state-city-auto-dropdown\/trunk\/includes\/ajax-actions.php#L8","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset?sfp_email=&sfph_mail=&reponame=&new=3089374%40country-state-city-auto-dropdown%2Ftrunk&old=3068802%40country-state-city-auto-dropdown%2Ftrunk&sfp_email=&sfph_mail=","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/17dcacaf-0e2a-4bef-b944-fb7e43d25777?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4362","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T09:15:12.393","lastModified":"2024-05-22T09:15:12.393","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The SiteOrigin Widgets Bundle plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's 'siteorigin_widget' shortcode in all versions up to, and including, 1.60.0 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/so-widgets-bundle\/trunk\/base\/inc\/shortcode.php#L27","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088997\/so-widgets-bundle\/trunk\/base\/inc\/shortcode.php","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/b7926ec6-3441-4062-93b2-6c2120c9f406?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4896","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T09:15:12.790","lastModified":"2024-05-22T09:15:12.790","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The WPB Elementor Addons plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘url’ parameter in all versions up to, and including, 1.0.9 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with Contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/browser\/wpb-elementor-addons\/trunk\/templates\/videos_grid.php#L323","source":"security@wordfence.com"},{"url":"https:\/\/plugins.trac.wordpress.org\/changeset\/3088737\/#file26","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/103dea33-0c30-460e-80e4-fead18928a62?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-5025","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T09:15:13.043","lastModified":"2024-05-22T09:15:13.043","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Memberpress plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the ‘arglist’ parameter in all versions up to, and including, 1.11.29 due to insufficient input sanitization and output escaping. This makes it possible for authenticated attackers, with Contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":6.4,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.1,"impactScore":2.7}]},"references":[{"url":"https:\/\/memberpress.com\/change-log\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/f147641a-f430-4743-901e-539373dc10b7?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-5031","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T09:15:13.350","lastModified":"2024-05-22T09:15:13.350","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Memberpress plugin for WordPress is vulnerable to Blind Server-Side Request Forgery in all versions up to, and including, 1.11.29 via the 'mepr-user-file' shortcode. This makes it possible for authenticated attackers, with Contributor-level access and above, to make web requests to arbitrary locations originating from the web application and can be used to query and modify information from internal services."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:L\/UI:N\/S:C\/C:H\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"HIGH","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":8.5,"baseSeverity":"HIGH"},"exploitabilityScore":3.1,"impactScore":4.7}]},"references":[{"url":"https:\/\/memberpress.com\/change-log\/","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/80064e3b-6996-49eb-a475-0ffe0e894f9e?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-4153","sourceIdentifier":"security@huntr.dev","published":"2024-05-22T10:15:08.647","lastModified":"2024-05-22T10:15:08.647","vulnStatus":"Received","descriptions":[{"lang":"en","value":"A vulnerability in lunary-ai\/lunary version 1.2.2 allows attackers to bypass user creation limits and potentially evade payment requirements. The issue arises from an undefined behavior when handling input to the API, specifically through a POST request to the \/v1\/users endpoint. By crafting a request with a new user's email and assigning them an 'admin' role, attackers can invite additional users beyond the set limit. This vulnerability could be exploited to add an unlimited number of users without adhering to the intended restrictions."}],"metrics":{"cvssMetricV30":[{"source":"security@huntr.dev","type":"Secondary","cvssData":{"version":"3.0","vectorString":"CVSS:3.0\/AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:L\/I:N\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"LOW","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"NONE","availabilityImpact":"NONE","baseScore":4.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":2.8,"impactScore":1.4}]},"weaknesses":[{"source":"security@huntr.dev","type":"Primary","description":[{"lang":"en","value":"CWE-475"}]}],"references":[{"url":"https:\/\/huntr.com\/bounties\/336db0ae-fe33-44b9-ba9d-bf117e0d90c4","source":"security@huntr.dev"}]}},{"cve":{"id":"CVE-2024-4262","sourceIdentifier":"security@wordfence.com","published":"2024-05-22T10:15:09.583","lastModified":"2024-05-22T10:15:09.583","vulnStatus":"Received","descriptions":[{"lang":"en","value":"The Piotnet Addons For Elementor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via multiple widgets in all versions up to, and including, 2.4.28 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page."}],"metrics":{"cvssMetricV31":[{"source":"security@wordfence.com","type":"Primary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:C\/C:L\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"CHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":7.2,"baseSeverity":"HIGH"},"exploitabilityScore":3.9,"impactScore":2.7}]},"references":[{"url":"https:\/\/plugins.trac.wordpress.org\/changeset?sfp_email=&sfph_mail=&reponame=&new=3088562%40piotnet-addons-for-elementor&old=3048934%40piotnet-addons-for-elementor&sfp_email=&sfph_mail=","source":"security@wordfence.com"},{"url":"https:\/\/www.wordfence.com\/threat-intel\/vulnerabilities\/id\/812cc8f1-f89e-47c4-b029-f6a3dbc55d70?source=cve","source":"security@wordfence.com"}]}},{"cve":{"id":"CVE-2024-5193","sourceIdentifier":"cna@vuldb.com","published":"2024-05-22T11:15:53.487","lastModified":"2024-05-22T11:15:53.487","vulnStatus":"Received","descriptions":[{"lang":"en","value":"A vulnerability was found in Ritlabs TinyWeb Server 1.94. It has been classified as problematic. Affected is an unknown function of the component Request Handler. The manipulation with the input %0D%0A leads to crlf injection. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. VDB-265830 is the identifier assigned to this vulnerability. NOTE: The vendor was contacted early about this disclosure but did not respond in any way."}],"metrics":{"cvssMetricV31":[{"source":"cna@vuldb.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:N\/UI:N\/S:U\/C:N\/I:L\/A:N","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"NONE","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"NONE","integrityImpact":"LOW","availabilityImpact":"NONE","baseScore":5.3,"baseSeverity":"MEDIUM"},"exploitabilityScore":3.9,"impactScore":1.4}],"cvssMetricV2":[{"source":"cna@vuldb.com","type":"Secondary","cvssData":{"version":"2.0","vectorString":"AV:N\/AC:L\/Au:N\/C:N\/I:P\/A:N","accessVector":"NETWORK","accessComplexity":"LOW","authentication":"NONE","confidentialityImpact":"NONE","integrityImpact":"PARTIAL","availabilityImpact":"NONE","baseScore":5.0},"baseSeverity":"MEDIUM","exploitabilityScore":10.0,"impactScore":2.9,"acInsufInfo":false,"obtainAllPrivilege":false,"obtainUserPrivilege":false,"obtainOtherPrivilege":false,"userInteractionRequired":false}]},"weaknesses":[{"source":"cna@vuldb.com","type":"Primary","description":[{"lang":"en","value":"CWE-93"}]}],"references":[{"url":"https:\/\/github.com\/DMCERTCE\/CRLF_Tiny","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?ctiid.265830","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?id.265830","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?submit.333059","source":"cna@vuldb.com"}]}},{"cve":{"id":"CVE-2024-5194","sourceIdentifier":"cna@vuldb.com","published":"2024-05-22T11:15:53.797","lastModified":"2024-05-22T11:15:53.797","vulnStatus":"Received","descriptions":[{"lang":"en","value":"A vulnerability was found in Arris VAP2500 08.50. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the file \/assoc_table.php. The manipulation of the argument id leads to command injection. The attack can be launched remotely. The exploit has been disclosed to the public and may be used. The associated identifier of this vulnerability is VDB-265831."}],"metrics":{"cvssMetricV31":[{"source":"cna@vuldb.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:H\/UI:N\/S:U\/C:L\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":4.7,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.2,"impactScore":3.4}],"cvssMetricV2":[{"source":"cna@vuldb.com","type":"Secondary","cvssData":{"version":"2.0","vectorString":"AV:N\/AC:L\/Au:M\/C:P\/I:P\/A:P","accessVector":"NETWORK","accessComplexity":"LOW","authentication":"MULTIPLE","confidentialityImpact":"PARTIAL","integrityImpact":"PARTIAL","availabilityImpact":"PARTIAL","baseScore":5.8},"baseSeverity":"MEDIUM","exploitabilityScore":6.4,"impactScore":6.4,"acInsufInfo":false,"obtainAllPrivilege":false,"obtainUserPrivilege":false,"obtainOtherPrivilege":false,"userInteractionRequired":false}]},"weaknesses":[{"source":"cna@vuldb.com","type":"Primary","description":[{"lang":"en","value":"CWE-77"}]}],"references":[{"url":"https:\/\/github.com\/h0e4a0r1t\/h0e4a0r1t.github.io\/blob\/master\/2024\/a%2B%26%5BE4%3Flp5%3Fk9_%3D%5D\/ARRIS_VAP2500-RCE-assoc_table.php.pdf","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?ctiid.265831","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?id.265831","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?submit.335252","source":"cna@vuldb.com"}]}},{"cve":{"id":"CVE-2024-5195","sourceIdentifier":"cna@vuldb.com","published":"2024-05-22T11:15:54.063","lastModified":"2024-05-22T11:15:54.063","vulnStatus":"Received","descriptions":[{"lang":"en","value":"A vulnerability was found in Arris VAP2500 08.50. It has been rated as critical. Affected by this issue is some unknown functionality of the file \/diag_s.php. The manipulation of the argument customer_info leads to command injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The identifier of this vulnerability is VDB-265832."}],"metrics":{"cvssMetricV31":[{"source":"cna@vuldb.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:H\/UI:N\/S:U\/C:L\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":4.7,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.2,"impactScore":3.4}],"cvssMetricV2":[{"source":"cna@vuldb.com","type":"Secondary","cvssData":{"version":"2.0","vectorString":"AV:N\/AC:L\/Au:M\/C:P\/I:P\/A:P","accessVector":"NETWORK","accessComplexity":"LOW","authentication":"MULTIPLE","confidentialityImpact":"PARTIAL","integrityImpact":"PARTIAL","availabilityImpact":"PARTIAL","baseScore":5.8},"baseSeverity":"MEDIUM","exploitabilityScore":6.4,"impactScore":6.4,"acInsufInfo":false,"obtainAllPrivilege":false,"obtainUserPrivilege":false,"obtainOtherPrivilege":false,"userInteractionRequired":false}]},"weaknesses":[{"source":"cna@vuldb.com","type":"Primary","description":[{"lang":"en","value":"CWE-77"}]}],"references":[{"url":"https:\/\/github.com\/h0e4a0r1t\/h0e4a0r1t.github.io\/blob\/master\/2024\/a%2B%26%5BE4%3Flp5%3Fk9_%3D%5D\/ARRIS_VAP2500-RCE-diag_s.php.pdf","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?ctiid.265832","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?id.265832","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?submit.335253","source":"cna@vuldb.com"}]}},{"cve":{"id":"CVE-2024-36010","sourceIdentifier":"416baaa9-dc9f-4396-8d5f-8c081fb06d67","published":"2024-05-22T12:15:10.660","lastModified":"2024-05-22T12:15:10.660","vulnStatus":"Received","descriptions":[{"lang":"en","value":"In the Linux kernel, the following vulnerability has been resolved:\n\nigb: Fix string truncation warnings in igb_set_fw_version\n\nCommit 1978d3ead82c (\"intel: fix string truncation warnings\")\nfixes '-Wformat-truncation=' warnings in igb_main.c by using kasprintf.\n\ndrivers\/net\/ethernet\/intel\/igb\/igb_main.c:3092:53: warning：‘%d’ directive output may be truncated writing between 1 and 5 bytes into a region of size between 1 and 13 [-Wformat-truncation=]\n 3092 |                                  \"%d.%d, 0x%08x, %d.%d.%d\",\n      |                                                     ^~\ndrivers\/net\/ethernet\/intel\/igb\/igb_main.c:3092:34: note：directive argument in the range [0, 65535]\n 3092 |                                  \"%d.%d, 0x%08x, %d.%d.%d\",\n      |                                  ^~~~~~~~~~~~~~~~~~~~~~~~~\ndrivers\/net\/ethernet\/intel\/igb\/igb_main.c:3092:34: note：directive argument in the range [0, 65535]\ndrivers\/net\/ethernet\/intel\/igb\/igb_main.c:3090:25: note：‘snprintf’ output between 23 and 43 bytes into a destination of size 32\n\nkasprintf() returns a pointer to dynamically allocated memory\nwhich can be NULL upon failure.\n\nFix this warning by using a larger space for adapter->fw_version,\nand then fall back and continue to use snprintf."}],"metrics":{},"references":[{"url":"https:\/\/git.kernel.org\/stable\/c\/c56d055893cbe97848611855d1c97d0ab171eccc","source":"416baaa9-dc9f-4396-8d5f-8c081fb06d67"}]}},{"cve":{"id":"CVE-2024-5196","sourceIdentifier":"cna@vuldb.com","published":"2024-05-22T12:15:11.097","lastModified":"2024-05-22T12:15:11.097","vulnStatus":"Received","descriptions":[{"lang":"en","value":"A vulnerability classified as critical has been found in Arris VAP2500 08.50. This affects an unknown part of the file \/tools_command.php. The manipulation of the argument cmb_header\/txt_command leads to command injection. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The identifier VDB-265833 was assigned to this vulnerability."}],"metrics":{"cvssMetricV31":[{"source":"cna@vuldb.com","type":"Secondary","cvssData":{"version":"3.1","vectorString":"CVSS:3.1\/AV:N\/AC:L\/PR:H\/UI:N\/S:U\/C:L\/I:L\/A:L","attackVector":"NETWORK","attackComplexity":"LOW","privilegesRequired":"HIGH","userInteraction":"NONE","scope":"UNCHANGED","confidentialityImpact":"LOW","integrityImpact":"LOW","availabilityImpact":"LOW","baseScore":4.7,"baseSeverity":"MEDIUM"},"exploitabilityScore":1.2,"impactScore":3.4}],"cvssMetricV2":[{"source":"cna@vuldb.com","type":"Secondary","cvssData":{"version":"2.0","vectorString":"AV:N\/AC:L\/Au:M\/C:P\/I:P\/A:P","accessVector":"NETWORK","accessComplexity":"LOW","authentication":"MULTIPLE","confidentialityImpact":"PARTIAL","integrityImpact":"PARTIAL","availabilityImpact":"PARTIAL","baseScore":5.8},"baseSeverity":"MEDIUM","exploitabilityScore":6.4,"impactScore":6.4,"acInsufInfo":false,"obtainAllPrivilege":false,"obtainUserPrivilege":false,"obtainOtherPrivilege":false,"userInteractionRequired":false}]},"weaknesses":[{"source":"cna@vuldb.com","type":"Secondary","description":[{"lang":"en","value":"CWE-77"}]}],"references":[{"url":"https:\/\/github.com\/h0e4a0r1t\/h0e4a0r1t.github.io\/blob\/master\/2024\/a%2B%26%5BE4%3Flp5%3Fk9_%3D%5D\/ARRIS_VAP2500-RCE-tools_command.php.pdf","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?ctiid.265833","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?id.265833","source":"cna@vuldb.com"},{"url":"https:\/\/vuldb.com\/?submit.335254","source":"cna@vuldb.com"}]}}]}